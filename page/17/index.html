<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.14.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="JsyBlog">
<meta property="og:url" content="http://example.com/page/17/index.html">
<meta property="og:site_name" content="JsyBlog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="SongyangJi">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/17/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/17/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>JsyBlog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">JsyBlog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">SongyangJi</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">245</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">109</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/30/Reactor%E5%92%8CProactor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SongyangJi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JsyBlog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | JsyBlog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/11/30/Reactor%E5%92%8CProactor/" class="post-title-link" itemprop="url">Reactor模式和Proactor模式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-30 09:19:26" itemprop="dateCreated datePublished" datetime="2021-11-30T09:19:26+08:00">2021-11-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-23 01:40:24" itemprop="dateModified" datetime="2022-09-23T01:40:24+08:00">2022-09-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Reactor 模式也叫 Dispatcher 模式，我觉得这个名字更贴合该模式的含义，即 <strong>I&#x2F;O</strong> 多路复⽤监<br>听事件，收到事件后，根据事件类型分配（<strong>Dispatch</strong>）给某个进程&#x2F;线程。</p>
<p>Reactor 模式主要由 <strong>Reactor</strong> 和<strong>处理资源池</strong>这两个核⼼部分组成，它俩负责的事情如下：</p>
<ol>
<li><strong>Reactor 负责监听和分发事件，事件类型包含连接事件、读写事件</strong>；</li>
<li><strong>处理资源池负责处理事件，如 read -&gt; 业务逻辑 -&gt; send</strong>；</li>
</ol>
<p>Reactor 模式是灵活多变的，可以应对不同的业务场景，灵活在于：</p>
<ol>
<li>Reactor 的数量可以只有⼀个，也可以有多个；</li>
<li>处理资源池可以是单个进程 &#x2F; 线程，也可以是多个进程 &#x2F;线程；</li>
</ol>
<p>将上⾯的两个因素排列组设⼀下，理论上就可以有 4 种⽅案选择：</p>
<ol>
<li>单 Reactor 单进程 &#x2F; 线程；</li>
<li>单 Reactor 多进程 &#x2F; 线程；</li>
<li>多 Reactor 单进程 &#x2F; 线程；</li>
<li>多 Reactor 多进程 &#x2F; 线程；</li>
</ol>
<p>其中，「多 Reactor 单进程 &#x2F; 线程」实现⽅案相⽐「单 Reactor 单进程 &#x2F; 线程」⽅案，不仅复杂⽽且也没有性能优势，因此实际中并没有应⽤。</p>
<p>剩下的 3 个⽅案都是⽐较经典的，且都有应⽤在实际的项⽬中：<br>单 Reactor 单进程 &#x2F; 线程；<br>单 Reactor 多线程 &#x2F; 进程；<br>多 Reactor 多进程 &#x2F; 线程；( Netty 和 Memcache 都采⽤了「多 Reactor 多线程、「多 Reactor 多进程」⽅案的开源软件是 Nginx)</p>
<p>⽅案具体使⽤进程还是线程，要看使⽤的编程语⾔以及平台有关：</p>
<p>Java 语⾔⼀般使⽤线程，⽐如 Netty;</p>
<p>C 语⾔使⽤进程和线程都可以，例如 Nginx 使⽤的是进程，Memcache 使⽤的是线程。</p>
<p>接下来，分别介绍这三个经典的 Reactor ⽅案。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/30/lua/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SongyangJi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JsyBlog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | JsyBlog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/11/30/lua/" class="post-title-link" itemprop="url">Lua脚本以及在redis中使用lua</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-11-30 08:13:10 / 修改时间：09:11:04" itemprop="dateCreated datePublished" datetime="2021-11-30T08:13:10+08:00">2021-11-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="什么是lua"><a href="#什么是lua" class="headerlink" title="什么是lua"></a>什么是lua</h1><h2 id="Mac安装-lua"><a href="#Mac安装-lua" class="headerlink" title="Mac安装 lua"></a>Mac安装 lua</h2><p><strong>安装</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew search lua</span><br><span class="line">brew install lua</span><br></pre></td></tr></table></figure>

<p><strong>进入shell</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua</span><br></pre></td></tr></table></figure>

<p><strong>运行脚本文件</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x test_lua.lua</span><br><span class="line">/test_lua.lua</span><br></pre></td></tr></table></figure>


<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p><strong>行注释</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这是注释</span></span><br></pre></td></tr></table></figure>


<p><strong>段注释</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">这是块注释</span></span><br><span class="line"><span class="comment">这是块注释</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure>





<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(b) <span class="comment">-- 无初始值为 nil</span></span><br></pre></td></tr></table></figure>


<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>在redis脚本中不能使用全局变量，只能使用局部变量（其实是为了防止脚本之间相互影响）</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">local</span> b</span><br><span class="line"><span class="keyword">local</span> c, d</span><br><span class="line"><span class="keyword">local</span> e, f, g = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br></pre></td></tr></table></figure>


<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="空"><a href="#空" class="headerlink" title="空"></a>空</h3><p>没有赋值的变量或者表的字段即为nil，空。</p>
<h3 id="布尔"><a href="#布尔" class="headerlink" title="布尔"></a>布尔</h3><p>只有true，false。</p>
<h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p>包括整数、浮点数，1、2.0、3.5e10</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> s1 = <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">local</span> s2 = <span class="string">&quot;abc&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><p>lua中唯一的数据结构，既可以当数组，也可以当字典。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&#125;</span><br><span class="line">b = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">c = &#123;<span class="string">&#x27;s1&#x27;</span>, <span class="string">&#x27;s2&#x27;</span>, <span class="string">&#x27;s3&#x27;</span>&#125;</span><br><span class="line">d = &#123;<span class="number">1</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;a&#x27;</span>&#125;</span><br><span class="line">c[<span class="number">1</span>] <span class="comment">-- &#x27;s1&#x27;</span></span><br><span class="line">d[<span class="number">1</span>] = d[<span class="number">1</span>] + <span class="number">1</span></span><br></pre></td></tr></table></figure>


<p><strong>注意：Lua规定数组的索引从 1 开始的，而不是 0</strong></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">(函数列表)</span></span></span><br><span class="line">  函数题</span><br><span class="line"><span class="keyword">end</span> </span><br></pre></td></tr></table></figure>


<p>例子1</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m</span><span class="params">(a,b)</span></span></span><br><span class="line">  <span class="keyword">return</span> a*b</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>递归</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span><span class="params">(n)</span></span></span><br><span class="line">  <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> fun(n - <span class="number">2</span>) + fun(n - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">5</span>&gt;<span class="number">10</span>) <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;10&#x27;</span>);</span><br><span class="line"><span class="keyword">elseif</span> <span class="number">15</span>&gt;<span class="number">10</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;15&#x27;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件表达式 <span class="keyword">do</span></span><br><span class="line">  语句块</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sum = <span class="number">0</span></span><br><span class="line">num = <span class="number">1</span></span><br><span class="line"><span class="comment">-- 注意 do 和 end</span></span><br><span class="line"><span class="keyword">while</span> num &lt;= <span class="number">100</span> <span class="keyword">do</span></span><br><span class="line">    sum = sum + num</span><br><span class="line">    num = num + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;sum =&quot;</span>,sum)</span><br></pre></td></tr></table></figure>



<h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 = 初值, 终值, 步长 <span class="keyword">do</span></span><br><span class="line">  语句块</span><br><span class="line"><span class="keyword">end</span>  </span><br></pre></td></tr></table></figure>

<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="comment">-- 默认步长是1</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, <span class="number">100</span> <span class="keyword">do</span></span><br><span class="line">    sum = sum + i</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>另一个格式</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var1, var2, ..., varn <span class="keyword">in</span> 迭代器 <span class="keyword">do</span></span><br><span class="line">  语句块</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>





<p><strong>表的遍历</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- #获取表的长度</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, #a <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">print</span>(i)</span><br><span class="line">  <span class="built_in">print</span>(a[i])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 ipairs</span></span><br><span class="line"><span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">ipairs</span>(a) <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">print</span>(index)</span><br><span class="line">  <span class="built_in">print</span>(value)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h1 id="常用库"><a href="#常用库" class="headerlink" title="常用库"></a>常用库</h1><h2 id="String库"><a href="#String库" class="headerlink" title="String库"></a>String库</h2><ol>
<li><p>获取长度</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(#a) <span class="comment">-- 长度为3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">len</span>(<span class="string">&#x27;abc&#x27;</span>))</span><br></pre></td></tr></table></figure>


</li>
<li><p>大小写转换</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>.<span class="built_in">lower</span>(s)</span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">upper</span>(s)</span><br></pre></td></tr></table></figure>

</li>
<li><p>子串</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 闭区间，end可以取到</span></span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">sub</span>(s, start, [,<span class="keyword">end</span>])</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Table-库"><a href="#Table-库" class="headerlink" title="Table 库"></a>Table 库</h2><p>暂略。</p>
<h2 id="Math-库"><a href="#Math-库" class="headerlink" title="Math 库"></a>Math 库</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">math</span>.<span class="built_in">max</span>(x, ...)</span><br><span class="line"><span class="built_in">math</span>.<span class="built_in">min</span>(x, ...)</span><br><span class="line"><span class="built_in">math</span>.<span class="built_in">abs</span>(x)</span><br></pre></td></tr></table></figure>





<h1 id="Redis和Lua"><a href="#Redis和Lua" class="headerlink" title="Redis和Lua"></a>Redis和Lua</h1><h3 id="lua使用redis"><a href="#lua使用redis" class="headerlink" title="lua使用redis"></a>lua使用redis</h3><p>在lua脚本使用<code>redis.call</code></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis.call(<span class="string">&#x27;set&#x27;</span>,<span class="string">&#x27;key1&#x27;</span>,<span class="string">&#x27;val1&#x27;</span>)</span><br><span class="line"><span class="keyword">local</span> v = redis.call(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> v</span><br></pre></td></tr></table></figure>

<h3 id="redis-cli中使用lua"><a href="#redis-cli中使用lua" class="headerlink" title="redis-cli中使用lua"></a>redis-cli中使用lua</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL script numkeys key [key ...] arg [arg ...]</span><br></pre></td></tr></table></figure>



<h3 id="KEYS-和-ARGV"><a href="#KEYS-和-ARGV" class="headerlink" title="KEYS 和 ARGV"></a>KEYS 和 ARGV</h3><p>使用 <code>KEYS</code>获取键，使用<code>ARGV</code>获取值。</p>
<blockquote>
<p>注意索引从 1 开始。</p>
</blockquote>
<h3 id="原子性和执行时间"><a href="#原子性和执行时间" class="headerlink" title="原子性和执行时间"></a>原子性和执行时间</h3><p>Redis执行lua脚本是原子的，也就是在一个脚本执行期间不会执行其他命令。</p>
<p>所有其他的命令都必须在脚本执行完成后才能执行。</p>
<p>为了防止一个脚本执行时间太长，Redis提供<code>lua-time-limit</code>限制脚本的最长运行时间（默认是 5 秒），</p>
<p>时间到了，就可以接受其他命令，但这个脚本的执行就无法无确保原子性了，因为它还没有只执行完。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SongyangJi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JsyBlog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | JsyBlog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/11/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/" class="post-title-link" itemprop="url">计算机网络面试问题汇总</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-29 23:42:04" itemprop="dateCreated datePublished" datetime="2021-11-29T23:42:04+08:00">2021-11-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-30 00:30:38" itemprop="dateModified" datetime="2022-09-30T00:30:38+08:00">2022-09-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="SYN-FLOOD"><a href="#SYN-FLOOD" class="headerlink" title="SYN FLOOD"></a>SYN FLOOD</h1><p>SYN Flood 是种典型的 DoS（拒绝服务）攻击，其目的是通过消耗服务器所有可用资源使服务器无法用于处理合法请求。通过重复发送初始连接请求（SYN）数据包，攻击者能够压倒目标服务器上的所有可用端口，导致目标设备根本不响应合法请求。</p>
<h2 id="SYN攻击的原理"><a href="#SYN攻击的原理" class="headerlink" title="SYN攻击的原理"></a>SYN攻击的原理</h2><p>在 TCP 建立连接的过程中，<strong>因为服务端不确定自己发给客户端的 SYN-ACK 消息或客户端反馈的 ACK 消息是否会丢在半路，所以会给每个待完成的半开连接状态设一个定时器</strong>，如果超过时间还没有收到客户端的 ACK 消息，则重新发送一次 SYN-ACK 消息给客户端，直到重试超过一定次数时才会放弃。</p>
<p><strong>服务端为了维持半开连接状态，需要分配内核资源维护半开连接</strong>。当攻击者伪造海量的虚假 IP 向服务端发送 SYN 包时，就形成了 SYN FLOOD 攻击。攻击者故意不响应 ACK 消息，导致服务端被大量注定不能完成的半开连接占据，直到资源耗尽，停止响应正常的连接请求。</p>
<p><strong>SYN flood攻击目前有两种方法，不过都与服务端没收到<em>ACK</em>有关</strong>。恶意用户可以跳过发送最后的<em>ACK</em>信息；或者在<em>SYN</em>里通过欺骗来源IP地址，这让服务器送<em>SYN-ACK</em>到假造的IP地址，因此永不可能收到<em>ACK</em>。这两个案例服务器会花点时间等待ACK通知，故一个简单的网络拥塞可能是由于没有<em>ACK</em>造成的。</p>
<p>解决方法：</p>
<ol>
<li><p>直接的方法是<strong>提高 TCP 端口容量</strong>，<strong>减少半开连接的资源占用时间</strong>，然而该方法只是稍稍提高了防御能力，算不上解决问题；</p>
</li>
<li><p><strong>部署能够辨别恶意 IP 的路由器</strong>，将伪造 IP 地址的发送方发送的 SYN 消息过滤掉，该方案作用一般不是太大；</p>
</li>
<li><p><strong>SYN Cache</strong>：该方法首先<strong>构造一个全局 Hash Table，用来缓存系统当前所有的半开连接信息</strong>。在 Hash Table 中的每个桶的容量大小是有限制的，<del>当桶满时，会主动丢掉早来的信息</del>。</p>
<p><strong>当服务端收到一个 SYN 消息后，会通过一个映射函数生成一个相应的 Key 值，使得当前半连接信息存入相应的桶中</strong>。<strong>当收到客户端正确的ack报文后，服务端才开始分配传输资源块</strong>，并将相应的半开连接信息从表中删除。<strong>和服务器传输资源相比，维护表的开销要小得多</strong>。</p>
</li>
<li><p><strong>SYN Cookie</strong>：<strong>服务端通过特定的算法将半开连接信息编码成序列号或者时间戳</strong>，<strong>用作服务端给客户端的消息编号，随 SYN-ACK 消息一同返回给连接发起方</strong>，这样<strong>在连接建立完成前服务端不保存任何信息</strong>，<strong>直到发送方发送 ACK 确认报文并且服务端成功验证编码信息后，服务端才开始分配传输资源</strong>。若请求方是攻击者，则不会向服务端会 ACK 消息，由于未成功建立连接，因此服务端并没有花费任何额外的开销。</p>
<p>然而该方案也存在一些缺点，<strong>由于服务端并不保存半开连接状态，因此也就丧失了超时重传的能力</strong>，这在一定程度上降低了正常用户的连接成功率。此外，客户端发送给服务端的确认报文存在传输丢失的可能，当 ACK 确认报文丢失时，服务端和客户端会对连接的成功与否产生歧义，此时就需要上层应用采取相应的策略进行处理了。</p>
</li>
</ol>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/SYN_cookie">SYN cookie wiki</a></p>
<p>发起一个 TCP 连接时，客户端将一个 TCP SYN 包发送给服务器。作为响应，服务器将 TCP SYN + ACK 包返回给客户端。此数据包中有一个<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE#.E5.BA.8F.E5.88.97.E5.8F.B7.E5.92.8C.E7.A1.AE.E8.AE.A4">序号</a>（sequence number，TCP头中的第二个32 bit），它被 TCP 用来重新组装数据流。根据 TCP 规范，由端点发送的第一个序号可以是由该端点决定的任何值。SYN Cookies 是根据以下规则构造的初始序号：</p>
<ul>
<li>令 <strong>t</strong> 为一个缓慢递增的时间戳（通常为 <code>time() &gt;&gt; 6 </code>，提供 64 秒的分辨率）；</li>
<li>令 <strong>m</strong> 为服务器会在 SYN 队列条目中存储的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E5%88%86%E6%AE%B5%E5%A4%A7%E5%B0%8F">最大分段大小</a>（maximum segment size，简称为 MSS）；</li>
<li>令 <strong>s</strong> 为一个加密<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E7%AE%97%E6%B3%95">散列</a>函数对服务器和客户端各自的 IP 地址和端口号以及 <strong>t</strong> 进行运算的结果。返回得到的数值 <strong>s</strong> 必须是一个24位值。</li>
</ul>
<p>初始 TCP 序号，也就是所谓的 <em>SYN cookie</em>，按照如下算法得到：</p>
<ul>
<li>头五位：<strong>t</strong> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%90%8C%E4%BD%99">mod</a> 32；</li>
<li>中三位：<strong>m</strong> 编码后的数值；</li>
<li>末24位：<strong>s</strong> 本身；</li>
</ul>
<p>注：由于 <em>m</em> 必须用 3 位进行编码，服务器在启用了 SYN Cookie 时只能为 <em>m</em> 发送八种不同的数值。</p>
<p>根据 TCP 规范，当客户端发回 TCP ACK 包给服务器以响应服务器的 SYN + ACK 包时，客户端必须使用由服务器发送的初始序号加1作为数据包中的确认号。服务器接着从确认号中减去 1 以便还原向客户端发送的原始 SYN Cookie。</p>
<p>接下来服务器进行以下检查：</p>
<ul>
<li>根据当前的时间以及 <strong>t</strong> 来检查连接是否过期。</li>
<li>重新计算 <strong>s</strong> 来确认这是不是一个有效的 SYN Cookie。</li>
<li>从 3 位编码中解码 <strong>m</strong>，以便之后用来重建 SYN 队列条目。在此之后，连接照常进行。</li>
</ul>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/SYN_flood">SYN flood Wiki</a></p>
<h1 id="从浏览器输入域名到显示出网页的过程"><a href="#从浏览器输入域名到显示出网页的过程" class="headerlink" title="从浏览器输入域名到显示出网页的过程"></a>从浏览器输入域名到显示出网页的过程</h1><ul>
<li>1、输入地址</li>
<li>2、浏览器查找域名的 IP 地址</li>
<li>3、浏览器向 web 服务器发送一个 HTTP 请求</li>
<li>4、服务器的永久重定向响应</li>
<li>6、服务器处理请求</li>
<li>7、服务器返回一个 HTTP 响应</li>
<li>8、浏览器显示 HTML</li>
<li>9、浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等</li>
</ul>
<blockquote>
<p>浏览器从输入网址到渲染页面主要分为以下几个过程</p>
<ul>
<li>URL 输入</li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/cns?from=10680">DNS 解析</a></li>
<li>建立 TCP 连接</li>
<li>发送 HTTP &#x2F; HTTPS 请求（建立 TLS 连接）</li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/cvm?from=10680">服务器</a>响应请求</li>
<li>浏览器解析渲染页面</li>
<li>HTTP 请求结束，断开 TCP 连接</li>
</ul>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lepeCoder/p/15147895.html">https://www.cnblogs.com/lepeCoder/p/15147895.html</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/133906695">https://zhuanlan.zhihu.com/p/133906695</a></p>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h2 id="TCP-粘包问题"><a href="#TCP-粘包问题" class="headerlink" title="TCP 粘包问题"></a>TCP 粘包问题</h2><p><strong>为什么会发生TCP粘包和拆包?</strong></p>
<p>① 发送方写入的数据大于套接字缓冲区的大小，此时将发生拆包。</p>
<p>② 发送方写入的数据小于套接字缓冲区大小，由于 TCP 默认使用 Nagle 算法，只有当收到一个确认后，才将分组发送给对端，当发送方收集了多个较小的分组，就会一起发送给对端，这将会发生粘包。</p>
<p>③ 进行 MSS （最大报文长度）大小的 TCP 分段，当 TCP 报文的数据部分大于 MSS 的时候将发生拆包。</p>
<p>④ 发送方发送的数据太快，接收方处理数据的速度赶不上发送端的速度，将发生粘包。</p>
<p><strong>常见解决方法</strong></p>
<p>① <strong>在消息的头部添加消息长度字段</strong>，服务端获取消息头的时候解析消息长度，然后向后读取相应长度的内容。</p>
<p>② 固定消息数据的长度，服务端每次读取既定长度的内容作为一条完整消息，当消息不够长时，空位补上固定字符。但是该方法会浪费网络资源。</p>
<p>③ <strong>设置消息边界，也可以理解为分隔符</strong>，服务端从数据流中按消息边界分离出消息内容，一般使用换行符。</p>
<blockquote>
<ol>
<li><p>单看传输层，TCP是「面向字节流」传输的，本身是没有「包」的概念的，接收方将接收的报文段（segment）的数据提取出来按序放置在缓存中。</p>
</li>
<li><p>但是从应用层的角度看是有「包」的概念的，例如http&#x2F;1.1中采用了「管道(pipeline)」的思想，即可以多个http数据流「复用」同一个TCP，因此各个http数据流之间是「纠缠」的，那么就需要在应用层进行处理，「区分不同」的数据流，自然就需要处理「粘包」的问题。</p>
</li>
<li><p>个人认为TCP层没有「包」的概念反映了TCP层对应用层「多数据流」的支持较弱，这恰恰导致了粘包问题。而这种弱势也导致了HTTP&#x2F;3转向了QUIC，也就是基于UDP，自行实现更好的「多数据流复用&#x2F;分用」。</p>
</li>
</ol>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/29/Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SongyangJi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JsyBlog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | JsyBlog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/11/29/Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" class="post-title-link" itemprop="url">Redis实现分布式锁</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-29 11:00:11" itemprop="dateCreated datePublished" datetime="2021-11-29T11:00:11+08:00">2021-11-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-02 22:44:06" itemprop="dateModified" datetime="2022-09-02T22:44:06+08:00">2022-09-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="分布式锁简介"><a href="#分布式锁简介" class="headerlink" title="分布式锁简介"></a>分布式锁简介</h1><blockquote>
<p>分布式锁，是一种思想，它的实现方式有很多。比如，我们将沙滩当做分布式锁的组件，那么它看起来应该是这样的：</p>
<ul>
<li><strong>加锁</strong><br>在沙滩上踩一脚，留下自己的脚印，就对应了加锁操作。其他进程或者线程，看到沙滩上已经有脚印，证明锁已被别人持有，则等待。</li>
<li><strong>解锁</strong><br>把脚印从沙滩上抹去，就是解锁的过程。</li>
<li><strong>锁超时</strong><br>为了避免死锁，我们可以设置一阵风，在单位时间后刮起，将脚印自动抹去。</li>
</ul>
</blockquote>
<p>分布式锁的实现有很多，比如基于数据库、memcached、Redis、系统文件、zookeeper等。它们的核心的理念跟上面的过程大致相同。</p>
<p>在许多环境中不同进程必须以互斥方式使用共享资源进行操作时，分布式锁是一个非常有用的原语。此试图提供一种更规范的算法来实现Redis的分布式锁。我们提出了一种称为<code>Redlock</code>的算法，它实现了<code>DLM</code>（猜测是<code>Distributed Lock Manager</code>的缩写，分布式锁管理器），我们认为它比普通的单实例方法更安全。</p>
<h2 id="锁的安全和活性保证"><a href="#锁的安全和活性保证" class="headerlink" title="锁的安全和活性保证"></a>锁的安全和活性保证</h2><p>算法的三个核心特征（三大最低保证）：</p>
<ul>
<li><strong>Safety property</strong>（安全性）：互斥。确保在任何给定时刻下，只有一个客户端可以持有锁；</li>
<li><strong>Liveness property A</strong>（活性A）：无死锁。即使存在曾经锁定资源的客户端崩溃或者出现网络分区异常，确保锁总是能够成功获取；</li>
<li><strong>Liveness property B</strong>（活性B）：容错性。只要大多数Redis节点处于正常运行状态，客户端就可以获取和释放锁。</li>
</ul>
<h2 id="主从结构故障转移时的并发问题"><a href="#主从结构故障转移时的并发问题" class="headerlink" title="主从结构故障转移时的并发问题"></a>主从结构故障转移时的并发问题</h2><p>文档中还指出了目前算法对于故障转移的实现还存在明显的竞态条件问题（描述的应该是<code>Redis</code>主从架构下的问题）：</p>
<ul>
<li>客户端A获取Redis主节点中的锁（假设锁定的资源为X）</li>
<li>在Redis主节点把KEY同步到Redis从节点之前，Redis主节点崩溃</li>
<li>Redis从节点因为故障晋升为主节点</li>
<li>此时，客户端B获取资源X的锁成功，问题是资源X的锁在前面已经被客户端A获取过，这样就出现了并发问题。</li>
</ul>
<h1 id="单机下Redis实现锁"><a href="#单机下Redis实现锁" class="headerlink" title="单机下Redis实现锁"></a>单机下Redis实现锁</h1><p>单个实例是我们将用于此处描述的分布式算法的基础。</p>
<h2 id="锁的获取"><a href="#锁的获取" class="headerlink" title="锁的获取"></a>锁的获取</h2><p>下面的redis命令是获取锁的核心思想 —— 如果键不存在，则设置一个id值（此时相当于拿到了锁），并且为了保证上面所说的活性要求，还设置了键的过期时间。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET resource_name my_random_value NX PX 30000</span><br></pre></td></tr></table></figure>

<p>这实际上是<code>setnx</code>和<code>setex</code>的结合体，不过它是原子的。</p>
<p>如果较低版本的客户端中不支持这个命令，那就要使用lua脚本。</p>
<h2 id="锁的释放"><a href="#锁的释放" class="headerlink" title="锁的释放"></a>锁的释放</h2><p>下面的lua脚本的含义是：</p>
<p>当键存在，并且键值正是当前线程的独属id时（也就是防止释放别的线程加的锁，这就是这个独属于加到锁的线程的id的作用）。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>




<h2 id="使用Jedis实现”丐版“Redis锁"><a href="#使用Jedis实现”丐版“Redis锁" class="headerlink" title="使用Jedis实现”丐版“Redis锁"></a>使用Jedis实现”丐版“Redis锁</h2><p><del>注意下面的代码只能算是对redis加锁的原理予以初步的实践，远远达不到高性能、高可靠。</del></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRedisLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">JedisPool</span> <span class="variable">jedisPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPool</span>(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">EXPIRE_TIME_OUT</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">// SET命令已经提供了可选的复合操作符</span></span><br><span class="line">    <span class="comment">// EX：设置超时时间，单位是秒</span></span><br><span class="line">    <span class="comment">// PX：设置超时时间，单位是毫秒</span></span><br><span class="line">    <span class="comment">// NX：IF NOT EXIST的缩写，只有KEY不存在的前提下才会设置K-V，设置成功返回1，否则返回0</span></span><br><span class="line">    <span class="comment">// XX：IF EXIST的缩写，只有在KEY存在的前提下才会设置K-V，设置成功返回1，否则返回0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SetParams</span> <span class="variable">params</span> <span class="operator">=</span> SetParams.setParams().nx().px(EXPIRE_TIME_OUT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; lockedId = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String lockName;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">MyRedisLock</span><span class="params">(String lockName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lockName = lockName;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MyRedisLock <span class="title function_">getLock</span><span class="params">(String lockName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyRedisLock</span>(lockName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        lockedId.set(id);</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> jedisPool.getResource()) &#123;</span><br><span class="line">            <span class="comment">// 加锁失败就重试</span></span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">statusCode</span> <span class="operator">=</span> jedis.set(lockName, id, params);</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;OK&quot;</span>.equals(statusCode)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>); <span class="comment">// 可以设计成 wait-notify 范式，不过这里就简陋一点了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> jedisPool.getResource()) &#123;</span><br><span class="line">            <span class="comment">// 为做到原子性，使用 Lua 脚本</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span></span><br><span class="line">                    <span class="string">&quot;if redis.call(&#x27;get&#x27;,KEYS[1]) == ARGV[1] then&quot;</span> +</span><br><span class="line">                            <span class="string">&quot;   return redis.call(&#x27;del&#x27;,KEYS[1]) &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;else&quot;</span> +</span><br><span class="line">                            <span class="string">&quot;   return 0 &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;end&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> lockedId.get();</span><br><span class="line">            jedis.eval(script, Collections.singletonList(lockName), Collections.singletonList(id)).toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 测试代码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyRedisLock</span> <span class="variable">lock</span> <span class="operator">=</span> MyRedisLock.getLock(<span class="string">&quot;lock1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        MyInteger.testLock(lock);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line">        <span class="type">MyInteger</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInteger</span>(N);</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(N);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            pool.submit(() -&gt; &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    integer.decr();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            countDownLatch.await(); <span class="comment">// just wait all tasks to finish</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;end : &quot;</span> + integer.getX());</span><br><span class="line">        <span class="type">long</span> <span class="variable">r</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时 &quot;</span> + (r - l) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>上述算法的主要缺点：</p>
<ol>
<li>忙等（busy-waiting）的问题，消耗CPU资源；</li>
<li>只适用于单机；</li>
<li>不可重入</li>
<li>没有限制等待获取的锁的超时时间</li>
<li>不能做到在等待锁的时候响应中断</li>
</ol>
<h1 id="Redisson实现分布式锁"><a href="#Redisson实现分布式锁" class="headerlink" title="Redisson实现分布式锁"></a>Redisson实现分布式锁</h1><p><a target="_blank" rel="noopener" href="https://redisson.org/">Redisson</a>是架设在<a target="_blank" rel="noopener" href="http://redis.cn/">Redis</a>基础上的一个Java驻内存数据网格（In-Memory Data Grid）。</p>
<p>相对于Jedis而言，Redisson是一个更高级的客户端。</p>
<p>它里面实现了各种分布式锁（本文只介绍和使用简单的）。</p>
<h2 id="使用Redisson中的锁"><a href="#使用Redisson中的锁" class="headerlink" title="使用Redisson中的锁"></a>使用Redisson中的锁</h2><p><strong>maven依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.16.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p><strong>简单使用 lock</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 配置类</span></span><br><span class="line">  <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">  config.useSingleServer().setAddress(<span class="string">&quot;redis://127.0.0.1:6379&quot;</span>);</span><br><span class="line">  config.useSingleServer().setPassword(<span class="string">&quot;redis1234&quot;</span>);</span><br><span class="line">  <span class="comment">// 初始化客户端</span></span><br><span class="line">  <span class="keyword">final</span> <span class="type">RedissonClient</span> <span class="variable">client</span> <span class="operator">=</span> Redisson.create(config);  </span><br><span class="line">  <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> client.getLock(<span class="string">&quot;lock1&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 加锁</span></span><br><span class="line">lock.lock();</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="comment">// do something ...  </span></span><br><span class="line">  &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">      <span class="comment">// 释放锁</span></span><br><span class="line">      lock.unlock();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h2 id="Redisson中RLock的实现特点"><a href="#Redisson中RLock的实现特点" class="headerlink" title="Redisson中RLock的实现特点"></a>Redisson中RLock的实现特点</h2><p><code>Redisson</code>中<code>RLock</code>的实现是基本参照了<code>Redis</code>的<code>red lock</code>算法进行实现，不过在原始的<code>red lock</code>算法下进行了改良，主要包括下面的特性：</p>
<ul>
<li>互斥</li>
<li>无死锁</li>
<li>可重入，类似于<code>ReentrantLock</code>，同一个线程可以重复获取同一个资源的锁（一般使用计数器实现），锁的重入特性一般情况下有利于提高资源的利用率</li>
<li><strong>续期</strong>，这个是一个比较前卫解决思路，也就是如果一个客户端对资源<code>X</code>永久锁定，那么并不是直接对<code>KEY</code>生存周期设置为<code>-1</code>，而是通<strong>过一个守护线程每隔固定周期延长<code>KEY</code>的过期时间</strong>，这样就能实现<strong>在守护线程不被杀掉的前提下，避免客户端崩溃导致锁无法释放长期占用资源的问题</strong></li>
<li><strong>锁状态变更订阅</strong>，依赖于<code>org.redisson.pubsub.LockPubSub</code>，用于订阅和通知锁释放事件</li>
<li>数据类型选用了<code>HASH</code>，配合<code>Lua</code>脚本完成多个命令的原子性</li>
</ul>
<p><code>RLock</code>的类图</p>
<p><img src="/2021/11/29/Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/rlock.jpeg"></p>
<p>RedissonLock<code>就是</code>RLock<code>的直接实现，也是分布式锁实现的核心类，从源码中看到</code>Redisson.getLock()<code>就是直接实例化</code>RedissonLock。</p>
<p><code>RedissonLock</code>的类继承图</p>
<p><img src="/2021/11/29/Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/redission-lock.jpeg"></p>
<h2 id="加锁整体流程"><a href="#加锁整体流程" class="headerlink" title="加锁整体流程"></a>加锁整体流程</h2><blockquote>
<p>下面的代码是版本3.16.4中的，其他版本有点差别：</p>
</blockquote>
<h3 id="构造锁"><a href="#构造锁" class="headerlink" title="构造锁"></a>构造锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">RedissonLock</span><span class="params">(CommandAsyncExecutor commandExecutor, String name)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(commandExecutor, name);</span><br><span class="line">    <span class="comment">//命令执行器</span></span><br><span class="line">    <span class="built_in">this</span>.commandExecutor = commandExecutor;</span><br><span class="line">    <span class="comment">//UUID字符串</span></span><br><span class="line">    <span class="built_in">this</span>.id = commandExecutor.getConnectionManager().getId();</span><br><span class="line">    <span class="comment">//内部锁过期时间(默认是 30*1000 , 也就是 30 秒)</span></span><br><span class="line">    <span class="built_in">this</span>.internalLockLeaseTime = commandExecutor.</span><br><span class="line">                getConnectionManager().getCfg().getLockWatchdogTimeout();</span><br><span class="line">    <span class="built_in">this</span>.entryName = id + <span class="string">&quot;:&quot;</span> + name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>lockWatchdogTimeout</code>参数只有在没有使用<code>leaseTimeout</code>参数定义的成功获取到锁的场景（简单来说就是不设置时限的加锁）下生效，<br>如果看门狗在下一个<code>lockWatchdogTimeout</code>周期内不进行续期，那么锁就会过期释放<br>（从源码上看，每三分之一<code>lockWatchdogTimeout</code>就会执行一次续期任务，每次通过<code>pexpire</code>把<code>KEY</code>的存活周期延长<code>lockWatchdogTimeout</code>），<code>lockWatchdogTimeout</code>的默认值为<code>30000</code>，也就是<code>30</code>秒。</p>
<p>这里先列举一下<code>RedissonLock</code>中获取名称的方法，以便后面分析这些名称作为<code>K-V</code>结构的<code>KEY</code>时候使用：</p>
<ul>
<li><code>id</code>：由配置实例化时候实例化的<code>UUID</code>实例生成，从源码上分析每个连接方式的<code>Redisson</code>实例有唯一的<code>UUID</code>，<code>ConnectionManager</code>初始化的时候会调用<code>UUID id = UUID.randomUUID()</code>，笔者认为可以理解为<code>Redisson</code>实例在某个应用程序进程中的唯一标识，毕竟一般情况下，一个应用程序应该只会应用一种<code>Redisson</code>的连接方式</li>
<li><code>getEntryName()</code>：返回的是<code>UUID + : + $KEY</code>，例如<code>559cc9df-bad8-4f6c-86a4-ffa51b7f1c36:resource:x</code></li>
<li><code>getName()</code>：返回的是<code>$KEY</code>，例如<code>resource:x</code></li>
<li><code>getChannelName()</code>：返回的是<code>redisson_lock__channel:&#123;$KEY&#125;</code>，例如<code>redisson_lock__channel:&#123;resource:x&#125;</code></li>
<li><code>getLockName(long threadId)</code>：返回的是<code>UUID + : + $threadId</code>，例如<code>559cc9df-bad8-4f6c-86a4-ffa51b7f1c36:1</code></li>
</ul>
<h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">		<span class="keyword">public</span> RLock <span class="title function_">getLock</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RedissonLock</span>(commandExecutor, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">   	 * LeaseTime - 获取后持有锁的最长时间，如果它尚未通过调用unlock 。 如果leaseTime 为-1，则保持锁定直到显式解锁。</span></span><br><span class="line"><span class="comment">   	 */</span></span><br><span class="line">		 <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">long</span> leaseTime, TimeUnit unit, <span class="type">boolean</span> interruptibly)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      	<span class="comment">// 当前线程ID</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">      	<span class="comment">// 尝试获取锁</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">ttl</span> <span class="operator">=</span> tryAcquire(-<span class="number">1</span>, leaseTime, unit, threadId);</span><br><span class="line">        <span class="comment">// lock acquired</span></span><br><span class="line">        <span class="comment">// 如果ttl为 null，则证明获取锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      	<span class="comment">// 如果获取锁失败，则订阅到对应这个锁的channel</span></span><br><span class="line">        RFuture&lt;RedissonLockEntry&gt; future = subscribe(threadId);</span><br><span class="line">        <span class="keyword">if</span> (interruptibly) &#123;</span><br><span class="line">            commandExecutor.syncSubscriptionInterrupted(future);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            commandExecutor.syncSubscription(future);</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 不断尝试</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 再次尝试获取锁</span></span><br><span class="line">                ttl = tryAcquire(-<span class="number">1</span>, leaseTime, unit, threadId);</span><br><span class="line">                <span class="comment">// lock acquired</span></span><br><span class="line">                <span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// waiting for message</span></span><br><span class="line">                <span class="comment">// ttl大于0 则等待ttl时间后继续尝试获取</span></span><br><span class="line">                <span class="keyword">if</span> (ttl &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        future.getNow().getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (interruptibly) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        future.getNow().getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (interruptibly) &#123;</span><br><span class="line">                        future.getNow().getLatch().acquire();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        future.getNow().getLatch().acquireUninterruptibly();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 取消对channel的订阅</span></span><br><span class="line">            unsubscribe(future, threadId);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        get(lockAsync(leaseTime, unit));</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>如上代码，就是加锁的全过程。先调用<code>tryAcquire</code>来获取锁，如果返回值ttl为空，则证明加锁成功，返回；如果不为空，则证明加锁失败。这时候，它会订阅这个锁的Channel，等待锁释放的消息，然后重新尝试获取锁。流程如下：</p>
<img src="lock1.webp" style="zoom:60%;" />











<p>获取锁的过程是怎样的呢？接下来就要看<code>tryAcquire</code>方法。在这里，它有两种处理方式，一种是带有过期时间的锁，一种是不带过期时间的锁。</p>
<h3 id="获取互斥状态"><a href="#获取互斥状态" class="headerlink" title="获取互斥状态"></a>获取互斥状态</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">// 同步方法依赖异步方法</span></span><br><span class="line">    <span class="keyword">private</span> Long <span class="title function_">tryAcquire</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit, <span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> get(tryAcquireAsync(waitTime, leaseTime, unit, threadId));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过传入锁持有的最大时间和线程ID异步获取锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; RFuture&lt;Long&gt; <span class="title function_">tryAcquireAsync</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit, <span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">        RFuture&lt;Long&gt; ttlRemainingFuture;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;   <span class="comment">// 锁持有最大时间不为-1，也就是明确锁的持有时间，不是永久持有的场景</span></span><br><span class="line">            ttlRemainingFuture = tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 先按照30秒的过期时间来执行获取锁的方法</span></span><br><span class="line">            ttlRemainingFuture = tryLockInnerAsync(waitTime, internalLockLeaseTime,</span><br><span class="line">                    TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果还持有这个锁，则开启定时任务不断刷新该锁的过期时间</span></span><br><span class="line">        ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">            <span class="comment">// // 执行异常场景直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// lock acquired（当前已经获取到锁）</span></span><br><span class="line">            <span class="keyword">if</span> (ttlRemaining == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span><br><span class="line">                    internalLockLeaseTime = unit.toMillis(leaseTime);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果是永久持有，定时调度进行 续期操作</span></span><br><span class="line">                    scheduleExpirationRenewal(threadId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> ttlRemainingFuture;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h4 id="底层加锁逻辑"><a href="#底层加锁逻辑" class="headerlink" title="底层加锁逻辑"></a>底层加锁逻辑</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; RFuture&lt;T&gt; <span class="title function_">tryLockInnerAsync</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit, <span class="type">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> evalWriteAsync(getRawName(), LongCodec.INSTANCE, command,</span><br><span class="line">             <span class="comment">//如果锁不存在，则通过hincrby设置持有数为 1 ，并设置过期时间</span></span><br><span class="line">             <span class="comment">// KEYS[1] ：hash类型的键，代表哪个锁</span></span><br><span class="line">             <span class="comment">// ARGV[2] ：hash类型的字段，代表目前获取到锁的线程名</span></span><br><span class="line">             <span class="comment">// ARGV[1] ：传入的锁的过期时间                       </span></span><br><span class="line">            <span class="string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                    <span class="comment">// 如果锁已存在，并且锁的是当前线程，则通过hincrby给数值递增1</span></span><br><span class="line">                    <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span>, <span class="comment">// //如果锁已存在，但并非本线程，则返回过期时间ttl</span></span><br><span class="line">            Collections.singletonList(getRawName(), unit.toMillis(leaseTime), getLockName(threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这段LUA代码看起来并不复杂，有三个判断：</p>
<ul>
<li><strong>通过exists判断，如果锁不存在，则设置值和过期时间，加锁成功</strong></li>
<li><strong>通过hexists判断，如果锁已存在，并且锁的是当前线程，则证明是重入锁，加锁成功</strong></li>
<li><strong>如果锁已存在，但锁的不是当前线程，则证明有其他线程持有锁。返回当前锁的过期时间，加锁失败</strong></li>
</ul>
<img src="lock2.webp" style="zoom:60%;" />





<p>最后再概括一下<code>Redisson</code>中实现<code>red lock</code>算法使用的<code>HASH</code>数据类型：</p>
<ul>
<li><code>KEY</code>代表的就是资源或者锁，<strong>创建、存在性判断，延长生存周期和删除操作总是针对<code>KEY</code>进行的</strong></li>
<li><code>FIELD</code>代表的是锁名称<code>lockName()</code>，但是其实它由<code>Redisson</code>连接管理器实例的初始化<code>UUID</code>拼接客户端线程<code>ID</code>组成，严格来说应该是获取锁的客户端线程唯一标识；</li>
<li><code>VALUE</code>代表的是客户端线程对于锁的持有量。</li>
</ul>
<h2 id="解锁整体流程"><a href="#解锁整体流程" class="headerlink" title="解锁整体流程"></a>解锁整体流程</h2><h3 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> RFuture&lt;Void&gt; <span class="title function_">unlockAsync</span><span class="params">(<span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    RPromise&lt;Void&gt; result = <span class="keyword">new</span> <span class="title class_">RedissonPromise</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// // 返回的RFuture如果持有的结果为true，说明解锁成功，返回NULL说明线程ID异常，加锁和解锁的客户端线程不是同一个线程</span></span><br><span class="line">    RFuture&lt;Boolean&gt; future = unlockInnerAsync(threadId);</span><br><span class="line">    future.onComplete((opStatus, e) -&gt; &#123;</span><br><span class="line">      	<span class="comment">// 需要取消看门狗的续期任务</span></span><br><span class="line">        cancelExpirationRenewal(threadId);</span><br><span class="line">		<span class="comment">// 这是内部的异常，说明解锁异常</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            result.tryFailure(e);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 这种情况说明线程ID异常，加锁和解锁的客户端线程不是同一个线程，抛出IllegalMonitorStateException异常</span></span><br><span class="line">        <span class="keyword">if</span> (opStatus == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">IllegalMonitorStateException</span> <span class="variable">cause</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>(<span class="string">&quot;attempt to unlock lock, not locked by current thread by node id: &quot;</span></span><br><span class="line">                    + id + <span class="string">&quot; thread-id: &quot;</span> + threadId);</span><br><span class="line">            result.tryFailure(cause);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 走到这里说明正常解锁</span></span><br><span class="line">        result.trySuccess(<span class="literal">null</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="解锁的底层逻辑"><a href="#解锁的底层逻辑" class="headerlink" title="解锁的底层逻辑"></a>解锁的底层逻辑</h3><p>核心还是lua脚本实现的原子性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title function_">unlockInnerAsync</span><span class="params">(<span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">            <span class="comment">// KEYS[1] 锁名</span></span><br><span class="line">            <span class="comment">// ARGV[3] 线程id</span></span><br><span class="line">            <span class="comment">// 如果释放锁的线程和已存在锁的线程不是同一个线程，返回null         </span></span><br><span class="line">            <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[3]) == 0) then &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return nil;&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                    <span class="comment">// 通过hincrby递减1的方式，释放一次锁</span></span><br><span class="line">                    <span class="string">&quot;local counter = redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[3], -1); &quot;</span> +</span><br><span class="line">                    <span class="comment">// 若剩余次数大于0 ，则刷新过期时间</span></span><br><span class="line">                    <span class="string">&quot;if (counter &gt; 0) then &quot;</span> +</span><br><span class="line">                    <span class="comment">// ARGV[2] 过期时间</span></span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2]); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return 0; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;else &quot;</span> +</span><br><span class="line">                    <span class="comment">// 否则证明锁已经释放，删除key并发布锁释放的消息</span></span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;del&#x27;, KEYS[1]); &quot;</span> +</span><br><span class="line">                    <span class="comment">// KEYS[2] ： 指的是 publish 的频道名</span></span><br><span class="line">                    <span class="comment">// ARGV[1] ：解锁的消息</span></span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;publish&#x27;, KEYS[2], ARGV[1]); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return 1; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return nil;&quot;</span>,</span><br><span class="line">            Arrays.asList(getRawName(), getChannelName()), LockPubSub.UNLOCK_MESSAGE, internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol>
<li><p><strong>如果解锁的线程和当前锁的线程不是同一个，解锁失败，抛出异常</strong>‘’</p>
</li>
<li><p><strong>通过hincrby递减1，先释放一次锁。</strong></p>
</li>
<li><p><strong>若剩余次数还大于0，则证明当前锁是重入锁，刷新过期时间；</strong></p>
</li>
<li><p><strong>若剩余次数小于0，删除key并发布锁释放的消息，解锁成功</strong></p>
</li>
</ol>
<img src="unlock.webp" style="zoom:60%;" />






<h2 id="Redisson的锁总结"><a href="#Redisson的锁总结" class="headerlink" title="Redisson的锁总结"></a>Redisson的锁总结</h2><p><code>Redisson</code>中的<code>red lock</code>实现，应用到下面的核心技术：</p>
<ul>
<li>合理应用<code>Redis</code>的基本数据类型<code>HASH</code></li>
<li><code>Redis</code>的订阅发布</li>
<li><code>Lua</code>脚本的原子性</li>
<li><code>Netty</code>中的<code>Promise</code>实现</li>
<li><code>Netty</code>中的时间轮<code>HashedWheelTimer</code>和对应的定时任务<code>(HashedWheel)Timeout</code></li>
<li><code>Semaphore</code>进行带期限、永久或者可中断的阻塞以及唤醒，替代<code>CountDownLatch</code>中的无等待期限阻塞</li>
</ul>
<p>上面的核心技术相对合理地应用，才能实现一个高效而且容错能力相对比较高的分布式锁方案，但是从目前来看，<code>Redisson</code>仍未解决<code>red lock</code>算法中的故障转移缺陷，笔者认为这个有可能是<code>Redis</code>实现分布式锁方案的一个底层缺陷，<strong>此方案在<code>Redis</code>单实例中是相对完善</strong>，一旦应用在<code>Redis</code>集群（普通主从、哨兵或者<code>Cluster</code>），有几率会出现前文提到的节点角色切换导致多个不同客户端获取到同一个资源对应的锁的问题。暂时无解。</p>
<blockquote>
<p>但值得注意的是，上面的两种实现方式都是针对单机Redis实例而进行的。如果我们有多个Redis实例，请参阅<strong>Redlock算法</strong>。该算法的具体内容，请参考<a target="_blank" rel="noopener" href="http://redis.cn/topics/distlock.html">http://redis.cn/topics/distlock.html</a></p>
</blockquote>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/throwable/p/14264804.html">冷饭新炒：理解Redisson中分布式锁的实现 </a></p>
<p><a target="_blank" rel="noopener" href="https://redis.io/topics/distlock">Distributed locks with Redis</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/dlf123321/article/details/123032170?spm=1001.2014.3001.5501">分布式锁的进化过程</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/29/Jmeter%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SongyangJi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JsyBlog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | JsyBlog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/11/29/Jmeter%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">Jmeter使用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-29 10:18:42" itemprop="dateCreated datePublished" datetime="2021-11-29T10:18:42+08:00">2021-11-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-12-17 23:03:46" itemprop="dateModified" datetime="2021-12-17T23:03:46+08:00">2021-12-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%B5%8B%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">测试</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Add-Threads（Users）添加线程组"><a href="#Add-Threads（Users）添加线程组" class="headerlink" title="Add Threads（Users）添加线程组"></a>Add Threads（Users）添加线程组</h2><p><strong>线程组主要参数详解</strong></p>
<ol>
<li>线程数：虚拟用户数。一个虚拟用户占用一个进程或线程。模拟多少用户访问也就填写多少个线程数量。</li>
<li>Ramp-Up时间(秒)：设置的虚拟用户数需要多长时间全部启动。如果线程数为<code>100</code>，准备时长为<code>5</code>，那么需要<code>5</code>秒钟启动<code>100</code>个线程，也就是每秒钟启动<code>20</code>个线程。 相当于每秒模拟<code>20</code>个用户进行访问，设置为零我理解为并发访问。</li>
<li>循环次数：如果线程数为<code>100</code>，循环次数为<code>100</code>。那么总请求数为<code>100*100=10000</code> 。如果勾选了“永远”，那么所有线程会一直发送请求，直到选择停止运行脚本。</li>
</ol>
<h2 id="Add-Sample-添加取样器（）"><a href="#Add-Sample-添加取样器（）" class="headerlink" title="Add Sample 添加取样器（）"></a>Add Sample 添加取样器（）</h2><h3 id="Add-Sample-HTTP-Request-添加http接口测试（）"><a href="#Add-Sample-HTTP-Request-添加http接口测试（）" class="headerlink" title="Add Sample HTTP Request 添加http接口测试（）"></a>Add Sample HTTP Request 添加http接口测试（）</h3><p><strong>Http请求主要参数详解</strong></p>
<ul>
<li>协议：向目标服务器发送HTTP请求协议，可以是<code>HTTP</code>或<code>HTTPS</code>，默认为<code>HTTP</code>。</li>
<li>服务器名称或IP ：<code>HTTP</code>请求发送的目标服务器名称或<code>IP</code>。</li>
<li>端口号：目标服务器的端口号，默认值为80</li>
<li>方法：发送<code>HTTP</code>请求的方法，可用方法包括<code>GET</code>、<code>POST</code>、<code>HEAD</code>、<code>PUT</code>、<code>OPTIONS</code>、<code>TRACE</code>、<code>DELETE</code>等。</li>
<li>路径：目标<code>URL</code>路径（<code>URL</code>中去掉服务器地址、端口及参数后剩余部分）。</li>
<li>字符集编码：编码方式，默认为<code>ISO-8859-1</code>编码，这里配置为<code>utf-8</code>。</li>
<li>参数：同请求一起发送参数 ，在请求中发送的<code>URL</code>参数，用户可以将<code>URL</code>中所有参数设置在本表中，表中每行为一个参数（对应<code>URL</code>中的 <code>key=value</code>），注意参数传入中文时需要勾选“编码”。</li>
</ul>
<h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><h3 id="Add-Assertions-Json-Assertion-添加Json断言（）"><a href="#Add-Assertions-Json-Assertion-添加Json断言（）" class="headerlink" title="Add Assertions Json Assertion 添加Json断言（）"></a>Add Assertions Json Assertion 添加Json断言（）</h3><h3 id="Add-Listener-Assertion-Results-添加断言结果（）"><a href="#Add-Listener-Assertion-Results-添加断言结果（）" class="headerlink" title="Add Listener Assertion Results 添加断言结果（）"></a>Add Listener Assertion Results 添加断言结果（）</h3><h2 id="结果报告"><a href="#结果报告" class="headerlink" title="结果报告"></a>结果报告</h2><h3 id="Add-Listener-View-Results-Tree-添加察看结果树（）"><a href="#Add-Listener-View-Results-Tree-添加察看结果树（）" class="headerlink" title="Add Listener View Results Tree 添加察看结果树（）"></a>Add Listener View Results Tree 添加察看结果树（）</h3><h3 id="Add-Listener-Aggregate-Report-添加聚合报告（）"><a href="#Add-Listener-Aggregate-Report-添加聚合报告（）" class="headerlink" title="Add Listener Aggregate Report 添加聚合报告（）"></a>Add Listener Aggregate Report 添加聚合报告（）</h3><p><strong>聚合报告参数详解</strong></p>
<ol>
<li>Label：每个 <code>JMeter</code> 的 <code>element</code>（例如我这里只有一个 <code>Spring WebFlux</code>）都有一个 <code>Name</code> 属性，这里显示的就是 <code>Name</code> 属性的值。</li>
<li>样本(Samples)：请求数——表示这次测试中一共发出了多少个请求，我这里模拟了<code>100</code>个用户循环<code>6</code>次也就为<code>100*6=600</code>。</li>
<li>平均值(Average)：平均响应时间 (单位:<code>ms</code>)。默认是单个<code>Request</code>的平均响应时间，当使用了<code>Transaction Controller</code>时，也可以是<code>Transaction</code>为单位显示平均响应时间。</li>
<li>中位数(Median)： 50％ 用户的响应时间。</li>
<li>90% 百分位(Line)：90％用户的响应时间。相邻几个<code>*%</code>同意。</li>
<li>最小值(Min)：最小响应时间。</li>
<li>最大值(Max)：最大响应时间。</li>
<li>异常(Error) %：错误率——错误请求数&#x2F;请求总数。</li>
<li>吞吐量(Throughput)：吞吐量——默认情况下表示每秒完成的请求数（<code>Request per Second</code>），当使用了 <code>Transaction Controller</code> 时，也可以表示类似 <code>LoadRunner</code> 的 <code>Transaction per Second</code> 数 。</li>
<li>接收 KB&#x2F;Sec：每秒从服务器端接收到的数据量，相当于<code>LoadRunner</code>中的<code>Throughput/Sec</code>。</li>
<li>发送 KB&#x2F;Sec：每秒向服务器发送的数据量，相当于<code>LoadRunner</code>中的<code>Throughput/Sec</code>。</li>
</ol>
<blockquote>
<p>一般而言，性能测试中我们需要重点关注的数据有： Samples、Average、Min、Max、Error、Throughput。</p>
</blockquote>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6bc152ca6126">Apache JMeter 入门教程</a></p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/10364657">软件压力测试</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/28/%E7%AE%97%E6%B3%95%E9%A2%98API/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SongyangJi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JsyBlog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | JsyBlog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/11/28/%E7%AE%97%E6%B3%95%E9%A2%98API/" class="post-title-link" itemprop="url">算法题C++模板API</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-28 22:28:28" itemprop="dateCreated datePublished" datetime="2021-11-28T22:28:28+08:00">2021-11-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-02 22:44:06" itemprop="dateModified" datetime="2022-09-02T22:44:06+08:00">2022-09-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="语法类"><a href="#语法类" class="headerlink" title="语法类"></a>语法类</h1><h2 id="类与结构体"><a href="#类与结构体" class="headerlink" title="类与结构体"></a>类与结构体</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z) : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y), <span class="built_in">z</span>(z) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="function">Node <span class="title">node</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    Node node1 = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="重新定义类型"><a href="#重新定义类型" class="headerlink" title="重新定义类型"></a>重新定义类型</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> P1 pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; P2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">F1</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> P3 = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="type">int</span> m, n;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line"><span class="comment">//        memset(g, 0, sizeof(g));</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, g[i + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, g[i] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h1><h2 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : a) &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> b[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="built_in">reverse</span>(b, b + <span class="number">3</span>); <span class="comment">// [)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : b) &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a % <span class="number">2</span> &lt; b % <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对数组排序</span></span><br><span class="line">    <span class="type">int</span> a[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sort</span>(a, a + <span class="number">4</span>); <span class="comment">// 注意是 [)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : a) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从大到小</span></span><br><span class="line">    <span class="built_in">sort</span>(a, a + <span class="number">4</span>, [](<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt; y;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : a) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从大到小</span></span><br><span class="line">    <span class="built_in">sort</span>(a, a + <span class="number">4</span>, cmp); <span class="comment">// 传入 cmp 函数指针</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : a) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// vector&lt;vector&lt;int&gt; &gt; vs;</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">vs</span>(<span class="number">10</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>)); <span class="comment">// 10 * 2</span></span><br><span class="line">    <span class="built_in">sort</span>(vs.<span class="built_in">begin</span>(), vs.<span class="built_in">end</span>(), [](vector&lt;<span class="type">int</span>&gt; &amp;a, vector&lt;<span class="type">int</span>&gt; &amp;b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] != b[<span class="number">0</span>] ? a[<span class="number">0</span>] &lt; b[<span class="number">0</span>] : a[<span class="number">1</span>] &gt; b[<span class="number">1</span>]; <span class="comment">// 先按第一维从小排序,再第二维从大到小排序</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 注意，默认的sort，其实是按vector&lt;int&gt;的字典序排序。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="lower-bound、upper-bound"><a href="#lower-bound、upper-bound" class="headerlink" title="lower_bound、upper_bound"></a>lower_bound、upper_bound</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="built_in">sort</span>(a, a + <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回值 int*</span></span><br><span class="line">    <span class="type">int</span> idx = <span class="built_in">lower_bound</span>(a, a + <span class="number">5</span>, <span class="number">5</span>) - a;</span><br><span class="line">    cout &lt;&lt; idx &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; a[idx] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> idx2 = <span class="built_in">upper_bound</span>(a, a + <span class="number">5</span>, <span class="number">5</span>) - a;</span><br><span class="line">    cout &lt;&lt; idx2 &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; a[idx2] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> it1 = <span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">7</span>);</span><br><span class="line">    <span class="comment">// 返回值是 vector&lt;int&gt;::iterator</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator it2 = <span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">7</span>);</span><br><span class="line">    cout &lt;&lt; *it1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; *it2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> idx3 = <span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">7</span>) - v.<span class="built_in">begin</span>();</span><br><span class="line">    cout &lt;&lt; idx3 &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; v[idx3] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="data-structure"><a href="#data-structure" class="headerlink" title="data structure"></a>data structure</h1><p>头文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br></pre></td></tr></table></figure>








<h2 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化方式</span></span><br><span class="line">    P2 p2 = &#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="function">P2 <span class="title">p3</span><span class="params">(<span class="number">5</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line">    P2 p4 = <span class="built_in">make_pair</span>(<span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; p2.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; p2.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; p3.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; p3.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; p4.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; p4.second &lt;&lt; endl;</span><br><span class="line">   </span><br><span class="line">    vector&lt;P2&gt; v = &#123;&#123;<span class="number">1</span>, <span class="number">5</span>&#125;,</span><br><span class="line">                    &#123;<span class="number">2</span>, <span class="number">4</span>&#125;,</span><br><span class="line">                    &#123;<span class="number">3</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解包</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [x, y] : v) &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s1;</span><br><span class="line">    s1.<span class="built_in">push_back</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    s1 += <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    s1 += <span class="string">&quot;c&quot;</span>;</span><br><span class="line">    s1.<span class="built_in">append</span>(<span class="string">&quot;def&quot;</span>); <span class="comment">// aka +</span></span><br><span class="line">    cout &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反转</span></span><br><span class="line">    <span class="built_in">reverse</span>(s1.<span class="built_in">begin</span>(), s1.<span class="built_in">end</span>());</span><br><span class="line">    cout &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接访问</span></span><br><span class="line">    cout &lt;&lt; s1[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s1[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 子串</span></span><br><span class="line">    string s = <span class="string">&quot;0123456&quot;</span>;</span><br><span class="line">    s1 = s.<span class="built_in">substr</span>(<span class="number">2</span>,<span class="number">4</span>); <span class="comment">// s.substring(2, 2 + 4); aka 2345</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>字符串和数字互转</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">stoi</span>(s);</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    string y = <span class="built_in">to_string</span>(x);</span><br><span class="line">    cout &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>子串和find</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;01234567890123456789&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子串</span></span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">substr</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">substr</span>(<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">substr</span>(<span class="number">2</span>, <span class="number">4</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">substr</span>(<span class="number">2</span>, <span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find、rfind</span></span><br><span class="line">    <span class="type">int</span> p1 = s.<span class="built_in">find</span>(<span class="string">&quot;012&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1 &quot;</span> &lt;&lt; p1 &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> p2 = s.<span class="built_in">find</span>(<span class="string">&quot;012&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2 &quot;</span> &lt;&lt; p2 &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> rp = s.<span class="built_in">rfind</span>(<span class="string">&quot;012&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;rp &quot;</span> &lt;&lt; rp &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>split</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> s[] = <span class="string">&quot;a b   c  d e&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* delim = <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="type">char</span>* p = <span class="literal">nullptr</span>;</span><br><span class="line">    p = <span class="built_in">strtok</span>(s, delim);</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">        p = <span class="built_in">strtok</span>(<span class="literal">nullptr</span>, delim);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a1;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a3 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a4</span><span class="params">(<span class="number">100</span>, <span class="number">0x3f3f3f3f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空</span></span><br><span class="line">    a1.<span class="built_in">clear</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;empty &quot;</span> &lt;&lt; a1.<span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    a1.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    a1.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    a1.<span class="built_in">push_back</span>(<span class="number">3</span>); <span class="comment">// 推入</span></span><br><span class="line">    a1.<span class="built_in">pop_back</span>(); <span class="comment">// 弹出</span></span><br><span class="line">    a1.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  原来的值不清空</span></span><br><span class="line">    a1.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器 [)</span></span><br><span class="line">    a1.<span class="built_in">begin</span>();</span><br><span class="line">    a1.<span class="built_in">end</span>(); <span class="comment">// 取不到</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头</span></span><br><span class="line">    cout &lt;&lt; a1.<span class="built_in">front</span>() &lt;&lt; endl;  <span class="comment">// aka a1[0]</span></span><br><span class="line">    <span class="comment">// 尾巴</span></span><br><span class="line">    cout &lt;&lt; a1.<span class="built_in">back</span>() &lt;&lt; endl; <span class="comment">// 可以取到 aka a1[a1.size() - 1]</span></span><br><span class="line"></span><br><span class="line">    a1.<span class="built_in">insert</span>(a1.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">999</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; ---- &quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : a1) &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// 这么写是错的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = a.<span class="built_in">begin</span>(); it != a.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*it % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            a.<span class="built_in">erase</span>(it);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : a) &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// 正确做法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = a.<span class="built_in">begin</span>(); it != a.<span class="built_in">end</span>();) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*it % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            it = a.<span class="built_in">erase</span>(it); <span class="comment">// 返回下一个有效的iterator</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; *(it++) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : a) &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>





<h2 id="queue、stack"><a href="#queue、stack" class="headerlink" title="queue、stack"></a>queue、stack</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    st.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    st.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; st.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; dq;</span><br><span class="line">    </span><br><span class="line">    dq.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    dq.<span class="built_in">push_front</span>(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    dq.<span class="built_in">pop_front</span>();</span><br><span class="line">    dq.<span class="built_in">pop_back</span>();</span><br><span class="line">    </span><br><span class="line">    dq.<span class="built_in">front</span>();</span><br><span class="line">    dq.<span class="built_in">back</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Node &amp;node) <span class="type">const</span> &#123; <span class="comment">// 注意两个 const 修饰</span></span><br><span class="line">        <span class="keyword">return</span> x * y &lt; node.x * node.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 大根堆</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; pq1;</span><br><span class="line">    <span class="comment">// 小根堆</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; pq2;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;Node&gt; pq3;</span><br><span class="line">    pq3.<span class="built_in">push</span>(&#123;<span class="number">2</span>, <span class="number">2</span>&#125;);</span><br><span class="line">    pq3.<span class="built_in">push</span>(&#123;<span class="number">3</span>, <span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(pq3.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node node = pq3.<span class="built_in">top</span>();</span><br><span class="line">        pq3.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不可以既重写Node的操作符，又使用greater</span></span><br><span class="line"><span class="comment">//    priority_queue&lt;Node, vector&lt;Node&gt;, greater&lt;Node&gt;&gt; pq4;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="set、unordered-set"><a href="#set、unordered-set" class="headerlink" title="set、unordered_set"></a>set、unordered_set</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断存在与否</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">count</span>(<span class="number">1</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">find</span>(<span class="number">1</span>) != s.<span class="built_in">end</span>()) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正序遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : s) &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 或者</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    s.<span class="built_in">erase</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逆序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = s.<span class="built_in">rbegin</span>(); it != s.<span class="built_in">rend</span>(); ++it) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; -------------- &quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历删除的正确做法</span></span><br><span class="line">    s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>();) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*it % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            s.<span class="built_in">erase</span>(it++);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; *(it++) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : s) &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    s = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分查找</span></span><br><span class="line">    <span class="keyword">auto</span> it = s.<span class="built_in">lower_bound</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">advance</span>(it, <span class="number">1</span>); <span class="comment">// O(len)</span></span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">advance</span>(it, <span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">advance</span>(it, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (it == s.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;to end&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>unordered_set更简单，因为它是无序的，所以api’更少。</p>
<p><strong>自定义排序类型</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Node &amp;b) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x != b.x ? x &lt; b.x : y &lt; b.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    set&lt;Node&gt; set = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">                    &#123;<span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                    &#123;<span class="number">2</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; node : set) &#123;</span><br><span class="line">        cout &lt;&lt; node.x &lt;&lt;<span class="string">&quot;,&quot;</span> &lt;&lt; node.y &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="map、unordered-map"><a href="#map、unordered-map" class="headerlink" title="map、unordered_map"></a>map、unordered_map</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line">    mp = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">          &#123;<span class="number">3</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line">    cout &lt;&lt; mp[<span class="number">1</span>]++ &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; mp[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    mp.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 如果键已经存在，则不插入</span></span><br><span class="line">    cout &lt;&lt; mp[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断存在与否</span></span><br><span class="line">    <span class="keyword">if</span> (mp.<span class="built_in">find</span>(<span class="number">1</span>) != mp.<span class="built_in">end</span>()) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mp.<span class="built_in">count</span>(<span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    mp = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">          &#123;<span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">          &#123;<span class="number">5</span>, <span class="number">6</span>&#125;,</span><br><span class="line">          &#123;<span class="number">7</span>, <span class="number">8</span>&#125;&#125;;</span><br><span class="line">   	<span class="keyword">for</span>(<span class="keyword">auto</span> [k,v] : mp) &#123;</span><br><span class="line">        cout &lt;&lt; k &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;item :mp) &#123;</span><br><span class="line">        cout &lt;&lt; item.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; item.second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = mp.<span class="built_in">rbegin</span>(); it != mp.<span class="built_in">rend</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="multiset、multimap"><a href="#multiset、multimap" class="headerlink" title="multiset、multimap"></a>multiset、multimap</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    multiset&lt;<span class="type">int</span>&gt; multiset;</span><br><span class="line"></span><br><span class="line">    multiset.<span class="built_in">insert</span>(<span class="number">4</span>);</span><br><span class="line">    multiset.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    multiset.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">    multiset.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x : multiset) &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    multimap&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">    mp.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    mp.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    mp.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it:mp) &#123;</span><br><span class="line">        cout &lt;&lt; it.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it.second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="容器的相互转换"><a href="#容器的相互转换" class="headerlink" title="容器的相互转换"></a>容器的相互转换</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; dq = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(dq.begin(), dq.end())</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x : a) &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">99</span>; <span class="comment">// 不影响原值</span></span><br><span class="line">    <span class="keyword">while</span> (!dq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; dq.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">        dq.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/28/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SongyangJi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JsyBlog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | JsyBlog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/11/28/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="post-title-link" itemprop="url">Lambda表达式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-28 19:34:21" itemprop="dateCreated datePublished" datetime="2021-11-28T19:34:21+08:00">2021-11-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-02 22:44:06" itemprop="dateModified" datetime="2022-09-02T22:44:06+08:00">2022-09-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="C-中lambda表达式"><a href="#C-中lambda表达式" class="headerlink" title="C++中lambda表达式"></a>C++中lambda表达式</h1><p>Lambda表达式包含一个函数对象参数</p>
<p>标识一个 Lambda 表达式的开始，这部分必须存在，不能省略。函数对象参数是传递给编译器自动生成的函数对象类的构造函数的。函数对象参数只能使用那些到定义 Lambda 为止时 Lambda 所在作用范围内可见的局部变量(包括 Lambda 所在类<br>的 this)。函数对象参数有以下形式：</p>
<ul>
<li>空。没有任何函数对象参数。</li>
<li>&#x3D;。函数体内可以使用 Lambda 所在范围内所有可见的局部变量（包括 Lambda 所在类的 this），并且是值传递方式（相当于编译器自动为我们按值传递了所有局部变量）。</li>
<li>&amp;。函数体内可以使用 Lambda 所在范围内所有可见的局部变量（包括 Lambda 所在类的 this），并且是引用传递方式（相当于是编译器自动为我们按引用传递了所有局部变量）。</li>
<li>this。函数体内可以使用 Lambda 所在类中的成员变量。</li>
</ul>
<p>具体的使用方法示例：</p>
<ul>
<li><code>a</code>。将 a 按值进行传递。按值进行传递时，函数体内不能修改传递进来的 a 的拷贝，因为默认情况下函数是 const 的，要<br>修改传递进来的拷贝，可以添加 mutable 修饰符。</li>
<li><code>&amp;a</code>。将 a 按引用进行传递。</li>
<li><code>a，&amp;b</code>。将 a 按值传递，b 按引用进行传递。</li>
<li><code>[=]，&amp;a，&amp;b</code>。除 a 和 b 按引用进行传递外，其他参数都按值进行传递。</li>
<li><code>[&amp;]，a，b</code>。除 a 和 b 按值进行传递外，其他参数都按引用进行传递</li>
</ul>
<p>sort使用lambda表达式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">allCellsDistOrder</span>(<span class="type">int</span> R, <span class="type">int</span> C, <span class="type">int</span> r0, <span class="type">int</span> c0) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; R; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; C; j++) &#123;</span><br><span class="line">                ret.<span class="built_in">push_back</span>(&#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(ret.<span class="built_in">begin</span>(), ret.<span class="built_in">end</span>(), [=](vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b) &#123;<span class="comment">//因为r0,c0是当前函数的局部变量，所以只能使用值传递而不能使用引用传递造成指针混乱</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(a[<span class="number">0</span>] - r0) + <span class="built_in">abs</span>(a[<span class="number">1</span>] - c0) &lt; <span class="built_in">abs</span>(b[<span class="number">0</span>] - r0) + <span class="built_in">abs</span>(b[<span class="number">1</span>] - c0);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/27/IPC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SongyangJi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JsyBlog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | JsyBlog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/11/27/IPC/" class="post-title-link" itemprop="url">进程间通信IPC</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-27 17:40:03" itemprop="dateCreated datePublished" datetime="2021-11-27T17:40:03+08:00">2021-11-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-12-15 00:37:43" itemprop="dateModified" datetime="2021-12-15T00:37:43+08:00">2021-12-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>进程间通信（IPC：interprocess communication）是一种涉及一个进程与另一个进程的通信的机制。 这通常只发生在一个系统中。</p>
<p>沟通可以有两种类型 -</p>
<ul>
<li>在仅从一个进程启动的相关进程之间，例如父进程和子进程。</li>
<li>在不相关的进程之间，或两个或多个不同的进程之间。</li>
</ul>
<p>具体来说，有下面三大类形式：</p>
<p><img src="/2021/11/27/IPC/ipc.png"></p>
<p>按照《UNIX网络编程 卷2：进程间通信》的目录分类：</p>
<ol>
<li>消息传递（管道、FIFO、消息队列）</li>
<li>同步（互斥锁和条件变量、读写锁、信号量）</li>
<li>共享内存（匿名的、具名的）</li>
</ol>
<h1 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h1><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p><strong>管道是两个或多个相关或相互关联的过程之间的通信媒介。</strong></p>
<p>它可以在一个进程内，也可以在子进程和父进程之间进行通信。 通信也可以是多层次的，例如父母，孩子和孙子之间的通信等。通过写入管道的一个过程和管道的其他读取来实现通信。 </p>
<p><strong>要实现管道系统调用，请创建两个文件，一个用于写入文件，另一个用于从文件中读取。</strong></p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipedes[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure>

<p>该系统调用将创建用于单向通信的管道，即，它创建两个描述符，第一个连接到管道读取而另一个连接以写入管道。</p>
<p>描述符pipedes [0]用于读取，pipedes [1]用于写入。 无论写入管道[1]是什么都可以从pipedes [0]中读取。</p>
<p>此调用在成功时返回零，在失败时返回-1。 要了解失败的原因，请使用errno variable或perror（）函数进行检查。</p>
<p>如下图这是使用管道进行双向通信的常见做法：</p>
<p><img src="/2021/11/27/IPC/pipe_with_two.jpg" alt="img"></p>
<h3 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 用两个单工的管道实现双向通信</span></span><br><span class="line">    <span class="type">int</span> pipefds1[<span class="number">2</span>], pipefds2[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> returnstatus1, returnstatus2;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="type">char</span> pipe1writemessage[<span class="number">20</span>] = <span class="string">&quot;Hi&quot;</span>;</span><br><span class="line">    <span class="type">char</span> pipe2writemessage[<span class="number">20</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">char</span> readmessage[<span class="number">20</span>];</span><br><span class="line">    returnstatus1 = pipe(pipefds1);</span><br><span class="line">    <span class="keyword">if</span> (returnstatus1 == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Unable to create pipe 1 \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    returnstatus2 = pipe(pipefds2);</span><br><span class="line">    <span class="keyword">if</span> (returnstatus2 == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Unable to create pipe 2 \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid != <span class="number">0</span>) &#123; <span class="comment">// Parent process </span></span><br><span class="line">        close(pipefds1[<span class="number">0</span>]); <span class="comment">// Close the unwanted pipe1 read side</span></span><br><span class="line">        close(pipefds2[<span class="number">1</span>]); <span class="comment">// Close the unwanted pipe2 write side</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;In Parent: Writing to pipe 1 – Message is %s\n&quot;</span>, pipe1writemessage);</span><br><span class="line">        write(pipefds1[<span class="number">1</span>], pipe1writemessage, <span class="keyword">sizeof</span>(pipe1writemessage));</span><br><span class="line">        read(pipefds2[<span class="number">0</span>], readmessage, <span class="keyword">sizeof</span>(readmessage));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;In Parent: Reading from pipe 2 – Message is %s\n&quot;</span>, readmessage);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//child process</span></span><br><span class="line">        close(pipefds1[<span class="number">1</span>]); <span class="comment">// Close the unwanted pipe1 write side</span></span><br><span class="line">        close(pipefds2[<span class="number">0</span>]); <span class="comment">// Close the unwanted pipe2 read side</span></span><br><span class="line">        read(pipefds1[<span class="number">0</span>], readmessage,</span><br><span class="line">             <span class="keyword">sizeof</span>(readmessage));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;In Child: Reading from pipe 1 – Message is %s\n&quot;</span>, readmessage);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;In Child: Writing to pipe 2 – Message is %s\n&quot;</span>, pipe2writemessage);</span><br><span class="line">        write(pipefds2[<span class="number">1</span>], pipe2writemessage,</span><br><span class="line">              <span class="keyword">sizeof</span>(pipe2writemessage));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h2><p>暂略</p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>当我们已经拥有共享内存时，为什么我们需要消息队列？ 这将有多种原因，让我们试着将其分解为多个点以简化 -</p>
<ul>
<li>如所理解的，一<strong>旦进程接收到消息，它将不再可用于任何其他过程</strong>。 而在共享内存中，数据可供多个进程访问。</li>
<li>如果我们想要与小消息格式进行通信。</li>
<li>当多个进程同时通信时，<strong>共享内存数据需要通过同步进行保护</strong>。</li>
<li>使用共享内存的写入和读取频率很高，但<strong>实现该功能将非常复杂</strong>。 在这种情况下使用不值得。</li>
<li>如果<strong>并不是所有进程都需要访问共享内存</strong>，那么使用消息队列实现会更好。</li>
<li>如果我们想要<strong>与不同的数据包进行通信</strong>，则说过程A将消息类型1发送到进程B，消息类型10发送到进程C，消息类型20发送到进程D.在这种情况下，使用消息队列实现更简单。 为了将给定的消息类型简化为1,10,20，它可以是0或+ ve或-ve，如下所述。</li>
<li>当然，<strong>消息队列的顺序是FIFO</strong>（先进先出）。 插入队列中的第一条消息是第一个要检索的消息。</li>
</ul>
<ol>
<li>通过一个进程写入共享内存并通过另一个进程从共享内存中读取。 我们知道，阅读也可以通过多个流程完成</li>
</ol>
<p><img src="/2021/11/27/IPC/message_queue.jpg" alt="消息队列"></p>
<ol start="2">
<li>一个进程使用不同的数据包写入共享内存，并通过多个进程从中读取，即按消息类型。</li>
</ol>
<p><img src="/2021/11/27/IPC/multiple_message_queue.jpg" alt="多个消息队列"></p>
<h3 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h3><p>这里以POSIX的接口为实例</p>
<table>
<thead>
<tr>
<th>API</th>
<th>API 作用</th>
</tr>
</thead>
<tbody><tr>
<td>mqd_t mq_open(const char <em>name, int oflag, mode_t mode, struct mq_attr</em> attr)</td>
<td>创建命名消息队列</td>
</tr>
<tr>
<td>mqd_t mq_close(mqd_t mqdes)</td>
<td>结束到开放式消息队列的连接</td>
</tr>
<tr>
<td>mqd_t mq_unlink(const char *name)</td>
<td>结束到开放式消息队列的连接，并在最后一个进程关闭此队列时将其删除</td>
</tr>
<tr>
<td>mqd_t mq_send(mqd_t mqdes, const char *msg_ptr, size_t msg_len, unsigned msg_prio)</td>
<td>将消息放入队列</td>
</tr>
<tr>
<td>ssize_t mq_receive(mqd_t mqdes, char <em>msg_ptr, size_t msg_len, unsigned</em> msg_prio)</td>
<td>在队列中接收消息</td>
</tr>
<tr>
<td>mqd_t mq_notify(mqd_t mqdes, const struct sigevent *notification)</td>
<td>通知进程或线程消息已存在于队列中</td>
</tr>
<tr>
<td>mqd_t mq_getattr(mqd_t mqdes, struct mq_attr <em>attr) 、mqd_t mq_setattr(mqd_t mqdes, struct mq_attr</em> newattr, struct mq_attr *oldattr)</td>
<td>设置或获取消息队列属性</td>
</tr>
</tbody></table>
<h1 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h1><h2 id="互斥锁与条件变量"><a href="#互斥锁与条件变量" class="headerlink" title="互斥锁与条件变量"></a>互斥锁与条件变量</h2><p>这里互斥锁和条件变量的使用，与Java的<code>synchronized+wait+notify</code>以及<code>Lock+Condition</code> 机制在语义上和使用上十分相似，就不详细介绍了。</p>
<h3 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法"></a>使用方法</h3><blockquote>
<p>linux c版本的条件变量和互斥锁(mutex)，不是C++的。</p>
</blockquote>
<ol>
<li>互斥锁的初始化</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>互斥锁的销毁</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>加锁与解锁</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure>



<ol start="4">
<li>条件变量的函数</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">           <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></table></figure>





<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>基本上信号量分为两种类型 -</p>
<p><strong>Binary Semaphores</strong> - 只有两个状态0和1，即锁定&#x2F;解锁或可用&#x2F;不可用，Mutex实现。</p>
<p><strong>Counting Semaphores</strong> - 允许任意资源计数的信号量称为计数信号量。</p>
<h3 id="使用方法-3"><a href="#使用方法-3" class="headerlink" title="使用方法"></a>使用方法</h3><table>
<thead>
<tr>
<th>API</th>
<th>API 作用</th>
</tr>
</thead>
<tbody><tr>
<td>sem_t *sem_open(const char  *name, int oflag, mode_t mode, unsigned int value)</td>
<td>创建命名信号量</td>
</tr>
<tr>
<td>int sem_init(sem_t *sem, int pshared, unsigned int value)</td>
<td>初始化信号量结构</td>
</tr>
<tr>
<td>int sem_close(sem_t *sem)</td>
<td>结束到开放式信号量的连接</td>
</tr>
<tr>
<td>int sem_unlink(const char *name)</td>
<td>结束到开放式信号量的连接，并在最后一个进程关闭此信号量时将其删除</td>
</tr>
<tr>
<td>int sem_getvalue(sem_t <em>sem, int</em> sval)</td>
<td>将信号量的值复制到指定整数中</td>
</tr>
<tr>
<td>int sem_wait(sem_t *sem)</td>
<td>递减信号量计数，当其他进程拥有信号量时进行阻塞，或者当其他进程拥有信号量时返回错误（aka P 操作）</td>
</tr>
<tr>
<td>int sem_post(sem_t *sem)</td>
<td>递增信号量计数（aka V 操作）</td>
</tr>
</tbody></table>
<h1 id="共享内存相关"><a href="#共享内存相关" class="headerlink" title="共享内存相关"></a>共享内存相关</h1><h2 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h2><p>mmap()系统调用在调用进程的虚拟地址空间中提供映射，该映射将文件或设备映射到内存中。 这有两种类型 -</p>
<p><strong>File mapping or File-backed mapping</strong> - 此映射将进程的虚拟内存区域映射到文件。 这意味着读取或写入这些内存区域会导致文件被读取或写入。 这是默认的映射类型。</p>
<p><strong>Anonymous mapping</strong> - 此映射映射进程的虚拟内存区域，不受任何文件的支持。 内容初始化为零。 此映射类似于动态内存分配（malloc()），并在某些malloc()实现中用于某些分配。</p>
<p>当两个或多个进程共享相同的页面时，每个进程可以根据映射类型查看其他进程所做的页面内容的更改。 映射类型可以是私有的也可以是共享的 -</p>
<p><strong>Private Mapping (MAP_PRIVATE)</strong> - 对此映射内容的修改对其他进程不可见，并且映射不会传送到基础文件。</p>
<p><strong>Shared Mapping (MAP_SHARED)</strong> - 对此映射内容的修改对其他进程可见，并且映射将传送到基础文件。</p>
<h3 id="使用方法-4"><a href="#使用方法-4" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数</li>
</ul>
<p>虚拟地址addr可以是用户指定的，也可以是内核生成的（将addr作为NULL传递）;</p>
<p>字段length需要以字节为单位的映射大小;</p>
<p>字段prot表示存储器保护值，例如PROT_NONE，PROT_READ，PROT_WRITE，PROT_EXEC，分别用于可能无法访问，读取，写入或执行的区域。 该值可以是单个（PROT_NONE），也可以与三个标志中的任何一个（最后3个）进行OR运算;</p>
<p>字段flags指示映射类型或MAP_PRIVATE或MAP_SHARED;</p>
<p>字段fd表示标识要映射的文件的文件描述符;</p>
<p>字段offset表示文件的起始点，如果需要映射整个文件，则偏移量应为零。</p>
<ul>
<li>返回值</li>
</ul>
<p>在成功时返回映射的起始地址，或者在出错时返回MAP_FAILED。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></table></figure>

<p>执行已映射内存映射区域的取消映射。</p>
<p>字段addr表示映射的起始地址，length表示要取消映射的映射的字节大小。</p>
<h3 id="实例代码-1"><a href="#实例代码-1" class="headerlink" title="实例代码"></a>实例代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Filename: mmap_test.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_mmap_sample_data</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">mmapstat</span>;</span></span><br><span class="line">    <span class="type">char</span> *data;</span><br><span class="line">    <span class="type">int</span> minbyteindex;</span><br><span class="line">    <span class="type">int</span> maxbyteindex;</span><br><span class="line">    <span class="type">int</span> offset;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">int</span> unmapstatus;</span><br><span class="line">    write_mmap_sample_data();</span><br><span class="line">    <span class="keyword">if</span> (stat(<span class="string">&quot;MMAP_DATA.txt&quot;</span>, &amp;mmapstat) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;stat failure&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((fd = open(<span class="string">&quot;MMAP_DATA.txt&quot;</span>, O_RDONLY)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open failure&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    data = mmap((<span class="type">caddr_t</span>) <span class="number">0</span>, mmapstat.st_size, PROT_READ, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (data == (<span class="type">caddr_t</span>) (<span class="number">-1</span>)) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap failure&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    minbyteindex = <span class="number">0</span>;</span><br><span class="line">    maxbyteindex = mmapstat.st_size - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Enter -1 to quit or &quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;enter a number between %d and %d: &quot;</span>, minbyteindex, maxbyteindex);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;offset);</span><br><span class="line">        <span class="keyword">if</span> ((offset &gt;= <span class="number">0</span>) &amp;&amp; (offset &lt;= maxbyteindex))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Received char at %d is %c\n&quot;</span>, offset, data[offset]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (offset != <span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Received invalid index %d\n&quot;</span>, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (offset != <span class="number">-1</span>);</span><br><span class="line">    unmapstatus = munmap(data, mmapstat.st_size);</span><br><span class="line">    <span class="keyword">if</span> (unmapstatus == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;munmap failure&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    system(<span class="string">&quot;rm -f MMAP_DATA.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_mmap_sample_data</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">textfilestat</span>;</span></span><br><span class="line">    fd = open(<span class="string">&quot;MMAP_DATA.txt&quot;</span>, O_CREAT | O_TRUNC | O_WRONLY, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;File open error &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Write A to Z</span></span><br><span class="line">    ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">        write(fd, &amp;ch, <span class="keyword">sizeof</span>(ch));</span><br><span class="line">        ch++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Write 0 to 9</span></span><br><span class="line">    ch = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        write(fd, &amp;ch, <span class="keyword">sizeof</span>(ch));</span><br><span class="line">        ch++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Write a to z</span></span><br><span class="line">    ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt;= <span class="string">&#x27;z&#x27;</span>) &#123;</span><br><span class="line">        write(fd, &amp;ch, <span class="keyword">sizeof</span>(ch));</span><br><span class="line">        ch++;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>共享内存是两个或多个进程之间共享的内存。 但是，为什么我们需要共享内存或其他一些通信方式？</p>
<p>重申一下，每个进程都有自己的地址空间，如果任何进程想要将自己的地址空间中的某些信息与其他进程通信，那么只有IPC（进程间通信）技术才有可能。 我们已经知道，沟通可以在相关或不相关的流程之间进行。</p>
<h3 id="Posix-版本"><a href="#Posix-版本" class="headerlink" title="Posix 版本"></a>Posix 版本</h3><table>
<thead>
<tr>
<th>API</th>
<th>API 作用</th>
</tr>
</thead>
<tbody><tr>
<td>int shm_open(const char *name, int oflag, mode_t mode)</td>
<td>创建共享内存，成功返回描述符</td>
</tr>
<tr>
<td>int shm_unlink(const char *name)</td>
<td>结束到共享内存的连接，并在最后一个进程关闭它时将其删除</td>
</tr>
<tr>
<td>void <em>mmap(void</em> addr, size_t length, int prot, int flags, int fd, off_t offset)</td>
<td>映射内存</td>
</tr>
</tbody></table>
<p>Posix的共享内存区构筑在<code>mmap</code>之上。</p>
<h3 id="SystemV-版本"><a href="#SystemV-版本" class="headerlink" title="SystemV 版本"></a>SystemV 版本</h3><p>相关函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建或分配System V共享内存段, 成功时返回有效的共享内存标识符（用于进一步调用共享内存）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span></span><br><span class="line"><span class="comment">// 为System V共享内存段执行共享内存操作，即将共享内存段附加到调用进程的地址空间。成功时返回附加共享内存段的地址。 </span></span><br><span class="line"><span class="type">void</span> * <span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span></span><br><span class="line"><span class="comment">// 从调用进程的地址空间中分离共享内存段的System V共享内存段。将在成功时返回0，在失败时返回-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span></span><br><span class="line"><span class="comment">// 执行System V共享内存段的控制操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span>  </span><br></pre></td></tr></table></figure>





<blockquote>
<p>参考链接</p>
<p>《UNIX网络编程 卷2：进程间通信》</p>
<p><a target="_blank" rel="noopener" href="https://iowiki.com/inter_process_communication/inter_process_communication_index.html">WIKI教程</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/52php/p/5861372.html">Linux进程间通信（六）：共享内存 shmget()、shmat()、shmdt()、shmctl() </a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/27/Linux%E5%91%BD%E4%BB%A4-%E2%80%94%E2%80%94-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9B%91%E6%8E%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SongyangJi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JsyBlog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | JsyBlog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/11/27/Linux%E5%91%BD%E4%BB%A4-%E2%80%94%E2%80%94-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9B%91%E6%8E%A7/" class="post-title-link" itemprop="url">Linux命令 —— 进程、线程监控</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-27 13:02:16" itemprop="dateCreated datePublished" datetime="2021-11-27T13:02:16+08:00">2021-11-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-28 15:28:16" itemprop="dateModified" datetime="2022-03-28T15:28:16+08:00">2022-03-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/26/HTTP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SongyangJi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JsyBlog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | JsyBlog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/11/26/HTTP/" class="post-title-link" itemprop="url">HTTP协议</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-26 08:33:48" itemprop="dateCreated datePublished" datetime="2021-11-26T08:33:48+08:00">2021-11-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-01-04 01:32:41" itemprop="dateModified" datetime="2023-01-04T01:32:41+08:00">2023-01-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>一个不错的网站可以学习：</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP">https://developer.mozilla.org/zh-CN/docs/Web/HTTP</a></p>
<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p><strong>一个HTTP请求报文由四个部分组成：请求行、请求头部、空行、请求数据。</strong></p>
<h2 id="HTTP头部"><a href="#HTTP头部" class="headerlink" title="HTTP头部"></a>HTTP头部</h2><p>参考文章：</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers</a></p>
<p>HTTP 头部本质上是一个传递额外重要信息的键值对。</p>
<p>主要分为：通用头部，请求头部，响应头部和实体头部。</p>
<ol>
<li>通用头：是客户端和服务器都可以使用的头部，可以在客户端、服务器和其他应用程序之间提供一些非常有用的通用功能，如Date头部。</li>
<li>请求头：请求报文特有的，它们为服务器提供了一些额外信息，比如客户端希望接收什么类型的数据，如Accept头部。</li>
<li>响应头：响应报文特有的，比如，客服端在与哪种类型的服务器进行交互，如Server头部。</li>
<li>实体头：实体首部字段是包含在请求报文和响应报文中的实体部分使用的首部，用于补充内容的更新时间等与实体相关的信息。</li>
</ol>
<h3 id="通用头部"><a href="#通用头部" class="headerlink" title="通用头部"></a>通用头部</h3><table>
<thead>
<tr>
<th>协议头</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cache-Control</td>
<td>用来指定当前的请求/回复中是否使用缓存机制</td>
<td>Cache-Control: no-store</td>
</tr>
<tr>
<td>Connection</td>
<td>客户端（浏览器）想要优先使用的连接类型</td>
<td>Connection: keep-alive (Upgrade)</td>
</tr>
<tr>
<td>Date</td>
<td>报文创建时间</td>
<td>Date: Dec, 26 Dec 2015 17: 30: 00 GMT</td>
</tr>
<tr>
<td>Trailer</td>
<td>会实现说明在报文主体后记录哪些首部字段，该首部字段可以使用在 HTTP/1.1 版本分块传输编码时</td>
<td>Trailer: Expiress</td>
</tr>
<tr>
<td>Transfer-Encoding</td>
<td>用来改变报文格式</td>
<td>Transfer-Encoding: chunked</td>
</tr>
<tr>
<td>Upgrade</td>
<td>要求服务器升级到一个高版本协议</td>
<td>Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td>
</tr>
<tr>
<td>Via</td>
<td>告诉服务器，这个请求是由哪些代理发出的</td>
<td>Via: 1.0 fred, 1.1 <a href="http://itbilu.com.com" target="_blank">itbilu.com.com</a> (Apache/1.1)</td>
</tr>
<tr>
<td>Warning</td>
<td>一个一般性的警告，表示在实体内容中可能存在错误</td>
<td>Warning: 199 Miscellaneous warning</td>
</tr>
</tbody>
</table>



<p>比较重要的有 <code>Cache-Control</code>、<code>Connection</code>。</p>
<h3 id="请求头部"><a href="#请求头部" class="headerlink" title="请求头部"></a>请求头部</h3><table>
<thead>
<tr>
<th>协议头</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept</td>
<td>告诉服务器自己允许哪些媒体类型</td>
<td>Accept: text/plain</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>浏览器申明可接受的字符集</td>
<td>Accept-Charset: utf-8</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>浏览器申明自己接收的编码方法</td>
<td>Accept-Encoding: gzip, deflate</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>浏览器可接受的响应内容语言列表</td>
<td>Accept-Language: en-US</td>
</tr>
<tr>
<td>Authorization</td>
<td>用于表示 HTTP 协议中需要认证资源的认证信息</td>
<td>Authorization: Basic OSdjJGRpbjpvcGVul ANIc2SdDE==</td>
</tr>
<tr>
<td>Expect</td>
<td>表示客户端要求服务器做出特定的行为</td>
<td>Expect: 100-continue</td>
</tr>
<tr>
<td>From</td>
<td>发起此请求的用户的邮件地址</td>
<td>From: <a href="mailto:user@itbilu.com" target="_blank">user@itbilu.com</a></td>
</tr>
<tr>
<td>Host</td>
<td>表示服务器的域名以及服务器所监听的端口号</td>
<td>Host: <a href="http://www.itbilu.com:80" target="_blank">www.itbilu.com:80</a></td>
</tr>
<tr>
<td>If-XXX</td>
<td>条件请求</td>
<td>If-Modified-Since: Dec, 26 Dec 2015 17:30:00 GMT</td>
</tr>
<tr>
<td>Max-Forwards</td>
<td>限制该消息可被代理及网关转发的次数</td>
<td>Max-Forwards: 10</td>
</tr>
<tr>
<td>Range</td>
<td>表示请求某个实体的一部分，字节偏移以 0 开始</td>
<td>Range: bytes=500-999</td>
</tr>
<tr>
<td>Referer</td>
<td>表示浏览器所访问的前一个页面，可以认为是之前访问页面的链接将浏览器带到了当前页面</td>
<td>Referer: <a href="http://itbilu.com/nodejs" target="_blank">http://itbilu.com/nodejs</a></td>
</tr>
<tr>
<td>User-Agent</td>
<td>浏览器的身份标识字符串</td>
<td>User-Agent: Mozilla/……</td>
</tr>
</tbody>
</table>


<p>比较重要的有<code>Referer</code>、<code>User-Agent</code>、<code>Range</code>。</p>
<h3 id="响应头部"><a href="#响应头部" class="headerlink" title="响应头部"></a>响应头部</h3><table>
<thead>
<tr>
<th>协议头</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept-Ranges</td>
<td>字段的值表示可用于定义范围的单位</td>
<td>Accept-Ranges: bytes</td>
</tr>
<tr>
<td>Age</td>
<td>创建响应的时间</td>
<td>Age：5744337</td>
</tr>
<tr>
<td>ETag</td>
<td>唯一标识分配的资源</td>
<td>Etag：W/"585cd998-7c0f"</td>
</tr>
<tr>
<td>Location</td>
<td>表示重定向后的 URL</td>
<td>Location: <a href="http://www.zcmhi.com/archives/94.html" target="_blank">http://www.zcmhi.com/archives/94.html</a></td>
</tr>
<tr>
<td>Retry-After</td>
<td>告知客户端多久后再发送请求</td>
<td>Retry-After: 120</td>
</tr>
<tr>
<td>Server</td>
<td>告知客户端服务器信息</td>
<td>Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)</td>
</tr>
<tr>
<td>Vary</td>
<td>缓存控制</td>
<td>Vary: Origin</td>
</tr>
</tbody>
</table>


<p>比较重要的有<code>Accept-Ranges</code>、<code>Location</code></p>
<h3 id="实体头部"><a href="#实体头部" class="headerlink" title="实体头部"></a>实体头部</h3><table>
<thead>
<tr>
<th>协议头</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>Allow</td>
<td>对某网络资源的有效的请求行为，不允许则返回405</td>
<td>Allow: GET, HEAD</td>
</tr>
<tr>
<td>Content-encoding</td>
<td>返回内容的编码方式</td>
<td>Content-Encoding: gzip</td>
</tr>
<tr>
<td>Content-Length</td>
<td>返回内容的字节长度</td>
<td>Content-Length: 348</td>
</tr>
<tr>
<td>Content-Language</td>
<td>响应体的语言</td>
<td>Content-Language: en,zh</td>
</tr>
<tr>
<td>Content-Location</td>
<td>请求资源可替代的备用的另一地址</td>
<td>Content-Location: /index.htm</td>
</tr>
<tr>
<td>Content-MD5</td>
<td>返回资源的MD5校验值</td>
<td>Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</td>
</tr>
<tr>
<td>Content-Range</td>
<td>在整个返回体中本部分的字节位置</td>
<td>Content-Range: bytes 21010-47021/47022</td>
</tr>
<tr>
<td>Content-Type</td>
<td>返回内容的MIME类型</td>
<td>Content-Type: text/html; charset=utf-8</td>
</tr>
<tr>
<td>Expires</td>
<td>响应过期的日期和时间</td>
<td>Expires: Thu, 01 Dec 2010 16:00:00 GMT</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>请求资源的最后修改时间</td>
<td>Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT</td>
</tr>
</tbody>
</table>


<p>比较重要的有<code>Content-encoding</code>、<code>Content-Length</code>、<code>Content-Type</code>、<code>Content-MD5</code>、<code>Content-Range</code></p>
<h2 id="常用头部"><a href="#常用头部" class="headerlink" title="常用头部"></a>常用头部</h2><p>从hertz的<code>pkg/protocol/consts/headers.go</code> 里面列出了bytedancer认为的一些比较常用的header。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	HeaderAuthorization = <span class="string">&quot;Authorization&quot;</span></span><br><span class="line">	HeaderHost          = <span class="string">&quot;Host&quot;</span></span><br><span class="line">	HeaderReferer       = <span class="string">&quot;Referer&quot;</span></span><br><span class="line">	HeaderContentType   = <span class="string">&quot;Content-Type&quot;</span></span><br><span class="line">	HeaderUserAgent     = <span class="string">&quot;User-Agent&quot;</span></span><br><span class="line">	HeaderExpect        = <span class="string">&quot;Expect&quot;</span></span><br><span class="line">	HeaderConnection    = <span class="string">&quot;Connection&quot;</span></span><br><span class="line">	HeaderContentLength = <span class="string">&quot;Content-Length&quot;</span></span><br><span class="line">	HeaderCookie        = <span class="string">&quot;Cookie&quot;</span></span><br><span class="line"></span><br><span class="line">	HeaderServer           = <span class="string">&quot;Server&quot;</span></span><br><span class="line">	HeaderServerLower      = <span class="string">&quot;server&quot;</span></span><br><span class="line">	HeaderSetCookie        = <span class="string">&quot;Set-Cookie&quot;</span></span><br><span class="line">	HeaderSetCookieLower   = <span class="string">&quot;set-cookie&quot;</span></span><br><span class="line">	HeaderTransferEncoding = <span class="string">&quot;Transfer-Encoding&quot;</span></span><br><span class="line">	HeaderDate             = <span class="string">&quot;Date&quot;</span></span><br><span class="line"></span><br><span class="line">	HeaderRange        = <span class="string">&quot;Range&quot;</span></span><br><span class="line">	HeaderAcceptRanges = <span class="string">&quot;Accept-Ranges&quot;</span></span><br><span class="line">	HeaderContentRange = <span class="string">&quot;Content-Range&quot;</span></span><br><span class="line"></span><br><span class="line">	HeaderIfModifiedSince = <span class="string">&quot;If-Modified-Since&quot;</span></span><br><span class="line">	HeaderLastModified    = <span class="string">&quot;Last-Modified&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Message body information</span></span><br><span class="line">	HeaderContentEncoding = <span class="string">&quot;Content-Encoding&quot;</span></span><br><span class="line">	HeaderAcceptEncoding  = <span class="string">&quot;Accept-Encoding&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Redirects</span></span><br><span class="line">	HeaderLocation = <span class="string">&quot;Location&quot;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ... </span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><p>HTTP 状态码由三个十进制数字组成，第一个数字定义了状态码的类型，后两个并没有起到分类的作用。HTTP 状态码共有 5 种类型：</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1XX</td>
<td>指示信息–表示请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td><strong>成功</strong>–表示请求已被成功处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td><strong>重定向</strong>–要完成的请求需要进行附加操作</td>
</tr>
<tr>
<td>4XX</td>
<td><strong>客户端错误</strong>–请求有语法错误或者请求无法实现，服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td><strong>服务器端错误</strong>–服务器处理请求出现错误</td>
</tr>
</tbody></table>
<p>下面是常用的状态码分类：</p>
<h3 id="1xx"><a href="#1xx" class="headerlink" title="1xx"></a>1xx</h3><p>1xx 类状态码属于提示信息，是协议处理中的⼀种中间状态，实际⽤到的⽐较少。</p>
<h3 id="2xx"><a href="#2xx" class="headerlink" title="2xx"></a>2xx</h3><p>2xx 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。</p>
<p>「<strong>200 OK</strong>」是最常⻅的成功状态码，表示⼀切正常。如果是⾮ HEAD 请求，服务器返回的响应头都会有 body</p>
<p>数据。</p>
<p>「<strong>204 No Content</strong>」也是常⻅的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</p>
<p>「<strong>206 Partial Content</strong>」是应⽤于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，⽽是其中的⼀部分，也是服务器处理成功的状态。</p>
<h3 id="3xx"><a href="#3xx" class="headerlink" title="3xx"></a>3xx</h3><p>3xx 类状态码表示客户端请求的资源发送了变动，需要客户端⽤新的 URL 重新发送请求获取资源，也就是重定</p>
<p>向。</p>
<p>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明请求的资源已经不存在了，需改⽤新的 URL 再次访问。</p>
<p>「<strong>302 Found</strong>」表示临时重定向，说明请求的资源还在，但暂时需要⽤另⼀个 URL 来访问。</p>
<p>301 和 302 都会在响应头⾥使⽤字段 Location ，指明后续要跳转的 URL，浏览器会⾃动重定向新的 URL。 </p>
<p>「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲⽂件，也称缓存重定向，⽤于缓存控制。</p>
<blockquote>
<p>重定向有两种：一种是302响应，称为临时重定向，一种是301响应，称为永久重定向。两者的区别是，如果服务器发送301永久重定向响应，浏览器会缓存<code>/hi</code>到<code>/hello</code>这个重定向的关联，下次请求<code>/hi</code>的时候，浏览器就直接发送<code>/hello</code>请求了。</p>
</blockquote>
<h3 id="4xx"><a href="#4xx" class="headerlink" title="4xx"></a>4xx</h3><p>4xx 类状态码表示客户端发送的报⽂有误，服务器⽆法处理，也就是错误码的含义。</p>
<p>「<strong>400 Bad Request</strong>」表示客户端请求的报⽂有错误，但只是个笼统的错误。</p>
<p>「<strong>403 Forbidden</strong>」表示服务器禁⽌访问资源，并不是客户端的请求出错。</p>
<p>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以⽆法提供给客户端。</p>
<h3 id="5xx"><a href="#5xx" class="headerlink" title="5xx"></a>5xx</h3><p>5xx 类状态码表示客户端请求报⽂正确，但是服务器处理时内部发⽣了错误，属于服务器端的错误码。</p>
<p>「<strong>500 Internal Server Error</strong>」与 400 类型，是个笼统通⽤的错误码，服务器发⽣了什么错误，我们并不知道。</p>
<p>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不⽀持，类似“即将开业，敬请期待”的意思。</p>
<p>「<strong>502 Bad Gateway</strong>」通常是服务器作为⽹关或代理时返回的错误码，表示服务器⾃身⼯作正常，访问后端服务器</p>
<p>发⽣了错误。</p>
<p>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时⽆法响应服务器，类似“⽹络服务正忙，请稍后᯿试”的意思。</p>
<h2 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h2><p>HTTP&#x2F;0.9 只定义了一种方法: GET。</p>
<p>HTTP&#x2F;1.0 定义了三种请求方法：GET, POST 和 HEAD 方法。</p>
<p>HTTP&#x2F;1.1 增加了六种请求方法：OPTIONS, PUT, PATCH, DELETE, TRACE 和 CONNECT 方法。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>请求指定的页面信息，并返回具体内容，通常只用于读取数据。</td>
</tr>
<tr>
<td>HEAD</td>
<td>类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头。</td>
</tr>
<tr>
<td>POST</td>
<td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立或已有资源的更改。</td>
</tr>
<tr>
<td>PUT</td>
<td>替换指定的资源，没有的话就新增。</td>
</tr>
<tr>
<td>DELETE</td>
<td>请求服务器删除 URL 标识的资源数据。</td>
</tr>
<tr>
<td>CONNECT</td>
<td>将服务器作为代理，让服务器代替用户进行访问。</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>向服务器发送该方法，会返回对指定资源所支持的 HTTP 请求方法。</td>
</tr>
<tr>
<td>TRACE</td>
<td>回显服务器收到的请求数据，即服务器返回自己收到的数据，主要用于测试和诊断。</td>
</tr>
<tr>
<td>PATCH</td>
<td>是对 PUT 方法的补充，用来对已知资源进行局部更新。</td>
</tr>
</tbody>
</table>



<p>用的最多的自然是<code>GET</code>、<code>POST</code>了， 甚至有一种观点认为只需要使用POST就够了。</p>
<h3 id="GET-和-POST-的区别"><a href="#GET-和-POST-的区别" class="headerlink" title="GET 和 POST 的区别"></a>GET 和 POST 的区别</h3><ul>
<li>get 提交的数据会放在 URL 之后，并且<strong>请求参数会被完整的保留在浏览器的记录</strong>里，由于<strong>参数直接暴露在 URL 中</strong>，可能会存在安全问题，因此往往用于获取资源信息。GET上要在url之外带一些参数就只能依靠url上附带querystring。</li>
<li>编码格式： get 请求只支持 URL 编码，post 请求支持多种编码格式。</li>
<li>字符集：get 只支持 ASCII 字符格式的参数，而 post 方法没有限制。</li>
<li>数据大小：get 提交的数据大小有限制（这里所说的<strong>限制是浏览器带来的</strong>，一般都限制在几千），而 post 方法提交的数据没限制</li>
<li>get 方式需要使用 queryString 来取得变量的值，而 post 方式通过将body解析成实体类来获取（当然还有其他的方式）。</li>
<li>TCP数据包：get 方法产生一个 TCP 数据包，post 方法产生两个（<strong>并不是所有的浏览器中都产生两个</strong>）。</li>
</ul>
<h2 id="特点（优点和缺点）"><a href="#特点（优点和缺点）" class="headerlink" title="特点（优点和缺点）"></a>特点（优点和缺点）</h2><h2 id="HTTP-如何保存状态"><a href="#HTTP-如何保存状态" class="headerlink" title="HTTP 如何保存状态"></a>HTTP 如何保存状态</h2><p>因为一个 HTTP 服务器并不保存关于客户机的任何信息，所以我们说 HTTP 是一个无状态协议。</p>
<p>通常有两种解决方案：</p>
<p>① <strong>基于 Session 实现的会话保持</strong></p>
<p>在客户端第一次向服务器发送 HTTP 请求后，<strong>服务器会创建一个 Session 对象并将客户端的身份信息以键值对的形式存储下来</strong>，然后<strong>分配一个会话标识（SessionId）给客户端</strong>，这个<strong>会话标识一般保存在客户端 Cookie 中</strong>，之后每次该浏览器<strong>发送 HTTP 请求都会带上 Cookie 中的 SessionId 到服务器</strong>，服务器根据会话标识就可以将之前的状态信息与会话联系起来，从而实现会话保持。</p>
<ul>
<li><p>优点：<strong>安全性高</strong>，因为状态信息保存在服务器端。</p>
</li>
<li><p><strong>缺点</strong>：**水平拓展差，由于大型网站往往采用的是分布式服务器，浏览器发送的 HTTP 请求一般要先通过负载均衡器才能到达具体的后台服务器，倘若同一个浏览器两次 HTTP 请求分别落在不同的服务器上时，基于 Session 的方法就不能实现会话保持了。</p>
</li>
</ul>
<p>【解决方法：<strong>采用中间件</strong>，例如 Redis，我们通过<strong>将 Session 的信息存储在 Redis 中</strong>，使得每个服务器都可以访问到之前的状态信息】</p>
<p>② <strong>基于 Cookie 实现的会话保持</strong></p>
<p>当服务器发送响应消息时，在 HTTP 响应头中设置 Set-Cookie 字段，用来存储客户端的状态信息。客户端解析出 HTTP 响应头中的字段信息，并根据其生命周期创建不同的 Cookie，这样一来每次浏览器发送 HTTP 请求的时候都会带上 Cookie 字段，从而实现状态保持。</p>
<p><strong>基于 Cookie 的会话保持与基于 Session 实现的会话保持最主要的区别是前者完全将会话状态信息存储在浏览器 Cookie 中。</strong></p>
<p><strong>优点</strong>：<strong>服务器无状态</strong>， 减轻服务器存储压力，同时便于服务端做水平拓展。</p>
<p><strong>缺点</strong>：该<strong>方式不够安全</strong>，因为状态信息存储在客户端，这意味着不能在会话中保存机密数据。除此之外，浏览器每次发起 HTTP 请求时都需要发送额外的 Cookie 到服务器端，会<strong>占用更多带宽</strong>。</p>
<p><strong>拓展：Cookie被禁用了怎么办？</strong></p>
<p>若遇到 Cookie 被禁用的情况，则可以通过重写 URL 的方式将会话标识放在 URL 的参数里，也可以实现会话保持。</p>
<blockquote>
<p><strong>URL重写</strong>（英语：URL Rewriting）是一种REST的相关技术，它可以在Web Server中，针对用户所提供的URL进行转换后，再传入Web Server中的程序处理器。</p>
<p>如果浏览器不支持Cookie或用户阻止了所有Cookie，可以把会话ID附加在HTML页面中所有的URL上，这些页面作为响应发送给客户。这样，当用户单击URL时，会话ID被自动作为请求行的一部分而不是作为头行发送回服务器。这种方法称为URL重写(URL rewriting)。</p>
</blockquote>
<p>详细参考<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/URL%E9%87%8D%E5%AF%AB">URL重写</a></p>
<h1 id="HTTP-与-HTTPs"><a href="#HTTP-与-HTTPs" class="headerlink" title="HTTP 与 HTTPs"></a>HTTP 与 HTTPs</h1><p>HTTPS 采用对称加密和非对称加密相结合的方式，首先使用 SSL&#x2F;TLS 协议进行加密传输，为了弥补非对称加密的缺点，HTTPS <strong>①采用证书来进一步加强非对称加密的安全性</strong>，<strong>②使用非对称加密交换后面通信传输用到的<em>会话密钥</em></strong>，<strong>③后续的所有信息都通过使用该对称秘钥进行加密解密</strong>，完成整个 HTTPS 的流程。</p>
<h2 id="HTTP-与-HTTPS的区别"><a href="#HTTP-与-HTTPS的区别" class="headerlink" title="HTTP 与 HTTPS的区别"></a>HTTP 与 HTTPS的区别</h2><ol>
<li><strong>HTTP 是超⽂本传输协议，信息是明⽂传输</strong>，存在安全⻛险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在TCP 和 HTTP ⽹络层之间加⼊了<em>SSL&#x2F;TLS</em>安全协议，使得<strong>报⽂能够加密传输</strong>。</li>
<li>HTTP 连接建⽴相对简单， TCP 三次握⼿之后便可进⾏ HTTP 的报⽂传输。⽽ <strong>HTTPS 在 TCP 三次握⼿之后，还需进⾏ SSL&#x2F;TLS 的握⼿过程</strong>，才可进⼊加密报⽂传输。</li>
<li>HTTP 的端⼝号是 80，HTTPS 的端⼝号是 443。</li>
<li>HTTPS 协议需要<strong>向 CA（证书权威机构）申请数字证书</strong>，来保证服务器的身份是可信的。</li>
</ol>
<blockquote>
<p>SSL 是 “<em>Secure Sockets Layer</em> 的缩写，中⽂叫做「安全套接层」。它是在上世纪 90 年代中期，由⽹景公司</p>
<p>设计的。</p>
<p>到了1999年，SSL 因为应⽤⼴泛，已经成为互联⽹上的事实标准。IETF 就在那年把 SSL 标准化。标准化之后的名</p>
<p>称改为 TLS（是 “<em>Transport Layer Security</em>” 的缩写），中⽂叫做 「传输层安全协议」。</p>
<p>很多相关的⽂章都把这两者并列称呼（SSL&#x2F;TLS），因为这两者可以视作同⼀个东⻄的不同阶段。</p>
</blockquote>
<h2 id="HTTPS-解决了-HTTP-的哪些问题"><a href="#HTTPS-解决了-HTTP-的哪些问题" class="headerlink" title="HTTPS 解决了 HTTP 的哪些问题"></a>HTTPS 解决了 HTTP 的哪些问题</h2><p>HTTP 由于是明⽂传输，所以安全上存在以下三个⻛险：</p>
<ol>
<li><p>窃听⻛险，⽐如通信链路上可以获取通信内容；</p>
</li>
<li><p>篡改⻛险，⽐如强制植⼊垃圾⼴告；</p>
</li>
<li><p>冒充⻛险，⽐如冒充淘宝⽹站。</p>
</li>
</ol>
<img src="https1.png" style="zoom:80%;" />





<p>HTTP<strong>S</strong> 在 HTTP 与 TCP 层之间加⼊了 SSL&#x2F;TLS 协议，可以很好的解决了上述的⻛险：</p>
<p>信息加密：交互信息⽆法被窃取。</p>
<p>校验机制：⽆法篡改通信内容，篡改了就不能正常显示。</p>
<p>身份证书：证明淘宝是真的淘宝⽹。</p>
<blockquote>
<p>HTTPS 是如何解决上⾯的三个⻛险的？</p>
</blockquote>
<ul>
<li><p><strong>混合加密</strong>的⽅式实现信息的<strong>机密性</strong>，解决了窃听的⻛险。</p>
</li>
<li><p><strong>摘要算法</strong>的⽅式来实现<strong>完整性</strong>，它能够为数据⽣成独⼀⽆⼆的<em>指纹</em>，指纹⽤于校验数据的完整性，解决</p>
</li>
</ul>
<p>了篡改的⻛险。</p>
<ul>
<li>将服务器公钥放⼊到<strong>数字证书</strong>中，解决了<strong>冒充⻛险</strong>。</li>
</ul>
<blockquote>
<p>这部分内容可以参考 <a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html">数字签名是什么？</a></p>
</blockquote>
<h3 id="1-混合加密"><a href="#1-混合加密" class="headerlink" title="1. 混合加密"></a>1. 混合加密</h3><img src="秘钥.png" style="zoom:80%;" />





<p>HTTPS 采⽤的是对称加密和⾮对称加密结合的<strong>混合加密</strong>⽅式：</p>
<ul>
<li><p>在通信建⽴前采⽤⾮对称加密的⽅式交换<strong>会话秘钥</strong>，后续就不再使⽤⾮对称加密。</p>
</li>
<li><p>在通信过程中全部使⽤对称加密的<strong>会话秘钥</strong>加密明⽂数据。</p>
</li>
</ul>
<p>采⽤「混合加密」的⽅式的原因：</p>
<ul>
<li><p><strong>对称加密只使⽤⼀个密钥，运算速度快</strong>，密钥必须保密，<strong>但⽆法做到安全的密钥交换</strong>。</p>
</li>
<li><p><strong>⾮对称加密使⽤两个密钥</strong>：公钥和私钥，公钥可以任意分发⽽私钥保密，<strong>解决了密钥交换问题但速度慢</strong>。</p>
</li>
</ul>
<h3 id="2-摘要算法"><a href="#2-摘要算法" class="headerlink" title="2. 摘要算法"></a>2. 摘要算法</h3><p><strong>摘要算法</strong>⽤来实现完整性，能够为数据⽣成独⼀⽆⼆的<em>指纹</em>，<strong>⽤于校验数据的完整性</strong>，解决了篡改的⻛险。</p>
<img src="摘要.png" style="zoom:80%;" />



<p>客户端在发送明⽂之前会通过摘要算法算出明⽂的「指纹」，发送的时候把「指纹 + 明⽂」⼀同加密成密⽂后，发</p>
<p>送给服务器，服务器解密后，⽤相同的摘要算法算出发送过来的明⽂，通过⽐较客户端携带的「指纹」和当前算出</p>
<p>的「指纹」做⽐较，若「指纹」相同，说明数据是完整的。</p>
<h3 id="3-数字证书"><a href="#3-数字证书" class="headerlink" title="3. 数字证书"></a>3. 数字证书</h3><p>客户端先向服务器端索要公钥，然后⽤公钥加密信息，服务器收到密⽂后，⽤⾃⼰的私钥解密。</p>
<p>这就存在些问题，如何保证公钥不被篡改和信任度？</p>
<p>所以这⾥就需要借助第三⽅权威机构 CA （certificate authority  数字证书认证机构），<strong>将服务器公钥放在数字证书</strong>（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。</p>
<img src="数字证书.png" style="zoom:70%;" />



<p>通过数字证书的⽅式保证服务器公钥的身份，解决冒充的⻛险。</p>
<h3 id="名词总结"><a href="#名词总结" class="headerlink" title="名词总结"></a>名词总结</h3><ol>
<li>秘钥：某个用来完成加密、解密、完整性验证等密码学应用的秘密信息。在对称加密中加密解密使用的是同一个秘钥；在非对称加密中，又分为公钥和私钥。</li>
<li>摘要：根据一定的运算规则对原数据进行某种形式的提取，这种提取就是摘要。可以用于数据完整性验证。由于摘要算法不可逆，理论上无法通过反向运算取得原数据内容。摘要算法有MD5等。</li>
<li>数字签名：一种功能类似写在纸上的普通签名、但是使用了<em>公钥加密</em> 领域的技术，以用于鉴别数字信息的方法。数字签名算法是依靠<em>公钥加密技术</em>来实现的。RSA等算法可以实现数字签名。</li>
<li>数字证书：由证书中心（Certificate Authority）颁发的用于标志通讯各方身份信息的一个数字认证。在SSL中，①服务器将自己的公钥和自身的其他信息向CA注册，②CA再用自己的私钥加密成数字证书颁发给，③然后客户端再用CA的公钥去解密数字证书，如果合法就可以得到可靠的服务器的公钥。</li>
</ol>
<h3 id="客户端为什么信任第三方证书"><a href="#客户端为什么信任第三方证书" class="headerlink" title="客户端为什么信任第三方证书"></a>客户端为什么信任第三方证书</h3><ol>
<li><p>没有CA的私钥无法篡改签名<br><strong>假设中间人篡改了证书原文，由于他没有 CA 机构的私钥，所以无法得到此时加密后的签名，因此无法篡改签名。</strong>客户端浏览器收到该证书后会发现原文和签名解密后的值不一致，则说明证书被中间人篡改，证书不可信，从而终止向服务器传输信息。</p>
</li>
<li><p>替换证书但是域名不一致<br>上述过程说明证书无法被篡改，我们考虑更严重的情况，例如中间人拿到了 CA 机构认证的证书，它想窃取网站 A 发送给客户端的信息，于是它成为中间人拦截到了 A 传给客户端的证书，然后将其替换为自己的证书。此时客户端浏览器收到的是被中间人掉包后的证书，但由于证书里包含了客户端请求的网站信息，因此客户端浏览器只需要把证书里的域名与自己请求的域名比对一下就知道证书有没有被掉包了。</p>
</li>
</ol>
<p>CA之所以是CA，就是因为它是普遍被大家接受的权威结构，里面罗列着一些普遍被大家认可的证书，而这些通常会内置在浏览器中。</p>
<p>如果CA不被信任或者CA带头作恶，那相当于法官带头犯罪，什么手段都规避不了。</p>
<h2 id="HTTP-与-HTTPs-的工作方式（建立连接的过程）"><a href="#HTTP-与-HTTPs-的工作方式（建立连接的过程）" class="headerlink" title="HTTP 与 HTTPs 的工作方式（建立连接的过程）"></a>HTTP 与 HTTPs 的工作方式（建立连接的过程）</h2><h3 id="HTTP-1"><a href="#HTTP-1" class="headerlink" title="HTTP"></a>HTTP</h3><p>HTTP 使用 TCP（而不是 UDP）作为它的支撑运输层协议。其默认工作在 TCP 协议 80 端口，HTTP 客户机发起一个与服务器的 TCP 连接，一旦连接建立，浏览器和服务器进程就可以通过套接字接口访问 TCP。客户机从套接字接口发送 HTTP 请求报文和接收 HTTP 响应报文。类似地，服务器也是从套接字接口接收 HTTP 请求报文和发送 HTTP 响应报文。其通信内容以明文的方式发送，不通过任何方式的数据加密。当通信结束时，客户端与服务器关闭连接。</p>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>HTTPS 协议基本流程：</p>
<ol>
<li><p>客户端<strong>向服务器索要并验证服务器的公钥</strong>。</p>
</li>
<li><p><strong>双⽅协商⽣产「会话秘钥」</strong>。</p>
</li>
<li><p><strong>双⽅采⽤「会话秘钥」进⾏加密通信</strong>。</p>
</li>
</ol>
<h4 id="SSL-x2F-TLS-建立过程"><a href="#SSL-x2F-TLS-建立过程" class="headerlink" title="SSL&#x2F;TLS 建立过程"></a>SSL&#x2F;TLS 建立过程</h4><p>前两步也就是 SSL&#x2F;TLS 的建⽴过程，也就是握⼿阶段。</p>
<p>SSL&#x2F;TLS 的「握⼿阶段」涉及四次通信，可⻅下图：</p>
<p><img src="/2021/11/26/HTTP/SSL.png"></p>
<p>SSL&#x2F;TLS 协议建⽴的详细流程：</p>
<ol>
<li><strong>ClientHello</strong></li>
</ol>
<p>⾸先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求。</p>
<p>在这⼀步，客户端主要向服务器发送以下信息：</p>
<p>（1）客户端⽀持的 SSL&#x2F;TLS 协议版本，如 TLS 1.2 版本。</p>
<p>（2）客户端⽣产的随机数（ <strong>Client Random</strong> ），后⾯⽤于⽣产「会话秘钥」。</p>
<p>（3）客户端⽀持的密码套件列表，如 RSA 加密算法。</p>
<ol start="2">
<li><strong>SeverHello</strong></li>
</ol>
<p>服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello 。服务器回应的内容有如下内容：</p>
<p>（1）确认 SSL&#x2F; TLS 协议版本，如果浏览器不⽀持，则关闭加密通信。</p>
<p>（2）服务器⽣产的随机数（ <strong>Server Random</strong> ），后⾯⽤于⽣产「会话秘钥」。</p>
<p>（3）确认的密码套件列表，如 RSA 加密算法。</p>
<p>（4）<strong>服务器的数字证书</strong>。</p>
<ol start="3">
<li><strong>客户端回应</strong></li>
</ol>
<p>客户端收到服务器的回应之后，<strong>⾸先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性</strong>。</p>
<p>如果证书没有问题，客户端会<strong>从数字证书中取出服务器的公钥</strong>，然后<strong>使⽤它加密报⽂</strong>，向服务器发送如下信息：</p>
<p>（1）<strong>⼀个随机数（ pre-master key ）</strong>。该随机数会被服务器公钥加密。</p>
<p>（2）<strong>加密通信算法改变通知，表示随后的信息都将⽤「会话秘钥」加密通信。</strong></p>
<p>（3）客户端握⼿结束通知，表示客户端的握⼿阶段已经结束。这⼀项同时<strong>把之前所有内容的发⽣的数据做个摘</strong></p>
<p><strong>要，⽤来供服务端校验</strong>。</p>
<p>上⾯第⼀项的随机数是整个握⼿阶段的第三个随机数，这样<strong>服务器和客户端就同时有三个随机数</strong>，接着就⽤<strong>双⽅协商的加密算法，各⾃⽣成本次通信的「会话秘钥」</strong>。</p>
<ol start="4">
<li><strong>服务器的最后回应</strong></li>
</ol>
<p>服务器收到客户端的<strong>第三个随机数（ pre-master key ）</strong>之后，通过协商的加密算法，计算出<strong>本次通信的「会话秘钥」</strong>。然后，向客户端发⽣最后的信息：</p>
<p>（1）<strong>加密通信算法改变通知，表示随后的信息都将⽤「会话秘钥」加密通信。</strong></p>
<p>（2）服务器握⼿结束通知，表示服务器的握⼿阶段已经结束。这⼀项同时<strong>把之前所有内容的发⽣的数据做个摘</strong></p>
<p><strong>要，⽤来供客户端校验</strong>。</p>
<p>⾄此，整个 SSL&#x2F;TLS 的握⼿阶段全部结束。接下来，客户端与服务器进⼊加密通信，就完全是使⽤普通的 HTTP</p>
<p>协议，只不过⽤「会话秘钥」加密内容。</p>
<blockquote>
<p>简洁版</p>
<p>TLS握手协议 </p>
<ol>
<li>客户端发出一个 client hello 消息，携带的信息包括：所支持的 SSL&#x2F;TLS 版本列表；支持的与加密算法；所支持的数据压缩方法；随机数 A。</li>
<li>服务端响应一个 server hello 消息，携带的信息包括：协商采用的 SSL&#x2F;TLS 版本号；会话 ID；随机数 B；服务端数字证书 serverCA；由于双向认证需求，服务端需要对客户端进行认证，会同时发送一个 client certificate request，表示请求客户端的证书。</li>
<li>客户端校验服务端的数字证书；校验通过之后发送随机数 C，该随机数称为 pre-master-key，使用数字证书中的公钥加密后发出；由于服务端发起了 client certificate request，客户端使用私钥加密一个随机数 clientRandom 随客户端的证书 clientCA 一并发出。</li>
<li>服务端校验客户端的证书，并成功将客户端加密的随机数 clientRandom 解密；根据随机数 A&#x2F;随机数 B&#x2F;随机数 C（pre-master-key） 产生动态密钥 master-key，加密一个 finish 消息发至客户端。</li>
<li>客户端根据同样的随机数和算法生成 master-key，加密一个 finish 消息发送至服务端。</li>
<li>服务端和客户端分别解密成功，至此握手完成，之后的数据包均采用 master-key 进行加密传输。</li>
</ol>
</blockquote>
<h1 id="HTTP-x2F-1-1、HTTP-x2F-2、HTTP-x2F-3-演变"><a href="#HTTP-x2F-1-1、HTTP-x2F-2、HTTP-x2F-3-演变" class="headerlink" title="HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 演变"></a>HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 演变</h1><h2 id="HTTP-x2F-1-1-和-HTTP-x2F-1-0-的区别"><a href="#HTTP-x2F-1-1-和-HTTP-x2F-1-0-的区别" class="headerlink" title="HTTP&#x2F;1.1 和 HTTP&#x2F;1.0 的区别"></a>HTTP&#x2F;1.1 和 HTTP&#x2F;1.0 的区别</h2><ol>
<li><p><strong>缓存处理</strong>：在 HTTP&#x2F;1.0 中主要使用 header 里的 if-modified-Since, Expries 来做缓存判断的标准。而 HTTP&#x2F;1.1 请求头中添加了更多与缓存相关的字段，从而支持更为灵活的缓存策略，例如 <code>Entity-tag</code>,<code> If-Unmodified-Since</code>, <code>If-Match</code>,<code> If-None-Match</code> 等可供选择的缓存头来控制缓存策略。</p>
</li>
<li><p><strong>分片传输</strong>： 当客户端请求某个资源时，HTTP&#x2F;1.0 默认将该资源相关的整个对象传送给请求方，但很多时候可能客户端并不需要对象的所有信息。而在 <strong>HTTP&#x2F;1.1 的请求头中引入了 range 头域</strong>，它允许只请求部分资源，其使得开发者可以多线程请求某一资源，从而充分的利用带宽资源，实现高效并发。</p>
</li>
<li><p><strong>长连接</strong>：HTTP&#x2F;1.0 默<strong>认浏览器和服务器之间保持短暂连接</strong>，<strong>浏览器的每次请求都需要与服务器建立一个 TCP 连接，服务器完成后立即断开 TCP 连接</strong>。HTTP&#x2F;1.1 默认使用的是持久连接，其支持在同一个 TCP 请求中传送多个 HTTP 请求和响应。此之前的 HTTP 版本的默认连接都是使用非持久连接，如果想要在旧版本的 HTTP 协议上维持持久连接，则需要指定 Connection 的首部字段的值为 Keep-Alive。</p>
</li>
<li><p><strong>管道（pipeline）⽹络传输</strong>，只要第⼀个请求发出去了，不必等其回来，就可以发第⼆个请求出去，可以减少整体的响应时间。</p>
</li>
<li><p>错误通知的管理：HTTP&#x2F;1.1 在 1.0 的基础上新增了 24 个错误状态响应码，例如 414 表示客户端请求中所包含的 URL 地址太长，以至于服务器无法处理；410 表示所请求的资源已经被永久删除。</p>
</li>
<li><p>Host 请求头：早期 HTTP&#x2F;1.0 中认为每台服务器都绑定一个唯一的 IP 地址并提供单一的服务，请求消息中的 URL 并没有传递主机名。而随着虚拟主机的出现，<strong>一台物理服务器上可以存在多个虚拟主机，并且它们共享同一个 IP 地址</strong>。为了支持虚拟主机，HTTP&#x2F;1.1 中添加了 host 请求头，请求消息和响应消息中应声明这个字段，若请求消息中缺少该字段时服务端会响应一个 404 错误状态码。</p>
</li>
</ol>
<h2 id="HTTP-x2F-1-X-和-HTTP-x2F-2-0-的区别"><a href="#HTTP-x2F-1-X-和-HTTP-x2F-2-0-的区别" class="headerlink" title="HTTP&#x2F;1.X 和 HTTP&#x2F;2.0 的区别"></a>HTTP&#x2F;1.X 和 HTTP&#x2F;2.0 的区别</h2><p>但 HTTP&#x2F;1.1 还是有性能瓶颈 : </p>
<ul>
<li><p>请求 &#x2F; 响应头部（Header）未经压缩就发送，⾸部信息越多延迟越⼤。只能压缩 Body 的部分；</p>
</li>
<li><p>发送冗⻓的⾸部。每次互相发送相同的⾸部造成的浪费较多；</p>
</li>
<li><p>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端⼀直请求不到数据，也就是<strong>队头阻塞；</strong></p>
</li>
<li><p>请求只能从客户端开始，<strong>服务器只能被动响应</strong>。</p>
</li>
</ul>
<p>HTTP&#x2F;2 协议是基于 HTTPS 的，所以 HTTP&#x2F;2 的安全性也是有保障的。</p>
<h3 id="1-头部压缩"><a href="#1-头部压缩" class="headerlink" title="1. 头部压缩"></a>1. 头部压缩</h3><p>HTTP&#x2F;2 会压缩头（Header）<strong>如果你同时发出多个请求，他们的头是⼀样的或是相似的，那么，协议会帮你消除重复的部分</strong>。<br>这就是所谓的 HPACK 算法：<strong>在客户端和服务器同时维护⼀张头信息表，所有字段都会存⼊这个表，⽣成⼀个索引号，以后就不发送同样字段了，只发送索引号</strong>，这样就提⾼速度了。</p>
<h3 id="2-⼆进制格式"><a href="#2-⼆进制格式" class="headerlink" title="2. ⼆进制格式"></a>2. ⼆进制格式</h3><p>HTTP&#x2F;2 不再像 HTTP&#x2F;1.1 ⾥的纯⽂本形式的报⽂，⽽是全⾯采⽤了⼆进制格式，头信息和数据体都是⼆进制，并且统称为帧（frame）：头信息帧和数据帧。</p>
<p><img src="/2021/11/26/HTTP/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%A0%BC%E5%BC%8F.png"></p>
<p>这样虽然对⼈不友好，但是对计算机⾮常友好，因为计算机只懂⼆进制，那么收到报⽂后，⽆需再将明⽂的报⽂转<br>成⼆进制，⽽是直接解析⼆进制报⽂，这<strong>增加了数据传输的效率</strong>。</p>
<h3 id="3-数据流"><a href="#3-数据流" class="headerlink" title="3. 数据流"></a>3. 数据流</h3><p>HTTP&#x2F;2 的数据包不是按顺序发送的，同⼀个连接⾥⾯连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。<br>每个请求或回应的所有数据包，称为⼀个数据流（ Stream ）。每个数据流都标记着⼀个独⼀⽆⼆的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数</p>
<p>客户端还可以<strong>指定数据流的优先级</strong>。优先级⾼的请求，服务器就先响应该请求。</p>
<h3 id="4-多路复⽤"><a href="#4-多路复⽤" class="headerlink" title="4. 多路复⽤"></a>4. 多路复⽤</h3><p>HTTP&#x2F;2 是可以<strong>在⼀个连接中并发多个请求或回应，⽽不⽤按照顺序⼀⼀对应</strong>。</p>
<p><strong>移除了 HTTP&#x2F;1.1 中的串⾏请求</strong>，不需要排队等待，也就<strong>解决了「队头阻塞」问题（一定程度上），降低了延迟</strong>，⼤幅度提⾼</p>
<p>了连接的利⽤率。</p>
<p>举例来说，在⼀个 TCP 连接⾥，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程⾮常耗时，于是就</p>
<p>回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分。</p>
<p><img src="/2021/11/26/HTTP/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png"></p>
<h3 id="5-服务器推送"><a href="#5-服务器推送" class="headerlink" title="5. 服务器推送"></a>5. 服务器推送</h3><p>HTTP&#x2F;2 还在⼀定程度上改善了传统的「请求 - 应答」⼯作模式，服务不再是被动地响应，也可以主动向客户端发</p>
<p>送消息。举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会⽤到的 JS、CSS ⽂件等静态资源主动发给客户端，减少延时的等待，也就是服务器推送（Server Push，也叫 Cache Push）。</p>
<h2 id="HTTP-x2F-2-0-和-HTTP-x2F-3-0-的区别"><a href="#HTTP-x2F-2-0-和-HTTP-x2F-3-0-的区别" class="headerlink" title="HTTP&#x2F;2.0 和 HTTP&#x2F;3.0 的区别"></a>HTTP&#x2F;2.0 和 HTTP&#x2F;3.0 的区别</h2><p>HTTP&#x2F;2 主要的问题在于，多个 HTTP 请求在复⽤⼀个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求<br>的。所以⼀旦发⽣了丢包现象，就会触发 TCP 的重传机制，这样在⼀个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来。</p>
<ul>
<li><strong>队头阻塞问题</strong>：HTTP&#x2F;1.1 中的管道（ pipeline）传输中如果有⼀个请求阻塞了，那么队列后面请求也统统被阻塞住了</li>
<li><strong>复用TCP的丢包问题</strong>：HTTP&#x2F;2 多个请求复⽤⼀个TCP连接，⼀旦发⽣丢包，就会阻塞住所有的 HTTP 请求。</li>
</ul>
<p>这都是基于 TCP 传输层的问题，所以 HTTP&#x2F;3 把 HTTP 下层的 TCP 协议改成了 UDP！</p>
<img src="http3.0.png" style="zoom:70%;" />





<blockquote>
<p>⼤家都知道 UDP 是不可靠传输的，但基于 UDP 的 <strong>QUIC</strong> 协议 可以实现类似 TCP 的可靠性传输。</p>
<p>QUIC 有⾃⼰的⼀套机制可以保证传输的可靠性的。当某个流发⽣丢包时，只会阻塞这个流，其他流不会受到</p>
<p>影响。</p>
<p>TLS3 升级成了最新的 1.3 版本，头部压缩算法也升级成了 QPack 。</p>
<p>HTTPS 要建⽴⼀个连接，要花费 6 次交互，先是建⽴三次握⼿，然后是 TLS&#x2F;1.3 的三次握⼿。QUIC 直接</p>
<p>把以往的 TCP 和 TLS&#x2F;1.3 的 6 次交互合并成了 <strong>3</strong> 次，减少了交互次数。</p>
<p>所以， <strong>QUIC 是⼀个在 UDP 之上的伪 TCP + TLS + HTTP&#x2F;2 的多路复⽤</strong>的协议。</p>
<p>QUIC 是新协议，对于很多⽹络设备，根本不知道什么是 QUIC，只会当做 UDP，这样会出现新的问题。所以</p>
<p>HTTP&#x2F;3 现在普及的进度⾮常的缓慢，不知道未来 UDP 是否能够逆袭 TCP。</p>
</blockquote>
<h2 id="了解HTTP3"><a href="#了解HTTP3" class="headerlink" title="了解HTTP3"></a>了解HTTP3</h2><h3 id="HTTP-x2F-2-存在的问题"><a href="#HTTP-x2F-2-存在的问题" class="headerlink" title="HTTP&#x2F;2 存在的问题"></a>HTTP&#x2F;2 存在的问题</h3><p>我们知道，传统 Web 平台的数据传输都基于 TCP 协议，而 TCP 协议在创建连接之前不可避免的需要三次握手，如果需要提高数据交互的安全性，即增加传输层安全协议（TLS），还会增加更多的握手次数。</p>
<p> HTTP 从 1.0 到 2.0，其传输层都是基于 TCP 协议的。即使是带来巨大性能提升的 HTTP&#x2F;2，也无法完全解决 TCP 协议存在的固有问题（慢启动，拥塞窗口尺寸的设置等）。</p>
<p><strong>此外，HTTP&#x2F;2 多路复用只是减少了连接数，其队头的拥塞问题并没有完全解决</strong>，倘若 TCP 丢包率过大，则 HTTP&#x2F;2 的表现将不如 HTTP&#x2F;1.1。</p>
<h3 id="QUIC-协议"><a href="#QUIC-协议" class="headerlink" title="QUIC 协议"></a>QUIC 协议</h3><p>QUIC（Quick UDP Internet Connections），直译为<strong>快速 UDP 网络连接</strong>，是谷歌制定的一种基于 UDP 的低延迟传输协议。其主要目的是解决采用传输层 TCP 协议存在的问题，同时满足传输层和应用层对多连接、低延迟等的需求。该协议融合了 TCP, TLS, HTTP&#x2F;2 等协议的特性，并基于 UDP传输。该协议带来的主要提升有：</p>
<p>低延迟连接。当客户端第一次连接服务器时，QUIC 只需要 1 RTT（Round-Trid Time）延迟就可以建立安全可靠的连接（采用 TLS 1.3 版本），相比于 TCP + TLS 的 3 次 RTT 要更加快捷。之后，客户端可以在本地缓存加密的认证信息，当再次与服务器建立连接时可以实现 0 RTT 的连接建立延迟。</p>
<p>QUIC 复用了 HTTP&#x2F;2 协议的多路复用功能，由于 QUIC 基于 UDP，所以也避免了 HTTP&#x2F;2存在的队头阻塞问题。</p>
<p>基于 UDP 协议的 QUIC 运行在用户域而不是系统内核，这使得 QUIC 协议可以快速的更新和部署，从而很好地解决了 TPC 协议部署及更新的困难。</p>
<p>QUIC 的报文是经过加密和认证的，除了少量的报文，其它所有的 QUIC 报文头部都经过了认证，报文主体经过了加密。只要有攻击者篡改 QUIC 报文，接收端都能及时发现。</p>
<p>具有向前纠错机制，每个数据包携带了除了本身内容外的部分其他数据包的内容，使得在出现少量丢包的情况下，尽量地减少其它包的重传次数，其通过牺牲单个包所携带的有效数据大小换来更少的重传次数，这在丢包数量较小的场景下能够带来一定程度的性能提升。</p>
<h3 id="HTTP-x2F-3"><a href="#HTTP-x2F-3" class="headerlink" title="HTTP&#x2F;3"></a>HTTP&#x2F;3</h3><p><strong>HTTP&#x2F;3 是在 QUIC 基础上发展起来的，其底层使用 UDP 进行数据传输</strong>，上层仍然使用 HTTP&#x2F;2。</p>
<p><strong>在 UDP 与 HTTP&#x2F;2 之间存在一个 QUIC 层</strong>，<strong>其中 TLS 加密过程在该层进行处理</strong>。</p>
<p>HTTP&#x2F;3 主要有以下几个特点：</p>
<p>① <strong>使用 UDP 作为传输层进行通信</strong>；</p>
<p>② <strong>在 UDP 之上的 QUIC 协议保证了 HTTP&#x2F;3 的安全性</strong>。QUIC 在建立连接的过程中就完成了 TLS 加密握手；</p>
<p>③ 建立连接快，正常只需要 1 RTT 即可建立连接。如果有缓存之前的会话信息，则直接验证和建立连接，此过程 0 RTT。建立连接时，也可以带有少量业务数据；</p>
<p>④ 不和具体底层连接绑定，QUIC 为每个连接的两端分别分配了一个唯一 ID，上层连接只认这对逻辑 ID。网络切换或者断连时，只需要继续发送数据包即可完成连接的建立；</p>
<p>⑤ 使用 QPACK 进行头部压缩，因为 在 HTTP&#x2F;2 中的 HPACK 要求传输过程有序，这会导致队头阻塞，而 QPACK 不存在这个问题。</p>
<blockquote>
<p><strong>tcp的慢</strong></p>
<ol>
<li>握手次数过多(TCP以及SSL&#x2F;TLS的握手)</li>
<li>防止拥塞的<strong>慢启动</strong></li>
<li><strong>丢包导致的队头阻塞</strong></li>
</ol>
<p><strong>quic为啥快</strong></p>
<ol>
<li><strong>减少往返次数RTT</strong>,缩短连接建立时间： 缓存对方的信息</li>
<li>连接多路复用，<strong>且采用独立数据流避免丢包阻塞</strong></li>
<li>使用前行纠错恢复丢失的包，减少超时重传</li>
<li>连接保存连接标志符，网络迁移连接快</li>
</ol>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如下为HTTP协议族的网络协议层架构：</p>
<img src="http123.png" style="zoom:80%;" />







<p>最后我们使用一张图来清晰的表示出 HTTP 协议的发展变化：</p>
<img src="http-all.png" style="zoom:48%;" />






<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">超文本传输协议 - 维基百科，自由的百科全书</a></p>
<p><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2016/08/http.html">HTTP 协议入门</a></p>
<p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html">数字签名是什么？</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhoudawei/p/9257276.html">nginx配置ssl证书实现https </a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/16/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><span class="page-number current">17</span><a class="page-number" href="/page/18/">18</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/18/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SongyangJi</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  





</body>
</html>
