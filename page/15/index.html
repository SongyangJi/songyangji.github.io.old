<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.14.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="JsyBlog">
<meta property="og:url" content="http://example.com/page/15/index.html">
<meta property="og:site_name" content="JsyBlog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="SongyangJi">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/15/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/15/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>JsyBlog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">JsyBlog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">SongyangJi</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">245</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">109</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/10/Sandbox%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SongyangJi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JsyBlog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | JsyBlog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/10/Sandbox%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">Sandbox的安全机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-10 21:51:54" itemprop="dateCreated datePublished" datetime="2021-12-10T21:51:54+08:00">2021-12-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-02 22:44:06" itemprop="dateModified" datetime="2022-09-02T22:44:06+08:00">2022-09-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/sandbox/" itemprop="url" rel="index"><span itemprop="name">sandbox</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Sandbox的安全机制如何设计？"><a href="#Sandbox的安全机制如何设计？" class="headerlink" title="Sandbox的安全机制如何设计？"></a>Sandbox的安全机制如何设计？</h1><p>对于Linux而言，它的风格是一贯的。沙盒是进程而不是线程，这点非常明确。</p>
<h2 id="用户权限相关"><a href="#用户权限相关" class="headerlink" title="用户权限相关"></a>用户权限相关</h2><h3 id="Nobody-用户"><a href="#Nobody-用户" class="headerlink" title="Nobody 用户"></a>Nobody 用户</h3><p>在许多Unix系统与类Unix系统（如Linux）中，nobody是一个没有任何权限的用户。<br>该用户不拥有任何文件，也没有任何特殊权限。某些系统还会定义类似的用户组“nogroup”。<br>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @Author: 吉松阳</span></span><br><span class="line"><span class="comment"> * @Date: 2021/9/23</span></span><br><span class="line"><span class="comment"> * @Description: </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pwd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> *<span class="title">pw</span>;</span></span><br><span class="line">    <span class="type">char</span> *username = <span class="string">&quot;nobody&quot;</span>;</span><br><span class="line">    pw = getpwnam(username);</span><br><span class="line">    <span class="keyword">if</span> (!pw) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s is not exist\n&quot;</span>, username);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pw-&gt;pw_name = %s\n&quot;</span>, pw-&gt;pw_name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pw-&gt;pw_passwd = %s\n&quot;</span>, pw-&gt;pw_passwd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pw-&gt;pw_uid = %d\n&quot;</span>, pw-&gt;pw_uid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pw-&gt;pw_gid = %d\n&quot;</span>, pw-&gt;pw_gid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pw-&gt;pw_gecos = %s\n&quot;</span>, pw-&gt;pw_gecos);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pw-&gt;pw_dir = %s\n&quot;</span>, pw-&gt;pw_dir);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pw-&gt;pw_shell = %s\n&quot;</span>, pw-&gt;pw_shell);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是 MacOS Big Sur 上的 nobody 用户相关信息。<br>其中<code>/var/empty</code>表明它不拥有任何文件，<code>/usr/bin/false</code>表明它不能登录使用shell</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pw-&gt;pw_name = nobody</span><br><span class="line">pw-&gt;pw_passwd = *</span><br><span class="line">pw-&gt;pw_uid = -2</span><br><span class="line">pw-&gt;pw_gid = -2</span><br><span class="line">pw-&gt;pw_gecos = Unprivileged User</span><br><span class="line">pw-&gt;pw_dir = /var/empty</span><br><span class="line">pw-&gt;pw_shell = /usr/bin/false</span><br></pre></td></tr></table></figure>

<p>在运行oj用户的代码的时候，是以nobody的身份运行的，意味着它的权限非常有限，不能去执行那些危险的代码。</p>
<h3 id="root-用户"><a href="#root-用户" class="headerlink" title="root 用户"></a>root 用户</h3><p>root用户，即系统的管理员。<br>sandbox程序本身需要 root权限。<br>如何区分呢？<br>将上面的代码中的用户名替换成 root, 输出为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pw-&gt;</span><span class="language-bash">pw_name = root</span></span><br><span class="line"><span class="meta prompt_">pw-&gt;</span><span class="language-bash">pw_passwd = *</span></span><br><span class="line"><span class="meta prompt_">pw-&gt;</span><span class="language-bash">pw_uid = 0</span></span><br><span class="line"><span class="meta prompt_">pw-&gt;</span><span class="language-bash">pw_gid = 0</span></span><br><span class="line"><span class="meta prompt_">pw-&gt;</span><span class="language-bash">pw_gecos = System Administrator</span></span><br><span class="line"><span class="meta prompt_">pw-&gt;</span><span class="language-bash">pw_dir = /var/root</span></span><br><span class="line"><span class="meta prompt_">pw-&gt;</span><span class="language-bash">pw_shell = /bin/sh</span></span><br></pre></td></tr></table></figure>
<p>发现uid、gid 均为 0。<br>于是在运行沙箱之前判定一下程序的执行者的uid、gid是不是 root 用户即可。</p>
<h2 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h2><h3 id="setuid-x2F-setgid"><a href="#setuid-x2F-setgid" class="headerlink" title="setuid&#x2F;setgid"></a>setuid&#x2F;setgid</h3><ul>
<li><p>background infomation<br>内核为每个进程维护的三个UID值。<br>这三个UID分别是实际用户ID(real uid)、有效用户ID(effective uid)、保存的设置用户ID(saved set-user ID)。<br>其中 real uid 指的是运行某程序的实际用户ID（登录shell的那个用户的uid）；<br>effective uid 指的是指当前进程是以哪个用户ID来运行的；<br>保存的设置用户ID就是有效用户ID的一个副本，与SUID权限有关。<br>一般情况下 real uid 和 effective uid 相同，但是使用<code>setuid</code>、<code>chmod +s</code>之后，二者就不一定相同了。</p>
</li>
<li><p><code>setuid</code>函数定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setuid</span><span class="params">(<span class="type">uid_t</span> uid)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数说明：<br>+（1） 如果进程具有超级用户权限，那么 <code>setuid(uid_t uid)</code>会将三种 uid 全部设置成参数uid；<br> (启动sandbox其实就是要求以root身份启动的)</p>
<ul>
<li>(2) 如果 uid 等于 real uid 或者 saved set-user ID, 那么只把 effective uid 修改成 uid；</li>
<li>(3) 两种情况都不满组足，返回 -1 , errno被设置为 EPERM。</li>
</ul>
</li>
<li><p>返回值<br>执行成功则返回0； 失败则返回-1, 错误代码存于errno.</p>
</li>
<li><p>使用场景</p>
<ul>
<li>降低权限，比如在sandbox中通过让程序以 nobody 的身份来运行。</li>
<li>提高权限，但是最好注意在使用完 root 权限后建议马上执行setuid(getuid())，来抛弃root 权限，避免不必要的风险。</li>
</ul>
</li>
</ul>
<h3 id="setrlimit-x2F-getrlimit"><a href="#setrlimit-x2F-getrlimit" class="headerlink" title="setrlimit&#x2F;getrlimit"></a>setrlimit&#x2F;getrlimit</h3><ul>
<li><p>头文件:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br></pre></td></tr></table></figure>

</li>
<li><p>函数说明:<br>获取或设定资源使用限制。<br>每种资源都有相关的软硬限制:<strong>软限制</strong>是内核强加给相应资源的限制值，<strong>硬限制</strong>是软限制的最大值。<br>非授权调用进程只可以将其软限制指定为0~硬限制范围中的某个值，同时能不可逆转地降低其硬限制。<br>授权进程可以任意改变其软硬限制。<br>RLIM_INFINITY的值表示不对资源限制。</p>
</li>
<li><p>函数定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getrlimit</span><span class="params">(<span class="type">int</span> resource, <span class="keyword">struct</span> rlimit *rlim)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setrlimit</span><span class="params">(<span class="type">int</span> resource, <span class="type">const</span> <span class="keyword">struct</span> rlimit *rlim)</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>resource：可能的选择有</p>
<ul>
<li>RLIMIT_AS &#x2F;&#x2F; 进程的最大虚内存空间，字节为单位。</li>
<li>RLIMIT_CORE &#x2F;&#x2F; 内核转存文件的最大长度。</li>
<li>RLIMIT_CPU &#x2F;&#x2F; 最大允许的CPU使用时间，秒为单位。当进程达到软限制，内核将给其发送<strong>SIGXCPU</strong>信号，这一信号的默认行为是终止进程的执行。<br>然而，可以捕捉信号，处理句柄可将控制返回给主程序。<br>如果进程继续耗费CPU时间，核心会以每秒一次的频率给其发送SIGXCPU信号。<br>如果达到硬限制，那时将给进程发送 SIGKILL信号终止其执行。</li>
<li>RLIMIT_DATA &#x2F;&#x2F; 进程数据段的最大值。</li>
<li>RLIMIT_FSIZE &#x2F;&#x2F; 进程可建立的文件的最大长度。如果进程试图超出这一限制时，核心会给其发送<strong>SIGXFSZ</strong>信号，默认情况下将终止进程的执行。</li>
<li>RLIMIT_LOCKS &#x2F;&#x2F; 进程可建立的锁和租赁的最大值。</li>
<li>RLIMIT_MEMLOCK &#x2F;&#x2F; 进程可锁定在内存中的最大数据量，字节为单位。</li>
<li>RLIMIT_MSGQUEUE &#x2F;&#x2F; 进程可为POSIX消息队列分配的最大字节数。</li>
<li>RLIMIT_NICE &#x2F;&#x2F; 进程可通过setpriority() 或 nice()调用设置的最大完美值。</li>
<li>RLIMIT_NOFILE &#x2F;&#x2F; 指定比进程可打开的最大文件描述词大一的值，超出此值，将会产生EMFILE错误。</li>
<li>RLIMIT_NPROC &#x2F;&#x2F; 用户可拥有的最大进程数。</li>
<li>RLIMIT_RTPRIO &#x2F;&#x2F; 进程可通过sched_setscheduler 和 sched_setparam设置的最大实时优先级。</li>
<li>RLIMIT_SIGPENDING &#x2F;&#x2F; 用户可拥有的最大挂起信号数。</li>
<li>RLIMIT_STACK &#x2F;&#x2F; 最大的进程栈，以字节为单位。</li>
</ul>
<p>rlimit：描述资源软硬限制的结构体，原型如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> &#123;</span></span><br><span class="line">	<span class="type">rlim_t</span>  rlim_cur;               <span class="comment">/* current (soft) limit 软限制 */</span></span><br><span class="line">	<span class="type">rlim_t</span>  rlim_max;               <span class="comment">/* maximum value for rlim_cur 硬限制 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<ul>
<li><p>返回值<br><strong>成功执行时，返回 0 。失败返回 -1</strong> 。<br>errno被设为以下的某个值：</p>
<ul>
<li>EFAULT：rlim指针指向的空间不可访问</li>
<li>EINVAL：参数无效</li>
<li>EPERM：增加资源限制值时，权能不允许</li>
</ul>
</li>
<li><p>参考链接：<br><a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/getrlimit.2.html">getrlimit(2) — Linux manual page</a></p>
</li>
</ul>
<h1 id="使用seccomp限制syscall"><a href="#使用seccomp限制syscall" class="headerlink" title="使用seccomp限制syscall"></a>使用seccomp限制syscall</h1><h2 id="什么是seccomp"><a href="#什么是seccomp" class="headerlink" title="什么是seccomp"></a>什么是seccomp</h2><p>seccomp（全称 <strong>secure computing mode</strong>）是linux kernel从2.6.23版本开始所支持的一种安全机制。<br>seccomp是一种<strong>内核中的安全机制</strong>,正常情况下,程序可以使用所有的syscall,这是不安全的。<br>比如劫持程序流后通过execve的syscall来<code>getshell</code>。<br>通过seccomp我们可以在程序中禁用掉某些syscall,这样就算劫持了程序流也只能调用部分的syscall了.</p>
<p><strong>通过seccomp，我们限制程序使用某些系统调用，这样可以减少系统的暴露面，同时是程序进入一种“安全”的状态。</strong><br>详细介绍可参考seccomp内核文档(见参考链接)。</p>
<h2 id="如何使用seccomp"><a href="#如何使用seccomp" class="headerlink" title="如何使用seccomp"></a>如何使用seccomp</h2><p>seccomp可以通过系统调用ptrctl(2)或者通过系统调用seccomp(2)开启，前提是内核配置中开启了CONFIG_SECCOMP和CONFIG_SECCOMP_FILTER。</p>
<p>seccomp支持两种模式：<strong>SECCOMP_MODE_STRICT</strong> 和 <strong>SECCOMP_MODE_FILTER</strong>。</p>
<ul>
<li>在SECCOMP_MODE_STRICT模式下，进程不能使用<code>read(2)</code>、<code>write(2)</code>、<code>_exit(2)</code>和<code>sigreturn(2)</code>以外的其他系统调用。</li>
<li>在SECCOMP_MODE_FILTER模式下，可以利用BerkeleyPacket Filter配置哪些系统调用及它们的参数可以被进程使用。</li>
</ul>
<h2 id="如何查看是否使用了seccomp"><a href="#如何查看是否使用了seccomp" class="headerlink" title="如何查看是否使用了seccomp"></a>如何查看是否使用了seccomp</h2><p>通常有两种方法：<br>利用<code>prctl(2)</code>的PR_GET_SECCOMP的参数获取当前进程的seccomp状态。</p>
<ul>
<li>返回值0表示没有使用seccomp;</li>
<li>返回值2表示使用了seccomp并处于SECCOMP_MODE_FILTER模式； </li>
<li>其他情况进程会被SIGKILL信号杀死。</li>
</ul>
<p>从Linux3.8开始，可以利用&#x2F;proc&#x2F;$pid&#x2F;status中的Seccomp字段查看。如果没有seccomp字段，说明内核不支持seccomp。</p>
<ul>
<li><p>举例:<br>查看mysql服务的seccomp的状态，发现并没有进入安全限制模式。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/`pidof mysqld`/status</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出</span></span><br><span class="line">Name:	mysqld</span><br><span class="line">......</span><br><span class="line">Seccomp:	0</span><br><span class="line">Seccomp_filters:	0</span><br></pre></td></tr></table></figure>
<p>在sandbox环境下执行 python3 脚本，<br>查看次进程的seccomp的状态，发现进程处于SECCOMP_MODE_FILTER模式 。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Name:	python3</span><br><span class="line">......</span><br><span class="line">Seccomp:	2</span><br><span class="line">Seccomp_filters:	1</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码示例<br>使用 <code>syscall</code> 调用 execve，如果没有安全限制的话，会正常进入 shell</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;seccomp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    scmp_filter_ctx ctx; <span class="comment">// scmp 过滤上下文</span></span><br><span class="line">    ctx = seccomp_init(SCMP_ACT_ALLOW); <span class="comment">// 初始化过滤状态为允许所有系统调用</span></span><br><span class="line">    seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), <span class="number">0</span>); <span class="comment">// 添加需要限制的系统调用</span></span><br><span class="line">    seccomp_load(ctx); <span class="comment">// 装载上下文</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *filename = <span class="string">&quot;/bin/sh&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *argv[] = &#123;<span class="string">&quot;/bin/sh&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="type">char</span> *envp[] = &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line">    syscall(SYS_execve, filename, argv, envp); <span class="comment">// execve</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -o ban ban.c -l seccomp</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">须先实现安装</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sudo apt install libseccomp-dev libseccomp2 seccomp</span></span><br></pre></td></tr></table></figure>
<p>运行程序</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">songyangji@SongyangJi-Ubuntu-DeskStop:~/桌面$ ./ban</span><br><span class="line">错误的系统调用 (核心已转储) # Bad system call (core dumped)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="api-rule"><a href="#api-rule" class="headerlink" title="api rule"></a>api rule</h2><h3 id="SCMP-SYS"><a href="#SCMP-SYS" class="headerlink" title="SCMP_SYS"></a>SCMP_SYS</h3><p>根据系统调用名获取系统调用号，虽然你可以直接使用 <code>__NR_syscall</code> 直接指定，但是为了跨平台最好使用它获取。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">SCMP_SYS</span><span class="params">(syscall_name)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="scmp-filter-ctx"><a href="#scmp-filter-ctx" class="headerlink" title="scmp_filter_ctx"></a>scmp_filter_ctx</h3><p>结构体定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> * scmp_filter_ctx;</span><br></pre></td></tr></table></figure>
<p>seccmp的过滤器上下文，保存、传递了我们传入的系统调用过滤条件。</p>
<h3 id="seccomp-init"><a href="#seccomp-init" class="headerlink" title="seccomp_init"></a>seccomp_init</h3><ul>
<li><p>函数说明:<br>seccomp_init的作用就是初始化 scmp_filter_ctx结构。<br>需要注意的是，任何其他libseccomp中的函数调用，必须在seccomp_init之后。</p>
</li>
<li><p>函数定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scmp_filter_ctx <span class="title function_">seccomp_init</span><span class="params">(<span class="type">uint32_t</span> def_action)</span>; </span><br></pre></td></tr></table></figure>
</li>
<li><p>返回值<br>成功返回scmp_filter_ctx（过滤器上下文） ctx；<br>失败返回NULL</p>
</li>
<li><p>参数说明<br>def_action用于指定默认行为，有效动作值如下：（当线程调用了<code>seccomp</code>过滤规则中没有相关配置规则的系统调用时触发）</p>
<ul>
<li>SCMP_ACT_KILL<br>线程将会被内核以SIGSYS信号终止；</li>
<li>SCMP_ACT_KILL_PROCESS<br>整个进程被终止；</li>
<li>SCMP_ACT_TRAP<br>线程将会抛出一个SIGSYS信号；</li>
<li>SCMP_ACT_ERRNO(uint16_t errno)<br>线程调用与筛选规则匹配的系统调用时，它将收到一个errno的返回值；</li>
<li>SCMP_ACT_TRACE(uint16_t msg_num)<br>略</li>
<li>SCMP_ACT_LOG<br>不会对调用系统调用的线程产生任何影响，但系统调用会被记录到日志。</li>
<li>SCMP_ACT_ALLOW<br>不会对调用系统调用的线程产生任何影响。</li>
</ul>
</li>
</ul>
<h3 id="seccomp-rule-addXXX"><a href="#seccomp-rule-addXXX" class="headerlink" title="seccomp_rule_addXXX"></a>seccomp_rule_addXXX</h3><h4 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明:"></a>函数说明:</h4><p>  这个函数组都会向当前seccomp过滤器添加新的过滤规则。</p>
<blockquote>
<p>调用应用程序提供的所有过滤器规则被组合成一个联合，并带有额外的逻辑来消除冗余的系统调用过滤器。<br>例如，如果添加了一条规则，该规则允许给定的系统调用具有一组特定的参数值，<br>然后又添加了一条规则，该规则允许相同的系统调用而不管参数值如何，<br>那么第一个更具体的规则将有效地从过滤器中删除第二个更通用的规则。</p>
</blockquote>
<h4 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">seccomp_rule_add</span><span class="params">(scmp_filter_ctx ctx, <span class="type">uint32_t</span> action,</span></span><br><span class="line"><span class="params">                            <span class="type">int</span> syscall, <span class="type">unsigned</span> <span class="type">int</span> arg_cnt, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">seccomp_rule_add_exact</span><span class="params">(scmp_filter_ctx ctx, <span class="type">uint32_t</span> action,</span></span><br><span class="line"><span class="params">                                  <span class="type">int</span> syscall, <span class="type">unsigned</span> <span class="type">int</span> arg_cnt, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">seccomp_rule_add_array</span><span class="params">(scmp_filter_ctx ctx,</span></span><br><span class="line"><span class="params">                                  <span class="type">uint32_t</span> action, <span class="type">int</span> syscall,</span></span><br><span class="line"><span class="params">                                  <span class="type">unsigned</span> <span class="type">int</span> arg_cnt,</span></span><br><span class="line"><span class="params">                                  <span class="type">const</span> <span class="keyword">struct</span> scmp_arg_cmp *arg_array)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">seccomp_rule_add_exact_array</span><span class="params">(scmp_filter_ctx ctx,</span></span><br><span class="line"><span class="params">                                        <span class="type">uint32_t</span> action, <span class="type">int</span> syscall,</span></span><br><span class="line"><span class="params">                                        <span class="type">unsigned</span> <span class="type">int</span> arg_cnt,</span></span><br><span class="line"><span class="params">                                        <span class="type">const</span> <span class="keyword">struct</span> scmp_arg_cmp *arg_array)</span>;</span><br></pre></td></tr></table></figure>


<h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><ul>
<li><ol>
<li>action有效动作值如下：（当线程调用了<code>seccomp</code>过滤规则中有相关配置规则的系统调用时触发）</li>
</ol>
<ul>
<li>SCMP_ACT_KILL<br>线程将会被内核终止；</li>
<li>SCMP_ACT_KILL_PROCESS<br>整个进程被终止；</li>
<li>SCMP_ACT_TRAP<br>线程将会抛出一个SIGSYS信号；</li>
<li>SCMP_ACT_ERRNO(uint16_t errno)<br>线程调用与筛选规则匹配的系统调用时，它将收到一个errno的返回值；</li>
<li>SCMP_ACT_TRACE(uint16_t msg_num)<br>略</li>
<li>SCMP_ACT_LOG<br>会对调用系统调用的线程产生任何影响，但系统调用会被记录到日志。</li>
<li>SCMP_ACT_ALLOW<br>不会对调用系统调用的线程产生任何影响（也就是允许调用这个system call）。</li>
<li>SCMP_ACT_NOTIFY<br>略</li>
</ul>
</li>
<li><ol start="2">
<li>arg_cnt 指定规则配置的系统调用的参数的匹配情况的个数（因为后面是一个变长数组）</li>
</ol>
</li>
<li><ol start="3">
<li>边长数组的元素是 <code>scmp_arg_cmp</code> 结构体，定义如下。</li>
</ol>
</li>
</ul>
<p>系统调用的参数比较规则相关定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Comparison operators</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">scmp_compare</span> &#123;</span></span><br><span class="line">	_SCMP_CMP_MIN = <span class="number">0</span>,</span><br><span class="line">	SCMP_CMP_NE = <span class="number">1</span>,		<span class="comment">/**&lt; not equal */</span></span><br><span class="line">	SCMP_CMP_LT = <span class="number">2</span>,		<span class="comment">/**&lt; less than */</span></span><br><span class="line">	SCMP_CMP_LE = <span class="number">3</span>,		<span class="comment">/**&lt; less than or equal */</span></span><br><span class="line">	SCMP_CMP_EQ = <span class="number">4</span>,		<span class="comment">/**&lt; equal */</span></span><br><span class="line">	SCMP_CMP_GE = <span class="number">5</span>,		<span class="comment">/**&lt; greater than or equal */</span></span><br><span class="line">	SCMP_CMP_GT = <span class="number">6</span>,		<span class="comment">/**&lt; greater than */</span></span><br><span class="line">	SCMP_CMP_MASKED_EQ = <span class="number">7</span>,		<span class="comment">/**&lt; masked equality */</span></span><br><span class="line">	_SCMP_CMP_MAX,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Argument datum</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint64_t</span> <span class="type">scmp_datum_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Argument / Value comparison definition</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scmp_arg_cmp</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> arg;	<span class="comment">/**&lt; argument number, starting at 0 */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">scmp_compare</span> <span class="title">op</span>;</span>	<span class="comment">/**&lt; the comparison op, e.g. SCMP_CMP_* */</span></span><br><span class="line">	<span class="type">scmp_datum_t</span> datum_a;</span><br><span class="line">	<span class="type">scmp_datum_t</span> datum_b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有效比较操作值（ op ）如下：</p>
<ul>
<li><p>SCMP_CMP_NE<br>参数值不等于基准值时匹配，例如：<br>SCMP_CMP( arg , SCMP_CMP_NE , datum )</p>
</li>
<li><p>SCMP_CMP_LT<br>参数值小于基准值时匹配，例如：<br>SCMP_CMP( arg , SCMP_CMP_LT , datum )</p>
</li>
<li><p>SCMP_CMP_LE<br>参数值小于或等于基准值时匹配，例如：<br>SCMP_CMP( arg , SCMP_CMP_LE , datum )</p>
</li>
<li><p>SCMP_CMP_EQ<br>参数值等于基准值时匹配，例如：<br>SCMP_CMP( arg , SCMP_CMP_EQ , datum )</p>
</li>
<li><p>SCMP_CMP_GE<br>参数值大于或等于基准值时匹配，例如：<br>SCMP_CMP( arg , SCMP_CMP_GE , datum )</p>
</li>
<li><p>SCMP_CMP_GT<br>参数值大于基准值时匹配，例如：<br>SCMP_CMP( arg , SCMP_CMP_GT , datum )</p>
</li>
<li><p>SCMP_CMP_MASKED_EQ<br>当掩码参数值等于掩码基准值时匹配，例如：<br>SCMP_CMP( arg , SCMP_CMP_MASKED_EQ , mask , datum )</p>
</li>
</ul>
<p>注意，scmp_arg_cmp 此结构不能直接生成，需要调用它提供的宏生成，有如下宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> scmp_arg_cmp <span class="title function_">SCMP_CMP</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> arg,</span></span><br><span class="line"><span class="params">                                    <span class="keyword">enum</span> scmp_compare op, ...)</span>;</span><br><span class="line">       <span class="keyword">struct</span> scmp_arg_cmp <span class="title function_">SCMP_A0</span><span class="params">(<span class="keyword">enum</span> scmp_compare op, ...)</span>;</span><br><span class="line">       <span class="keyword">struct</span> scmp_arg_cmp <span class="title function_">SCMP_A1</span><span class="params">(<span class="keyword">enum</span> scmp_compare op, ...)</span>;</span><br><span class="line">       <span class="keyword">struct</span> scmp_arg_cmp <span class="title function_">SCMP_A2</span><span class="params">(<span class="keyword">enum</span> scmp_compare op, ...)</span>;</span><br><span class="line">       <span class="keyword">struct</span> scmp_arg_cmp <span class="title function_">SCMP_A3</span><span class="params">(<span class="keyword">enum</span> scmp_compare op, ...)</span>;</span><br><span class="line">       <span class="keyword">struct</span> scmp_arg_cmp <span class="title function_">SCMP_A4</span><span class="params">(<span class="keyword">enum</span> scmp_compare op, ...)</span>;</span><br><span class="line">       <span class="keyword">struct</span> scmp_arg_cmp <span class="title function_">SCMP_A5</span><span class="params">(<span class="keyword">enum</span> scmp_compare op, ...)</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">struct</span> scmp_arg_cmp <span class="title function_">SCMP_CMP64</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> arg,</span></span><br><span class="line"><span class="params">                                    <span class="keyword">enum</span> scmp_compare op, ...)</span>;</span><br><span class="line">       <span class="keyword">struct</span> scmp_arg_cmp <span class="title function_">SCMP_A0_64</span><span class="params">(<span class="keyword">enum</span> scmp_compare op, ...)</span>;</span><br><span class="line">       <span class="keyword">struct</span> scmp_arg_cmp <span class="title function_">SCMP_A1_64</span><span class="params">(<span class="keyword">enum</span> scmp_compare op, ...)</span>;</span><br><span class="line">       <span class="keyword">struct</span> scmp_arg_cmp <span class="title function_">SCMP_A2_64</span><span class="params">(<span class="keyword">enum</span> scmp_compare op, ...)</span>;</span><br><span class="line">       <span class="keyword">struct</span> scmp_arg_cmp <span class="title function_">SCMP_A3_64</span><span class="params">(<span class="keyword">enum</span> scmp_compare op, ...)</span>;</span><br><span class="line">       <span class="keyword">struct</span> scmp_arg_cmp <span class="title function_">SCMP_A4_64</span><span class="params">(<span class="keyword">enum</span> scmp_compare op, ...)</span>;</span><br><span class="line">       <span class="keyword">struct</span> scmp_arg_cmp <span class="title function_">SCMP_A5_64</span><span class="params">(<span class="keyword">enum</span> scmp_compare op, ...)</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">struct</span> scmp_arg_cmp <span class="title function_">SCMP_CMP32</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> arg,</span></span><br><span class="line"><span class="params">                                    <span class="keyword">enum</span> scmp_compare op, ...)</span>;</span><br><span class="line">       <span class="keyword">struct</span> scmp_arg_cmp <span class="title function_">SCMP_A0_32</span><span class="params">(<span class="keyword">enum</span> scmp_compare op, ...)</span>;</span><br><span class="line">       <span class="keyword">struct</span> scmp_arg_cmp <span class="title function_">SCMP_A1_32</span><span class="params">(<span class="keyword">enum</span> scmp_compare op, ...)</span>;</span><br><span class="line">       <span class="keyword">struct</span> scmp_arg_cmp <span class="title function_">SCMP_A2_32</span><span class="params">(<span class="keyword">enum</span> scmp_compare op, ...)</span>;</span><br><span class="line">       <span class="keyword">struct</span> scmp_arg_cmp <span class="title function_">SCMP_A3_32</span><span class="params">(<span class="keyword">enum</span> scmp_compare op, ...)</span>;</span><br><span class="line">       <span class="keyword">struct</span> scmp_arg_cmp <span class="title function_">SCMP_A4_32</span><span class="params">(<span class="keyword">enum</span> scmp_compare op, ...)</span>;</span><br><span class="line">       <span class="keyword">struct</span> scmp_arg_cmp <span class="title function_">SCMP_A5_32</span><span class="params">(<span class="keyword">enum</span> scmp_compare op, ...)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>解释一下上面的这么多宏的功能分类依据，A{0-5}中的0、1、2、3、4、5用于指定系统调用的那个参数，<br>32还是64自然是指定32位机器还是64位机器，<br>SCMP_CMP的第一个参数<code>unsigned int arg</code>的功能就是<code>A&#123;$arg_num&#125;</code>中的<code>$arg_num</code>，<br>所有宏的第一个参数<code>op</code>就是用于指定比较的规则，如上已经介绍过。</p>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>函数成功时返回零；<br>失败时返回负的errno值。</p>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>1. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(open), <span class="number">1</span>, SCMP_CMP(<span class="number">1</span>, SCMP_CMP_MASKED_EQ, O_WRONLY | O_RDWR, <span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<p>指定<code>open(const *path, int oflags)</code>系统调用的<code>oflags</code>参数如果既没有O_WRONLY，也没有O_RDWR（二进制对应位），就是允许的，<br>换言之这条规则禁用掉了 open的 w、rw。</p>
<h3 id="seccomp-load"><a href="#seccomp-load" class="headerlink" title="seccomp_load"></a>seccomp_load</h3><ul>
<li><p>函数说明:<br>将ctx提供的seccomp过滤器加载到内核中；<br>如果函数成功，新的 seccomp 过滤器将在函数返回时处于活动状态</p>
</li>
<li><p>函数定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">seccomp_load</span><span class="params">(scmp_filter_ctx ctx)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回值<br>成功时返回0，失败时返回以下错误码：<br>-ECANCELED<br>  There was a system failure beyond the control of the<br>library.<br>-EFAULT<br>  Internal libseccomp failure.<br>-EINVAL<br>  Invalid input, either the context or architecture token is invalid.<br>-ENOMEM<br>  The library was unable to allocate enough memory.<br>-ESRCH<br>  Unable to load the filter due to thread issues.</p>
</li>
</ul>
<h3 id="seccomp-release-3"><a href="#seccomp-release-3" class="headerlink" title="seccomp_release(3)"></a>seccomp_release(3)</h3><ul>
<li><p>函数说明:<br>释放ctx 中的 seccomp 过滤器结构的内存，该过滤器首先由seccomp_init(3)或seccomp_reset(3)初始化，<br>并释放与给定 seccomp 过滤器上下文关联的任何内存。<br>加载到内核中的任何 seccomp过滤器不受影响。</p>
</li>
<li><p>函数定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">seccomp_release</span><span class="params">(scmp_filter_ctx ctx)</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p>  <a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/prctl/seccomp_filter.txt">Secure Computing with filters</a><br>  <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man3/seccomp_init.3.html">seccomp_init(3)</a><br>  <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man3/seccomp_rule_add.3.html">seccomp_rule_add(3)</a><br>  <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man3/seccomp_load.3.html">seccomp_load(3)</a><br>  <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man3/seccomp_release.3.html">seccomp_release(3)</a></p>
<blockquote>
<p>参考链接</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%B2%99%E7%9B%92_(%E9%9B%BB%E8%85%A6%E5%AE%89%E5%85%A8)">沙箱安全</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/10/LinkLayer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SongyangJi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JsyBlog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | JsyBlog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/10/LinkLayer/" class="post-title-link" itemprop="url">LinkLayer</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-10 20:53:24" itemprop="dateCreated datePublished" datetime="2021-12-10T20:53:24+08:00">2021-12-10</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/10/IP%20%E5%8D%8F%E8%AE%AE%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94DNS%E3%80%81NAT%E3%80%81ICMP%E3%80%81DHCP%E3%80%81ARP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SongyangJi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JsyBlog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | JsyBlog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/10/IP%20%E5%8D%8F%E8%AE%AE%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94DNS%E3%80%81NAT%E3%80%81ICMP%E3%80%81DHCP%E3%80%81ARP/" class="post-title-link" itemprop="url">IP 协议相关技术——DNS、NAT、ICMP、DHCP、ARP</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-10 00:42:13" itemprop="dateCreated datePublished" datetime="2021-12-10T00:42:13+08:00">2021-12-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-16 17:13:07" itemprop="dateModified" datetime="2022-03-16T17:13:07+08:00">2022-03-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><blockquote>
<p>注意DNS是应用层的协议，不是网络层的协议。</p>
</blockquote>
<h2 id="DNS简介"><a href="#DNS简介" class="headerlink" title="DNS简介"></a>DNS简介</h2><p>DNS（Domain Name System）是域名系统的英文缩写，是一种组织成域层次结构的计算机和网络服务命名系统，用于 TCP&#x2F;IP 网络。</p>
<h2 id="DNS-作用"><a href="#DNS-作用" class="headerlink" title="DNS 作用"></a>DNS 作用</h2><p>通常我们有两种方式识别主机：通过主机名或者 IP 地址。人们喜欢便于记忆的主机名表示，而路由器则喜欢定长的、有着层次结构的 IP 地址。为了满足这些不同的偏好，我们就需要一种能够进行主机名到 IP 地址转换的目录服务，<strong>域名系统作为将域名和 IP 地址相互映射的一个分布式数据库</strong>，能够使人更方便地访问互联网。</p>
<h2 id="DNS-域名解析原理"><a href="#DNS-域名解析原理" class="headerlink" title="DNS 域名解析原理"></a>DNS 域名解析原理</h2><p>DNS 采用了分布式的设计方案，其域名空间采用一种树形的层次结构：</p>
<p><img src="/2021/12/10/IP%20%E5%8D%8F%E8%AE%AE%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94DNS%E3%80%81NAT%E3%80%81ICMP%E3%80%81DHCP%E3%80%81ARP/dns.png"></p>
<p>上图展示了 DNS 服务器的部分层次结构，从上到下依次为<strong>根域名服务器</strong>、<strong>顶级域名服务器</strong>和<strong>权威域名服务器</strong>。</p>
<ol>
<li><p>域名服务器在因特网上有13个，大部分位于北美洲。</p>
</li>
<li><p>第二层为顶级域服务器，这些服务器负责顶级域名（如 com、org、net、edu）和所有国家的顶级域名（如uk、fr、ca 和 jp）。</p>
</li>
<li><p>在第三层为权威 DNS 服务器，因特网上具有公共可访问主机（例如 Web 服务器和邮件服务器）的每个组织机构必须提供公共可访问的 DNS 记录，这些记录由组织机构的权威 DNS 服务器负责保存，这些记录将这些主机的名称映射为 IP 地址。</p>
</li>
</ol>
<p>所以域名的层级关系类似⼀个树状结构：</p>
<ul>
<li><p>根 DNS 服务器</p>
</li>
<li><p>顶级域 DNS 服务器（com）</p>
</li>
<li><p>权威 DNS 服务器（server.com）</p>
</li>
</ul>
<p>除此之外，还有一类重要的 DNS 服务器，叫做<strong>本地 DNS 服务器</strong>。本地 DNS 服务器严格来说不在 DNS 服务器的层次结构中，但它对 DNS 层次结构是很重要的。</p>
<p>一般来说，<strong>每个网络服务提供商（ISP） 都有一台本地 DNS 服务器</strong>。<strong>当主机与某个 ISP 相连时，该 ISP 提供一台主机的 IP 地址，该主机具有一台或多台其本地 DNS 服务器的 IP 地址</strong>。主机的本地 DNS 服务器通常和主机距离较近，<strong>当主机发起 DNS 请求时，该请求被发送到本地 DNS 服务器，它起着代理的作用，并将该请求转发到 DNS 服务器层次结构中</strong>。</p>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><img src="dns2.png" style="zoom:30%;" />

<p>我们以一个例子来了解 DNS 的工作原理，假设主机 A（IP 地址为 abc.xyz.edu） 想知道主机 B 的 IP 地址 （def.mn.edu）。</p>
<ol>
<li>主机 A 首先<strong>向它的本地 DNS 服务器发送一个 DNS 查询报文</strong>。该查询报文含有被转换的主机名 def.mn.edu</li>
<li>本地 DNS 服务器<strong>将该报文转发到根 DNS 服务器</strong>；</li>
<li>根 DNS 服务器注意到查询的 IP 地址前缀为 edu 后向本地 DNS 服务器<strong>返回负责 edu 的顶级域名服务器的 IP 地址列表</strong>。</li>
<li>该本地 DNS 服务器则再次向这些顶级域名服务器发送查询报文。该顶级域名服务器注意到 mn.edu 的前缀，并<strong>用权威域名服务器的 IP 地址进行响应</strong>。</li>
<li>通常情况下，顶级域名服务器并不总是知道每台主机的权威 DNS 服务器的 IP 地址，而只知道中间的某个服务器，该中间 DNS 服务器依次能找到用于相应主机的 IP 地址，我们假设中间经历了权威服务器 ① 和 ②，最后<strong>找到了负责 def.mn.edu 的权威 DNS 服务器</strong> ③</li>
<li>之后，<strong>本地 DNS 服务器直接向该服务器发送查询报文</strong>从而获得主机 B 的IP 地址。</li>
</ol>
<p>在上图中，IP 地址的查询其实经历了两种查询方式，分别是递归查询和迭代查询。</p>
<p><strong>域名解析查询的两种方式</strong></p>
<p>DNS查询有两种方式：<strong>递归</strong>和<strong>迭代</strong>。</p>
<ul>
<li><p>DNS客户端设置使用的DNS服务器一般都是递归服务器，它负责全权处理客户端的DNS查询请求，直到返回最终结果。</p>
</li>
<li><p>DNS服务器之间一般采用迭代查询方式。</p>
</li>
</ul>
<h2 id="DNS-为什么用-UDP"><a href="#DNS-为什么用-UDP" class="headerlink" title="DNS 为什么用 UDP"></a>DNS 为什么用 UDP</h2><h3 id="综合使用TCP和UDP"><a href="#综合使用TCP和UDP" class="headerlink" title="综合使用TCP和UDP"></a>综合使用TCP和UDP</h3><p>更正确的答案是 DNS 既使用 TCP 又使用 UDP。</p>
<p>当进行区域传送（<strong>主域名服务器向辅助域名服务器传送变化的那部分数据</strong>）时会使用 TCP，因为数据同步传送的数据量比一个请求和应答的数据量要多，而 TCP 允许的报文长度更长，因此为了保证数据的正确性，会使用基于可靠连接的 TCP。（DNS服务器与服务器之间用TCP）</p>
<p>udp适用于小包，无上下文的情况，好处是开销小。很容易理解，udp查询就是一问一答，url和ip地址都是很短的字符串，都不会超过一个包。</p>
<p>当客户端向 DNS 服务器查询域名 ( 域名解析) 的时候，一般返回的内容不会超过 <strong>DNS 报文的最大长度，即 512 字节</strong>。用 UDP 传输时，不需要经过 TCP 三次握手的过程，从而大大提高了响应速度，但这要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。</p>
<h3 id="历史发展"><a href="#历史发展" class="headerlink" title="历史发展"></a>历史发展</h3><p>当年内容贫乏，硬件性能低下。认为主机查询的动作频次低，数据量少。用TCP短连结握手和挥手的开销比查询还高。用长连接服务器又承受不住。UDP是很好的选择。</p>
<p>互联网起来后DNS频率急剧增加，所以又加上了TCP版本。</p>
<p>随着恶意的DNS污染出现后，DNS又升级了TLS版本。</p>
<h3 id="无需TCP的可靠传输（省去握手挥手开销）"><a href="#无需TCP的可靠传输（省去握手挥手开销）" class="headerlink" title="无需TCP的可靠传输（省去握手挥手开销）"></a>无需TCP的可靠传输（省去握手挥手开销）</h3><ol>
<li>第一，传输包的大小。首先我们知道tcp要做的事很简单，就是要保证一个可靠及高效的服务。所谓可靠，那就是比如说，本要发的包丢了，那就重传，目的尽量保证这个包到达对端。但是你如果包很大，你每次都整体重传，那肯定不满足高效的原则了（tcp做的很大一部分工作也就是把需要丢的包重传而不是每次整体重传）。基于此，dns查询的包基本大小就是固定的，就是一个包的大小，如果丢了那就再传一次就得了，根本不需要tcp的这种可靠传输。</li>
<li>第二，如果只是传输一个包大小，再来几个握手来几个挥手，就太得不偿失了。</li>
<li>第三，dns查询，本身一个查询，对端就会给一个回复，这个回复就可以当做是一个响应。已经能满足dns查询的这种需求了。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000039759438"><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000039759438">DNS劫持如何避免和解决?</a></a></p>
<h1 id="ARP-地址解析协议"><a href="#ARP-地址解析协议" class="headerlink" title="ARP 地址解析协议"></a>ARP 地址解析协议</h1><p>地址解析协议（英语：Address Resolution Protocol，缩写：ARP）是一个通过解析网络层地址来找寻数据链路层地址的网络传输协议，它在IPv4中极其重要。</p>
<p>在IPv6中<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%82%BB%E5%B1%85%E5%8F%91%E7%8E%B0%E5%8D%8F%E8%AE%AE">邻居发现协议</a>（NDP）用于代替地址解析协议（ARP）。</p>
<h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><p>在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BB%A5%E5%A4%AA%E7%BD%91">以太网</a>协议中规定，<strong>同一局域网中的一台主机要和另一台主机进行直接通信，必须要知道目标主机的MAC地址</strong>。而在TCP&#x2F;IP协议中，网络层和传输层只关心目标主机的IP地址。</p>
<p>这就导致在以太网中使用IP协议时，数据链路层的以太网协议接到上层IP协议提供的数据中，只包含目的主机的IP地址。于是需要一种方法，<strong>根据目的主机的IP地址，获得其<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/MAC%E5%9C%B0%E5%9D%80">MAC地址</a>。这就是ARP协议要做的事情</strong>。所谓<strong>地址解析（address resolution）</strong>就是主机在发送帧前将目标IP地址转换成目标MAC地址的过程。</p>
<p>另外，当发送主机和目的主机不在同一个<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%B1%80%E5%9F%9F%E7%BD%91">局域网</a>中时，即便知道对方的MAC地址，两者也不能直接通信，必须经过<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1">路由</a>转发才可以。所以<strong>此时，发送主机通过ARP协议获得的将不是目的主机的真实MAC地址，而是一台可以通往局域网外的路由器的MAC地址</strong>。于是此后发送主机发往目的主机的所有帧，都将发往该路由器，通过它向外发送。这种情况称为委托ARP或<strong>ARP代理（ARP Proxy）</strong>。</p>
<p>在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AE">点对点链路</a>中不使用ARP，实际上在<strong>点对点网络</strong>中也不使用MAC地址，因为在此类网络中分别已经获取了对端的IP地址。</p>
<h2 id="数据包结构"><a href="#数据包结构" class="headerlink" title="数据包结构"></a>数据包结构</h2><p>为了把IP地址映射到48位以太网地址用于传输，需要一个体现地址转换协议的包格式。</p>
<h3 id="以太网链路层"><a href="#以太网链路层" class="headerlink" title="以太网链路层"></a>以太网链路层</h3><ul>
<li>目标以太网地址：目标MAC地址。FF:FF:FF:FF:FF:FF （二进制全1）为广播地址。</li>
<li>源以太网地址：发送方MAC地址。</li>
<li>帧类型：以太类型，ARP为0x0806。</li>
</ul>
<h3 id="以太网报文数据"><a href="#以太网报文数据" class="headerlink" title="以太网报文数据"></a>以太网报文数据</h3><ul>
<li>硬件类型：如以太网（0x0001）、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%B0%81%E5%8C%85%E7%84%A1%E7%B7%9A%E9%9B%BB">分组无线网</a>。</li>
<li>协议类型：如<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE">网际协议</a>(IP)（0x0800）、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/IPv6">IPv6</a>（0x86DD）。</li>
<li>硬件地址长度：每种硬件地址的字节长度，一般为6（以太网）。</li>
<li>协议地址长度：每种协议地址的字节长度，一般为4（IPv4）。</li>
<li>操作码：1为ARP请求，2为ARP应答，3为<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%80%86%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE">RARP</a>请求，4为RARP应答。</li>
<li><strong>源硬件地址</strong>：n个字节，n由硬件地址长度得到，一般为发送方MAC地址。</li>
<li><strong>源协议地址</strong>：m个字节，m由协议地址长度得到，一般为发送方IP地址。</li>
<li><strong>目标硬件地址</strong>：n个字节，n由硬件地址长度得到，一般为目标MAC地址。</li>
<li><strong>目标协议地址</strong>：m个字节，m由协议地址长度得到，一般为目标IP地址。</li>
</ul>
<table class="wikitable" style="text-align:center;">
<tbody><tr>
<th>长度(位)</th>
<th>48</th>
<th>48</th>
<th>16</th>
<th>16</th>
<th>16</th>
<th>8</th>
<th>8</th>
<th>16</th>
<th>48</th>
<th>32</th>
<th>48</th>
<th>32
</th></tr>
<tr>
<td style="min-height:60px;"><b>数据类型</b></td>
<td style="width:96px;">目标以太网地址</td>
<td style="width:96px;">源以太网地址</td>
<td style="width:32px;">帧类型</td>
<td style="width:32px;">硬件类型</td>
<td style="width:32px;">协议类型</td>
<td style="width:16px;">硬件地址长度</td>
<td style="width:16px;">协议地址长度</td>
<td style="width:32px;">操作码</td>
<td style="width:96px;">源硬件地址</td>
<td style="width:64px;">源协议地址</td>
<td style="width:96px;">目标硬件地址</td>
<td style="width:64px;">目标协议地址
</td></tr>
<tr>
<td><b>组成</b></td>
<td colspan="3">14字节 以太网首部</td>
<td colspan="9">28字节 ARP请求/应答
</td></tr></tbody></table>


<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>在每台安装有TCP&#x2F;IP协议的电脑或路由器里都有一个<strong>ARP缓存表，表里的IP地址与MAC地址是一对应的</strong>。</p>
<p>以主机A（192.168.38.10）向主机B（192.168.38.11）发送数据为例。</p>
<ol>
<li>当发送数据时，主机A会<strong>先在自己的ARP缓存表中寻找是否有目标IP地址</strong>。如果找到就知道目标MAC地址为（00-BB-00-62-C2-02），直接把目标MAC地址写入帧里面发送就可。</li>
<li>如果在ARP缓存表中没有找到相对应的IP地址，<strong>主机A就会在网络上发送一个广播（ARP request），目标MAC地址是“FF.FF.FF.FF.FF.FF”</strong>，这表示向同一网段内的所有主机发出这样的询问：“192.168.38.11的MAC地址是什么？”</li>
<li><strong>网络上其他主机并不响应ARP询问，只有主机B接收到这个帧时，才向主机A做出这样的回应</strong>（ARP response）：“192.168.38.11的MAC地址是00-BB-00-62-C2-02”，此回应以单播方式。这样，主机A就知道主机B的MAC地址，它就可以向主机B发送信息。同时它<strong>还更新自己的ARP高速缓存</strong>（ARP cache），下次再向主机B发送信息时，直接从ARP缓存表里查找就可。</li>
</ol>
<p>ARP缓存表采用老化机制，在一段时间内如果表中的某一行没有使用，就会被删除，这样可减少缓存表的长度，加快查询速度。</p>
<h2 id="免费ARP（gratuitous-ARP）"><a href="#免费ARP（gratuitous-ARP）" class="headerlink" title="免费ARP（gratuitous ARP）"></a>免费ARP（gratuitous ARP）</h2><p>主机发送ARP查询（广播）自己的IP地址，当ARP功能被开启或者是端口初始配置完成，主机向网络发送免费ARP来<strong>查询自己的IP地址确认地址唯一可用</strong>。</p>
<p>作用：</p>
<ol>
<li><strong>确定网络中是否有其他主机使用了IP地址</strong>，如果有应答则产生错误消息。</li>
<li><strong>免费ARP可以做更新ARP缓存用</strong>，网络中的其他主机收到该广播则在缓存中更新条目，收到该广播的主机无论是否存在与IP地址相关的条目都会强制更新，如果存在旧条目则会将MAC更新为广播包中的MAC。</li>
</ol>
<blockquote>
<p>也就是主动告诉其他主机自己的IP和Mac地址的对应关系，以供更新之用。</p>
</blockquote>
<blockquote>
<p>参考<br><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8%E8%AE%AE">ARP</a></p>
</blockquote>
<h1 id="NAT（网络地址转换）"><a href="#NAT（网络地址转换）" class="headerlink" title="NAT（网络地址转换）"></a>NAT（网络地址转换）</h1><p>NAT（Network Address Translation），即<strong>网络地址转换</strong>，它是一种把内部私有网络地址翻译成公有网络 IP 地址的技术。该技术不仅能解决 IP 地址不足的问题，而且还能隐藏和保护网络内部主机，从而避免来自外部网络的攻击。</p>
<p>NAT 的实现方式主要有三种：</p>
<ul>
<li>静态转换（Basic NAT）：<strong>内部私有 IP 地址和公有 IP 地址是一对一的关系</strong>，并且不会发生改变。通过静态转换，可以实现外部网络对内部网络特定设备的访问，这种方式原理简单，但当某一共有 IP 地址被占用时，跟这个 IP 绑定的内部主机将无法访问 Internet。</li>
<li>动态转换：采用动态转换的方式时，<strong>私有 IP 地址每次转化成的公有 IP 地址是不唯一的</strong>。当私有 IP 地址被授权访问 Internet 时会被随机转换成一个合法的公有 IP 地址。当 ISP 通过的合法 IP 地址数量略少于网络内部计算机数量时，可以采用这种方式。</li>
<li><strong>端口多路复用</strong>（NAPT）：该方式将外出数据包的源端口进行端口转换，<strong>通过端口多路复用的方式，实现内部网络所有主机共享一个合法的外部 IP 地址进行 Internet 访问</strong>，从而最大限度地节约 IP 地址资源。同时，该方案可以隐藏内部网络中的主机，从而有效避免来自 Internet 的攻击。</li>
</ul>
<p>NAPT维护一个带有IP以及端口号的NAT表，结构如下。</p>
<table>
<thead>
<tr>
<th align="center">内网IP</th>
<th align="center">外网IP</th>
</tr>
</thead>
<tbody><tr>
<td align="center">192.168.1.55:5566</td>
<td align="center">219.152.168.222:9200</td>
</tr>
<tr>
<td align="center">192.168.1.59:80</td>
<td align="center">219.152.168.222:9201</td>
</tr>
<tr>
<td align="center">192.168.1.59:4465</td>
<td align="center">219.152.168.222:9202</td>
</tr>
</tbody></table>
<p>支持端口转换的NAT可以分为两类：<strong>源地址转换</strong>和<strong>目的地址转换</strong>。</p>
<p>前一种情形下发起连接的计算机的IP地址将会被重写，使得内网主机发出的数据包能够到达外网主机。</p>
<p>后一种情况下被连接计算机的IP地址将被重写，使得外网主机发出的数据包能够到达内网主机。</p>
<p>实际上，<strong>以上两种方式通常会一起被使用以支持双向通信</strong>。</p>
<p>如何支持这样的一对多的映射关系呢？就是利用发送端的源端口来进行的。</p>
<h1 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h1><p><strong>动态主配置协议</strong>（英语：<strong>D</strong>ynamic <strong>H</strong>ost <strong>C</strong>onfiguration <strong>P</strong>rotocol，缩写：<strong>DHCP</strong>），是一个用于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE">IP</a>网络的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE">网络协议</a>，位于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B">OSI模型</a>的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E5%B1%82">应用层</a>，使用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE">UDP</a>协议工作，主要有两个用途：</p>
<ul>
<li><strong>用于内部网或网络服务供应商自动分配IP地址给用户</strong>；</li>
<li>用于内部网管理员对所有电脑作中央管理。</li>
</ul>
<blockquote>
<p> 我们的电脑通常都是通过 DHCP 动态获取 IP 地址，⼤⼤省去了配 IP 信息繁琐的过程。</p>
</blockquote>
<h2 id="DHCP工作步骤"><a href="#DHCP工作步骤" class="headerlink" title="DHCP工作步骤"></a>DHCP工作步骤</h2><ol>
<li><strong>发现</strong> ：客户端⾸先发起 <strong>DHCP</strong> 发现报⽂（<strong>DHCP DISCOVER</strong>） 的 IP 数据报，由于客户端没有 IP 地址，也不知道</li>
</ol>
<p>DHCP 服务器的地址，所以使⽤的是 UDP ⼴播通信，其使⽤的⼴播⽬的地址是 255.255.255.255（端⼝</p>
<p>67） 并且使⽤ 0.0.0.0（端⼝ 68） 作为源 IP 地址。DHCP 客户端将该 IP 数据报传递给链路层，链路层然后</p>
<p>将帧⼴播到所有的⽹络中设备。</p>
<ol start="2">
<li><p><strong>提供</strong> ：DHCP 服务器收到 DHCP 发现报⽂时，⽤ <strong>DHCP</strong> 提供报⽂（<strong>DHCP OFFER</strong>） 向客户端做出响应。该报⽂仍然使⽤ IP ⼴播地址 255.255.255.255，该报⽂信息携带服务器提供可租约的 IP 地址、⼦⽹掩码、默认⽹关、DNS 服务器以及 <strong>IP</strong> 地址租⽤期。</p>
</li>
<li><p><strong>请求</strong> ：客户端收到⼀个或多个服务器的 DHCP 提供报⽂后，从中选择⼀个服务器，并向选中的服务器发送 <strong>DHCP</strong> 请求报⽂（<strong>DHCP REQUEST</strong>进⾏响应，回显配置的参数。</p>
</li>
<li><p><strong>确认</strong> ：最后，服务端⽤ <strong>DHCP ACK</strong> 报⽂对 DHCP 请求报⽂进⾏响应，应答所要求的参数。</p>
</li>
</ol>
<p>⼀旦客户端收到 DHCP ACK 后，交互便完成了，并且<strong>客户端能够在租⽤期内使⽤ DHCP 服务器分配的 IP 地址</strong>。</p>
<p><strong>如果租约的 DHCP IP 地址快到期时，客户端会向服务器发送 DHCP 请求报⽂</strong>：</p>
<ul>
<li><p>服务器如果同意继续租⽤，则⽤ DHCP ACK 报⽂进⾏应答，客户端就会延⻓租期。</p>
</li>
<li><p>服务器如果不同意继续租⽤，则⽤ DHCP NACK 报⽂，客户端就要停⽌使⽤租约的 IP 地址。</p>
</li>
</ul>
<p>可以发现，DHCP 交互中，全程都是使⽤ <strong>UDP</strong> ⼴播通信。</p>
<h2 id="DHCP中继"><a href="#DHCP中继" class="headerlink" title="DHCP中继"></a>DHCP中继</h2><blockquote>
<p> 如果 DHCP 服务器和客户端不是在同⼀个局域⽹内，路由器⼜不会转发⼴播包，那不是每个⽹络都要配⼀个 DHCP 服务器？</p>
</blockquote>
<img src="dhcp.png" style="zoom:60%;" />



<p>所以，为了解决这⼀问题，就出现了 <strong>DHCP中继代理</strong>。有了 DHCP 中继代理以后，对不同⽹段的 <strong>IP</strong> 地址分配也可以由⼀个 <strong>DHCP</strong> 服务器统⼀进⾏管理。DHCP 客户端会向 DHCP 中继代理发送 DHCP 请求包，⽽ <strong>DHCP 中继代理在收到这个⼴播包以后，再以单播的形式发给 DHCP 服务器</strong>。</p>
<p>服务器端收到该包以后再向 DHCP 中继代理返回应答，并由 DHCP 中继代理将此包⼴播给 DHCP 客户端 。</p>
<p>因此，DHCP 服务器即使不在同⼀个链路上也可以实现统⼀分配和管理IP地址。</p>
<h1 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h1><p><strong>ICMP</strong>（Internet Control Message Protocol）是<strong>因特网控制报文协议</strong>，主要是实现 IP 协议中未实现的部分功能，是一种网络层协议。</p>
<p><strong>该协议并不传输数据，只传输控制信息来辅助网络层通信</strong>。</p>
<p>路由器严密监视Internet的操作，当路由器处理一个数据包发生意外的时候，可通过Internet控制消息协议向数据包的源端报告有关事件。</p>
<p>其主要的功能是验证网络是否畅通（确认接收方是否成功接收到 IP 数据包）以及辅助 IP 协议实现可靠传输（若发生 IP 丢包，ICMP 会通知发送方 IP 数据包被丢弃的原因，之后发送方会进行相应的处理）。</p>
<p>最重要的消息类型：</p>
<ol>
<li>目的地不可达：数据包无法传递，原因如不能定位一个目标，或者设置了DF但却遇到了小数据包网络；</li>
<li>超时：当TTL达到0而被丢弃时，路由器发送超时消息；</li>
<li>参数问题：在头字段中检测到一个非法字段；</li>
<li>源抑制：抑制包，可以用于拥塞控制（但现在很少使用）；</li>
<li>重定向：一个数据包被错误的路由；</li>
<li>响应请求与应答：检查一台机器是否存活；</li>
<li>请求&#x2F;应答时间戳：与上面类似不过要求带上时间戳。</li>
</ol>
<h2 id="ICMP应用"><a href="#ICMP应用" class="headerlink" title="ICMP应用"></a>ICMP应用</h2><ul>
<li><p>Ping<br>Ping（Packet Internet Groper），即<strong>因特网包探测器</strong>，是一种工作在网络层的服务命令，主要用于测试网络连接量。本地主机通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 响应报文，Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率从而推断网络是否通畅、运行是否正常等。</p>
</li>
<li><p>TraceRoute<br>TraceRoute 是 ICMP 的另一个应用，其<strong>主要用来跟踪一个分组从源点耗费最少 TTL 到达目的地的路径</strong>。TraceRoute 通过逐渐增大 TTL 值并重复发送数据报来实现其功能，首先，TraceRoute 会发送一个 TTL 为 1 的 IP 数据报到目的地，当路径上的第一个路由器收到这个数据报时，它将 TTL 的值减 1，此时 TTL &#x3D; 0，所以路由器会将这个数据报丢掉，并返回一个差错报告报文，之后源主机会接着发送一个 TTL 为 2 的数据报，并重复此过程，直到数据报能够刚好到达目的主机。此时 TTL &#x3D; 0，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文，之后源主机便知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/09/Redis%E9%AB%98%E5%8F%AF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SongyangJi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JsyBlog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | JsyBlog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/09/Redis%E9%AB%98%E5%8F%AF%E7%94%A8/" class="post-title-link" itemprop="url">Redis高可用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-09 20:45:27" itemprop="dateCreated datePublished" datetime="2021-12-09T20:45:27+08:00">2021-12-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-12-10 21:56:33" itemprop="dateModified" datetime="2021-12-10T21:56:33+08:00">2021-12-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在介绍哨兵之前，首先从宏观角度回顾一下Redis实现高可用相关的技术。它们包括：持久化、复制、哨兵和集群，其主要作用和解决的问题是：</p>
<ul>
<li>持久化：持久化是最简单的高可用方法(有时甚至不被归为高可用的手段)，主要作用是数据备份，即将数据存储在硬盘，保证数据不会因进程退出而丢失。</li>
<li>复制：复制是高可用Redis的基础，哨兵和集群都是在复制基础上实现高可用的。复制主要实现了数据的多机备份，以及对于读操作的负载均衡和简单的故障恢复。缺陷：故障恢复无法自动化；写操作无法负载均衡；存储能力受到单机的限制。</li>
<li>哨兵：在复制的基础上，哨兵实现了自动化的故障恢复。缺陷：写操作无法负载均衡；存储能力受到单机的限制。</li>
<li>集群：通过集群，Redis解决了写操作无法负载均衡，以及存储能力受到单机限制的问题，实现了较为完善的高可用方案。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/09/Redis-%E5%93%A8%E5%85%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SongyangJi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JsyBlog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | JsyBlog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/09/Redis-%E5%93%A8%E5%85%B5/" class="post-title-link" itemprop="url">Redis-哨兵</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-09 20:43:29" itemprop="dateCreated datePublished" datetime="2021-12-09T20:43:29+08:00">2021-12-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-12-12 15:18:32" itemprop="dateModified" datetime="2021-12-12T15:18:32+08:00">2021-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>Redis主从复制的作用有数据热备、负载均衡、故障恢复等；但主从复制存在的一个问题是故障恢复无法自动化。本文将要介绍的哨兵，它基于Redis主从复制，主要作用便是解决主节点故障恢复的自动化问题，进一步提高系统的高可用性。</p>
</blockquote>
<h2 id="部署哨兵节点"><a href="#部署哨兵节点" class="headerlink" title="部署哨兵节点"></a>部署哨兵节点</h2><p><strong>哨兵节点本质上是特殊的Redis节点</strong>，它的两个基本功能是<strong>监控</strong>和<strong>故障转移</strong>。</p>
<p>新建一个配置文件<code>sentinel.conf</code>,内容为</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sentinel monitor mymaster ip port quorum</span></span><br><span class="line">sentinel monitor mymaster 192.168.92.128 6379 2</span><br></pre></td></tr></table></figure>



<p>其中，sentinel monitor mymaster 192.168.92.128 6379 2 配置的含义是：</p>
<p>该哨兵节点监控192.168.92.128:6379这个主节点，该主节点的名称是mymaster，最后的2表示最低通过票数，与主节点的故障判定有关：至少需要2个哨兵节点同意，才能判定主节点故障并进行故障转移。</p>
<p>注意，在配置哨兵监控一个系统的时候，只需要配置其监控主数据库即可，哨兵会自动发现所有复制该主库的从库。</p>
<p>哨兵节点的启动有两种方式，二者作用是完全相同的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel sentinel-26379.conf</span><br><span class="line">redis-server sentinel-26379.conf --sentinel</span><br></pre></td></tr></table></figure>


<p>哨兵系统的搭建过程，有几点需要注意：</p>
<p>（1）哨兵系统中的主从节点，与普通的主从节点并没有什么区别，故障发现和转移是由哨兵来控制和完成的。</p>
<p>（2）哨兵节点本质上是redis节点。</p>
<p>（3）<strong>每个哨兵节点，只需要配置监控主节点</strong>，便可以自动发现其他的哨兵节点和从节点。</p>
<p>（4）在哨兵节点启动和故障转移阶段，各个节点的配置文件会被重写(config rewrite)。</p>
<h2 id="Jedis使用哨兵"><a href="#Jedis使用哨兵" class="headerlink" title="Jedis使用哨兵"></a>Jedis使用哨兵</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testSentinel</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">         <span class="type">String</span> <span class="variable">masterName</span> <span class="operator">=</span> <span class="string">&quot;mymaster&quot;</span>;</span><br><span class="line">         Set&lt;String&gt; sentinels = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">         sentinels.add(<span class="string">&quot;192.168.92.128:26379&quot;</span>);</span><br><span class="line">         sentinels.add(<span class="string">&quot;192.168.92.128:26380&quot;</span>);</span><br><span class="line">         sentinels.add(<span class="string">&quot;192.168.92.128:26381&quot;</span>);</span><br><span class="line"> </span><br><span class="line">         <span class="type">JedisSentinelPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisSentinelPool</span>(masterName, sentinels); <span class="comment">//初始化过程做了很多工作</span></span><br><span class="line">         <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> pool.getResource();</span><br><span class="line">         jedis.set(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">         pool.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Jedis客户端对哨兵提供了很好的支持。如上述代码所示，我们只需要向Jedis提供哨兵节点集合和masterName，构造JedisSentinelPool对象；然后便可以像使用普通redis连接池一样来使用了：通过pool.getResource()获取连接，执行具体的命令。</p>
<p>在整个过程中，我们的代码<strong>不需要显式的指定主节点的地址</strong>，就可以连接到主节点；</p>
<p>代码中对故障转移没有任何体现，就可以<strong>在哨兵完成故障转移后自动的切换主节点</strong>。</p>
<p>之所以可以做到这一点，是因为在JedisSentinelPool的构造器中，进行了相关的工作；主要包括以下两点：</p>
<p>（1）<strong>遍历哨兵节点，获取主节点信息：</strong>遍历哨兵节点，通过其中一个哨兵节点+masterName获得主节点的信息；该功能是通过调用哨兵节点的sentinel get-master-addr-by-name命令实现，该命令示例如下：</p>
<p>一旦获得主节点信息，停止遍历（因此一般来说遍历到第一个哨兵节点，循环就停止了）。</p>
<p>（2）<strong>增加对哨兵的监听：</strong>这样当<strong>发生故障转移时，客户端便可以收到哨兵的通知</strong>，从而完成主节点的切换。具体做法是：<strong>利用redis提供的发布订阅功能，为每一个哨兵节点开启一个单独的线程，订阅哨兵节点的+switch-master频道，当收到消息时，重新初始化连接池</strong>。</p>
<p><strong>需要注意的是，哨兵只是配置提供者，而不是代理</strong>。</p>
<h2 id="哨兵的原理"><a href="#哨兵的原理" class="headerlink" title="哨兵的原理"></a>哨兵的原理</h2><p>关于哨兵的原理，关键是了解以下几个概念。</p>
<h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><p>每个哨兵节点维护了3个定时任务。定时任务的功能分别如下：1. 通过向主从节点发送info命令获取最新的主从结构；2. 通过发布订阅功能获取其他哨兵节点的信息；3. 通过向其他节点发送ping命令进行心跳检测，判断是否下线。</p>
<ol>
<li><p><strong>每10秒哨兵会向主数据库和从数据库发送Info命令</strong>。发送Info命令是的哨兵能够获得主节点的相关信息，并能够获得到从节点的信息，从而<strong>实现对新节点的自动发现</strong>。</p>
</li>
<li><p><strong>每2秒哨兵向主数据库和从数据库的__sentinel__:hello频道发送自己的信息</strong> ，用于分享和获取同样监控此数据库的哨兵节点的信息。当其他节点受到信息后，会判断发消息的哨兵节点是否是新发现的节点，如果是则会加入哨兵列表。</p>
</li>
<li><p><strong>每30秒会向主数据库、从数据库和其他哨兵节点发送PING命令</strong>。此命令的作用就是用于<strong>定时监控这些数据库和哨兵节点有没有停止服务</strong>，很关键的一点。</p>
</li>
</ol>
<h3 id="主观下线和客观下线"><a href="#主观下线和客观下线" class="headerlink" title="主观下线和客观下线"></a>主观下线和客观下线</h3><ul>
<li><p>主观下线：在心跳检测的定时任务中，如果其他节点超过一定时间没有回复，哨兵节点就会将其进行主观下线。顾名思义，<strong>主观下线的意</strong>思是一个哨兵节点“主观地”判断下线，也就是哨兵它自己认为一个节点下线了，但还没有得到其他节点的认同；与主观下线相对应的是客观下线。</p>
</li>
<li><p>客观下线：哨兵节点在对主节点进行主观下线后，会通过<code>sentinel is-master-down-by-addr</code>命令询问其他哨兵节点该主节点的状态；<strong>如果判断主节点下线的哨兵数量达到一定数值，则对该主节点进行客观下线</strong>。</p>
</li>
</ul>
<p>需要特别注意的是，<strong>客观下线是主节点才有的概念</strong>；<strong>如果从节点和哨兵节点发生故障，被哨兵主观下线后，不会再有后续的客观下线和故障转移操作</strong>。</p>
<h3 id="选举领导者哨兵节点"><a href="#选举领导者哨兵节点" class="headerlink" title="选举领导者哨兵节点"></a>选举领导者哨兵节点</h3><p>当主节点被判断客观下线以后，各个哨兵节点会进行协商，选举出一个领导者哨兵节点，并由该领导者节点对其进行故障转移操作。</p>
<p>监视该主节点的所有哨兵都有可能被选为领导者，选举使用的算法是Raft算法。</p>
<p>使用Raft算法选举领头哨兵的过程如下：</p>
<ol>
<li>发现主数据库客观下线的哨兵节点（称为节点A），向每个哨兵节点发送命令，要求对方选自己称为领导者哨兵。</li>
<li>如果目标哨兵节点没有选过其他人，则会同意将A设置成领头节点。</li>
<li>如果A发现有超过半数且超过quorum参数值的哨兵节点同意选自己为领导者节点，则A成功成为领导者节点。</li>
<li>当有多个哨兵节点同时参选领头节点的时候，则会出现任何节点都不能当选的情况，这个时候每个参选节点都等待一个随机时间重新发起参选请求，进行下一轮选举，直到选举成功。</li>
</ol>
<p><strong>注意：每次选举出来的最多只会选出一个领头哨兵。</strong></p>
<h3 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h3><p>选举出的领导者哨兵，开始进行故障恢复操作，该操作大体可以分为3个步骤： </p>
<ol>
<li><strong>在从节点中选择新的主节点</strong>：选择的原则是，<strong>首先过滤掉不健康的从节点；然后选择优先级最高的从节点(由slave-priority指定)；如果优先级无法区分，则选择复制偏移量最大的从节点；如果仍无法区分，则选择runid最小的从节点</strong>。（健康状态–&gt;优先级–&gt;复制偏移量–&gt;runid）</li>
<li><strong>更新主从状态</strong>：<strong>通过slaveof no one命令，让选出来的从节点成为主节点</strong>；并<strong>通过slaveof命令让其他节点成为其从节点</strong>。</li>
<li><strong>将已经下线的主节点(如localhost:6379)设置为新的主节点的从节点</strong>，当localhost:6379重新上线后，它会成为新的主节点的从节点。</li>
</ol>
<p>通过上述几个关键概念，可以基本了解哨兵的工作原理。为了更形象的说明，下图展示了领导者哨兵节点的日志，包括从节点启动到完成故障转移。</p>
<p><img src="/2021/12/09/Redis-%E5%93%A8%E5%85%B5/Redis-%E5%93%A8%E5%85%B51.png"></p>
<h2 id="配置与实践建议"><a href="#配置与实践建议" class="headerlink" title="配置与实践建议"></a>配置与实践建议</h2><h3 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h3><p>下面介绍与哨兵相关的几个配置。</p>
<ol>
<li>sentinel monitor {masterName} {masterIp} {masterPort} {quorum}</li>
</ol>
<p>sentinel monitor是哨兵最核心的配置，在前文讲述部署哨兵节点时已说明，其中：masterName指定了主节点名称，masterIp和masterPort指定了主节点地址<strong>，quorum是判断主节点客观下线的哨兵数量阈值</strong>：当判定主节点下线的哨兵数量达到quorum时，对主节点进行客观下线。<strong>quorum建议取值为N&#x2F;2 + 1（其中 N 为哨兵节点的数量）</strong>。</p>
<ol start="2">
<li>sentinel down-after-milliseconds {masterName} {time}</li>
</ol>
<p>sentinel down-after-milliseconds与主观下线的判断有关：<strong>哨兵使用ping命令对其他节点进行心跳检测，如果其他节点超过down-after-milliseconds配置的时间没有回复，哨兵就会将其进行主观下线</strong>。该配置对主节点、从节点和哨兵节点的主观下线判定都有效。</p>
<p>down-after-milliseconds的默认值是30000，即30s；可以根据不同的网络环境和应用要求来调整：值越大，对主观下线的判定会越宽松，好处是误判的可能性小，坏处是故障发现和故障转移的时间变长，客户端等待的时间也会变长。例如，如果应用对可用性要求较高，则可以将值适当调小，当故障发生时尽快完成转移；如果网络环境相对较差，可以适当提高该阈值，避免频繁误判。</p>
<ol start="3">
<li>sentinel parallel-syncs {masterName} {number}</li>
</ol>
<p>sentinel parallel-syncs与故障转移之后从节点的复制有关，<strong>规定了每次向新的主节点发起复制操作的从节点个数</strong>。例如，假设主节点切换完成之后，有3个从节点要向新的主节点发起复制；如果parallel-syncs&#x3D;1，则从节点会一个一个开始复制；如果parallel-syncs&#x3D;3，则3个从节点会一起开始复制。</p>
<p>parallel-syncs取值越大，从节点完成复制的时间越快，但是对主节点的网络负载、硬盘负载造成的压力也越大；应根据实际情况设置。例如，如果主节点的负载较低，而从节点对服务可用的要求较高，可以适量增加parallel-syncs取值。parallel-syncs的默认值是1。</p>
<ol start="4">
<li>sentinel failover-timeout {masterName} {time}</li>
</ol>
<p>sentinel failover-timeout与故障转移超时的判断有关，但是<strong>该参数不是用来判断整个故障恢复阶段的超时</strong>，而是其几个子阶段的超时，例如如果<strong>从节点晋升为主节点时间超过timeout</strong>，或<strong>从节点向新的主节点发起复制操作的时间</strong>(不包括复制数据的时间)超过timeout，都会导致故障转移超时失败。</p>
<p>failover-timeout的默认值是180000，即180s；如果超时，则下一次该值会变为原来的2倍。</p>
<h3 id="实践建议"><a href="#实践建议" class="headerlink" title="实践建议"></a>实践建议</h3><p>（1）<strong>哨兵节点的数量应不止一个</strong>，一方面增加哨兵节点的冗余，避免哨兵本身成为高可用的瓶颈；另一方面减少对下线的误判。此外，<strong>这些不同的哨兵节点应部署在不同的物理机上</strong>。</p>
<p>（2）<strong>哨兵节点的数量应该是奇数</strong>，便于哨兵通过投票做出“决策”：领导者选举的决策、客观下线的决策等。</p>
<p>（3）<strong>各个哨兵节点的配置应一致</strong>，包括硬件、参数等；此外，所有节点都应该使用ntp或类似服务，保证时间准确、一致。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/09/undolog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SongyangJi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JsyBlog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | JsyBlog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/09/undolog/" class="post-title-link" itemprop="url">MySQL —— Undo log</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-09 18:47:10" itemprop="dateCreated datePublished" datetime="2021-12-09T18:47:10+08:00">2021-12-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-12-11 01:53:31" itemprop="dateModified" datetime="2021-12-11T01:53:31+08:00">2021-12-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="undo-log的作用"><a href="#undo-log的作用" class="headerlink" title="undo log的作用"></a>undo log的作用</h2><p>为了保证事务的原子性，InnoDB引入了undo日志，undo日志记载了回滚操作所需的内容。</p>
<p>undo是<strong>逻辑日志</strong>，只是将数据库逻辑地恢复到原来的样子；所有修改都被逻辑地取消了，但是数据结构和页本身在回滚之后可能不大相同。</p>
<p>undo log有两个作用：<strong>提供回滚</strong>和**多版本并发控制(MVCC)**。</p>
<h2 id="事务id"><a href="#事务id" class="headerlink" title="事务id"></a>事务id</h2><p>在事务在对表中的记录进行修改的时候，会为这个事务分配一个唯一的事务id，这个事务id是递增的，所以事务id越小越先执行。未被分配事务id的事务的id默认是0。</p>
<h2 id="各种类型的Undo-log"><a href="#各种类型的Undo-log" class="headerlink" title="各种类型的Undo log"></a>各种类型的Undo log</h2><p>InnoDB对不同场景的设计了不同类型的undo日志，比如TRX_UNDO_INSERT_REC, TRX_UNDO_DEL_MARK_REC.</p>
<p>TRX_UNDO_UPD_EXIST_REC等等。</p>
<p>除了insert产生的undo日志中没有roll_pointer字段，其他的一般都有roll_pointer这个字段，这个字段就支撑了回滚和MVCC的功能。</p>
<p><img src="/2021/12/09/undolog/undolog.png"></p>
<h2 id="Undo-log-的管理"><a href="#Undo-log-的管理" class="headerlink" title="Undo log 的管理"></a>Undo log 的管理</h2><p>类型为FIL_PAGE_UNDO_LOG的页面，是专门用来存储undo日志的，不妨称为Undo页面。</p>
<p>一个事务写的undo日志可能在一个页面中放不下，所以MySQL使用链表来组织这些undo页面。</p>
<p>在一个事务执行过程中，最多分配4个页面链表，</p>
<p>分别是</p>
<ol>
<li>针对普通表的insert undo 链表；</li>
<li>针对普通表的update undo 链表；</li>
<li>针对临时表的insert undo 链表；</li>
<li>针对临时表的update undo 链表；</li>
</ol>
<p>每个undo页面链表都对应一个Undo Log Segment。Undo页面链表的第一个页中有一个名为Undo Log Segment Header的部分，用来存储关于这个段的信息。</p>
<p>同一个事务向一个undo链表写入的undo日志算是一个组，每个组都以一个Undo Log Header 部分开头。</p>
<h2 id="undo及redo如何记录事务"><a href="#undo及redo如何记录事务" class="headerlink" title="undo及redo如何记录事务"></a>undo及redo如何记录事务</h2><h3 id="Undo-Redo事务的简化过程"><a href="#Undo-Redo事务的简化过程" class="headerlink" title="Undo + Redo事务的简化过程"></a>Undo + Redo事务的简化过程</h3><p>假设有A、B两个数据，值分别为1,2，开始一个事务，事务的操作内容为：把1修改为3，2修改为4，那么实际的记录如下（简化）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A.事务开始.</span><br><span class="line">B.记录A=1到undo log.</span><br><span class="line">C.修改A=3.</span><br><span class="line">D.记录A=3到redo log.</span><br><span class="line">E.记录B=2到undo log.</span><br><span class="line">F.修改B=4.</span><br><span class="line">G.记录B=4到redo log.</span><br><span class="line">H.将redo log写入磁盘。</span><br><span class="line">I.事务提交</span><br></pre></td></tr></table></figure>

<p><strong>注意是先写 undo log，再操作，最后再写redo log</strong></p>
<h3 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h3><p>前面说到未提交的事务和回滚了的事务也会记录Redo Log，因此在进行恢复时,这些事务要进行特殊的的处理。有2种不同的恢复策略：</p>
<ul>
<li>进行恢复时，只重做已经提交了的事务。</li>
<li>进行恢复时，<strong>重做所有事务包括未提交的事务和回滚了的事务，然后通过Undo Log回滚那些未提交的事务</strong>。</li>
</ul>
<p>MySQL数据库InnoDB存储引擎使用了B策略, InnoDB存储引擎中的恢复机制有几个特点：</p>
<ul>
<li><p><strong>在重做Redo Log时，并不关心事务性</strong>。 恢复时，没有BEGIN，也没有COMMIT,ROLLBACK的行为。也不关心每个日志是哪个事务的。尽管事务ID等事务相关的内容会记入Redo Log，这些内容只是被当作要操作的数据的一部分。</p>
</li>
<li><p>使用B策略就<strong>必须要将Undo Log持久化</strong>，而且<strong>必须要在写Redo Log之前将对应的Undo Log写入磁盘</strong>。Undo和Redo Log的这种关联，使得持久化变得复杂起来。</p>
<p>为了降低复杂度，<strong>InnoDB将Undo Log看作数据，因此记录Undo Log的操作也会记录到redo log中</strong>。</p>
<p><strong>这样undo log就可以像数据一样缓存起来</strong>，<strong>而不用在redo log之前写入磁盘了</strong>。</p>
<p>包含Undo Log操作的Redo Log，看起来是这样的：</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">记录1: &lt;trx1, Undo log insert &lt;undo_insert …&gt;&gt; # 记录的 undo-log</span><br><span class="line">记录2: &lt;trx1, insert …&gt; # 重做日志本身</span><br><span class="line">记录3: &lt;trx2, Undo log insert &lt;undo_update …&gt;&gt;</span><br><span class="line">记录4: &lt;trx2, update …&gt;</span><br><span class="line">记录5: &lt;trx3, Undo log insert &lt;undo_delete …&gt;&gt;</span><br><span class="line">记录6: &lt;trx3, delete …&gt;</span><br></pre></td></tr></table></figure>



<p>到这里，还有一个问题没有弄清楚。既然Redo没有事务性，那岂不是会重新执行被回滚了的事务？<br>确实是这样。同时Innodb也会将事务回滚时的操作也记录到redo log中。<strong>回滚操作本质上也是对数据进行修改，因此回滚时对数据的操作也会记录到Redo Log中</strong>。</p>
<p><strong>一个回滚了的事务的Redo Log</strong>，看起来是这样的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">记录1: &lt;trx1, Undo log insert &lt;undo_insert …&gt;&gt; # 记录的 undo-log</span><br><span class="line">记录2: &lt;trx1, insert A…&gt; # 重做日志本身</span><br><span class="line">记录3: &lt;trx1, Undo log insert &lt;undo_update …&gt;&gt;</span><br><span class="line">记录4: &lt;trx1, update B…&gt;</span><br><span class="line">记录5: &lt;trx1, Undo log insert &lt;undo_delete …&gt;&gt;</span><br><span class="line">记录6: &lt;trx1, delete C…&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下面是对应的回滚操作</span></span><br><span class="line">记录7: &lt;trx1, insert C&gt; </span><br><span class="line">记录8: &lt;trx1, update B to old value&gt;</span><br><span class="line">记录9: &lt;trx1, delete A&gt;</span><br></pre></td></tr></table></figure>


<p><strong>一个被回滚了的事务在恢复时的操作就是先redo再undo，因此不会破坏数据的一致性</strong>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/09/redolog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SongyangJi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JsyBlog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | JsyBlog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/09/redolog/" class="post-title-link" itemprop="url">MySQL —— Redo log</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-09 18:47:05" itemprop="dateCreated datePublished" datetime="2021-12-09T18:47:05+08:00">2021-12-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-12-11 01:05:41" itemprop="dateModified" datetime="2021-12-11T01:05:41+08:00">2021-12-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="RedoLog介绍"><a href="#RedoLog介绍" class="headerlink" title="RedoLog介绍"></a>RedoLog介绍</h1><h2 id="引言——MySQL如何做到事务的持久性"><a href="#引言——MySQL如何做到事务的持久性" class="headerlink" title="引言——MySQL如何做到事务的持久性"></a>引言——MySQL如何做到事务的持久性</h2><p>MySQL中如何修改数据呢，先从磁盘中加载数据页到InnoDB buffer pool中，然后从InnoDB buffer pool 中取出页面，进行读写操作。</p>
<p>那么如何做到事务的持久性呢，也就是说如何确保InnoDB buffer pool中的脏页一定会被刷新到磁盘从而做到持久化呢？</p>
<p>一种最简单的方法，在事务提交成功之前，确保脏页被刷新到磁盘，换句话说，只有在脏页写到磁盘上之后，事务提交才算成功。</p>
<p>不过这种方案有缺点：</p>
<ol>
<li><strong>每次都刷新一个完整的页到磁盘性能开销很大</strong>。比如，一个页面中只有几个字节被修改的时候，刷新完整的页面到磁盘很浪费。</li>
<li><strong>磁盘的随机IO很慢</strong>，一个事务修改的很多页面可能并不相邻，这个时候每个事务结束前都这样同步刷新的磁盘随机IO代价很大。</li>
</ol>
<p>MySQL采取的做法是，仅仅记录下那些修改的操作，譬如<strong>修改某个表空间的某个页面的某个偏移量的某几个字节</strong>，然后将这样的记录及时写到文件中。然后每次事务提交前只需要刷新这样的日志文件到磁盘即可。</p>
<p>而这样的日志文件就是 <strong>rodo log</strong> 了。</p>
<p>刷新redo-log而不是完整的数据页到磁盘的好处有：</p>
<ol>
<li>redo日志相对来讲比较紧凑，占用的空间比较小；</li>
<li>redo日志是顺序写入磁盘的，磁盘的顺序IO效率很高。</li>
</ol>
<h2 id="redo日志格式"><a href="#redo日志格式" class="headerlink" title="redo日志格式"></a>redo日志格式</h2><p>redo log 包括两部分：</p>
<ol>
<li><p>一个是内存中的日志缓冲(redo log buffer)；</p>
</li>
<li><p>另一个是磁盘上的日志文件(redo log file)。</p>
</li>
</ol>
<p>下面依次介绍</p>
<ol>
<li>type：这条redo日志的格式；</li>
<li>space ID：表空间 ID；</li>
<li>page number：页号；</li>
<li>data：这条redo日志的具体内容。</li>
</ol>
<p>具体来说redo日志的种类有非常多，这里就不细谈了。</p>
<p>挖个坑。</p>
<h2 id="Mini-transaction-的概念"><a href="#Mini-transaction-的概念" class="headerlink" title="Mini-transaction 的概念"></a>Mini-transaction 的概念</h2><p>MySQL对底层页面的一次原子性的访问成为一个Mini-Transaction（MTR）</p>
<p>一个MTR产生多个redo日志。</p>
<p>之所以把它成为迷你的一个事务，是因为在进行崩溃恢复的时候需要把这一组redo日志作为一个不可分割的整体来处理。</p>
<img src="mtr.png" style="zoom:30%;" />



<h2 id="redo日志的管理"><a href="#redo日志的管理" class="headerlink" title="redo日志的管理"></a>redo日志的管理</h2><h3 id="log-block"><a href="#log-block" class="headerlink" title="log block"></a>log block</h3><p>redo日志放在大小为512字节的log block 中。每一个block被分为 3 部分：</p>
<ul>
<li>log block header</li>
<li>log block body</li>
<li>log block trailer</li>
</ul>
<p>而真正的redo日志是被放在占用 496 字节的 block body 中的。</p>
<h3 id="redo-log-buffer"><a href="#redo-log-buffer" class="headerlink" title="redo log buffer"></a>redo log buffer</h3><p>为了解决磁盘速度过慢的问题，写入redo日志也不是直接立即写到磁盘中的。</p>
<p>于是，MySQL向操作系统申请了一大片内存，称为redo 日志缓冲区，也成为 redo buffer，</p>
<p>一个redo buffer有若干的 log block 构成。可以指定<code>innodb_log_buffer_size</code>来指定 log buffer 的大小。</p>
<p>向 log buffer 中写入redo日志也是顺序写入的。</p>
<h2 id="redo-log的刷盘时机"><a href="#redo-log的刷盘时机" class="headerlink" title="redo log的刷盘时机"></a>redo log的刷盘时机</h2><p>redo日志总留在log buffer中，总是不安全的，只要没有写到稳定的存储介质（磁盘、固定硬盘等等）中就不能保证持久性。</p>
<p>那么在什么情况下，redo日志会被写到磁盘上呢？</p>
<ol>
<li><p>事务提交时：道理很好理解，事务提交还没有将redo log 刷盘就无法做到持久性；</p>
</li>
<li><p>log buffer 空间不足时：log buffer 这块内存总是有限大小的，那么在redo log不够使用时，也需要即使把redo log 刷新到磁盘。InnoDB在日志量达到总容量的额50% 时，就会刷盘；</p>
</li>
<li><p>后台线程定时刷新；</p>
</li>
<li><p>正常关闭服务器时；</p>
</li>
<li><p>做checkpoint时。</p>
</li>
</ol>
<h2 id="redo日志文件"><a href="#redo日志文件" class="headerlink" title="redo日志文件"></a>redo日志文件</h2><p>之前谈的所有的redo log其实都是内存性的结构，那么存在在稳定介质中的便是 redo日志文件了。</p>
<p>磁盘上的日志文件不止一个，而是以一个日志文件组的形式出现，一个日志文件组由多个日志文件组成，名字形式为”ib_logfile[数字]”。<br>每个日志文件的大小由<code>innodb_log_file_size</code>指定，默认是 48 MB。<br>日志文件组文件的个数由<code>innodb_log_files_in_group</code>指定，默认是2个。</p>
<p>所以，总体的日志文件的大小便是<strong>innodb_log_file_size*innodb_log_files_in_group</strong>，</p>
<p>如果以循环的方法向redo日志文件中写入数据，那岂不是新写入的会覆盖旧写入的吗？</p>
<p>如何解决这个问题，MySQL提出了 checkpoint的概念（后面或介绍）。</p>
<p>每个日志的文件格式是一样的，日志组内的其他的日志文件也是具有相同的格式。</p>
<p>前2048个字节存储一些管理信息，后面的字节，实际上就是对内存中的log buffer的镜像。</p>
<h2 id="log-sequence-number相关"><a href="#log-sequence-number相关" class="headerlink" title="log-sequence-number相关"></a>log-sequence-number相关</h2><h3 id="lsn"><a href="#lsn" class="headerlink" title="lsn"></a>lsn</h3><p>InndoDB设计了名为lsn的全局变量，用来记录当前已经写入的<strong>lsn</strong>值，初始值为8704，然后不断递增。</p>
<p>lsn指的是写入的redo 日志量，这包括了写到了 log buffer 中但没有刷新到磁盘的redo日志。</p>
<h3 id="flushed-to-disk-lsn"><a href="#flushed-to-disk-lsn" class="headerlink" title="flushed_to_disk_lsn"></a>flushed_to_disk_lsn</h3><p>相应的，InndoDB设计者提出了一个表示刷新到磁盘中的redo日志量的全局变量<strong>flushed_to_disk_lsn</strong>。</p>
<p>一开始，lsn等于flushed_to_disk_lsn，随着系统的运行，redo日志不断写入log buffer，但又没有即使刷盘，那么flushed_to_disk_lsn便和lsn拉开了差距。</p>
<h3 id="checkpoint-lsn"><a href="#checkpoint-lsn" class="headerlink" title="checkpoint_lsn"></a>checkpoint_lsn</h3><p>redo日志的大小总是有限的，那么就有必要对其进行重复利用。</p>
<p>具体的，如果redo日志对应的脏页已经刷新到磁盘，那么此时就没有必要再去保留这样的redo日志，</p>
<p>于是InnodB使用<strong>checkpoint_lsn</strong>表示当前系统中可以被覆盖redo日志总量是多少，这个变量的初始值也是8704。</p>
<p>MySQL中有后台线程在脏页刷新到磁盘的时候执行一次checkpoint操作，就是查看是否可以增加checkpoint_lsn（但是不是说只要刷新脏页就一定执行一次checkpoint操作）。</p>
<h2 id="innodb-flush-log-at-trx-commit"><a href="#innodb-flush-log-at-trx-commit" class="headerlink" title="innodb_flush_log_at_trx_commit"></a>innodb_flush_log_at_trx_commit</h2><p>它的取值有3种：</p>
<ul>
<li>0 ：事务提交时不会立即向磁盘同步redo日志。这样会加快处理速度，但是失去持久性这一保证，不可取。</li>
<li>1 ：事务提交时必须将redo日志同步到磁盘，这样可以保证事务的持久性。默认值就是1。</li>
<li>2：这是一个折中的选择，事务提交的时候需要同步到操作系统的写磁盘的缓冲区，但不一定要真正写到磁盘上。所以，如果数据库挂了，但是操作系统还没挂，持久性还是可以保证的；反之，持久性还是无法保证。</li>
</ul>
<h1 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h1><p>redo日志最重要的甚至是唯一的功能就是在数据库崩溃的时候提供数据恢复的保证了。</p>
<p>崩溃恢复的时候先找到恢复的起点。然后顺着日志文件就可以将数据正确恢复起来。</p>
<p>但是这个过程可以加快。</p>
<p>为了避免页面的随机IO，可以实现将redo文件的所有redo文件按照<strong>spaceID和pageNumber</strong><br>为键，然后组织成一张哈希表，然后遍历这张hash表就可以一次性完成对一个页面的恢复。<br>当然，同一个页面的redo日志必须安装时间顺序排序。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/09/Raft/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SongyangJi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JsyBlog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | JsyBlog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/09/Raft/" class="post-title-link" itemprop="url">Raft</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-09 13:58:09" itemprop="dateCreated datePublished" datetime="2021-12-09T13:58:09+08:00">2021-12-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-29 04:13:13" itemprop="dateModified" datetime="2022-03-29T04:13:13+08:00">2022-03-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>参考</p>
<p><a target="_blank" rel="noopener" href="https://zinglix.xyz/2020/06/25/raft/">https://zinglix.xyz/2020/06/25/raft/</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/ZmRS9Gjh9P-4lPLZ9jWk_A">https://mp.weixin.qq.com/s/ZmRS9Gjh9P-4lPLZ9jWk_A</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/09/Redis-Info%E5%91%BD%E4%BB%A4%E8%BE%93%E5%87%BA%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SongyangJi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JsyBlog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | JsyBlog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/09/Redis-Info%E5%91%BD%E4%BB%A4%E8%BE%93%E5%87%BA%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">Redis-Info命令输出详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-12-09 13:34:10 / 修改时间：13:59:00" itemprop="dateCreated datePublished" datetime="2021-12-09T13:34:10+08:00">2021-12-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Redis-Info-输出详解"><a href="#Redis-Info-输出详解" class="headerlink" title="Redis Info 输出详解"></a>Redis Info 输出详解</h1><p>Redis 的 info 命令是使用频率很高的一个命令，它主要是显示 Redis 服务器当前状态，故我们经常用于监控Redis 服务器。我收集了一些参数解释，方便随时查询</p>
<h1 id="Info命令简介"><a href="#Info命令简介" class="headerlink" title="Info命令简介"></a>Info命令简介</h1><p>在使用Redis的过程中，可能会遇到很多问题，需要我们去诊断、去观察Redis的健康情况。Redis给我们提供了的 <code>info</code> 命令，可以让我们近距离的接触它，观察它各方面的信息、运行状况。下面让我们看看 <code>info</code> 命令都给我们带来了哪些信息。</p>
<p>命令格式：<code>INFO [section]</code></p>
<p>Info 指令显示的信息分为 9 大块，每块都有很多参数。我们也可以通过给定可选的参数 section ，可以让命令只返回某一部分的信息。这 9 块分别是:</p>
<ul>
<li><code>server</code> 部分记录了 Redis 服务器的信息</li>
<li><code>clients</code> 部分记录了已连接客户端的信息</li>
<li><code>memory</code> 部分记录了服务器的内存信息</li>
<li><code>persistence</code> 部分记录了跟 RDB 持久化和 AOF 持久化有关的信息</li>
<li><code>stats</code> 部分记录了一般统计信息</li>
<li><code>replication</code> 部分记录了主&#x2F;从复制的相关信息</li>
<li><code>cpu</code> 部分记录了 CPU 的计算量统计信息</li>
<li><code>cluster</code> 部分记录了和集群有关的信息</li>
<li><code>keyspace</code> 部分记录了数据库相关的统计信息</li>
</ul>
<blockquote>
<p>不同版本的 Redis 可能对返回的一些域进行了增加或删减。 因此，一个健壮的客户端程序在对 INFO [section] 命令的输出进行分析时，应该能够跳过不认识的域，并且妥善地处理丢失不见的域。</p>
</blockquote>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h2><table>
<thead>
<tr>
<th>参数名称</th>
<th>参数含义</th>
</tr>
</thead>
<tbody><tr>
<td>redis_version</td>
<td>Redis 的服务器版本</td>
</tr>
<tr>
<td>redis_git_sha1</td>
<td>Redis 的服务器版本</td>
</tr>
<tr>
<td>redis_git_dirty</td>
<td>Git dirty flag</td>
</tr>
<tr>
<td>redis_build_id</td>
<td></td>
</tr>
<tr>
<td>redis_mode</td>
<td>运行模式：单机（集群）</td>
</tr>
<tr>
<td>os</td>
<td>Redis 服务器的宿主操作系统</td>
</tr>
<tr>
<td>arch_bits</td>
<td>架构（32 或 64 位）</td>
</tr>
<tr>
<td>multiplexing_api</td>
<td>Redis 所使用的事件处理机制，如epoll</td>
</tr>
<tr>
<td>gcc_version</td>
<td>编译 Redis 时所使用的 GCC 版本</td>
</tr>
<tr>
<td>process_id</td>
<td>服务器进程的 PID</td>
</tr>
<tr>
<td>run_id</td>
<td>Redis 服务器的随机标识符（用于 Sentinel 和集群）</td>
</tr>
<tr>
<td>tcp_port</td>
<td>TCP&#x2F;IP 监听端口</td>
</tr>
<tr>
<td>uptime_in_seconds</td>
<td>自 Redis 服务器启动以来，经过的秒数</td>
</tr>
<tr>
<td>uptime_in_days</td>
<td>自 Redis 服务器启动以来，经过的天数</td>
</tr>
<tr>
<td>hz</td>
<td>redis内部调度（进行关闭timeout的客户端，删除过期key等等）频率，程序规定serverCron每秒运行10次。</td>
</tr>
<tr>
<td>lru_clock</td>
<td>以分钟为单位进行自增的时钟，用于 LRU 管理</td>
</tr>
<tr>
<td>executable</td>
<td>启动脚本路径</td>
</tr>
<tr>
<td>config_file</td>
<td>启动时指定的配置文件（redis.conf）路径</td>
</tr>
</tbody></table>
<h2 id="Clients"><a href="#Clients" class="headerlink" title="Clients"></a>Clients</h2><table>
<thead>
<tr>
<th>参数名称</th>
<th>参数含义</th>
</tr>
</thead>
<tbody><tr>
<td>connected_clients</td>
<td>已连接客户端的数量（不包括通过从属服务器连接的客户端）</td>
</tr>
<tr>
<td>client_longest_output_list</td>
<td>当前连接的客户端当中，最长的输出列表</td>
</tr>
<tr>
<td>client_longest_input_buf</td>
<td>当前连接的客户端当中，最大输入缓存</td>
</tr>
<tr>
<td>blocked_clients</td>
<td>正在等待阻塞命令（BLPOP、BRPOP、BRPOPLPUSH）的客户端的数量</td>
</tr>
</tbody></table>
<h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><table>
<thead>
<tr>
<th>参数名称</th>
<th>参数含义</th>
</tr>
</thead>
<tbody><tr>
<td>used_memory</td>
<td>使用内存（B）</td>
</tr>
<tr>
<td>used_memory_human</td>
<td>人类可读的格式的使用内存（MB）</td>
</tr>
<tr>
<td>used_memory_rss</td>
<td>操作系统角度，返回redis已分配的内存（即常驻内存），这个值和top、ps命令的输出一致</td>
</tr>
<tr>
<td>used_memory_rss_human</td>
<td>如上</td>
</tr>
<tr>
<td>used_memory_peak</td>
<td>内存使用的峰值</td>
</tr>
<tr>
<td>used_memory_peak_human</td>
<td>如上</td>
</tr>
<tr>
<td>total_system_memory</td>
<td>整个系统内存</td>
</tr>
<tr>
<td>total_system_memory_human</td>
<td>如上</td>
</tr>
<tr>
<td>used_memory_lua</td>
<td>Lua脚本存储占用的内存</td>
</tr>
<tr>
<td>used_memory_lua_human</td>
<td>如上</td>
</tr>
<tr>
<td>maxmemory</td>
<td>Redis实例的最大内存配置</td>
</tr>
<tr>
<td>maxmemory_human</td>
<td>如上</td>
</tr>
<tr>
<td>maxmemory_policy</td>
<td>当达到maxmemory时的淘汰策略</td>
</tr>
<tr>
<td>mem_fragmentation_ratio</td>
<td>used_memory_rss&#x2F;used_memory的值。一般情况下，used_memory_rss略高于used_memory，当内存碎片较多时，则mem_fragmentation_ratio会较大，可以反映内存碎片是否很多</td>
</tr>
<tr>
<td>mem_allocator</td>
<td>内存分配器。可以是libc 、 jemalloc 或者 tcmalloc</td>
</tr>
</tbody></table>
<p>在理想情况下， <code>used_memory_rss</code> 的值应该只比 <code>used_memory</code> 稍微高一点儿。 当 <code>rss &gt; used</code> ，且两者的值相差较大时，表示存在（内部或外部的）内存碎片。 内存碎片的比率可以通过 <code>mem_fragmentation_ratio</code> 的值看出。 当 <code>used &gt; rss</code> 时，表示 Redis 的部分内存被操作系统换出到交换空间（swap）了，在这种情况下，操作可能会产生明显的延迟，需要重点关注。即：<code>mem_fragmentation_ratio</code> 小于1时</p>
<h2 id="Persistence"><a href="#Persistence" class="headerlink" title="Persistence"></a>Persistence</h2><table>
<thead>
<tr>
<th>参数名称</th>
<th>参数含义</th>
</tr>
</thead>
<tbody><tr>
<td>loading</td>
<td>服务器是否正在载入持久化文件</td>
</tr>
<tr>
<td>rdb_changes_since_last_save</td>
<td>离最近一次成功生成rdb文件，写入命令的个数</td>
</tr>
<tr>
<td>rdb_bgsave_in_progress</td>
<td>服务器是否正在创建rdb文件</td>
</tr>
<tr>
<td>rdb_last_save_time</td>
<td>最近一次成功rdb文件的时间戳</td>
</tr>
<tr>
<td>rdb_last_bgsave_status</td>
<td>最近一次成功rdb文件的状态</td>
</tr>
<tr>
<td>rdb_last_bgsave_time_sec</td>
<td>最近一次成功rdb文件的耗时</td>
</tr>
<tr>
<td>rdb_current_bgsave_time_sec</td>
<td>若当前正在创建rdb文件，指当前的创建操作已经耗费的时间</td>
</tr>
<tr>
<td>aof_enabled</td>
<td>aof是否开启</td>
</tr>
<tr>
<td>aof_rewrite_in_progress</td>
<td>aof的rewrite操作是否在进行中</td>
</tr>
<tr>
<td>aof_rewrite_scheduled</td>
<td>rewrite任务计划，当客户端发送bgrewriteaof指令，如果当前rewrite子进程正在执行，那么将客户端请求的bgrewriteaof变为计划任务，待aof子进程结束后执行rewrite</td>
</tr>
<tr>
<td>aof_last_rewrite_time_sec</td>
<td>最近一次aof rewrite耗费时长</td>
</tr>
<tr>
<td>aof_current_rewrite_time_sec</td>
<td>若当前正在执行aof rewrite，指当前的已经耗费的时间</td>
</tr>
<tr>
<td>aof_last_bgrewrite_status</td>
<td>最近一次aof bgrewrite的状态</td>
</tr>
<tr>
<td>aof_last_write_status</td>
<td>最近一次aof写入状态</td>
</tr>
<tr>
<td>开启 aof 后增加的一些info信息</td>
<td></td>
</tr>
<tr>
<td>aof_current_size</td>
<td>aof文件当前大小</td>
</tr>
<tr>
<td>aof_base_size</td>
<td>服务器启动时或者最近一次AOF重写后，文件的大小</td>
</tr>
<tr>
<td>aof_pending_rewrite</td>
<td>同上面的aof_rewrite_scheduled</td>
</tr>
<tr>
<td>aof_buffer_length</td>
<td>aof 缓冲区的大小</td>
</tr>
<tr>
<td>aof_rewrite_buffer_length</td>
<td>aof 重写缓冲区的大小</td>
</tr>
<tr>
<td>aof_pending_bio_fsync</td>
<td>后台IO队列中，等待fsync任务的个数</td>
</tr>
<tr>
<td>aof_delayed_fsync</td>
<td>被延迟的 fsync 调用数量</td>
</tr>
</tbody></table>
<h2 id="Stats"><a href="#Stats" class="headerlink" title="Stats"></a>Stats</h2><table>
<thead>
<tr>
<th>参数名称</th>
<th>参数含义</th>
</tr>
</thead>
<tbody><tr>
<td>total_connections_received</td>
<td>自启动起连接过的总数。如果连接过多，说明短连接严重或连接池使用有问题，需调研代码的连接设置</td>
</tr>
<tr>
<td>total_commands_processed</td>
<td>自启动起运行命令的总数</td>
</tr>
<tr>
<td>instantaneous_ops_per_sec</td>
<td>每秒执行的命令数，相当于QPS</td>
</tr>
<tr>
<td>total_net_input_bytes</td>
<td>网络入口流量字节数</td>
</tr>
<tr>
<td>total_net_output_bytes</td>
<td>网络出口流量字节数</td>
</tr>
<tr>
<td>instantaneous_input_kbps</td>
<td>网络入口kps</td>
</tr>
<tr>
<td>instantaneous_output_kbps</td>
<td>网络出口kps</td>
</tr>
<tr>
<td>rejected_connections</td>
<td>拒绝的连接个数，由于maxclients限制，拒绝新连接的个数</td>
</tr>
<tr>
<td>sync_full</td>
<td>主从完全同步成功次数</td>
</tr>
<tr>
<td>sync_partial_ok</td>
<td>主从部分同步成功次数</td>
</tr>
<tr>
<td>sync_partial_err</td>
<td>主从部分同步失败次数</td>
</tr>
<tr>
<td>expired_keys</td>
<td>自启动起过期的key的总数</td>
</tr>
<tr>
<td>evicted_keys</td>
<td>使用内存大于maxmemory后，淘汰的key的总数</td>
</tr>
<tr>
<td>keyspace_hits</td>
<td>在main dictionary字典中成功查到的key个数</td>
</tr>
<tr>
<td>keyspace_misses</td>
<td>同上，未命中的key的个数</td>
</tr>
<tr>
<td>pubsub_channels</td>
<td>发布&#x2F;订阅频道数</td>
</tr>
<tr>
<td>pubsub_patterns</td>
<td>发布&#x2F;订阅模式数</td>
</tr>
<tr>
<td>latest_fork_usec</td>
<td>上次的fork操作使用的时间（单位ms）</td>
</tr>
<tr>
<td>migrate_cached_sockets</td>
<td>是否已经缓存了到该地址的连接</td>
</tr>
<tr>
<td>slave_expires_tracked_keys</td>
<td>从实例到期key数量</td>
</tr>
<tr>
<td>active_defrag_hits</td>
<td>主动碎片整理命中次数</td>
</tr>
<tr>
<td>active_defrag_misses</td>
<td>主动碎片整理未命中次数</td>
</tr>
<tr>
<td>active_defrag_key_hits</td>
<td>主动碎片整理key命中次数</td>
</tr>
<tr>
<td>active_defrag_key_misses</td>
<td>主动碎片整理key未命中次数</td>
</tr>
</tbody></table>
<h2 id="Replication"><a href="#Replication" class="headerlink" title="Replication"></a>Replication</h2><table>
<thead>
<tr>
<th>参数名称</th>
<th>参数含义</th>
</tr>
</thead>
<tbody><tr>
<td>role</td>
<td>当前实例的角色master还是slave</td>
</tr>
<tr>
<td>connected_slaves:</td>
<td>slave的数量</td>
</tr>
<tr>
<td>master_replid</td>
<td>主实例启动随机字符串</td>
</tr>
<tr>
<td>master_replid2</td>
<td>主实例启动随机字符串2</td>
</tr>
<tr>
<td>slave0</td>
<td>slave机器的信息、状态</td>
</tr>
<tr>
<td>master_repl_offset</td>
<td>主从同步偏移量,此值如果和上面的offset相同说明主从一致没延迟，与master_replid可被用来标识主实例复制流中的位置。</td>
</tr>
<tr>
<td>second_repl_offset</td>
<td>主从同步偏移量2,此值如果和上面的offset相同说明主从一致没延迟</td>
</tr>
<tr>
<td>repl_backlog_active</td>
<td>复制缓冲区是否开启</td>
</tr>
<tr>
<td>repl_backlog_size</td>
<td>复制缓冲区大小</td>
</tr>
<tr>
<td>repl_backlog_first_byte_offset</td>
<td>复制缓冲区里偏移量的大小</td>
</tr>
<tr>
<td>repl_backlog_histlen</td>
<td>此值等于 master_repl_offset - repl_backlog_first_byte_offset,该值不会超过repl_backlog_size的大小</td>
</tr>
</tbody></table>
<h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><table>
<thead>
<tr>
<th>参数名称</th>
<th>参数含义</th>
</tr>
</thead>
<tbody><tr>
<td>used_cpu_sys</td>
<td>Redis 服务器耗费的系统 CPU</td>
</tr>
<tr>
<td>used_cpu_user</td>
<td>Redis 服务器耗费的用户 CPU</td>
</tr>
<tr>
<td>used_cpu_sys_children</td>
<td>后台进程耗费的系统 CPU</td>
</tr>
<tr>
<td>used_cpu_user_children</td>
<td>后台进程耗费的用户 CPU</td>
</tr>
</tbody></table>
<h2 id="Keyspace"><a href="#Keyspace" class="headerlink" title="Keyspace"></a>Keyspace</h2><table>
<thead>
<tr>
<th>参数名称</th>
<th>参数含义</th>
</tr>
</thead>
<tbody><tr>
<td>dbXXX:keys&#x3D;XXX,expires&#x3D;XXX</td>
<td>各个数据库（0-15）的 key 的数量，带有生存期的 key 的数量，平均存活时间</td>
</tr>
</tbody></table>
<p><strong>实例</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Server</span></span><br><span class="line">redis_version:3.2.3					 # Redis 的版本</span><br><span class="line">redis_git_sha1:00000000				 # Redis 的版本</span><br><span class="line">redis_git_dirty:0</span><br><span class="line">redis_build_id:9e93d0c7997bcfef</span><br><span class="line">redis_mode:standalone				 # 运行模式：单机（集群）</span><br><span class="line">os:Linux 2.6.32-431.el6.x86_64 x86_64 # 操作系统</span><br><span class="line">arch_bits:64						  # 操作系统位数</span><br><span class="line">multiplexing_api:epoll				 # redis所使用的事件处理机制</span><br><span class="line">gcc_version:4.4.7					 # gcc版本号</span><br><span class="line">process_id:1606						 # 当前 Redis 服务器进程id</span><br><span class="line">run_id:17e79b1966f1f891eff203a8e496151ee8a3a7a7</span><br><span class="line">tcp_port:7001						 # 端口号</span><br><span class="line">uptime_in_seconds:4360189			 # 运行时间(秒)</span><br><span class="line">uptime_in_days:50					 # 运行时间(天)</span><br><span class="line">hz:10								 # redis内部调度（进行关闭timeout的客户端，删除过期key等等）频率，程序规定serverCron每秒运行10次。</span><br><span class="line">lru_clock:5070330					 # Redis的逻辑时钟</span><br><span class="line">executable:/usr/local/bin/redis-server			# 启动脚本路径</span><br><span class="line">config_file:/opt/redis3/conf/redis_7001.conf	# 启动指定的配置文件路径</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Clients</span></span><br><span class="line">connected_clients:660				 # 连接的客户端数量</span><br><span class="line">client_longest_output_list:0		 # 当前连接的客户端当中，最长的输出列表</span><br><span class="line">client_biggest_input_buf:0			 # 当前连接的客户端当中，最大输入缓存</span><br><span class="line">blocked_clients:0					 # 阻塞的客户端数量</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Memory</span></span><br><span class="line">used_memory:945408832				# 使用内存（B）</span><br><span class="line">used_memory_human:901.61M			# 使用内存（MB）	</span><br><span class="line">used_memory_rss:1148919808			# 系统给redis分配的内存（即常驻内存），这个值和top命令的输出一致</span><br><span class="line">used_memory_rss_human:1.07G</span><br><span class="line">used_memory_peak:1162079480			# 内存使用的峰值</span><br><span class="line">used_memory_peak_human:1.08G		</span><br><span class="line">total_system_memory:6136483840		# 整个系统内存</span><br><span class="line">total_system_memory_human:5.72G</span><br><span class="line">used_memory_lua:122880				# Lua脚本存储占用的内存</span><br><span class="line">used_memory_lua_human:120.00K		</span><br><span class="line">maxmemory:2147483648				# Redis实例的最大内存配置</span><br><span class="line">maxmemory_human:2.00G</span><br><span class="line">maxmemory_policy:allkeys-lru		# 当达到maxmemory时的淘汰策略</span><br><span class="line">mem_fragmentation_ratio:1.22		# used_memory_rss/used_memory的比例。一般情况下，used_memory_rss略高于used_memory，当内存碎片较多时，则mem_fragmentation_ratio会较大，可以反映内存碎片是否很多</span><br><span class="line">mem_allocator:jemalloc-4.0.3		# 内存分配器</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Persistence</span>	</span><br><span class="line">loading:0								  # 服务器是否正在载入持久化文件</span><br><span class="line">rdb_changes_since_last_save:82423954	  #	离最近一次成功生成rdb文件，写入命令的个数                      </span><br><span class="line">rdb_bgsave_in_progress:0		          # 服务器是否正在创建rdb文件           </span><br><span class="line">rdb_last_save_time:1560991229		      # 最近一次成功rdb文件的时间戳               </span><br><span class="line">rdb_last_bgsave_status:ok		          # 最近一次成功rdb文件的状态           </span><br><span class="line">rdb_last_bgsave_time_sec:-1		          # 最近一次成功rdb文件的耗时            </span><br><span class="line">rdb_current_bgsave_time_sec:-1		      # 若当前正在创建rdb文件，指当前的创建操作已经耗费的时间                </span><br><span class="line">aof_enabled:0		                      # aof是否开启</span><br><span class="line">aof_rewrite_in_progress:0		          # aof的rewrite操作是否在进行中            </span><br><span class="line">aof_rewrite_scheduled:0		              # rewrite任务计划，当客户端发送bgrewriteaof指令，如果当前rewrite子进程正在执行，那么将客户端请求的bgrewriteaof变为计划任务，待aof子进程结束后执行rewrite        </span><br><span class="line">aof_last_rewrite_time_sec:-1		      # 最近一次aof rewrite耗费时长              </span><br><span class="line">aof_current_rewrite_time_sec:-1		      # 若当前正在执行aof rewrite，指当前的已经耗费的时间                </span><br><span class="line">aof_last_bgrewrite_status:ok		      # 最近一次aof bgrewrite的状态         </span><br><span class="line">aof_last_write_status:ok		          # 最近一次aof写入状态  </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启aof后增加的一些info信息</span></span><br><span class="line">-----------------------------  </span><br><span class="line">aof_current_size:0                 # aof当前大小</span><br><span class="line">aof_base_size:0                    # aof上次启动或rewrite的大小</span><br><span class="line">aof_pending_rewrite:0              # 同上面的aof_rewrite_scheduled</span><br><span class="line">aof_buffer_length:0                # aof buffer的大小</span><br><span class="line">aof_rewrite_buffer_length:0        # aof rewrite buffer的大小</span><br><span class="line">aof_pending_bio_fsync:0            # 后台IO队列中等待fsync任务的个数</span><br><span class="line">aof_delayed_fsync:0                # 延迟的fsync计数器 </span><br><span class="line">-----------------------------           </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Stats</span></span><br><span class="line">total_connections_received:15815		# 自启动起连接过的总数。如果连接过多，说明短连接严重或连接池使用有问题，需调研代码的连接设置</span><br><span class="line">total_commands_processed:502953838      # 自启动起运行命令的总数</span><br><span class="line">instantaneous_ops_per_sec:7             # 每秒执行的命令数，相当于QPS</span><br><span class="line">total_net_input_bytes:532510481889      # 网络入口流量字节数</span><br><span class="line">total_net_output_bytes:1571444057940    # 网络出口流量字节数</span><br><span class="line">instantaneous_input_kbps:0.37           # 网络入口kps</span><br><span class="line">instantaneous_output_kbps:0.59          # 网络出口kps</span><br><span class="line">rejected_connections:0                  # 拒绝的连接个数，由于maxclients限制，拒绝新连接的个数</span><br><span class="line">sync_full:1                             # 主从完全同步成功次数</span><br><span class="line">sync_partial_ok:0                       # 主从部分同步成功次数</span><br><span class="line">sync_partial_err:0                      # 主从部分同步失败次数</span><br><span class="line">expired_keys:4404930                    # 自启动起过期的key的总数</span><br><span class="line">evicted_keys:0                          # 使用内存大于maxmemory后，淘汰的key的总数</span><br><span class="line">keyspace_hits:337104556                 # 在main dictionary字典中成功查到的key个数</span><br><span class="line">keyspace_misses:22865229                # 同上，未命中的key的个数</span><br><span class="line">pubsub_channels:1                       # 发布/订阅频道数</span><br><span class="line">pubsub_patterns:0                       # 发布/订阅模式数</span><br><span class="line">latest_fork_usec:707                    # 上次的fork操作使用的时间（单位ms）</span><br><span class="line">migrate_cached_sockets:0                # 是否已经缓存了到该地址的连接</span><br><span class="line">slave_expires_tracked_keys:0			# 从实例到期key数量</span><br><span class="line">active_defrag_hits:0                    # 主动碎片整理命中次数</span><br><span class="line">active_defrag_misses:0                  # 主动碎片整理未命中次数</span><br><span class="line">active_defrag_key_hits:0                # 主动碎片整理key命中次数</span><br><span class="line">active_defrag_key_misses:0              # 主动碎片整理key未命中次数</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Replication</span></span><br><span class="line">role:master							  # 当前实例的角色master还是slave</span><br><span class="line">connected_slaves:1					  # slave的数量</span><br><span class="line">master_replid:8f81c045a2cb00f16a7fc5c90a95e02127413bcc		# 主实例启动随机字符串</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000     # 主实例启动随机字符串2</span><br><span class="line">slave0:ip=172.17.12.251,port=7002,state=online,offset=506247209326,lag=1	# slave机器的信息、状态</span><br><span class="line">master_repl_offset:506247209478		  # 主从同步偏移量,此值如果和上面的offset相同说明主从一致没延迟，与master_replid可被用来标识主实例复制流中的位置。</span><br><span class="line">second_repl_offset					  # 主从同步偏移量2,此值如果和上面的offset相同说明主从一致没延迟</span><br><span class="line">repl_backlog_active:1				  # 复制缓冲区是否开启</span><br><span class="line">repl_backlog_size:157286400			  # 复制缓冲区大小</span><br><span class="line">repl_backlog_first_byte_offset:506089923079		# 复制缓冲区里偏移量的大小</span><br><span class="line">repl_backlog_histlen:157286400		  # 此值等于 master_repl_offset - repl_backlog_first_byte_offset,该值不会超过repl_backlog_size的大小</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CPU</span></span><br><span class="line">used_cpu_sys:6834.06				  # 将所有redis主进程在核心态所占用的CPU时求和累计起来</span><br><span class="line">used_cpu_user:8282.10				  # 将所有redis主进程在用户态所占用的CPU时求和累计起来</span><br><span class="line">used_cpu_sys_children:0.11			  # 后台进程的核心态cpu使用率</span><br><span class="line">used_cpu_user_children:0.91           # 后台进程的用户态cpu使用率</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Cluster</span></span><br><span class="line">cluster_enabled:0		# 实例是否启用集群模式</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Keyspace		<span class="comment"># 各个数据库（0-15）的 key 的数量，带有生存期的 key 的数量，平均存活时间</span></span></span><br><span class="line">db0:keys=267906,expires=109608,avg_ttl=3426011859194</span><br><span class="line">db1:keys=182,expires=179,avg_ttl=503527626</span><br><span class="line">db8:keys=6,expires=0,avg_ttl=0</span><br><span class="line">db15:keys=2,expires=0,avg_ttl=0</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/09/Redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SongyangJi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JsyBlog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | JsyBlog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/09/Redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/" class="post-title-link" itemprop="url">Redis-主从复制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-12-09 13:19:34 / 修改时间：14:56:32" itemprop="dateCreated datePublished" datetime="2021-12-09T13:19:34+08:00">2021-12-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。</p>
<p>默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。</p>
<p><strong>主从复制的作用</strong></p>
<p>主从复制的作用主要包括：</p>
<ol>
<li><p><strong>数据备份</strong>：主从复制实现了<strong>数据的热备份</strong>，是持久化之外的一种数据冗余方式。</p>
</li>
<li><p>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</p>
</li>
<li><p><strong>负载均衡</strong>：在主从复制的基础上，配合<strong>读写分离</strong>，可以<strong>由主节点提供写服务，由从节点提供读服务</strong>（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</p>
<p>默认情况下，从库只能读，不可写。</p>
</li>
<li><p>高可用基石：除了上述作用以外，<strong>主从复制还是哨兵和集群能够实施的基础</strong>，因此说主从复制是Redis高可用的基础。</p>
</li>
</ol>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ol>
<li><strong>建立复制</strong></li>
</ol>
<p>需要注意，主从复制的开启，完全是在从节点发起的；不需要我们在主节点做任何事情。</p>
<p>从节点开启主从复制，有3种方式：</p>
<p>（1）配置文件</p>
<p>在从服务器的配置文件中加入：slaveof masterip masterport</p>
<p>（2）启动命令</p>
<p>redis-server启动命令后加入 –slaveof masterip masterport</p>
<p>（3）客户端命令</p>
<p>Redis服务器启动后，直接通过客户端执行命令：slaveof masterip masterport，则该Redis实例成为从节点。</p>
<p>上述3种方式是等效的，下面以客户端命令的方式为例，看一下当执行了slaveof后，Redis主节点和从节点的变化。</p>
<ol start="2">
<li><strong>改变主库</strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof masterip masterport</span><br></pre></td></tr></table></figure>



<ol start="3">
<li><strong>停止复制</strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof no one</span><br></pre></td></tr></table></figure>










<h2 id="上手实战"><a href="#上手实战" class="headerlink" title="上手实战"></a>上手实战</h2><p><strong>启动一主二从的集群架构</strong></p>
<p>分别在3个shell窗口中</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-server</span><br><span class="line">redis-server --port 6380 --slaveof 127.0.0.1 6379</span><br><span class="line">redis-server --port 6381 --slaveof 127.0.0.1 6379</span><br></pre></td></tr></table></figure>

<p>当然这里也可以在配置文件里修改然后指定配置文件启动。</p>
<p><strong>使用客户端连接</strong></p>
<p>分别在3个shell窗口中</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 6379</span><br><span class="line">redis-cli -p 6380</span><br><span class="line">redis-cli -p 6381</span><br></pre></td></tr></table></figure>





<p>使用<code>info replication</code>检查复制状态：</p>
<p><strong>主库状态</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Replication</span></span><br><span class="line">role:master # 角色：主库</span><br><span class="line">connected_slaves:2 # 从库数量</span><br><span class="line">slave0:ip=127.0.0.1,port=6380,state=online,offset=224,lag=0 # ip、端口、状态、复制偏移量</span><br><span class="line">slave1:ip=127.0.0.1,port=6381,state=online,offset=224,lag=1 </span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:4b6a1f35a960797cfce477656751eb3add4b320a</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:224</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1  # 复制缓冲区</span><br><span class="line">repl_backlog_size:1048576 # 复制缓冲区大小（默认是1MB）</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:224</span><br></pre></td></tr></table></figure>





<p><strong>从库状态</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Replication</span></span><br><span class="line">role:slave # 角色：从库</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:3</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:238 # 从库偏移量</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1 # 从库只读（默认）</span><br><span class="line">replica_announced:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:4b6a1f35a960797cfce477656751eb3add4b320a</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:238 # 主库 偏移量 (二者相同表示复制没有延迟)</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:238</span><br></pre></td></tr></table></figure>



<h2 id="主从复制的步骤"><a href="#主从复制的步骤" class="headerlink" title="主从复制的步骤"></a>主从复制的步骤</h2><h3 id="连接建立阶段"><a href="#连接建立阶段" class="headerlink" title="连接建立阶段"></a>连接建立阶段</h3><p>该阶段的主要作用是在主从节点之间建立连接，为数据同步做好准备。</p>
<ol>
<li><p><strong>保存主节点信息</strong><br>从节点服务器内部维护了两个字段，即masterhost和masterport字段，用于存储主节点的ip和port信息。需要注意的是，slaveof是异步命令，从节点完成主节点ip和port的保存后，向发送slaveof命令的客户端直接返回OK，实际的复制操作在这之后才开始进行。</p>
</li>
<li><p><strong>建立socket连接</strong><br>从节点每秒1次调用复制定时函数replicationCron()，如果发现了有主节点可以连接，便会根据主节点的ip和port，创建socket连接。如果连接成功，则：<strong>从节点为该socket建立一个专门处理复制工作的文件事件处理器，负责后续的复制工作，如接收RDB文件、接收命令传播等</strong>。<strong>主节点接收到从节点的socket连接后（即accept之后），为该socket创建相应的客户端状态，并将从节点看做是连接到主节点的一个客户端，后面的步骤会以从节点向主节点发送命令请求的形式来进行</strong>。</p>
</li>
<li><p><strong>发送ping命令检测</strong><br>从节点成为主节点的客户端之后，发送ping命令进行首次请求，<strong>目的是检查socket连接是否可用，以及主节点当前是否能够处理请求</strong>。从节点发送ping命令后，可能出现3种情况：</p>
<p>（1）返回pong：说明socket连接正常，且主节点当前可以处理请求，复制过程继续。</p>
<p>（2）超时：一定时间后从节点仍未收到主节点的回复，说明socket连接不可用，则从节点断开socket连接，并重连。</p>
<p>（3）返回pong以外的结果：如果主节点返回其他结果，如正在处理超时运行的脚本，说明主节点当前无法处理命令，则从节点断开socket连接，并重连。</p>
</li>
</ol>
<h3 id="数据同步阶段"><a href="#数据同步阶段" class="headerlink" title="数据同步阶段"></a>数据同步阶段</h3><p>主从节点之间的连接建立以后，便可以开始进行数据同步，该阶段可以理解为从节点数据的初始化。具体执行的方式是：从节点向主节点发送<code>psync</code>命令（Redis2.8以前是<code>sync</code>命令），开始同步。</p>
<p><strong>数据同步阶段是主从复制最核心的阶段</strong>，根据主从节点当前状态的不同，可以分为<strong>全量复制</strong>和<strong>增量复制</strong>，下面会有一章专门讲解这两种复制方式以及psync命令的执行过程，这里不再详述。</p>
<h3 id="命令传播阶段"><a href="#命令传播阶段" class="headerlink" title="命令传播阶段"></a>命令传播阶段</h3><p>数据同步阶段完成后，主从节点进入命令传播阶段；在这个阶段主节点将自己执行的写命令发送给从节点，从节点接收命令并执行，从而保证主从节点数据的一致性。</p>
<p>在命令传播阶段，除了发送写命令，主从节点还维持着<strong>心跳机制：PING和REPLCONF ACK</strong>。由于心跳机制的原理涉及增量复制，因此将在介绍了部分复制的相关内容后单独介绍该心跳机制。</p>
<p><strong>延迟与不一致</strong></p>
<p>需要注意的是，命令传播是异步的过程，即主节点发送写命令后并不会等待从节点的回复；因此实际上主从节点之间很难保持实时的一致性，延迟在所难免。</p>
<p>数据不一致的程度，与<strong>主从节点之间的网络状况</strong>、<strong>主节点写命令的执行频率</strong>、以及<strong>主节点中的repl-disable-tcp-nodelay配置</strong>等有关。</p>
<p><code>repl-disable-tcp-nodelay no</code>：该配置作用于命令传播阶段，控制主节点是否禁止与从节点的TCP_NODELAY；默认no，即不禁止TCP_NODELAY。当设置为yes时，TCP会对包进行合并从而减少带宽，但是发送的频率会降低，从节点数据延迟增加，一致性变差；具体发送频率与Linux内核的配置有关，默认配置为40ms。当设置为no时，TCP会立马将主节点的数据发送给从节点，带宽增加但延迟变小。</p>
<p>一般来说，只有当应用对Redis数据不一致的容忍度较高，且主从节点之间网络状况不好时，才会设置为yes；多数情况使用默认值no。</p>
<h2 id="数据同步阶段（全量复制和部分复制）"><a href="#数据同步阶段（全量复制和部分复制）" class="headerlink" title="数据同步阶段（全量复制和部分复制）"></a>数据同步阶段（全量复制和部分复制）</h2><p>在Redis2.8以前，从节点向主节点发送<code>sync</code>命令请求同步数据，此时的同步方式是全量复制；</p>
<p>在Redis2.8及以后，从节点可以发送<code>psync</code>命令请求同步数据，此时<strong>根据主从节点当前状态的不同</strong>，同步方式可能是全量复制或部分复制。后文介绍以Redis2.8及以后版本为例。</p>
<ol>
<li>全量复制：<strong>用于初次复制或其他无法进行部分复制的情况</strong>，<strong>将主节点中的所有数据都发送给从节点</strong>，是一个非常重量级的操作。</li>
<li>部分复制：<strong>用于网络中断等情况后的复制</strong>，<strong>只将中断期间主节点执行的写命令发送给从节点</strong>，与全量复制相比更加高效。需要注意的是，<strong>如果网络中断时间过长，导致主节点没有能够完整地保存中断期间执行的写命令，则无法进行部分复制，仍使用全量复制</strong>。</li>
</ol>
<h3 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h3><p>Redis通过<code>psync</code>命令进行全量复制的过程如下：</p>
<p>（1）从节点判断无法进行部分复制，向主节点发送全量复制的请求；或从节点发送部分复制的请求，但主节点判断无法进行部分复制；具体判断过程需要在讲述了部分复制原理后再介绍。</p>
<p>（2）主节点收到全量复制的命令后，执行bgsave，<strong>在后台生成RDB文件</strong>，<strong>并使用一个缓冲区（称为复制缓冲区）记录从现在开始执行的所有写命令。</strong></p>
<p>（3）主节点的bgsave执行完成后，<strong>将RDB文件发送给从节点</strong>；从节点首先清除自己的旧数据，然后载入接收的RDB文件，将数据库状态更新至主节点执行bgsave时的数据库状态。</p>
<p>（4）主节点<strong>将前述复制缓冲区中的所有写命令发送给从节点</strong>，从节点执行这些写命令，将数据库状态更新至主节点的最新状态</p>
<p>（5）如果<strong>从节点开启了AOF，则会触发bgrewriteaof的执行</strong>，从而保证AOF文件更新至主节点的最新状态。</p>
<p>通过全量复制的过程可以看出，全量复制是非常重型的操作：</p>
<p>（1）主节点通过bgsave命令fork子进程进行RDB持久化，该过程是非常消耗CPU、内存(页表复制)、硬盘IO的；</p>
<p>（2）主节点通过网络将RDB文件发送给从节点，对主从节点的带宽都会带来很大的消耗；</p>
<p>（3）<strong>从节点清空老数据、载入新RDB文件的过程是阻塞的</strong>，无法响应客户端的命令；如果从节点执行bgrewriteaof，也会带来额外的消耗。</p>
<blockquote>
<p>可以使用无硬盘复制，也就是说在复制初始化阶段，主节点不会把RDB写到磁盘上之后再一次性发给客户端，而是通过网络直接发个从节点。</p>
</blockquote>
<h3 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h3><p>由于全量复制在主节点数据量较大时效率太低，因此Redis2.8开始提供部分复制，用于处理网络中断时的数据同步。</p>
<blockquote>
<p>虽然不同版本的redis的复制有差异，不过前后兼容。</p>
</blockquote>
<p>部分复制的实现，依赖于三个重要的概念：</p>
<p>（1）<strong>复制偏移量</strong></p>
<p><strong>主节点和从节点分别维护一个复制偏移量（offset）</strong>，代表的是<strong>主节点向从节点传递的字节数</strong>；主节点每次向从节点传播N个字节数据时，主节点的offset增加N；从节点每次收到主节点传来的N个字节数据时，从节点的offset增加N。</p>
<p><strong>复制偏移量offset用于判断主从节点的数据库状态是否一致</strong>：如果二者offset相同，则一致；如果offset不同，则不一致，此时可以根据两个offset找出从节点缺少的那部分数据。</p>
<p>例如，如果主节点的offset是1000，而从节点的offset是500，那么部分复制就需要将offset为501-1000的数据传递给从节点。而offset为501-1000的数据存储的位置，就是下面要介绍的复制积压缓冲区。</p>
<p>（2）<strong>复制积压缓冲区</strong></p>
<p><strong>复制积压缓冲区是由主节点维护的、固定长度的、先进先出(FIFO)队列</strong>，默认大小1MB；当主节点开始有从节点时创建，其作用是备份主节点最近发送给从节点的数据。<strong>注意，无论主节点有一个还是多个从节点，都只需要一个复制积压缓冲区</strong>。</p>
<p>在命令传播阶段，<strong>主节点除了将写命令发送给从节点，还会发送一份给复制积压缓冲区，作为写命令的备份</strong>；除了存储写命令，复制积压缓冲区中还存储了其中的每个字节对应的复制偏移量（offset）。由于复制积压缓冲区定长且是先进先出，所以它保存的是主节点最近执行的写命令；<strong>时间较早的写命令会被挤出缓冲区</strong>。</p>
<p>由于该缓冲区长度固定且有限，因此可以备份的写命令也有限，<strong>当主从节点offset的差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制。</strong>反过来说，为了提高网络中断时部分复制执行的概率，可以根据需要增大复制积压缓冲区的大小(通过配置<code>repl-backlog-size</code>)；例如如果网络中断的平均时间是60s，而主节点平均每秒产生的写命令(特定协议格式)所占的字节数为100KB，则复制积压缓冲区的平均需求为6MB，保险起见，可以设置为12MB，来保证绝大多数断线情况都可以使用部分复制。</p>
<p><strong>从节点将自己的消费offset发送给主节点后，主节点根据offset和缓冲区大小决定能否执行部分复制</strong>：</p>
<ul>
<li>如果offset偏移量之后的数据，仍然都在复制积压缓冲区里，则执行部分复制；</li>
<li>如果offset偏移量之后的数据已不在复制积压缓冲区中（数据已被挤出），则执行全量复制。</li>
</ul>
<p>（3）<strong>服务器运行ID(runid)</strong></p>
<p>**每个Redis节点(无论主从)，在启动时都会自动生成一个随机ID(每次启动都不一样)**，由40个随机的十六进制字符组成；runid用来唯一识别一个Redis节点。通过info Server命令，可以查看节点的runid。</p>
<p>主从节点初次复制时，主节点将自己的runid发送给从节点，从节点将这个runid保存起来；</p>
<p><strong>当断线重连时，从节点会将这个runid发送给主节点；主节点根据runid判断能否进行部分复制</strong>：</p>
<ul>
<li>如果从节点保存的runid与主节点现在的runid相同，说明主从节点之前同步过，主节点会继续尝试使用部分复制(到底能不能部分复制还要看offset和复制积压缓冲区的情况)；</li>
<li>如果从节点保存的runid与主节点现在的runid不同，说明从节点在断线前同步的Redis节点并不是当前的主节点，只能进行全量复制。</li>
</ul>
<h2 id="命令传播阶段（心跳机制）"><a href="#命令传播阶段（心跳机制）" class="headerlink" title="命令传播阶段（心跳机制）"></a>命令传播阶段（心跳机制）</h2><h3 id="主-gt-从-PING"><a href="#主-gt-从-PING" class="headerlink" title="主-&gt;从 : PING"></a>主-&gt;从 : PING</h3><p>每隔指定的时间，主节点会向从节点发送<code>PING</code>命令，这个PING命令的作用，主要是为了让从节点进行超时判断。</p>
<p>PING发送的频率由repl-ping-slave-period参数控制，单位是秒，默认值是10s。</p>
<p>关于该PING命令究竟是由主节点发给从节点，还是相反，有一些争议；因为在Redis的官方文档中，对该参数的注释中说明是从节点向主节点发送PING命令。</p>
<h3 id="从-gt-主：REPLCONF-ACK"><a href="#从-gt-主：REPLCONF-ACK" class="headerlink" title="从-&gt;主：REPLCONF ACK"></a>从-&gt;主：REPLCONF ACK</h3><p>在命令传播阶段，从节点会向主节点发送<code>REPLCONF ACK</code>命令，频率是每秒1次；命令格式为：<code>REPLCONF ACK &#123;offset&#125;</code>，其中offset指从节点保存的复制偏移量。REPLCONF ACK命令的作用包括：</p>
<p>（1）<strong>实时监测主从节点网络状态</strong>：<strong>该命令会被主节点用于复制超时的判断</strong>。此外，在主节点中使用info Replication，可以看到其从节点的状态中的lag值，代表的是主节点上次收到该REPLCONF ACK命令的时间间隔，在正常情况下，该值应该是0或1。</p>
<p>（2）<strong>检测命令丢失</strong>：从节点发送了自身的offset，主节点会与自己的offset对比，如果从节点数据缺失（如网络丢包），主节点会重新推送缺失的数据（这里也会利用复制积压缓冲区）。注意<strong>，offset和复制积压缓冲区，不仅可以用于部分复制，也可以用于处理命令丢失等情形</strong>；区别在于前者是在断线重连后进行的，而后者是在主从节点没有断线的情况下进行的。</p>
<p>（3）<strong>辅助保证从节点的数量和延迟</strong>：Redis主节点中使用<code>min-slaves-to-write</code>和<code>min-slaves-max-lag</code>参数，来保证主节点在不安全的情况下不会执行写命令；</p>
<p>所谓不安全，是指从节点数量太少，或延迟过高。</p>
<p>例如<code>min-slaves-to-write</code>和<code>min-slaves-max-lag</code>分别是3和10，含义是如果从节点数量小于3个，或所有从节点的延迟值都大于10s，则主节点拒绝执行写命令。</p>
<p>而这里从节点延迟值的获取，就是通过主节点接收到REPLCONF ACK命令的时间来判断的，即前面所说的info Replication中的lag值。</p>
<h1 id="实际应用的问题"><a href="#实际应用的问题" class="headerlink" title="实际应用的问题"></a>实际应用的问题</h1><h2 id="1-读写分离及其中的问题"><a href="#1-读写分离及其中的问题" class="headerlink" title="1. 读写分离及其中的问题"></a>1. 读写分离及其中的问题</h2><h3 id="（1）延迟与不一致问题"><a href="#（1）延迟与不一致问题" class="headerlink" title="（1）延迟与不一致问题"></a>（1）延迟与不一致问题</h3><p>由于<strong>主从复制的命令传播是异步的</strong>，延迟与数据的不一致不可避免。如果应用对数据不一致的接受程度程度较低，可能的优化措施包括：优化主从节点之间的网络环境（如在同机房部署）；监控主从节点延迟（通过offset）判断，<strong>如果从节点延迟过大，通知应用不再通过该从节点读取数据</strong>；<strong>使用集群同时扩展写负载和读负载等</strong>。</p>
<p>在命令传播阶段以外的其他情况下，从节点的数据不一致可能更加严重，例如连接在数据同步阶段，或从节点失去与主节点的连接时等。从节点的<code>slave-serve-stale-data</code>参数便与此有关：它控制这种情况下从节点的表现；如果为yes（默认值），则从节点仍能够响应客户端的命令，如果为no，则从节点只能响应info、slaveof等少数命令。该参数的设置与应用对数据一致性的要求有关；<strong>如果对数据一致性要求很高，则应设置为no</strong>。</p>
<h3 id="（2）数据过期问题"><a href="#（2）数据过期问题" class="headerlink" title="（2）数据过期问题"></a>（2）数据过期问题</h3><p>在单机版Redis中，存在两种删除策略：</p>
<ul>
<li>惰性删除：服务器不会主动删除数据，只有当客户端查询某个数据时，服务器判断该数据是否过期，如果过期则删除。</li>
<li>定期删除：服务器执行定时任务删除过期数据，但是考虑到内存和CPU的折中（删除会释放内存，但是频繁的删除操作对CPU不友好），该删除的频率和执行时间都受到了限制。</li>
</ul>
<p>在主从复制场景下，<strong>为了主从节点的数据一致性，从节点不会主动删除数据</strong>，而是由主节点控制从节点中过期数据的删除。由于主节点的惰性删除和定期删除策略，都不能保证主节点及时对过期数据执行删除操作，因此，当客户端通过Redis从节点读取数据时，很容易读取到已经过期的数据。</p>
<p><strong>Redis 3.2中，从节点在读取数据时，增加了对数据是否过期的判断</strong>：如果该数据已过期，则不返回给客户端；将Redis升级到3.2可以解决数据过期问题。</p>
<h3 id="（3）故障切换问题"><a href="#（3）故障切换问题" class="headerlink" title="（3）故障切换问题"></a>（3）故障切换问题</h3><p><strong>在没有使用哨兵的读写分离场景下</strong>，应用针对读和写分别连接不同的Redis节点；当主节点或从节点出现问题而发生更改时，需要及时修改应用程序读写Redis数据的连接；连接的切换可以手动进行，或者自己写监控程序进行切换，但前者响应慢、容易出错，后者实现复杂，成本都不算低。(所以后面有<strong>哨兵机制</strong>)</p>
<h2 id="2-各场景下复制的选择及优化技巧"><a href="#2-各场景下复制的选择及优化技巧" class="headerlink" title="2. 各场景下复制的选择及优化技巧"></a>2. 各场景下复制的选择及优化技巧</h2><p>在介绍了Redis复制的种种细节之后，现在我们可以来总结一下，在下面常见的场景中，何时使用部分复制，以及需要注意哪些问题。</p>
<h3 id="（1）第一次建立复制"><a href="#（1）第一次建立复制" class="headerlink" title="（1）第一次建立复制"></a>（1）第一次建立复制</h3><p>此时全量复制不可避免，但仍有几点需要注意：</p>
<p><strong>如果主节点的数据量较大，应该尽量避开流量的高峰期</strong>，避免造成阻塞；</p>
<p><strong>如果有多个从节点需要建立对主节点的复制，可以考虑将几个从节点错开</strong>，避免主节点带宽占用过大。</p>
<p><strong>如果从节点过多，也可以调整主从复制的拓扑结构，由一主多从结构变为树状结构</strong>（中间的节点既是其主节点的从节点，也是其从节点的主节点）；但使用树状结构应该谨慎：虽然主节点的直接从节点减少，降低了主节点的负担，但是多层从节点的延迟增大，数据一致性变差；且结构复杂，维护相当困难。</p>
<h3 id="（2）主节点重启"><a href="#（2）主节点重启" class="headerlink" title="（2）主节点重启"></a>（2）主节点重启</h3><p>主节点重启可以分为两种情况来讨论，一种是故障导致宕机，另一种则是有计划的重启。</p>
<p><strong>主节点宕机</strong></p>
<p>主节点宕机重启后，runid会发生变化，因此不能进行部分复制，只能全量复制。</p>
<p>实际上在主节点宕机的情况下，应进行故障转移处理，将其中的一个从节点升级为主节点，其他从节点从新的主节点进行复制；且故障转移应尽量的自动化，后面文章将要介绍的哨兵便可以进行自动的故障转移。</p>
<p><strong>安全重启：debug reload</strong></p>
<p>在一些场景下，可能希望对主节点进行重启，例如主节点内存碎片率过高，或者<strong>希望调整一些只能在启动时调整的参数</strong>。如果使用普通的手段重启主节点，会使得runid发生变化，可能导致不必要的全量复制。</p>
<p>为了解决这个问题，Redis提供了<code>debug reload</code>的重启方式：重启后，主节点的runid和offset都不受影响，避免了全量复制。</p>
<p>如下图所示，debug reload重启后runid和offset都未受影响：</p>
<h3 id="（3）从节点重启"><a href="#（3）从节点重启" class="headerlink" title="（3）从节点重启"></a>（3）从节点重启</h3><p>从节点宕机重启后，其保存的主节点的runid会丢失，因此即使再次执行slaveof，也无法进行部分复制。</p>
<h3 id="（4）网络中断"><a href="#（4）网络中断" class="headerlink" title="（4）网络中断"></a>（4）网络中断</h3><p>如果主从节点之间出现网络问题，造成短时间内网络中断，可以分为多种情况讨论。</p>
<p>第一种情况：网络问题时间极为短暂，只造成了短暂的丢包，主从节点都没有判定超时（未触发repl-timeout）；此时只需要通过REPLCONF ACK来补充丢失的数据即可。</p>
<p>第二种情况：网络问题时间很长，主从节点判断超时（触发了repl-timeout），且丢失的数据过多，超过了复制积压缓冲区所能存储的范围；此时主从节点无法进行部分复制，只能进行全量复制。<strong>为了尽可能避免这种情况的发生，应该根据实际情况适当调整复制积压缓冲区的大小</strong>；此外及时发现并修复网络中断，也可以减少全量复制。</p>
<p>第三种情况：介于前述两种情况之间，主从节点判断超时，且丢失的数据仍然都在复制积压缓冲区中；此时主从节点可以进行部分复制。</p>
<h2 id="3-复制相关的配置"><a href="#3-复制相关的配置" class="headerlink" title="3. 复制相关的配置"></a>3. 复制相关的配置</h2><p>这一节总结一下与复制有关的配置，说明这些配置的作用、起作用的阶段，以及配置方法等；通过了解这些配置，一方面加深对Redis复制的了解，另一方面掌握这些配置的方法，可以优化Redis的使用，少走坑。</p>
<p>配置大致可以分为主节点相关配置、从节点相关配置以及与主从节点都有关的配置，下面分别说明。</p>
<h3 id="（1）与主从节点都有关的配置"><a href="#（1）与主从节点都有关的配置" class="headerlink" title="（1）与主从节点都有关的配置"></a>（1）与主从节点都有关的配置</h3><p>首先介绍最特殊的配置，它决定了该节点是主节点还是从节点：</p>
<ol>
<li><p>slaveof masterip masterport：Redis启动时起作用；作用是建立复制关系，开启了该配置的Redis服务器在启动后成为从节点。该注释默认注释掉，即Redis服务器默认都是主节点。</p>
</li>
<li><p>repl-timeout 60：与各个阶段<strong>主从节点连接超时判断</strong>有关，见前面的介绍。</p>
</li>
</ol>
<h3 id="（2）主节点相关配置"><a href="#（2）主节点相关配置" class="headerlink" title="（2）主节点相关配置"></a>（2）主节点相关配置</h3><ol>
<li><p>repl-diskless-sync no：作用于全量复制阶段，控制主节点是否使用diskless复制（无盘复制）。所谓diskless复制，是指在全量复制时，主节点不再先把数据写入RDB文件，而是直接写入slave的socket中，整个过程中不涉及硬盘；diskless复制在磁盘IO很慢而网速很快时更有优势。需要注意的是，截至Redis3.0，diskless复制处于实验阶段，默认是关闭的。</p>
</li>
<li><p>repl-diskless-sync-delay 5：该配置作用于全量复制阶段，当主节点使用diskless复制时，该配置决定主节点向从节点发送之前停顿的时间，单位是秒；只有当diskless复制打开时有效，默认5s。之所以设置停顿时间，是基于以下两个考虑：(1)向slave的socket的传输一旦开始，新连接的slave只能等待当前数据传输结束，才能开始新的数据传输 (2)多个从节点有较大的概率在短时间内建立主从复制。</p>
</li>
<li><p>client-output-buffer-limit slave 256MB 64MB 60：与<strong>全量复制阶段主节点的缓冲区大小</strong>有关，见前面的介绍。</p>
</li>
<li><p>repl-disable-tcp-nodelay no：与<strong>命令传播阶段的延迟</strong>有关，见前面的介绍。</p>
</li>
<li><p>masterauth master-password：与连接建立阶段的身份验证有关，见前面的介绍。</p>
</li>
<li><p>repl-ping-slave-period 10：与<strong>命令传播阶段主从节点的超时判断</strong>有关，见前面的介绍。</p>
</li>
<li><p>repl-backlog-size 1mb：<strong>复制积压缓冲区的大小</strong>，见前面的介绍。</p>
</li>
<li><p>repl-backlog-ttl 3600：当主节点没有从节点时，复制积压缓冲区保留的时间，这样当断开的从节点重新连进来时，可以进行部分复制；默认3600s。如果设置为0，则永远不会释放复制积压缓冲区。</p>
</li>
<li><p>min-slaves-to-write 3：规定了<strong>主节点的最小从节点数目</strong>。</p>
</li>
<li><p>min-slaves-max-lag 10：<strong>从节点对应的最大延迟</strong>，见前面的介绍。</p>
</li>
</ol>
<h3 id="（3）从节点相关配置"><a href="#（3）从节点相关配置" class="headerlink" title="（3）从节点相关配置"></a>（3）从节点相关配置</h3><ol>
<li><p>slave-serve-stale-data yes：与<strong>从节点数据陈旧时是否响应客户端命令</strong>有关，见前面的介绍。</p>
</li>
<li><p>slave-read-only yes：<strong>从节点是否只读</strong>；默认是只读的。由于从节点开启写操作容易导致主从节点的数据不一致，因此该配置尽量不要修改。</p>
</li>
</ol>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kismetv/p/9236731.html"><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kismetv/p/9236731.html">深入学习Redis（3）：主从复制 </a></a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/14/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/16/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SongyangJi</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  





</body>
</html>
