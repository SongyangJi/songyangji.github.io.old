<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>IP 协议相关技术——DNS、NAT、ICMP、DHCP、ARP</title>
    <url>/2021/12/10/%20IP%20%E5%8D%8F%E8%AE%AE%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94DNS%E3%80%81NAT%E3%80%81ICMP%E3%80%81DHCP%E3%80%81ARP/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><blockquote>
<p>注意DNS是应用层的协议，不是网络层的协议。</p>
</blockquote>
<h2 id="DNS简介"><a href="#DNS简介" class="headerlink" title="DNS简介"></a>DNS简介</h2><p>DNS（Domain Name System）是域名系统的英文缩写，是一种组织成域层次结构的计算机和网络服务命名系统，用于 TCP/IP 网络。</p>
<h2 id="DNS-作用"><a href="#DNS-作用" class="headerlink" title="DNS 作用"></a>DNS 作用</h2><p>通常我们有两种方式识别主机：通过主机名或者 IP 地址。人们喜欢便于记忆的主机名表示，而路由器则喜欢定长的、有着层次结构的 IP 地址。为了满足这些不同的偏好，我们就需要一种能够进行主机名到 IP 地址转换的目录服务，<strong>域名系统作为将域名和 IP 地址相互映射的一个分布式数据库</strong>，能够使人更方便地访问互联网。</p>
<h2 id="DNS-域名解析原理"><a href="#DNS-域名解析原理" class="headerlink" title="DNS 域名解析原理"></a>DNS 域名解析原理</h2><p>DNS 采用了分布式的设计方案，其域名空间采用一种树形的层次结构：</p>
<p><img src="/dns.png"></p>
<p>上图展示了 DNS 服务器的部分层次结构，从上到下依次为<strong>根域名服务器</strong>、<strong>顶级域名服务器</strong>和<strong>权威域名服务器</strong>。</p>
<ol>
<li><p>域名服务器在因特网上有13个，大部分位于北美洲。</p>
</li>
<li><p>第二层为顶级域服务器，这些服务器负责顶级域名（如 com、org、net、edu）和所有国家的顶级域名（如uk、fr、ca 和 jp）。</p>
</li>
<li><p>在第三层为权威 DNS 服务器，因特网上具有公共可访问主机（例如 Web 服务器和邮件服务器）的每个组织机构必须提供公共可访问的 DNS 记录，这些记录由组织机构的权威 DNS 服务器负责保存，这些记录将这些主机的名称映射为 IP 地址。</p>
</li>
</ol>
<p>所以域名的层级关系类似⼀个树状结构：</p>
<ul>
<li><p>根 DNS 服务器</p>
</li>
<li><p>顶级域 DNS 服务器（com）</p>
</li>
<li><p>权威 DNS 服务器（server.com）</p>
</li>
</ul>
<p>除此之外，还有一类重要的 DNS 服务器，叫做<strong>本地 DNS 服务器</strong>。本地 DNS 服务器严格来说不在 DNS 服务器的层次结构中，但它对 DNS 层次结构是很重要的。</p>
<p>一般来说，<strong>每个网络服务提供商（ISP） 都有一台本地 DNS 服务器</strong>。<strong>当主机与某个 ISP 相连时，该 ISP 提供一台主机的 IP 地址，该主机具有一台或多台其本地 DNS 服务器的 IP 地址</strong>。主机的本地 DNS 服务器通常和主机距离较近，<strong>当主机发起 DNS 请求时，该请求被发送到本地 DNS 服务器，它起着代理的作用，并将该请求转发到 DNS 服务器层次结构中</strong>。</p>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><img src="dns2.png" style="zoom:30%;" />

<p>我们以一个例子来了解 DNS 的工作原理，假设主机 A（IP 地址为 abc.xyz.edu） 想知道主机 B 的 IP 地址 （def.mn.edu）。</p>
<ol>
<li>主机 A 首先<strong>向它的本地 DNS 服务器发送一个 DNS 查询报文</strong>。该查询报文含有被转换的主机名 def.mn.edu</li>
<li>本地 DNS 服务器<strong>将该报文转发到根 DNS 服务器</strong>；</li>
<li>根 DNS 服务器注意到查询的 IP 地址前缀为 edu 后向本地 DNS 服务器<strong>返回负责 edu 的顶级域名服务器的 IP 地址列表</strong>。</li>
<li>该本地 DNS 服务器则再次向这些顶级域名服务器发送查询报文。该顶级域名服务器注意到 mn.edu 的前缀，并<strong>用权威域名服务器的 IP 地址进行响应</strong>。</li>
<li>通常情况下，顶级域名服务器并不总是知道每台主机的权威 DNS 服务器的 IP 地址，而只知道中间的某个服务器，该中间 DNS 服务器依次能找到用于相应主机的 IP 地址，我们假设中间经历了权威服务器 ① 和 ②，最后<strong>找到了负责 def.mn.edu 的权威 DNS 服务器</strong> ③</li>
<li>之后，<strong>本地 DNS 服务器直接向该服务器发送查询报文</strong>从而获得主机 B 的IP 地址。</li>
</ol>
<p>在上图中，IP 地址的查询其实经历了两种查询方式，分别是递归查询和迭代查询。</p>
<p><strong>域名解析查询的两种方式</strong></p>
<p>DNS查询有两种方式：<strong>递归</strong>和<strong>迭代</strong>。</p>
<ul>
<li><p>DNS客户端设置使用的DNS服务器一般都是递归服务器，它负责全权处理客户端的DNS查询请求，直到返回最终结果。</p>
</li>
<li><p>DNS服务器之间一般采用迭代查询方式。</p>
</li>
</ul>
<h2 id="DNS-为什么用-UDP"><a href="#DNS-为什么用-UDP" class="headerlink" title="DNS 为什么用 UDP"></a>DNS 为什么用 UDP</h2><h3 id="综合使用TCP和UDP"><a href="#综合使用TCP和UDP" class="headerlink" title="综合使用TCP和UDP"></a>综合使用TCP和UDP</h3><p>更正确的答案是 DNS 既使用 TCP 又使用 UDP。</p>
<p>当进行区域传送（<strong>主域名服务器向辅助域名服务器传送变化的那部分数据</strong>）时会使用 TCP，因为数据同步传送的数据量比一个请求和应答的数据量要多，而 TCP 允许的报文长度更长，因此为了保证数据的正确性，会使用基于可靠连接的 TCP。（DNS服务器与服务器之间用TCP）</p>
<p>udp适用于小包，无上下文的情况，好处是开销小。很容易理解，udp查询就是一问一答，url和ip地址都是很短的字符串，都不会超过一个包。</p>
<p>当客户端向 DNS 服务器查询域名 ( 域名解析) 的时候，一般返回的内容不会超过 <strong>DNS 报文的最大长度，即 512 字节</strong>。用 UDP 传输时，不需要经过 TCP 三次握手的过程，从而大大提高了响应速度，但这要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。</p>
<h3 id="历史发展"><a href="#历史发展" class="headerlink" title="历史发展"></a>历史发展</h3><p>当年内容贫乏，硬件性能低下。认为主机查询的动作频次低，数据量少。用TCP短连结握手和挥手的开销比查询还高。用长连接服务器又承受不住。UDP是很好的选择。</p>
<p>互联网起来后DNS频率急剧增加，所以又加上了TCP版本。</p>
<p>随着恶意的DNS污染出现后，DNS又升级了TLS版本。</p>
<h3 id="无需TCP的可靠传输（省去握手挥手开销）"><a href="#无需TCP的可靠传输（省去握手挥手开销）" class="headerlink" title="无需TCP的可靠传输（省去握手挥手开销）"></a>无需TCP的可靠传输（省去握手挥手开销）</h3><ol>
<li>第一，传输包的大小。首先我们知道tcp要做的事很简单，就是要保证一个可靠及高效的服务。所谓可靠，那就是比如说，本要发的包丢了，那就重传，目的尽量保证这个包到达对端。但是你如果包很大，你每次都整体重传，那肯定不满足高效的原则了（tcp做的很大一部分工作也就是把需要丢的包重传而不是每次整体重传）。基于此，dns查询的包基本大小就是固定的，就是一个包的大小，如果丢了那就再传一次就得了，根本不需要tcp的这种可靠传输。</li>
<li>第二，如果只是传输一个包大小，再来几个握手来几个挥手，就太得不偿失了。</li>
<li>第三，dns查询，本身一个查询，对端就会给一个回复，这个回复就可以当做是一个响应。已经能满足dns查询的这种需求了。</li>
</ol>
<p><a href="https://segmentfault.com/a/1190000039759438"><a href="https://segmentfault.com/a/1190000039759438">DNS劫持如何避免和解决?</a></a></p>
<h1 id="ARP-地址解析协议"><a href="#ARP-地址解析协议" class="headerlink" title="ARP 地址解析协议"></a>ARP 地址解析协议</h1><p>地址解析协议（英语：Address Resolution Protocol，缩写：ARP）是一个通过解析网络层地址来找寻数据链路层地址的网络传输协议，它在IPv4中极其重要。</p>
<p>在IPv6中<a href="https://zh.wikipedia.org/wiki/%E9%82%BB%E5%B1%85%E5%8F%91%E7%8E%B0%E5%8D%8F%E8%AE%AE">邻居发现协议</a>（NDP）用于代替地址解析协议（ARP）。</p>
<h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><p>在<a href="https://zh.wikipedia.org/wiki/%E4%BB%A5%E5%A4%AA%E7%BD%91">以太网</a>协议中规定，<strong>同一局域网中的一台主机要和另一台主机进行直接通信，必须要知道目标主机的MAC地址</strong>。而在TCP/IP协议中，网络层和传输层只关心目标主机的IP地址。</p>
<p>这就导致在以太网中使用IP协议时，数据链路层的以太网协议接到上层IP协议提供的数据中，只包含目的主机的IP地址。于是需要一种方法，<strong>根据目的主机的IP地址，获得其<a href="https://zh.wikipedia.org/wiki/MAC%E5%9C%B0%E5%9D%80">MAC地址</a>。这就是ARP协议要做的事情</strong>。所谓<strong>地址解析（address resolution）</strong>就是主机在发送帧前将目标IP地址转换成目标MAC地址的过程。</p>
<p>另外，当发送主机和目的主机不在同一个<a href="https://zh.wikipedia.org/wiki/%E5%B1%80%E5%9F%9F%E7%BD%91">局域网</a>中时，即便知道对方的MAC地址，两者也不能直接通信，必须经过<a href="https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1">路由</a>转发才可以。所以<strong>此时，发送主机通过ARP协议获得的将不是目的主机的真实MAC地址，而是一台可以通往局域网外的路由器的MAC地址</strong>。于是此后发送主机发往目的主机的所有帧，都将发往该路由器，通过它向外发送。这种情况称为委托ARP或<strong>ARP代理（ARP Proxy）</strong>。</p>
<p>在<a href="https://zh.wikipedia.org/wiki/%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AE">点对点链路</a>中不使用ARP，实际上在<strong>点对点网络</strong>中也不使用MAC地址，因为在此类网络中分别已经获取了对端的IP地址。</p>
<h2 id="数据包结构"><a href="#数据包结构" class="headerlink" title="数据包结构"></a>数据包结构</h2><p>为了把IP地址映射到48位以太网地址用于传输，需要一个体现地址转换协议的包格式。</p>
<h3 id="以太网链路层"><a href="#以太网链路层" class="headerlink" title="以太网链路层"></a>以太网链路层</h3><ul>
<li>目标以太网地址：目标MAC地址。FF:FF:FF:FF:FF:FF （二进制全1）为广播地址。</li>
<li>源以太网地址：发送方MAC地址。</li>
<li>帧类型：以太类型，ARP为0x0806。</li>
</ul>
<h3 id="以太网报文数据"><a href="#以太网报文数据" class="headerlink" title="以太网报文数据"></a>以太网报文数据</h3><ul>
<li>硬件类型：如以太网（0x0001）、<a href="https://zh.wikipedia.org/wiki/%E5%B0%81%E5%8C%85%E7%84%A1%E7%B7%9A%E9%9B%BB">分组无线网</a>。</li>
<li>协议类型：如<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE">网际协议</a>(IP)（0x0800）、<a href="https://zh.wikipedia.org/wiki/IPv6">IPv6</a>（0x86DD）。</li>
<li>硬件地址长度：每种硬件地址的字节长度，一般为6（以太网）。</li>
<li>协议地址长度：每种协议地址的字节长度，一般为4（IPv4）。</li>
<li>操作码：1为ARP请求，2为ARP应答，3为<a href="https://zh.wikipedia.org/wiki/%E9%80%86%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE">RARP</a>请求，4为RARP应答。</li>
<li><strong>源硬件地址</strong>：n个字节，n由硬件地址长度得到，一般为发送方MAC地址。</li>
<li><strong>源协议地址</strong>：m个字节，m由协议地址长度得到，一般为发送方IP地址。</li>
<li><strong>目标硬件地址</strong>：n个字节，n由硬件地址长度得到，一般为目标MAC地址。</li>
<li><strong>目标协议地址</strong>：m个字节，m由协议地址长度得到，一般为目标IP地址。</li>
</ul>
<table class="wikitable" style="text-align:center;">
<tbody><tr>
<th>长度(位)</th>
<th>48</th>
<th>48</th>
<th>16</th>
<th>16</th>
<th>16</th>
<th>8</th>
<th>8</th>
<th>16</th>
<th>48</th>
<th>32</th>
<th>48</th>
<th>32
</th></tr>
<tr>
<td style="min-height:60px;"><b>数据类型</b></td>
<td style="width:96px;">目标以太网地址</td>
<td style="width:96px;">源以太网地址</td>
<td style="width:32px;">帧类型</td>
<td style="width:32px;">硬件类型</td>
<td style="width:32px;">协议类型</td>
<td style="width:16px;">硬件地址长度</td>
<td style="width:16px;">协议地址长度</td>
<td style="width:32px;">操作码</td>
<td style="width:96px;">源硬件地址</td>
<td style="width:64px;">源协议地址</td>
<td style="width:96px;">目标硬件地址</td>
<td style="width:64px;">目标协议地址
</td></tr>
<tr>
<td><b>组成</b></td>
<td colspan="3">14字节 以太网首部</td>
<td colspan="9">28字节 ARP请求/应答
</td></tr></tbody></table>


<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>在每台安装有TCP/IP协议的电脑或路由器里都有一个<strong>ARP缓存表，表里的IP地址与MAC地址是一对应的</strong>。</p>
<p>以主机A（192.168.38.10）向主机B（192.168.38.11）发送数据为例。</p>
<ol>
<li>当发送数据时，主机A会<strong>先在自己的ARP缓存表中寻找是否有目标IP地址</strong>。如果找到就知道目标MAC地址为（00-BB-00-62-C2-02），直接把目标MAC地址写入帧里面发送就可。</li>
<li>如果在ARP缓存表中没有找到相对应的IP地址，<strong>主机A就会在网络上发送一个广播（ARP request），目标MAC地址是“FF.FF.FF.FF.FF.FF”</strong>，这表示向同一网段内的所有主机发出这样的询问：“192.168.38.11的MAC地址是什么？”</li>
<li><strong>网络上其他主机并不响应ARP询问，只有主机B接收到这个帧时，才向主机A做出这样的回应</strong>（ARP response）：“192.168.38.11的MAC地址是00-BB-00-62-C2-02”，此回应以单播方式。这样，主机A就知道主机B的MAC地址，它就可以向主机B发送信息。同时它<strong>还更新自己的ARP高速缓存</strong>（ARP cache），下次再向主机B发送信息时，直接从ARP缓存表里查找就可。</li>
</ol>
<p>ARP缓存表采用老化机制，在一段时间内如果表中的某一行没有使用，就会被删除，这样可减少缓存表的长度，加快查询速度。</p>
<h2 id="免费ARP（gratuitous-ARP）"><a href="#免费ARP（gratuitous-ARP）" class="headerlink" title="免费ARP（gratuitous ARP）"></a>免费ARP（gratuitous ARP）</h2><p>主机发送ARP查询（广播）自己的IP地址，当ARP功能被开启或者是端口初始配置完成，主机向网络发送免费ARP来<strong>查询自己的IP地址确认地址唯一可用</strong>。</p>
<p>作用：</p>
<ol>
<li><strong>确定网络中是否有其他主机使用了IP地址</strong>，如果有应答则产生错误消息。</li>
<li><strong>免费ARP可以做更新ARP缓存用</strong>，网络中的其他主机收到该广播则在缓存中更新条目，收到该广播的主机无论是否存在与IP地址相关的条目都会强制更新，如果存在旧条目则会将MAC更新为广播包中的MAC。</li>
</ol>
<blockquote>
<p>也就是主动告诉其他主机自己的IP和Mac地址的对应关系，以供更新之用。</p>
</blockquote>
<blockquote>
<p>参考<br><a href="https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8%E8%AE%AE">ARP</a></p>
</blockquote>
<h1 id="NAT（网络地址转换）"><a href="#NAT（网络地址转换）" class="headerlink" title="NAT（网络地址转换）"></a>NAT（网络地址转换）</h1><p>NAT（Network Address Translation），即<strong>网络地址转换</strong>，它是一种把内部私有网络地址翻译成公有网络 IP 地址的技术。该技术不仅能解决 IP 地址不足的问题，而且还能隐藏和保护网络内部主机，从而避免来自外部网络的攻击。</p>
<p>NAT 的实现方式主要有三种：</p>
<ul>
<li>静态转换（Basic NAT）：<strong>内部私有 IP 地址和公有 IP 地址是一对一的关系</strong>，并且不会发生改变。通过静态转换，可以实现外部网络对内部网络特定设备的访问，这种方式原理简单，但当某一共有 IP 地址被占用时，跟这个 IP 绑定的内部主机将无法访问 Internet。</li>
<li>动态转换：采用动态转换的方式时，<strong>私有 IP 地址每次转化成的公有 IP 地址是不唯一的</strong>。当私有 IP 地址被授权访问 Internet 时会被随机转换成一个合法的公有 IP 地址。当 ISP 通过的合法 IP 地址数量略少于网络内部计算机数量时，可以采用这种方式。</li>
<li><strong>端口多路复用</strong>（NAPT）：该方式将外出数据包的源端口进行端口转换，<strong>通过端口多路复用的方式，实现内部网络所有主机共享一个合法的外部 IP 地址进行 Internet 访问</strong>，从而最大限度地节约 IP 地址资源。同时，该方案可以隐藏内部网络中的主机，从而有效避免来自 Internet 的攻击。</li>
</ul>
<p>NAPT维护一个带有IP以及端口号的NAT表，结构如下。</p>
<table>
<thead>
<tr>
<th align="center">内网IP</th>
<th align="center">外网IP</th>
</tr>
</thead>
<tbody><tr>
<td align="center">192.168.1.55:5566</td>
<td align="center">219.152.168.222:9200</td>
</tr>
<tr>
<td align="center">192.168.1.59:80</td>
<td align="center">219.152.168.222:9201</td>
</tr>
<tr>
<td align="center">192.168.1.59:4465</td>
<td align="center">219.152.168.222:9202</td>
</tr>
</tbody></table>
<p>支持端口转换的NAT可以分为两类：<strong>源地址转换</strong>和<strong>目的地址转换</strong>。</p>
<p>前一种情形下发起连接的计算机的IP地址将会被重写，使得内网主机发出的数据包能够到达外网主机。</p>
<p>后一种情况下被连接计算机的IP地址将被重写，使得外网主机发出的数据包能够到达内网主机。</p>
<p>实际上，<strong>以上两种方式通常会一起被使用以支持双向通信</strong>。</p>
<p>如何支持这样的一对多的映射关系呢？就是利用发送端的源端口来进行的。</p>
<h1 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h1><p><strong>动态主配置协议</strong>（英语：<strong>D</strong>ynamic <strong>H</strong>ost <strong>C</strong>onfiguration <strong>P</strong>rotocol，缩写：<strong>DHCP</strong>），是一个用于<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE">IP</a>网络的<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE">网络协议</a>，位于<a href="https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B">OSI模型</a>的<a href="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E5%B1%82">应用层</a>，使用<a href="https://zh.wikipedia.org/wiki/%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE">UDP</a>协议工作，主要有两个用途：</p>
<ul>
<li><strong>用于内部网或网络服务供应商自动分配IP地址给用户</strong>；</li>
<li>用于内部网管理员对所有电脑作中央管理。</li>
</ul>
<blockquote>
<p> 我们的电脑通常都是通过 DHCP 动态获取 IP 地址，⼤⼤省去了配 IP 信息繁琐的过程。</p>
</blockquote>
<h2 id="DHCP工作步骤"><a href="#DHCP工作步骤" class="headerlink" title="DHCP工作步骤"></a>DHCP工作步骤</h2><ol>
<li><strong>发现</strong> ：客户端⾸先发起 <strong>DHCP</strong> 发现报⽂（<strong>DHCP DISCOVER</strong>） 的 IP 数据报，由于客户端没有 IP 地址，也不知道</li>
</ol>
<p>DHCP 服务器的地址，所以使⽤的是 UDP ⼴播通信，其使⽤的⼴播⽬的地址是 255.255.255.255（端⼝</p>
<p>67） 并且使⽤ 0.0.0.0（端⼝ 68） 作为源 IP 地址。DHCP 客户端将该 IP 数据报传递给链路层，链路层然后</p>
<p>将帧⼴播到所有的⽹络中设备。</p>
<ol start="2">
<li><p><strong>提供</strong> ：DHCP 服务器收到 DHCP 发现报⽂时，⽤ <strong>DHCP</strong> 提供报⽂（<strong>DHCP OFFER</strong>） 向客户端做出响应。该报⽂仍然使⽤ IP ⼴播地址 255.255.255.255，该报⽂信息携带服务器提供可租约的 IP 地址、⼦⽹掩码、默认⽹关、DNS 服务器以及 <strong>IP</strong> 地址租⽤期。</p>
</li>
<li><p><strong>请求</strong> ：客户端收到⼀个或多个服务器的 DHCP 提供报⽂后，从中选择⼀个服务器，并向选中的服务器发送 <strong>DHCP</strong> 请求报⽂（<strong>DHCP REQUEST</strong>进⾏响应，回显配置的参数。</p>
</li>
<li><p><strong>确认</strong> ：最后，服务端⽤ <strong>DHCP ACK</strong> 报⽂对 DHCP 请求报⽂进⾏响应，应答所要求的参数。</p>
</li>
</ol>
<p>⼀旦客户端收到 DHCP ACK 后，交互便完成了，并且<strong>客户端能够在租⽤期内使⽤ DHCP 服务器分配的 IP 地址</strong>。</p>
<p><strong>如果租约的 DHCP IP 地址快到期时，客户端会向服务器发送 DHCP 请求报⽂</strong>：</p>
<ul>
<li><p>服务器如果同意继续租⽤，则⽤ DHCP ACK 报⽂进⾏应答，客户端就会延⻓租期。</p>
</li>
<li><p>服务器如果不同意继续租⽤，则⽤ DHCP NACK 报⽂，客户端就要停⽌使⽤租约的 IP 地址。</p>
</li>
</ul>
<p>可以发现，DHCP 交互中，全程都是使⽤ <strong>UDP</strong> ⼴播通信。</p>
<h2 id="DHCP中继"><a href="#DHCP中继" class="headerlink" title="DHCP中继"></a>DHCP中继</h2><blockquote>
<p> 如果 DHCP 服务器和客户端不是在同⼀个局域⽹内，路由器⼜不会转发⼴播包，那不是每个⽹络都要配⼀个 DHCP 服务器？</p>
</blockquote>
<img src="dhcp.png" style="zoom:60%;" />



<p>所以，为了解决这⼀问题，就出现了 <strong>DHCP中继代理</strong>。有了 DHCP 中继代理以后，对不同⽹段的 <strong>IP</strong> 地址分配也可以由⼀个 <strong>DHCP</strong> 服务器统⼀进⾏管理。DHCP 客户端会向 DHCP 中继代理发送 DHCP 请求包，⽽ <strong>DHCP 中继代理在收到这个⼴播包以后，再以单播的形式发给 DHCP 服务器</strong>。</p>
<p>服务器端收到该包以后再向 DHCP 中继代理返回应答，并由 DHCP 中继代理将此包⼴播给 DHCP 客户端 。</p>
<p>因此，DHCP 服务器即使不在同⼀个链路上也可以实现统⼀分配和管理IP地址。</p>
<h1 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h1><p><strong>ICMP</strong>（Internet Control Message Protocol）是<strong>因特网控制报文协议</strong>，主要是实现 IP 协议中未实现的部分功能，是一种网络层协议。</p>
<p><strong>该协议并不传输数据，只传输控制信息来辅助网络层通信</strong>。</p>
<p>路由器严密监视Internet的操作，当路由器处理一个数据包发生意外的时候，可通过Internet控制消息协议向数据包的源端报告有关事件。</p>
<p>其主要的功能是验证网络是否畅通（确认接收方是否成功接收到 IP 数据包）以及辅助 IP 协议实现可靠传输（若发生 IP 丢包，ICMP 会通知发送方 IP 数据包被丢弃的原因，之后发送方会进行相应的处理）。</p>
<p>最重要的消息类型：</p>
<ol>
<li>目的地不可达：数据包无法传递，原因如不能定位一个目标，或者设置了DF但却遇到了小数据包网络；</li>
<li>超时：当TTL达到0而被丢弃时，路由器发送超时消息；</li>
<li>参数问题：在头字段中检测到一个非法字段；</li>
<li>源抑制：抑制包，可以用于拥塞控制（但现在很少使用）；</li>
<li>重定向：一个数据包被错误的路由；</li>
<li>响应请求与应答：检查一台机器是否存活；</li>
<li>请求/应答时间戳：与上面类似不过要求带上时间戳。</li>
</ol>
<h2 id="ICMP应用"><a href="#ICMP应用" class="headerlink" title="ICMP应用"></a>ICMP应用</h2><ul>
<li><p>Ping<br>Ping（Packet Internet Groper），即<strong>因特网包探测器</strong>，是一种工作在网络层的服务命令，主要用于测试网络连接量。本地主机通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 响应报文，Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率从而推断网络是否通畅、运行是否正常等。</p>
</li>
<li><p>TraceRoute<br>TraceRoute 是 ICMP 的另一个应用，其<strong>主要用来跟踪一个分组从源点耗费最少 TTL 到达目的地的路径</strong>。TraceRoute 通过逐渐增大 TTL 值并重复发送数据报来实现其功能，首先，TraceRoute 会发送一个 TTL 为 1 的 IP 数据报到目的地，当路径上的第一个路由器收到这个数据报时，它将 TTL 的值减 1，此时 TTL = 0，所以路由器会将这个数据报丢掉，并返回一个差错报告报文，之后源主机会接着发送一个 TTL 为 2 的数据报，并重复此过程，直到数据报能够刚好到达目的主机。此时 TTL = 0，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文，之后源主机便知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>DNS</tag>
        <tag>NAT</tag>
        <tag>ICMP</tag>
        <tag>DHCP</tag>
        <tag>ARP</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache Commons-pool2使用入门</title>
    <url>/2021/10/02/Apache-Commons-pool2%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><blockquote>
<p>创建新的对象并初始化的操作，可能会消耗很多的时间。在这种对象的初始化工作包含了一些费时的操作（例如，从一台位于20,000千米以外的主机上读出一些数据）的时候，尤其是这样。在需要大量生成这样的对象的时候，就可能会对性能造成一些不可忽略的影响。要缓解这个问题，除了选用更好的硬件和更棒的虚拟机以外，适当地采用一些能够减少对象创建次数的编码技巧，也是一种有效的对策。对象池化技术（Object Pooling）就是这方面的著名技巧，而Jakarta Commons Pool组件则是处理对象池化的得力外援。</p>
</blockquote>
<p>Commons Pool组件提供了一整套用于实现对象池化的框架，以及若干种各具特色的对象池实现，可以有效地减少处理对象池化时的工作量，为其它重要的工作留下更多的精力和时间</p>
<p>Apache Common-pool2完全重写了的对象池的实现，显著的提升了性能和可伸缩性，特别是在高并发加载的情况下。2.0 版本包含可靠的实例跟踪和池监控。</p>
<h3 id="Maven-依赖"><a href="#Maven-依赖" class="headerlink" title="Maven 依赖"></a>Maven 依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">commons-pool2.version</span>&gt;</span>2.11.1<span class="tag">&lt;/<span class="name">commons-pool2.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;commons-pool2.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h2><p><code>Apache Commons Pool</code>实现了<strong>对象池</strong>的功能。定义了对象的生成、销毁、激活、钝化等操作及其状态转换，并提供几个默认的对象池实现。<br>在讲述其实现原理前，先提一下其中有几个重要的对象：</p>
<ul>
<li><p>Object Pool（对象池）。</p>
</li>
<li><p>PooledObject（池对象）。</p>
</li>
<li><p>PooledObjectFactory（池对象工厂）。</p>
</li>
</ul>
<p>三种之间的关系图：</p>
<p><img src="/2021/10/02/Apache-Commons-pool2%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/concepts-1.jpg" alt="关系图"></p>
<p>下面分别详细讲解它们的实现。</p>
<p>（以下三个均为接口，位于 org.apache.commons.pool2）</p>
<h3 id="ObjectPool"><a href="#ObjectPool" class="headerlink" title="ObjectPool"></a>ObjectPool</h3><p>Object Pool负责管理PooledObject，如：借出对象，返回对象，校验对象，有多少激活对象，有多少空闲对象。</p>
<p>以下为类图结构，有几个默认的实现类可以直接使用。</p>
<ul>
<li><p>GenericObjectPool。</p>
</li>
<li><p>ProsiedObjectPool。</p>
</li>
<li><p>SoftReferenceObjectPool。</p>
</li>
</ul>
<p><img src="/2021/10/02/Apache-Commons-pool2%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/object-pool.png" alt="Object Pool （对象池）"> </p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">borrowObject</td>
<td align="left">从池中借出一个对象。要么调用PooledObjectFactory.makeObject方法创建，要么对一个空闲对象使用PooledObjectFactory.activeObject进行激活，然后使用PooledObjectFactory.validateObject方法进行验证后再返回</td>
</tr>
<tr>
<td align="left">returnObject</td>
<td align="left">将一个对象返还给池。根据约定：对象必须 是使用borrowObject方法从池中借出的</td>
</tr>
<tr>
<td align="left">invalidateObject</td>
<td align="left">废弃一个对象。根据约定：对象必须 是使用borrowObject方法从池中借出的。通常在对象发生了异常或其他问题时使用此方法废弃它</td>
</tr>
<tr>
<td align="left">addObject</td>
<td align="left">使用工厂创建一个对象，<strong>钝化</strong>并且将它放入空闲对象池</td>
</tr>
<tr>
<td align="left">getNumberIdle</td>
<td align="left">返回池中空闲的对象数量。有可能是池中可供借出对象的近似值。如果这个信息无效，返回一个负数</td>
</tr>
<tr>
<td align="left">getNumActive</td>
<td align="left">返回从借出的对象数量。如果这个信息不可用，返回一个负数</td>
</tr>
<tr>
<td align="left">clear</td>
<td align="left">清除池中的所有空闲对象，释放其关联的资源（可选）。清除空闲对象必须使用PooledObjectFactory.destroyObject方法，池可用。</td>
</tr>
<tr>
<td align="left">close</td>
<td align="left">关闭池并释放关联的资源，池不可用。</td>
</tr>
</tbody></table>
<h3 id="PooledObject"><a href="#PooledObject" class="headerlink" title="PooledObject"></a>PooledObject</h3><p>用于封装对象（如：线程、数据库连接、TCP连接），将其包裹成可被池管理的对象。</p>
<p>此类的实现必须是线程安全的。</p>
<p>提供了两个默认的池对象实现：</p>
<ul>
<li>DefaultPoolObject。用于非软引用的普通对象。</li>
<li>PooledSoftReference。用于软引用的对象。</li>
</ul>
<p>在开发连接池、线程池等组件时，需要根据实际情况重载5个方法：startEvictionTest、endEvictionTest、allocate、deallocate和invalidate，用于在不同的场景下修改被包裹对象的内部状态。 </p>
<p>此接口的重要的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获得目标对象</span></span><br><span class="line"><span class="function">T <span class="title">getObject</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取PooledObject的状态</span></span><br><span class="line"><span class="function">PooledObjectState <span class="title">getState</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startEvictionTest</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">endEvictionTest</span><span class="params">(Deque&lt;PooledObject&lt;T&gt;&gt; idleQueue)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配对象。 如果原始状态为 IDLE, 则返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">allocate</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果当前已ALLOCATED ，则取消分配对象并将其设置为IDLE 。</span></span><br><span class="line"><span class="comment">// 如果状态为ALLOCATED则为true 。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">deallocate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invalidate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">PooledObjectState <span class="title">getState</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">markAbandoned</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">markReturning</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">... 省略其他方法</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<p>PooledObject有多种状态，在不同的环节或经过处理后状态会发生变化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.commons.pool2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">PooledObjectState</span> </span>&#123;</span><br><span class="line">    IDLE, <span class="comment">// 	位于队列中，未使用</span></span><br><span class="line">  </span><br><span class="line">    ALLOCATED, <span class="comment">// 已被分配，正在使用</span></span><br><span class="line">  </span><br><span class="line">    EVICTION,  <span class="comment">// 位于队列中，当前正在测试，可能会被回收到队列</span></span><br><span class="line">  </span><br><span class="line">    EVICTION_RETURN_TO_HEAD, <span class="comment">// 不在队列中，目前正在测试是否可能被驱逐。 </span></span><br><span class="line">  </span><br><span class="line">    VALIDATION, <span class="comment">// 位于队列中，当前正在验证</span></span><br><span class="line">  </span><br><span class="line">    VALIDATION_PREALLOCATED, <span class="comment">// 不在队列中，当前正在验证。当对象从池中被借出，在配置了testOnBorrow的情况下，对象从队列移除和进行预分配的时候会进行验证</span></span><br><span class="line">  </span><br><span class="line">    VALIDATION_RETURN_TO_HEAD, <span class="comment">// 不在队列中，正在进行验证。从池中借出对象时，从队列移除对象时会先进行测试。返回到队列头部的时候应该做一次完整的验证</span></span><br><span class="line">  </span><br><span class="line">    INVALID, <span class="comment">// 	回收或验证失败，【即将/已经】 销毁</span></span><br><span class="line">  </span><br><span class="line">    ABANDONED, <span class="comment">// 视为放弃，无效</span></span><br><span class="line">  </span><br><span class="line">    RETURNING <span class="comment">// 返还到池中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>状态转换如下图：</p>
<p><img src="/2021/10/02/Apache-Commons-pool2%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/PooledObjectState.png" alt="PooledObjectState"></p>
<h3 id="PooledObjectFactory"><a href="#PooledObjectFactory" class="headerlink" title="PooledObjectFactory"></a>PooledObjectFactory</h3><p>一个定义生命周期方法的接口，用于由ObjectPool提供服务的实例。</p>
<p>PooledObjectFactory必须实现线程安全。</p>
<p>Commons pool2 定义了抽象工厂<code>BasePooledObjectFactory</code>，使用者应该继承这个抽象类实现自己的池化工厂。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">makeObject</td>
<td align="left">每当需要新实例时都会调用makeObject 。</td>
</tr>
<tr>
<td align="left">activateObject</td>
<td align="left">每一个钝化（passivated）的ObjectPool实例从池中借出（borrowed）前调用。</td>
</tr>
<tr>
<td align="left">validateObject</td>
<td align="left">可能用于从池中借出对象时，对处于激活（activated）状态的ObjectPool实例进行测试确保它是有效的。也有可能在ObjectPool实例返还池中进行钝化前调用进行测试是否有效。它只对处于激活状态的实例调用。</td>
</tr>
<tr>
<td align="left">passivateObject</td>
<td align="left">当实例返还池中的时候调用。</td>
</tr>
<tr>
<td align="left">destroyObject</td>
<td align="left">当实例从池中被清理出去丢弃的时候调用。</td>
</tr>
</tbody></table>
<h2 id="常用的实现类"><a href="#常用的实现类" class="headerlink" title="常用的实现类"></a>常用的实现类</h2><h3 id="GenericObjectPool"><a href="#GenericObjectPool" class="headerlink" title="GenericObjectPool"></a>GenericObjectPool</h3><h3 id="borrowObject"><a href="#borrowObject" class="headerlink" title="borrowObject"></a><code>borrowObject</code></h3><p>下面是GenericObjectPool中borrowObject方法的逻辑实现，有阻塞式和非阻塞式两种获取对象的模式。<br>默认情况下是阻塞的（你可以传入配置类更改这一行为）。</p>
<p><img src="/2021/10/02/Apache-Commons-pool2%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/borrow.png" alt="borrow"></p>
<h3 id="returnObject"><a href="#returnObject" class="headerlink" title="returnObject"></a><code>returnObject</code></h3><p>下面是GenericObjectPool中returnObject方法的逻辑实现，在这里实现的FIFO（先进先出）和LIFO（后进先出）。</p>
<p><img src="/2021/10/02/Apache-Commons-pool2%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/return-object.png" alt="return-object.png"></p>
<h3 id="DefaultPooledObject"><a href="#DefaultPooledObject" class="headerlink" title="DefaultPooledObject"></a>DefaultPooledObject</h3><h2 id="使用介绍"><a href="#使用介绍" class="headerlink" title="使用介绍"></a>使用介绍</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">null</span>;</span><br><span class="line">  </span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       obj = pool.borrowObject();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//...use the object...</span></span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           <span class="comment">// invalidate the object</span></span><br><span class="line">           pool.invalidateObject(obj);</span><br><span class="line">           <span class="comment">// do not return the object to the pool twice</span></span><br><span class="line">           obj = <span class="keyword">null</span>;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">// make sure the object is returned to the pool</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">null</span> != obj) &#123;</span><br><span class="line">               pool.returnObject(obj);</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">         <span class="comment">// failed to borrow an object</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://commons.apache.org/proper/commons-pool/">Apache Commons Pool</a></p>
<p><a href="http://aofengblog.com/2014/08/06/Apache-Commons-Pool2-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Apache Commons Pool2 源码分析</a></p>
<p>注：插图来源于<a href="http://aofengblog.com/2014/08/06/Apache-Commons-Pool2-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">http://aofengblog.com/</a></p>
]]></content>
      <tags>
        <tag>第三方 Jar 整合</tag>
        <tag>池</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch入门</title>
    <url>/2021/10/23/Elasticsearch%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h1><h2 id="Elaticsearch-Stack-简介"><a href="#Elaticsearch-Stack-简介" class="headerlink" title="Elaticsearch Stack 简介"></a>Elaticsearch Stack 简介</h2><p>Elaticsearch，简称为es， es是一个高扩展的、<strong>分布式</strong>的、<strong>RESTful 风格</strong>的<strong>搜索和数据分析引擎</strong>。</p>
<p>它可以近乎实时的存储、检索数据。本身扩展性很好，可以扩展到上百台服务器，处理PB级别的数据。</p>
<p>Es也使用<strong>Java开发</strong>并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。</p>
<h2 id="Kibana简介"><a href="#Kibana简介" class="headerlink" title="Kibana简介"></a>Kibana简介</h2><p>Kibana 是一个免费且开放的用户界面，能够让您对 Elasticsearch 数据进行可视化，并让您在 Elastic Stack 中进行导航。您可以进行各种操作，从跟踪查询负载，到理解请求如何流经您的整个应用，都能轻松完成。</p>
<p>Es技术栈还有其他工具，目前介绍这两个。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>下面是二者下载链接，下载相应的版本即可。</p>
<p><a href="https://www.elastic.co/cn/downloads/elasticsearch">elasticsearch下载</a></p>
<p><a href="https://www.elastic.co/cn/downloads/kibana">kibana下载</a></p>
<p>或者对于mac用户直接使用brew安装启动即可（学习环境使用）</p>
<p>(M1的mac)</p>
<ul>
<li>安装 elasticsearch</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install elastic/tap/elasticsearch-full</span><br></pre></td></tr></table></figure>

<ul>
<li>安装 kibana </li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install elastic/tap/kibana-full</span><br></pre></td></tr></table></figure>

<p>分别启动。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew services start elasticsearch-full</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew services start kibana-full</span><br></pre></td></tr></table></figure>


<p>访问</p>
<p>es的默认端口 9200： <a href="http://localhost:9200/">http://localhost:9200/</a></p>
<p>kibana的默认端口 5601： <a href="http://localhost:5601/">http://localhost:5601/</a></p>
<p>注意：9300是tcp通讯端口，集群间和TCPClient都使用该端口，9200是http协议的RESTful接口。</p>
<p>如果正常展示web界面，以及如下文字，说明安装启动一切正常。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;SongyangJi-MacBookAir.local&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;cluster_name&quot;</span> : <span class="string">&quot;elasticsearch_jisongyang&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;cluster_uuid&quot;</span> : <span class="string">&quot;wCrPSWgyQnCCCVCr0Hhc1g&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;number&quot;</span> : <span class="string">&quot;7.14.2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build_flavor&quot;</span> : <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build_type&quot;</span> : <span class="string">&quot;tar&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build_hash&quot;</span> : <span class="string">&quot;6bc13727ce758c0e943c3c21653b3da82f627f75&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build_date&quot;</span> : <span class="string">&quot;2021-09-15T10:18:09.722761972Z&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build_snapshot&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;lucene_version&quot;</span> : <span class="string">&quot;8.9.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;minimum_wire_compatibility_version&quot;</span> : <span class="string">&quot;6.8.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;minimum_index_compatibility_version&quot;</span> : <span class="string">&quot;6.0.0-beta1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;tagline&quot;</span> : <span class="string">&quot;You Know, for Search&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Elasticsearch相关概念术语"><a href="#Elasticsearch相关概念术语" class="headerlink" title="Elasticsearch相关概念术语"></a>Elasticsearch相关概念术语</h1><h2 id="关系型数据库的比较与联系"><a href="#关系型数据库的比较与联系" class="headerlink" title="关系型数据库的比较与联系"></a>关系型数据库的比较与联系</h2><table>
<thead>
<tr>
<th>数据库实例/Es集群</th>
<th>库/索引</th>
<th>表/类型</th>
<th>行/文档</th>
<th>列/字段</th>
</tr>
</thead>
<tbody><tr>
<td>RelationalDB</td>
<td>Databases</td>
<td>Tables</td>
<td>Rows</td>
<td>Columns</td>
</tr>
<tr>
<td>Elasticsearch</td>
<td>Indexes</td>
<td>Types</td>
<td>Documents</td>
<td>Fields</td>
</tr>
</tbody></table>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul>
<li><p>index (索引)<br>一个索引就是一个拥有几分相似特征的文档的集合。</p>
</li>
<li><p>type（类型）<br>在一个索引中，你可以定义一种或多种类型。一个类型是你的索引的一个逻辑上的分类/分区，其语义完全由你来定。通常，会为具有一组共同字段的文档定义一个类型。</p>
</li>
</ul>
<p>不过，明显上述的概念定义是有点模糊的（不像关系型数据库的库表关系那样泾渭分明），所以在后来的版本中就取消了type这个语义。</p>
<ul>
<li>document 文档<br>一个文档是一个可被索引的基础信息单元。文档以JSON（Javascript Object Notation）格式来表示，而JSON是一个到处存在的互联网数据交互格式。在一个index，你可以存储任意多的文档。</li>
</ul>
<ul>
<li><p>field 字段</p>
<p>相当于是数据表的字段，对文档数据根据不同属性进行的分类标识，也就是 Json 中的键。</p>
</li>
</ul>
<ul>
<li><p>mapping 映射</p>
<p><strong>mapping是处理数据的方式和规则方面做一些限制</strong>，如某个字段的数据类型、默认值、分析器、是否被索引等等，这些都是映射里面可以设置的，其它就是处理es里面数据的一些使用规则设置也叫做映射，按着最优规则处理数据对性能提高很大，因此才需要建立映射，并且需要思考如何建立映射才能对性能更好。</p>
</li>
</ul>
<h1 id="与-Elasticsearch-交互"><a href="#与-Elasticsearch-交互" class="headerlink" title="与 Elasticsearch 交互"></a>与 Elasticsearch 交互</h1><p>你可以</p>
<ul>
<li>使用elasticsearch提供的UI工具<ol>
<li>elasticsearch-head插件</li>
<li>kibana的dev-tools</li>
</ol>
</li>
<li>使用elasticsearch提供的Restful接口直接访问<ol>
<li>cURL</li>
<li>postman</li>
</ol>
</li>
<li>使用elasticsearch提供的API进行访问<br>也就是用程序调api去与es交互，也是程序开发者的最关心的交互方式。</li>
</ul>
<h2 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h2><p>如果使用curl的话</p>
<ul>
<li>语法</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X&lt;VERB&gt; &#x27;&lt;PROTOCOL&gt;://&lt;HOST&gt;:&lt;PORT&gt;/&lt;PATH&gt;?&lt;QUERY_STRING&gt;&#x27; -d &#x27;&lt;BODY&gt;&#x27;</span><br></pre></td></tr></table></figure>



<p>各字段的含义：</p>
<table>
<thead>
<tr>
<th><code>VERB</code></th>
<th>适当的 HTTP <em>方法</em> 或 <em>谓词</em> : <code>GET</code>、 <code>POST</code>、 <code>PUT</code>、 <code>HEAD</code> 或者 <code>DELETE</code>。</th>
</tr>
</thead>
<tbody><tr>
<td><code>PROTOCOL</code></td>
<td><code>http</code> 或者 <code>https</code>（如果你在 Elasticsearch 前面有一个 <code>https</code> 代理）</td>
</tr>
<tr>
<td><code>HOST</code></td>
<td>Elasticsearch 集群中任意节点的主机名，或者用 <code>localhost</code> 代表本地机器上的节点。</td>
</tr>
<tr>
<td><code>PORT</code></td>
<td>运行 Elasticsearch HTTP 服务的端口号，默认是 <code>9200</code> 。</td>
</tr>
<tr>
<td><code>PATH</code></td>
<td>API 的终端路径（例如 <code>_count</code> 将返回集群中文档数量）。Path 可能包含多个组件，例如：<code>_cluster/stats</code> 和 <code>_nodes/stats/jvm</code> 。</td>
</tr>
<tr>
<td><code>QUERY_STRING</code></td>
<td>任意可选的查询字符串参数 (例如 <code>?pretty</code> 将格式化地输出 JSON 返回值，使其更容易阅读)</td>
</tr>
<tr>
<td><code>BODY</code></td>
<td>一个 JSON 格式的请求体 (如果请求需要的话)</td>
</tr>
</tbody></table>
<h2 id="使用kibana"><a href="#使用kibana" class="headerlink" title="使用kibana"></a>使用kibana</h2><p>在kibana的开发者工具<a href="http://localhost:5601/app/dev_tools#/console">console</a>。</p>
<p>以下为 <strong>version 7.14.2</strong> 的示范操作。</p>
<h3 id="索引的CRUD"><a href="#索引的CRUD" class="headerlink" title="索引的CRUD"></a>索引的CRUD</h3><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">PUT /problem</span><br></pre></td></tr></table></figure>

<p>返回值</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;acknowledged&quot;</span> : <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;shards_acknowledged&quot;</span> : <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;index&quot;</span> : <span class="string">&quot;problem&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /problem</span><br></pre></td></tr></table></figure>

<p>只介绍其中几个字段的含义：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;problem&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;aliases&quot;</span> : &#123; &#125;, <span class="comment">// 索引的别名</span></span><br><span class="line">    <span class="attr">&quot;mappings&quot;</span> : &#123; &#125;, <span class="comment">// mapping的规则</span></span><br><span class="line">    <span class="attr">&quot;settings&quot;</span> : &#123;  </span><br><span class="line">      <span class="attr">&quot;index&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;routing&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;allocation&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;include&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;_tier_preference&quot;</span> : <span class="string">&quot;data_content&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;number_of_shards&quot;</span> : <span class="string">&quot;1&quot;</span>,  <span class="comment">// 分片的数量，低版本的默认值是5，现在默认是1</span></span><br><span class="line">        <span class="attr">&quot;provided_name&quot;</span> : <span class="string">&quot;problem&quot;</span>, </span><br><span class="line">        <span class="attr">&quot;creation_date&quot;</span> : <span class="string">&quot;1635053207532&quot;</span>, <span class="comment">// 创建时间戳</span></span><br><span class="line">        <span class="attr">&quot;number_of_replicas&quot;</span> : <span class="string">&quot;1&quot;</span>,  <span class="comment">// 备份的数量</span></span><br><span class="line">        <span class="attr">&quot;uuid&quot;</span> : <span class="string">&quot;HfPT1GNyTTmYAXCSjIVoVA&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;version&quot;</span> : &#123;  </span><br><span class="line">          <span class="attr">&quot;created&quot;</span> : <span class="string">&quot;7140299&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">DELETE /index</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;acknowledged&quot;</span> : <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="文档的CRUD"><a href="#文档的CRUD" class="headerlink" title="文档的CRUD"></a>文档的CRUD</h3><h4 id="创建文档"><a href="#创建文档" class="headerlink" title="创建文档"></a>创建文档</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST problem&#x2F;_doc</span><br><span class="line">&#123;</span><br><span class="line">    &quot;difficult_level&quot;: &quot;简单&quot;,</span><br><span class="line">    &quot;id&quot;: &quot;1486&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;数组异或操作&quot;,</span><br><span class="line">    &quot;passing_rate&quot;: &quot;84.3%&quot;,</span><br><span class="line">    &quot;passing_rate_number&quot;: 0.843,</span><br><span class="line">    &quot;solutions&quot;: 381,</span><br><span class="line">    &quot;uri&quot;: &quot;xor-operation-in-an-array&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;problem&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;SJ7bsHwBtcEm-AFPQqjS&quot;</span>, <span class="comment">// 此id便是自动生成的</span></span><br><span class="line">  <span class="attr">&quot;_version&quot;</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;result&quot;</span> : <span class="string">&quot;created&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;_seq_no&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;_primary_term&quot;</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入完文档后，可以看看这个index的信息。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;problem&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;aliases&quot;</span> : &#123; &#125;,</span><br><span class="line">    <span class="comment">// 发现 mappings 信息多了出来，主要是刚刚插入的json串的键的信息，如类型，名称等等</span></span><br><span class="line">    <span class="attr">&quot;mappings&quot;</span> : &#123; </span><br><span class="line">      <span class="attr">&quot;properties&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;difficult_level&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;fields&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;keyword&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;ignore_above&quot;</span> : <span class="number">256</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;id&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;fields&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;keyword&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;ignore_above&quot;</span> : <span class="number">256</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;fields&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;keyword&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;ignore_above&quot;</span> : <span class="number">256</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;passing_rate&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;fields&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;keyword&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;ignore_above&quot;</span> : <span class="number">256</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;passing_rate_number&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;float&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;solutions&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;long&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;uri&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;fields&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;keyword&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;ignore_above&quot;</span> : <span class="number">256</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;settings&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;index&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;routing&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;allocation&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;include&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;_tier_preference&quot;</span> : <span class="string">&quot;data_content&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;number_of_shards&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;provided_name&quot;</span> : <span class="string">&quot;problem&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;creation_date&quot;</span> : <span class="string">&quot;1635053636611&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;number_of_replicas&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;uuid&quot;</span> : <span class="string">&quot;v12NNzubQ1u9g6x9wN9W0A&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;version&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;created&quot;</span> : <span class="string">&quot;7140299&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h4><p>搜索API的最基础的形式是没有指定任何查询的空搜索，它简单地返回集群中所有索引下的所有文档：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;_search</span><br></pre></td></tr></table></figure>



<p>这里我们搜索刚才创建的problem的索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET problem&#x2F;_search</span><br></pre></td></tr></table></figure>



<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;took&quot;</span> : <span class="number">2</span>, <span class="comment">// 执行整个搜索请求耗费了多少毫秒</span></span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span> : <span class="literal">false</span>, <span class="comment">// 是否超时, 可以指定 timeout 为 10 或者 10ms（10毫秒），或者 1s（1秒）如，GET /_search?timeout=10ms</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span> : &#123; <span class="comment">// 在查询中参与分片的总数，以及这些分片成功了多少个失败了多少个</span></span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;skipped&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;hits&quot;</span> : &#123; <span class="comment">// 结果中最重要的部分是 hits</span></span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : &#123; <span class="comment">// 配到的文档总数</span></span><br><span class="line">      <span class="attr">&quot;value&quot;</span> : <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;relation&quot;</span> : <span class="string">&quot;eq&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;max_score&quot;</span> : <span class="number">1.0</span>, <span class="comment">// 查询所匹配文档的 _score 的最大值</span></span><br><span class="line">    <span class="attr">&quot;hits&quot;</span> : [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;problem&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;SJ7bsHwBtcEm-AFPQqjS&quot;</span>, <span class="comment">// 自动生成的id</span></span><br><span class="line">        <span class="attr">&quot;_score&quot;</span> : <span class="number">1.0</span>, <span class="comment">// 衡量了文档与查询的匹配程度,  返回的文档是按照 _score 降序排列的</span></span><br><span class="line">        <span class="attr">&quot;_source&quot;</span> : &#123; <span class="comment">// 源文档，是你自己添加的文档</span></span><br><span class="line">          <span class="attr">&quot;difficult_level&quot;</span> : <span class="string">&quot;简单&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;id&quot;</span> : <span class="string">&quot;1486&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;数组异或操作&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;passing_rate&quot;</span> : <span class="string">&quot;84.3%&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;passing_rate_number&quot;</span> : <span class="number">0.843</span>,</span><br><span class="line">          <span class="attr">&quot;solutions&quot;</span> : <span class="number">381</span>,</span><br><span class="line">          <span class="attr">&quot;uri&quot;</span> : <span class="string">&quot;xor-operation-in-an-array&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html">Elasticsearch: 权威指南（中文）</a></p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.15/index.html">Elasticsearch Guide</a></p>
<p><a href="https://docs.spring.io/spring-data/elasticsearch/docs/current/reference/html/#reference">Spring 整合 Elasticsearch</a></p>
]]></content>
      <categories>
        <category>Elasticsearch</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Buffer Cache 和 Page Cache</title>
    <url>/2021/12/01/Buffer-Cache-%E5%92%8C-Page-Cache/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
  </entry>
  <entry>
    <title>Hadoop入门</title>
    <url>/2021/10/19/Hadoop%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="背景、概念"><a href="#背景、概念" class="headerlink" title="背景、概念"></a>背景、概念</h1><blockquote>
<p>Apache Hadoop 软件库是一个框架，允许使用简单的编程模型跨计算机集群分布式处理大型数据集。它旨在从单个服务器扩展到数千台机器，每台机器都提供本地计算和存储。该库本身不是依靠硬件来提供高可用性，而是设计用于检测和处理应用层的故障，因此在计算机集群之上提供高可用性服务，每台计算机都可能容易出现故障。</p>
</blockquote>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>该项目包括以下模块：</p>
<ul>
<li><strong>Hadoop Common</strong>：支持其他 Hadoop 模块的通用实用程序。</li>
<li><strong>Hadoop 分布式文件系统 (HDFS™)<strong>：提供对应用程序数据的</strong>高吞吐量访问</strong>的<strong>分布式文件系统</strong>。</li>
<li><strong>Hadoop YARN</strong>：用于<strong>作业调度</strong>和<strong>集群资源管理</strong>的框架。</li>
<li><strong>Hadoop MapReduce</strong>：一个基于 YARN 的系统，用于<strong>并行处理大型数据集</strong>。</li>
</ul>
<p><a href="https://hadoop.apache.org/">hadoop官网</a></p>
]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
  </entry>
  <entry>
    <title>AVL与RedBlackTree</title>
    <url>/2021/07/27/AVL%E4%B8%8ERedBlackTree/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="左旋右旋"><a href="#左旋右旋" class="headerlink" title="左旋右旋"></a>左旋右旋</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 右旋</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zig</span><span class="params">(Node *&amp;p)</span> </span>&#123;</span><br><span class="line">    Node *q = p-&gt;left;</span><br><span class="line">    p-&gt;left = q-&gt;right;</span><br><span class="line">    q-&gt;right = p;</span><br><span class="line">    p = q;</span><br><span class="line">    pushUp(p-&gt;right);</span><br><span class="line">    pushUp(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左旋</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zag</span><span class="params">(Node *&amp;q)</span> </span>&#123;</span><br><span class="line">    Node *p = q-&gt;right;</span><br><span class="line">    q-&gt;right = p-&gt;left;</span><br><span class="line">    p-&gt;left = q;</span><br><span class="line">    q = p;</span><br><span class="line">    pushUp(q-&gt;left);</span><br><span class="line">    pushUp(q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<img src="AVL与RedBlackTree/zig-zag.png" style="zoom:20%;" />









<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><h2 id="红黑树的性质"><a href="#红黑树的性质" class="headerlink" title="红黑树的性质"></a>红黑树的性质</h2><ol>
<li>性质1：每个节点要么是黑色，要么是红色。</li>
<li>性质2：根节点是黑色。</li>
<li>性质3：每个叶子节点（NIL）是黑色。</li>
<li>性质4：每个红色结点的两个子结点一定都是黑色。</li>
<li>性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。</li>
</ol>
<p><strong>当然红黑树也必须是二叉搜索树。</strong></p>
<p>总结后的精华就是下面两点：</p>
<ol>
<li><strong>红黑树的性质是每条路径的黑色节点数目相同</strong>;</li>
<li><strong>红黑树保证最长路径不超过最短路径的二倍，因而近似平衡</strong>;</li>
</ol>
<h1 id="AVL"><a href="#AVL" class="headerlink" title="AVL"></a>AVL</h1><h2 id="四种情况"><a href="#四种情况" class="headerlink" title="四种情况"></a>四种情况</h2><h2 id="添加步骤"><a href="#添加步骤" class="headerlink" title="添加步骤"></a>添加步骤</h2><h2 id="删除步骤"><a href="#删除步骤" class="headerlink" title="删除步骤"></a>删除步骤</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by SongyangJi on 2020/11/16.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  这个例子仅仅演示了AVL的基本操作，没有用泛型，只有键，没有值，</span></span><br><span class="line"><span class="comment"> *  并且假定所有数据都不相同。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;binaryTree/BinarySearchTree.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AVL</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 内部节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        Node *left, *right;</span><br><span class="line">        <span class="keyword">int</span> height = <span class="number">1</span>; <span class="comment">// 高度</span></span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> value, Node *left = <span class="literal">nullptr</span>, Node *right = <span class="literal">nullptr</span>)</span><br><span class="line">                : value(value), left(left), right(right) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Node *root = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    AVL() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> query(root, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        insert(root, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        remove(root, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  层次遍历，用来简单的检查</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">displayLayerOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;层次遍历:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;Node *&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            <span class="keyword">while</span> (size--) &#123;</span><br><span class="line">                Node *p = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; p-&gt;value &lt;&lt; <span class="string">&quot;   &quot;</span>;</span><br><span class="line">                q.push(p-&gt;left);</span><br><span class="line">                q.push(p-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getInOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        inOrder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> h(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~AVL() &#123;</span><br><span class="line">        helperDestructor(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//    // 求高度, 规定只有一个节点的高度为 1， 用于求平衡因子</span></span><br><span class="line"><span class="comment">//    int height(Node* t)&#123;</span></span><br><span class="line"><span class="comment">//        if(t == nullptr) return 0;</span></span><br><span class="line"><span class="comment">//        return max(height(t-&gt;left),height(t-&gt;right))+1;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">h</span><span class="params">(Node *t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t ? t-&gt;height : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 平衡因子</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">balance_factor</span><span class="params">(Node *t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> h(t-&gt;left) - h(t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新 p 操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(Node *p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        p-&gt;height = max(h(p-&gt;left), h(p-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 右旋</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">zig</span><span class="params">(Node *&amp;p)</span> </span>&#123;</span><br><span class="line">        Node *q = p-&gt;left;</span><br><span class="line">        p-&gt;left = q-&gt;right;</span><br><span class="line">        q-&gt;right = p;</span><br><span class="line">        p = q;</span><br><span class="line">        pushUp(p-&gt;right);</span><br><span class="line">        pushUp(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左旋</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">zag</span><span class="params">(Node *&amp;q)</span> </span>&#123;</span><br><span class="line">        Node *p = q-&gt;right;</span><br><span class="line">        q-&gt;right = p-&gt;left;</span><br><span class="line">        p-&gt;left = q;</span><br><span class="line">        q = p;</span><br><span class="line">        pushUp(q-&gt;left);</span><br><span class="line">        pushUp(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">  	 * 下面为 AVL树的四种情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// LL型,右旋 左子树的左子树插入节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LL</span><span class="params">(Node *&amp;t)</span> </span>&#123;</span><br><span class="line">        zig(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RR,左旋 右子树的右子树插入节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RR</span><span class="params">(Node *&amp;t)</span> </span>&#123;</span><br><span class="line">        zag(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LR，先左旋后右旋, 新节点位于t的左子树的右子树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LR</span><span class="params">(Node *&amp;t)</span> </span>&#123;</span><br><span class="line">        zag(t-&gt;left);</span><br><span class="line">        zig(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RL, 先右旋后左旋, 新节点位于t的右子树的左子树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RL</span><span class="params">(Node *&amp;t)</span> </span>&#123;</span><br><span class="line">        zig(t-&gt;right);</span><br><span class="line">        zag(t);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 插入操作，不仅要找到插入的位置，还要进行旋转进行高度的平衡</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node *&amp;t, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            t = <span class="keyword">new</span> Node(value);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入完成之后，自下而上的进行调整高度</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (value &lt; t-&gt;value) &#123; <span class="comment">// 向左插入</span></span><br><span class="line">            insert(t-&gt;left, value);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> leftH = h(t-&gt;left);</span><br><span class="line">            <span class="keyword">int</span> rightH = h(t-&gt;right);</span><br><span class="line">            <span class="comment">// 向左边插入，只有可能是 leftH &gt; rightH</span></span><br><span class="line">            <span class="keyword">if</span> (leftH - rightH &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// LL 型</span></span><br><span class="line">                <span class="keyword">if</span> (value &lt;= t-&gt;left-&gt;value) &#123;</span><br><span class="line">                    LL(t);</span><br><span class="line">                    <span class="comment">// LR 型</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; t-&gt;left-&gt;value) &#123;</span><br><span class="line">                    LR(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; t-&gt;value) &#123; <span class="comment">// 向右插入</span></span><br><span class="line">            insert(t-&gt;right, value);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> leftH = h(t-&gt;left);</span><br><span class="line">            <span class="keyword">int</span> rightH = h(t-&gt;right);</span><br><span class="line">						<span class="comment">// 向右边插入，只有可能是 rightH &gt; leftH </span></span><br><span class="line">            <span class="keyword">if</span> (rightH - leftH &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// RR型</span></span><br><span class="line">                <span class="keyword">if</span> (value &gt;= t-&gt;right-&gt;value) &#123;</span><br><span class="line">                    RR(t);</span><br><span class="line">                    <span class="comment">// RL型</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; t-&gt;right-&gt;value) &#123;</span><br><span class="line">                    RL(t);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 自底向上更新 t 的高度</span></span><br><span class="line">        pushUp(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Node *&amp;p, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; p-&gt;value) &#123;</span><br><span class="line"></span><br><span class="line">            remove(p-&gt;left, value);</span><br><span class="line">            <span class="comment">// 删除左子树的节点，唯一可能导致&quot;失衡&quot; 的情况是 bf由 -1 变成-2</span></span><br><span class="line">            <span class="keyword">int</span> bf = balance_factor(p);</span><br><span class="line">            <span class="keyword">if</span> (bf &lt; <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (h(p-&gt;right-&gt;right) &gt;= h(p-&gt;right-&gt;left)) &#123;</span><br><span class="line">                    RR(p);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    RL(p);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; p-&gt;value) &#123;</span><br><span class="line"></span><br><span class="line">            remove(p-&gt;right, value);</span><br><span class="line">            <span class="comment">// 删除右子树的节点，唯一可能导致&quot;失衡&quot; 的情况是 bf由 1 变成 2</span></span><br><span class="line">            <span class="keyword">int</span> bf = balance_factor(p);</span><br><span class="line">            <span class="keyword">if</span> (bf &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (h(p-&gt;left-&gt;left) &gt;= h(p-&gt;left-&gt;right)) &#123;</span><br><span class="line">                    LL(p);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    LR(p);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 下面细分成 3种情况 (左右子树都为空，一棵为空另一棵不为空，都不为空)</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;left == <span class="literal">nullptr</span> &amp;&amp; p-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> p;</span><br><span class="line">                p = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;left != <span class="literal">nullptr</span> &amp;&amp; p-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                Node *temp = p-&gt;left;</span><br><span class="line">                <span class="keyword">delete</span> p;</span><br><span class="line">                p = temp;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;left == <span class="literal">nullptr</span> &amp;&amp; p-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                Node *temp = p-&gt;right;</span><br><span class="line">                <span class="keyword">delete</span> p;</span><br><span class="line">                p = temp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 用前驱的值代替（后继也是一样）</span></span><br><span class="line">                Node *cur = p-&gt;left;</span><br><span class="line">                <span class="keyword">while</span> (cur-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    cur = cur-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                p-&gt;value = cur-&gt;value;</span><br><span class="line"></span><br><span class="line">                remove(p-&gt;left, cur-&gt;value);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 这个地方仍然要有形态的调整</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 删除左子树的节点，唯一可能导致&quot;失衡&quot; 的情况是 bf由 -1 变成-2</span></span><br><span class="line">                <span class="keyword">int</span> bf = balance_factor(p);</span><br><span class="line">                <span class="keyword">if</span> (bf &lt; <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (h(p-&gt;right-&gt;right) &gt;= h(p-&gt;right-&gt;left)) &#123;</span><br><span class="line">                        RR(p);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        RL(p);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 自底向上更新 t 的高度</span></span><br><span class="line">            pushUp(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">query</span><span class="params">(Node *p, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; p-&gt;value) &#123;</span><br><span class="line">            <span class="keyword">return</span> query(p-&gt;left, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; p-&gt;value) &#123;</span><br><span class="line">            <span class="keyword">return</span> query(p-&gt;right, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helperDestructor</span><span class="params">(Node *node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        helperDestructor(node-&gt;left);</span><br><span class="line">        helperDestructor(node-&gt;right);</span><br><span class="line">        <span class="keyword">delete</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node *node, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        inOrder(node-&gt;left, v);</span><br><span class="line">        v.push_back(node-&gt;value);</span><br><span class="line">        inOrder(node-&gt;right, v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AVL avl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= <span class="number">15</span>; x++) &#123;</span><br><span class="line">        avl.insert(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">11</span>,<span class="number">14</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x:v)&#123;</span><br><span class="line">        avl.remove(x);</span><br><span class="line">        avl.displayLayerOrder();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>






<blockquote>
<p>参考链接</p>
<p><a href="https://www.cnblogs.com/skywang12345/p/3245399.html">红黑树(一)之 原理和算法详细介绍</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>HikariCP配置信息</title>
    <url>/2021/08/23/HikariCP%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><table>
<thead>
<tr>
<th><strong>name</strong></th>
<th><strong>描述</strong></th>
<th><strong>构造器默认值</strong></th>
<th><strong>默认配置validate之后的值</strong></th>
<th><strong>validate重置</strong></th>
</tr>
</thead>
<tbody><tr>
<td>autoCommit</td>
<td>自动提交从池中返回的连接</td>
<td>TRUE</td>
<td>TRUE</td>
<td>–</td>
</tr>
<tr>
<td>connectionTimeout</td>
<td>等待来自池的连接的最大毫秒数</td>
<td>SECONDS.toMillis(30) = 30000</td>
<td>30000</td>
<td>如果小于250毫秒，则被重置回30秒</td>
</tr>
<tr>
<td>idleTimeout</td>
<td>连接允许在池中闲置的最长时间</td>
<td>MINUTES.toMillis(10) = 600000</td>
<td>600000</td>
<td>如果idleTimeout+1秒&gt;maxLifetime 且 maxLifetime&gt;0，则会被重置为0（代表永远不会退出）；如果idleTimeout!=0且小于10秒，则会被重置为10秒</td>
</tr>
<tr>
<td>maxLifetime</td>
<td>池中连接最长生命周期</td>
<td>MINUTES.toMillis(30) = 1800000</td>
<td>1800000</td>
<td>如果不等于0且小于30秒则会被重置回30分钟</td>
</tr>
<tr>
<td>connectionTestQuery</td>
<td>如果您的驱动程序支持JDBC4，我们强烈建议您不要设置此属性</td>
<td>null</td>
<td>null</td>
<td>–</td>
</tr>
<tr>
<td>minimumIdle</td>
<td>池中维护的最小空闲连接数</td>
<td>-1</td>
<td>10</td>
<td>minIdle&lt;0或者minIdle&gt;maxPoolSize,则被重置为maxPoolSize</td>
</tr>
<tr>
<td>maximumPoolSize</td>
<td>池中最大连接数，包括闲置和使用中的连接</td>
<td>-1</td>
<td>10</td>
<td>如果maxPoolSize小于1，则会被重置。当minIdle&lt;=0被重置为DEFAULT_POOL_SIZE则为10;如果minIdle&gt;0则重置为minIdle的值</td>
</tr>
<tr>
<td>metricRegistry</td>
<td>该属性允许您指定一个 Codahale / Dropwizard MetricRegistry 的实例，供池使用以记录各种指标</td>
<td>null</td>
<td>null</td>
<td>–</td>
</tr>
<tr>
<td>healthCheckRegistry</td>
<td>该属性允许您指定池使用的Codahale / Dropwizard HealthCheckRegistry的实例来报告当前健康信息</td>
<td>null</td>
<td>null</td>
<td>–</td>
</tr>
<tr>
<td>poolName</td>
<td>连接池的用户定义名称，主要出现在日志记录和JMX管理控制台中以识别池和池配置</td>
<td>null</td>
<td>HikariPool-1</td>
<td>–</td>
</tr>
<tr>
<td>initializationFailTimeout</td>
<td>如果池无法成功初始化连接，则此属性控制池是否将 fail fast</td>
<td>1</td>
<td>1</td>
<td>–</td>
</tr>
<tr>
<td>isolateInternalQueries</td>
<td>是否在其自己的事务中隔离内部池查询，例如连接活动测试</td>
<td>FALSE</td>
<td>FALSE</td>
<td>–</td>
</tr>
<tr>
<td>allowPoolSuspension</td>
<td>控制池是否可以通过JMX暂停和恢复</td>
<td>FALSE</td>
<td>FALSE</td>
<td>–</td>
</tr>
<tr>
<td>readOnly</td>
<td>从池中获取的连接是否默认处于只读模式</td>
<td>FALSE</td>
<td>FALSE</td>
<td>–</td>
</tr>
<tr>
<td>registerMbeans</td>
<td>是否注册JMX管理Bean（MBeans）</td>
<td>FALSE</td>
<td>FALSE</td>
<td>–</td>
</tr>
<tr>
<td>catalog</td>
<td>为支持 catalog 概念的数据库设置默认 catalog</td>
<td>driver default</td>
<td>null</td>
<td>–</td>
</tr>
<tr>
<td>connectionInitSql</td>
<td>该属性设置一个SQL语句，在将每个新连接创建后，将其添加到池中之前执行该语句。</td>
<td>null</td>
<td>null</td>
<td>–</td>
</tr>
<tr>
<td>driverClassName</td>
<td>HikariCP将尝试通过仅基于jdbcUrl的DriverManager解析驱动程序，但对于一些较旧的驱动程序，还必须指定driverClassName</td>
<td>null</td>
<td>null</td>
<td>–</td>
</tr>
<tr>
<td>transactionIsolation</td>
<td>控制从池返回的连接的默认事务隔离级别</td>
<td>null</td>
<td>null</td>
<td>–</td>
</tr>
<tr>
<td>validationTimeout</td>
<td>连接将被测试活动的最大时间量</td>
<td>SECONDS.toMillis(5) = 5000</td>
<td>5000</td>
<td>如果小于250毫秒，则会被重置回5秒</td>
</tr>
<tr>
<td>leakDetectionThreshold</td>
<td>记录消息之前连接可能离开池的时间量，表示可能的连接泄漏</td>
<td>0</td>
<td>0</td>
<td>如果大于0且不是单元测试，则进一步判断：(leakDetectionThreshold &lt; SECONDS.toMillis(2) or (leakDetectionThreshold &gt; maxLifetime &amp;&amp; maxLifetime &gt; 0)，会被重置为0 . 即如果要生效则必须&gt;0，而且不能小于2秒，而且当maxLifetime &gt; 0时不能大于maxLifetime</td>
</tr>
<tr>
<td>dataSource</td>
<td>这个属性允许你直接设置数据源的实例被池包装，而不是让HikariCP通过反射来构造它</td>
<td>null</td>
<td>null</td>
<td>–</td>
</tr>
<tr>
<td>schema</td>
<td>该属性为支持模式概念的数据库设置默认模式</td>
<td>driver default</td>
<td>null</td>
<td>–</td>
</tr>
<tr>
<td>threadFactory</td>
<td>此属性允许您设置将用于创建池使用的所有线程的java.util.concurrent.ThreadFactory的实例。</td>
<td>null</td>
<td>null</td>
<td>–</td>
</tr>
<tr>
<td>scheduledExecutor</td>
<td>此属性允许您设置将用于各种内部计划任务的java.util.concurrent.ScheduledExecutorService实例</td>
<td>null</td>
<td>null</td>
<td>–</td>
</tr>
</tbody></table>
<blockquote>
<p> <a href="https://github.com/brettwooldridge/HikariCP">HikariCP on github</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>Spring之整合一切</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP协议</title>
    <url>/2021/11/26/HTTP/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="HTTP头部"><a href="#HTTP头部" class="headerlink" title="HTTP头部"></a>HTTP头部</h2><p>HTTP 头部本质上是一个传递额外重要信息的键值对。</p>
<p>主要分为：通用头部，请求头部，响应头部和实体头部。</p>
<ol>
<li>通用头：是客户端和服务器都可以使用的头部，可以在客户端、服务器和其他应用程序之间提供一些非常有用的通用功能，如Date头部。</li>
<li>请求头：请求报文特有的，它们为服务器提供了一些额外信息，比如客户端希望接收什么类型的数据，如Accept头部。</li>
<li>响应头：响应报文特有的，比如，客服端在与哪种类型的服务器进行交互，如Server头部。</li>
<li>实体头：实体首部字段是包含在请求报文和响应报文中的实体部分使用的首部，用于补充内容的更新时间等与实体相关的信息。</li>
</ol>
<h3 id="通用头部"><a href="#通用头部" class="headerlink" title="通用头部"></a>通用头部</h3><table>
<thead>
<tr>
<th>协议头</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cache-Control</td>
<td>用来指定当前的请求/回复中是否使用缓存机制</td>
<td>Cache-Control: no-store</td>
</tr>
<tr>
<td>Connection</td>
<td>客户端（浏览器）想要优先使用的连接类型</td>
<td>Connection: keep-alive (Upgrade)</td>
</tr>
<tr>
<td>Date</td>
<td>报文创建时间</td>
<td>Date: Dec, 26 Dec 2015 17: 30: 00 GMT</td>
</tr>
<tr>
<td>Trailer</td>
<td>会实现说明在报文主体后记录哪些首部字段，该首部字段可以使用在 HTTP/1.1 版本分块传输编码时</td>
<td>Trailer: Expiress</td>
</tr>
<tr>
<td>Transfer-Encoding</td>
<td>用来改变报文格式</td>
<td>Transfer-Encoding: chunked</td>
</tr>
<tr>
<td>Upgrade</td>
<td>要求服务器升级到一个高版本协议</td>
<td>Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td>
</tr>
<tr>
<td>Via</td>
<td>告诉服务器，这个请求是由哪些代理发出的</td>
<td>Via: 1.0 fred, 1.1 <a href="http://itbilu.com.com" target="_blank">itbilu.com.com</a> (Apache/1.1)</td>
</tr>
<tr>
<td>Warning</td>
<td>一个一般性的警告，表示在实体内容中可能存在错误</td>
<td>Warning: 199 Miscellaneous warning</td>
</tr>
</tbody>
</table>



<p>比较重要的有 <code>Cache-Control</code>、<code>Connection</code>。</p>
<h3 id="请求头部"><a href="#请求头部" class="headerlink" title="请求头部"></a>请求头部</h3><table>
<thead>
<tr>
<th>协议头</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept</td>
<td>告诉服务器自己允许哪些媒体类型</td>
<td>Accept: text/plain</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>浏览器申明可接受的字符集</td>
<td>Accept-Charset: utf-8</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>浏览器申明自己接收的编码方法</td>
<td>Accept-Encoding: gzip, deflate</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>浏览器可接受的响应内容语言列表</td>
<td>Accept-Language: en-US</td>
</tr>
<tr>
<td>Authorization</td>
<td>用于表示 HTTP 协议中需要认证资源的认证信息</td>
<td>Authorization: Basic OSdjJGRpbjpvcGVul ANIc2SdDE==</td>
</tr>
<tr>
<td>Expect</td>
<td>表示客户端要求服务器做出特定的行为</td>
<td>Expect: 100-continue</td>
</tr>
<tr>
<td>From</td>
<td>发起此请求的用户的邮件地址</td>
<td>From: <a href="mailto:user@itbilu.com" target="_blank">user@itbilu.com</a></td>
</tr>
<tr>
<td>Host</td>
<td>表示服务器的域名以及服务器所监听的端口号</td>
<td>Host: <a href="http://www.itbilu.com:80" target="_blank">www.itbilu.com:80</a></td>
</tr>
<tr>
<td>If-XXX</td>
<td>条件请求</td>
<td>If-Modified-Since: Dec, 26 Dec 2015 17:30:00 GMT</td>
</tr>
<tr>
<td>Max-Forwards</td>
<td>限制该消息可被代理及网关转发的次数</td>
<td>Max-Forwards: 10</td>
</tr>
<tr>
<td>Range</td>
<td>表示请求某个实体的一部分，字节偏移以 0 开始</td>
<td>Range: bytes=500-999</td>
</tr>
<tr>
<td>Referer</td>
<td>表示浏览器所访问的前一个页面，可以认为是之前访问页面的链接将浏览器带到了当前页面</td>
<td>Referer: <a href="http://itbilu.com/nodejs" target="_blank">http://itbilu.com/nodejs</a></td>
</tr>
<tr>
<td>User-Agent</td>
<td>浏览器的身份标识字符串</td>
<td>User-Agent: Mozilla/……</td>
</tr>
</tbody>
</table>


<p>比较重要的有<code>Referer</code>、<code>User-Agent</code></p>
<h3 id="响应头部"><a href="#响应头部" class="headerlink" title="响应头部"></a>响应头部</h3><table>
<thead>
<tr>
<th>协议头</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept-Ranges</td>
<td>字段的值表示可用于定义范围的单位</td>
<td>Accept-Ranges: bytes</td>
</tr>
<tr>
<td>Age</td>
<td>创建响应的时间</td>
<td>Age：5744337</td>
</tr>
<tr>
<td>ETag</td>
<td>唯一标识分配的资源</td>
<td>Etag：W/"585cd998-7c0f"</td>
</tr>
<tr>
<td>Location</td>
<td>表示重定向后的 URL</td>
<td>Location: <a href="http://www.zcmhi.com/archives/94.html" target="_blank">http://www.zcmhi.com/archives/94.html</a></td>
</tr>
<tr>
<td>Retry-After</td>
<td>告知客户端多久后再发送请求</td>
<td>Retry-After: 120</td>
</tr>
<tr>
<td>Server</td>
<td>告知客户端服务器信息</td>
<td>Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)</td>
</tr>
<tr>
<td>Vary</td>
<td>缓存控制</td>
<td>Vary: Origin</td>
</tr>
</tbody>
</table>


<p>比较重要的有<code>Referer</code>、<code>User-Agent</code></p>
<h3 id="实体头部"><a href="#实体头部" class="headerlink" title="实体头部"></a>实体头部</h3><table>
<thead>
<tr>
<th>协议头</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>Allow</td>
<td>对某网络资源的有效的请求行为，不允许则返回405</td>
<td>Allow: GET, HEAD</td>
</tr>
<tr>
<td>Content-encoding</td>
<td>返回内容的编码方式</td>
<td>Content-Encoding: gzip</td>
</tr>
<tr>
<td>Content-Length</td>
<td>返回内容的字节长度</td>
<td>Content-Length: 348</td>
</tr>
<tr>
<td>Content-Language</td>
<td>响应体的语言</td>
<td>Content-Language: en,zh</td>
</tr>
<tr>
<td>Content-Location</td>
<td>请求资源可替代的备用的另一地址</td>
<td>Content-Location: /index.htm</td>
</tr>
<tr>
<td>Content-MD5</td>
<td>返回资源的MD5校验值</td>
<td>Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</td>
</tr>
<tr>
<td>Content-Range</td>
<td>在整个返回体中本部分的字节位置</td>
<td>Content-Range: bytes 21010-47021/47022</td>
</tr>
<tr>
<td>Content-Type</td>
<td>返回内容的MIME类型</td>
<td>Content-Type: text/html; charset=utf-8</td>
</tr>
<tr>
<td>Expires</td>
<td>响应过期的日期和时间</td>
<td>Expires: Thu, 01 Dec 2010 16:00:00 GMT</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>请求资源的最后修改时间</td>
<td>Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT</td>
</tr>
</tbody>
</table>


<p>比较重要的有<code>Content-encoding</code>、<code>Content-Length</code>、<code>Content-Type</code></p>
<h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><p>HTTP 状态码由三个十进制数字组成，第一个数字定义了状态码的类型，后两个并没有起到分类的作用。HTTP 状态码共有 5 种类型：</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1XX</td>
<td>指示信息–表示请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td><strong>成功</strong>–表示请求已被成功处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td><strong>重定向</strong>–要完成的请求需要进行附加操作</td>
</tr>
<tr>
<td>4XX</td>
<td><strong>客户端错误</strong>–请求有语法错误或者请求无法实现，服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td><strong>服务器端错误</strong>–服务器处理请求出现错误</td>
</tr>
</tbody></table>
<p>下面是常用的状态码分类：</p>
<h3 id="1xx"><a href="#1xx" class="headerlink" title="1xx"></a>1xx</h3><p>1xx 类状态码属于提示信息，是协议处理中的⼀种中间状态，实际⽤到的⽐较少。</p>
<h3 id="2xx"><a href="#2xx" class="headerlink" title="2xx"></a>2xx</h3><p>2xx 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。</p>
<p>「<strong>200 OK</strong>」是最常⻅的成功状态码，表示⼀切正常。如果是⾮ HEAD 请求，服务器返回的响应头都会有 body</p>
<p>数据。</p>
<p>「<strong>204 No Content</strong>」也是常⻅的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。「<strong>206 Partial Content</strong>」是应⽤于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，⽽</p>
<p>是其中的⼀部分，也是服务器处理成功的状态。</p>
<h3 id="3xx"><a href="#3xx" class="headerlink" title="3xx"></a>3xx</h3><p>3xx 类状态码表示客户端请求的资源发送了变动，需要客户端⽤新的 URL ᯿新发送请求获取资源，也就是重定</p>
<p>向。</p>
<p>「<strong>301 Moved Permanently</strong>」表示永久᯿定向，说明请求的资源已经不存在了，需改⽤新的 URL 再次访问。</p>
<p>「<strong>302 Found</strong>」表示临时᯿定向，说明请求的资源还在，但暂时需要⽤另⼀个 URL 来访问。</p>
<p>301 和 302 都会在响应头⾥使⽤字段 Location ，指明后续要跳转的 URL，浏览器会⾃动᯿定向新的 URL。 </p>
<p>「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，᯿定向已存在的缓冲⽂件，也称缓存᯿定向，⽤于缓</p>
<p>存控制。</p>
<h3 id="4xx"><a href="#4xx" class="headerlink" title="4xx"></a>4xx</h3><p>4xx 类状态码表示客户端发送的报⽂有误，服务器⽆法处理，也就是错误码的含义。</p>
<p>「<strong>400 Bad Request</strong>」表示客户端请求的报⽂有错误，但只是个笼统的错误。</p>
<p>「<strong>403 Forbidden</strong>」表示服务器禁⽌访问资源，并不是客户端的请求出错。</p>
<p>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以⽆法提供给客户端。</p>
<h3 id="5xx"><a href="#5xx" class="headerlink" title="5xx"></a>5xx</h3><p>5xx 类状态码表示客户端请求报⽂正确，但是服务器处理时内部发⽣了错误，属于服务器端的错误码。</p>
<p>「<strong>500 Internal Server Error</strong>」与 400 类型，是个笼统通⽤的错误码，服务器发⽣了什么错误，我们并不知道。</p>
<p>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不⽀持，类似“即将开业，敬请期待”的意思。</p>
<p>「<strong>502 Bad Gateway</strong>」通常是服务器作为⽹关或代理时返回的错误码，表示服务器⾃身⼯作正常，访问后端服务器</p>
<p>发⽣了错误。</p>
<p>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时⽆法响应服务器，类似“⽹络服务正忙，请稍后᯿试”的意</p>
<p>思。</p>
<h2 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h2><p>HTTP/0.9 只定义了一种方法: GET。</p>
<p>HTTP/1.0 定义了三种请求方法：GET, POST 和 HEAD 方法。</p>
<p>HTTP/1.1 增加了六种请求方法：OPTIONS, PUT, PATCH, DELETE, TRACE 和 CONNECT 方法。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>请求指定的页面信息，并返回具体内容，通常只用于读取数据。</td>
</tr>
<tr>
<td>HEAD</td>
<td>类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头。</td>
</tr>
<tr>
<td>POST</td>
<td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立或已有资源的更改。</td>
</tr>
<tr>
<td>PUT</td>
<td>替换指定的资源，没有的话就新增。</td>
</tr>
<tr>
<td>DELETE</td>
<td>请求服务器删除 URL 标识的资源数据。</td>
</tr>
<tr>
<td>CONNECT</td>
<td>将服务器作为代理，让服务器代替用户进行访问。</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>向服务器发送该方法，会返回对指定资源所支持的 HTTP 请求方法。</td>
</tr>
<tr>
<td>TRACE</td>
<td>回显服务器收到的请求数据，即服务器返回自己收到的数据，主要用于测试和诊断。</td>
</tr>
<tr>
<td>PATCH</td>
<td>是对 PUT 方法的补充，用来对已知资源进行局部更新。</td>
</tr>
</tbody>
</table>



<p>用的最多的自然是<code>GET</code>、<code>POST</code>了， 甚至有一种观点认为只需要使用POST就够了。</p>
<h3 id="GET-和-POST-的区别"><a href="#GET-和-POST-的区别" class="headerlink" title="GET 和 POST 的区别"></a>GET 和 POST 的区别</h3><ul>
<li>get 提交的数据会放在 URL 之后，并且<strong>请求参数会被完整的保留在浏览器的记录</strong>里，由于<strong>参数直接暴露在 URL 中</strong>，可能会存在安全问题，因此往往用于获取资源信息。GET上要在url之外带一些参数就只能依靠url上附带querystring。</li>
<li>编码格式： get 请求只支持 URL 编码，post 请求支持多种编码格式。</li>
<li>字符集：get 只支持 ASCII 字符格式的参数，而 post 方法没有限制。</li>
<li>数据大小：get 提交的数据大小有限制（这里所说的限制是浏览器带来的，一般都限制在几千），而 post 方法提交的数据没限制</li>
<li>get 方式需要使用 queryString 来取得变量的值，而 post 方式通过将body解析成实体类来获取（当然还有其他的方式）。</li>
<li>TCP数据包：get 方法产生一个 TCP 数据包，post 方法产生两个（并不是所有的浏览器中都产生两个）。</li>
</ul>
<h2 id="特点（优点和缺点）"><a href="#特点（优点和缺点）" class="headerlink" title="特点（优点和缺点）"></a>特点（优点和缺点）</h2><h2 id="HTTP-如何保存状态"><a href="#HTTP-如何保存状态" class="headerlink" title="HTTP 如何保存状态"></a>HTTP 如何保存状态</h2><p>因为一个 HTTP 服务器并不保存关于客户机的任何信息，所以我们说 HTTP 是一个无状态协议。</p>
<p>通常有两种解决方案：</p>
<p>① <strong>基于 Session 实现的会话保持</strong></p>
<p>在客户端第一次向服务器发送 HTTP 请求后，<strong>服务器会创建一个 Session 对象并将客户端的身份信息以键值对的形式存储下来</strong>，然后<strong>分配一个会话标识（SessionId）给客户端</strong>，这个<strong>会话标识一般保存在客户端 Cookie 中</strong>，之后每次该浏览器<strong>发送 HTTP 请求都会带上 Cookie 中的 SessionId 到服务器</strong>，服务器根据会话标识就可以将之前的状态信息与会话联系起来，从而实现会话保持。</p>
<ul>
<li><p>优点：<strong>安全性高</strong>，因为状态信息保存在服务器端。</p>
</li>
<li><p><strong>缺点</strong>：**水平拓展差，由于大型网站往往采用的是分布式服务器，浏览器发送的 HTTP 请求一般要先通过负载均衡器才能到达具体的后台服务器，倘若同一个浏览器两次 HTTP 请求分别落在不同的服务器上时，基于 Session 的方法就不能实现会话保持了。</p>
</li>
</ul>
<p>【解决方法：<strong>采用中间件</strong>，例如 Redis，我们通过<strong>将 Session 的信息存储在 Redis 中</strong>，使得每个服务器都可以访问到之前的状态信息】</p>
<p>② <strong>基于 Cookie 实现的会话保持</strong></p>
<p>当服务器发送响应消息时，在 HTTP 响应头中设置 Set-Cookie 字段，用来存储客户端的状态信息。客户端解析出 HTTP 响应头中的字段信息，并根据其生命周期创建不同的 Cookie，这样一来每次浏览器发送 HTTP 请求的时候都会带上 Cookie 字段，从而实现状态保持。</p>
<p><strong>基于 Cookie 的会话保持与基于 Session 实现的会话保持最主要的区别是前者完全将会话状态信息存储在浏览器 Cookie 中。</strong></p>
<p><strong>优点</strong>：<strong>服务器无状态</strong>， 减轻服务器存储压力，同时便于服务端做水平拓展。</p>
<p><strong>缺点</strong>：该<strong>方式不够安全</strong>，因为状态信息存储在客户端，这意味着不能在会话中保存机密数据。除此之外，浏览器每次发起 HTTP 请求时都需要发送额外的 Cookie 到服务器端，会<strong>占用更多带宽</strong>。</p>
<p><strong>拓展：Cookie被禁用了怎么办？</strong></p>
<p>若遇到 Cookie 被禁用的情况，则可以通过重写 URL 的方式将会话标识放在 URL 的参数里，也可以实现会话保持。</p>
<blockquote>
<p><strong>URL重写</strong>（英语：URL Rewriting）是一种REST的相关技术，它可以在Web Server中，针对用户所提供的URL进行转换后，再传入Web Server中的程序处理器。</p>
<p>如果浏览器不支持Cookie或用户阻止了所有Cookie，可以把会话ID附加在HTML页面中所有的URL上，这些页面作为响应发送给客户。这样，当用户单击URL时，会话ID被自动作为请求行的一部分而不是作为头行发送回服务器。这种方法称为URL重写(URL rewriting)。</p>
</blockquote>
<p>详细参考<a href="https://zh.wikipedia.org/wiki/URL%E9%87%8D%E5%AF%AB">URL重写</a></p>
<h1 id="HTTP-与-HTTPs"><a href="#HTTP-与-HTTPs" class="headerlink" title="HTTP 与 HTTPs"></a>HTTP 与 HTTPs</h1><p>HTTPS 采用对称加密和非对称加密相结合的方式，首先使用 SSL/TLS 协议进行加密传输，为了弥补非对称加密的缺点，HTTPS <strong>①采用证书来进一步加强非对称加密的安全性</strong>，<strong>②使用非对称加密交换后面通信传输用到的<em>会话密钥</em></strong>，<strong>③后续的所有信息都通过使用该对称秘钥进行加密解密</strong>，完成整个 HTTPS 的流程。</p>
<h2 id="HTTP-与-HTTPS的区别"><a href="#HTTP-与-HTTPS的区别" class="headerlink" title="HTTP 与 HTTPS的区别"></a>HTTP 与 HTTPS的区别</h2><ol>
<li><strong>HTTP 是超⽂本传输协议，信息是明⽂传输</strong>，存在安全⻛险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在<br>TCP 和 HTTP ⽹络层之间加⼊了<em>SSL/TLS</em>安全协议，使得<strong>报⽂能够加密传输</strong>。</li>
<li>HTTP 连接建⽴相对简单， TCP 三次握⼿之后便可进⾏ HTTP 的报⽂传输。⽽ <strong>HTTPS 在 TCP 三次握⼿之</strong></li>
</ol>
<p><strong>后，还需进⾏ SSL/TLS 的握⼿过程</strong>，才可进⼊加密报⽂传输。<br>3. HTTP 的端⼝号是 80，HTTPS 的端⼝号是 443。<br>4. HTTPS 协议需要<strong>向 CA（证书权威机构）申请数字证书</strong>，来保证服务器的身份是可信的。</p>
<blockquote>
<p>SSL 是 “<em>Secure Sockets Layer</em> 的缩写，中⽂叫做「安全套接层」。它是在上世纪 90 年代中期，由⽹景公司</p>
<p>设计的。</p>
<p>到了1999年，SSL 因为应⽤⼴泛，已经成为互联⽹上的事实标准。IETF 就在那年把 SSL 标准化。标准化之后的名</p>
<p>称改为 TLS（是 “<em>Transport Layer Security</em>” 的缩写），中⽂叫做 「传输层安全协议」。</p>
<p>很多相关的⽂章都把这两者并列称呼（SSL/TLS），因为这两者可以视作同⼀个东⻄的不同阶段。</p>
</blockquote>
<h2 id="HTTPS-解决了-HTTP-的哪些问题"><a href="#HTTPS-解决了-HTTP-的哪些问题" class="headerlink" title="HTTPS 解决了 HTTP 的哪些问题"></a>HTTPS 解决了 HTTP 的哪些问题</h2><p>HTTP 由于是明⽂传输，所以安全上存在以下三个⻛险：</p>
<ol>
<li><p>窃听⻛险，⽐如通信链路上可以获取通信内容；</p>
</li>
<li><p>篡改⻛险，⽐如强制植⼊垃圾⼴告；</p>
</li>
<li><p>冒充⻛险，⽐如冒充淘宝⽹站。</p>
</li>
</ol>
<img src="https1.png" style="zoom:80%;" />





<p>HTTP<strong>S</strong> 在 HTTP 与 TCP 层之间加⼊了 SSL/TLS 协议，可以很好的解决了上述的⻛险：</p>
<p>信息加密：交互信息⽆法被窃取。</p>
<p>校验机制：⽆法篡改通信内容，篡改了就不能正常显示。</p>
<p>身份证书：证明淘宝是真的淘宝⽹。</p>
<blockquote>
<p>HTTPS 是如何解决上⾯的三个⻛险的？</p>
</blockquote>
<ul>
<li><p><strong>混合加密</strong>的⽅式实现信息的<strong>机密性</strong>，解决了窃听的⻛险。</p>
</li>
<li><p><strong>摘要算法</strong>的⽅式来实现<strong>完整性</strong>，它能够为数据⽣成独⼀⽆⼆的<em>指纹</em>，指纹⽤于校验数据的完整性，解决</p>
</li>
</ul>
<p>了篡改的⻛险。</p>
<ul>
<li>将服务器公钥放⼊到<strong>数字证书</strong>中，解决了<strong>冒充⻛险</strong>。</li>
</ul>
<blockquote>
<p>这部分内容可以参考 <a href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html">数字签名是什么？</a></p>
</blockquote>
<h3 id="1-混合加密"><a href="#1-混合加密" class="headerlink" title="1. 混合加密"></a>1. 混合加密</h3><img src="秘钥.png" style="zoom:80%;" />





<p>HTTPS 采⽤的是对称加密和⾮对称加密结合的<strong>混合加密</strong>⽅式：</p>
<ul>
<li><p>在通信建⽴前采⽤⾮对称加密的⽅式交换<strong>会话秘钥</strong>，后续就不再使⽤⾮对称加密。</p>
</li>
<li><p>在通信过程中全部使⽤对称加密的<strong>会话秘钥</strong>加密明⽂数据。</p>
</li>
</ul>
<p>采⽤「混合加密」的⽅式的原因：</p>
<ul>
<li><p><strong>对称加密只使⽤⼀个密钥，运算速度快</strong>，密钥必须保密，<strong>但⽆法做到安全的密钥交换</strong>。</p>
</li>
<li><p><strong>⾮对称加密使⽤两个密钥</strong>：公钥和私钥，公钥可以任意分发⽽私钥保密，<strong>解决了密钥交换问题但速度慢</strong>。</p>
</li>
</ul>
<h3 id="2-摘要算法"><a href="#2-摘要算法" class="headerlink" title="2. 摘要算法"></a>2. 摘要算法</h3><p><strong>摘要算法</strong>⽤来实现完整性，能够为数据⽣成独⼀⽆⼆的<em>指纹</em>，<strong>⽤于校验数据的完整性</strong>，解决了篡改的⻛险。</p>
<img src="摘要.png" style="zoom:80%;" />



<p>客户端在发送明⽂之前会通过摘要算法算出明⽂的「指纹」，发送的时候把「指纹 + 明⽂」⼀同加密成密⽂后，发</p>
<p>送给服务器，服务器解密后，⽤相同的摘要算法算出发送过来的明⽂，通过⽐较客户端携带的「指纹」和当前算出</p>
<p>的「指纹」做⽐较，若「指纹」相同，说明数据是完整的。</p>
<h3 id="3-数字证书"><a href="#3-数字证书" class="headerlink" title="3. 数字证书"></a>3. 数字证书</h3><p>客户端先向服务器端索要公钥，然后⽤公钥加密信息，服务器收到密⽂后，⽤⾃⼰的私钥解密。</p>
<p>这就存在些问题，如何保证公钥不被篡改和信任度？</p>
<p>所以这⾥就需要借助第三⽅权威机构 CA （certificate authority  数字证书认证机构），<strong>将服务器公钥放在数字证书</strong>（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。</p>
<img src="数字证书.png" style="zoom:70%;" />



<p>通过数字证书的⽅式保证服务器公钥的身份，解决冒充的⻛险。</p>
<h3 id="名词总结"><a href="#名词总结" class="headerlink" title="名词总结"></a>名词总结</h3><ol>
<li>秘钥：某个用来完成加密、解密、完整性验证等密码学应用的秘密信息。在对称加密中加密解密使用的是同一个秘钥；在非对称加密中，又分为公钥和私钥。</li>
<li>摘要：根据一定的运算规则对原数据进行某种形式的提取，这种提取就是摘要。可以用于数据完整性验证。由于摘要算法不可逆，理论上无法通过反向运算取得原数据内容。摘要算法有MD5等。</li>
<li>数字签名：一种功能类似写在纸上的普通签名、但是使用了<em>公钥加密</em> 领域的技术，以用于鉴别数字信息的方法。数字签名算法是依靠<em>公钥加密技术</em>来实现的。RSA等算法可以实现数字签名。</li>
<li>数字证书：由证书中心（Certificate Authority）颁发的用于标志通讯各方身份信息的一个数字认证。在SSL中，①服务器将自己的公钥和自身的其他信息向CA注册，②CA再用自己的私钥加密成数字证书颁发给，③然后客户端再用CA的私钥去解密数字证书，如果合法就可以得到可靠的服务器的公钥。</li>
</ol>
<h3 id="客户端为什么信任第三方证书"><a href="#客户端为什么信任第三方证书" class="headerlink" title="客户端为什么信任第三方证书"></a>客户端为什么信任第三方证书</h3><ol>
<li><p>没有CA的私钥无法篡改签名<br><strong>假设中间人篡改了证书原文，由于他没有 CA 机构的私钥，所以无法得到此时加密后的签名，因此无法篡改签名。</strong>客户端浏览器收到该证书后会发现原文和签名解密后的值不一致，则说明证书被中间人篡改，证书不可信，从而终止向服务器传输信息。</p>
</li>
<li><p>替换证书但是域名不一致<br>上述过程说明证书无法被篡改，我们考虑更严重的情况，例如中间人拿到了 CA 机构认证的证书，它想窃取网站 A 发送给客户端的信息，于是它成为中间人拦截到了 A 传给客户端的证书，然后将其替换为自己的证书。此时客户端浏览器收到的是被中间人掉包后的证书，但由于证书里包含了客户端请求的网站信息，因此客户端浏览器只需要把证书里的域名与自己请求的域名比对一下就知道证书有没有被掉包了。</p>
</li>
</ol>
<p>CA之所以是CA，就是因为它是普遍被大家接受的权威结构，里面罗列着一些普遍被大家认可的证书，而这些通常会内置在浏览器中。</p>
<p>如果CA不被信任或者CA带头作恶，那相当于法官带头犯罪，什么手段都规避不了。</p>
<h2 id="HTTP-与-HTTPs-的工作方式（建立连接的过程）"><a href="#HTTP-与-HTTPs-的工作方式（建立连接的过程）" class="headerlink" title="HTTP 与 HTTPs 的工作方式（建立连接的过程）"></a>HTTP 与 HTTPs 的工作方式（建立连接的过程）</h2><h3 id="HTTP-1"><a href="#HTTP-1" class="headerlink" title="HTTP"></a>HTTP</h3><p>HTTP 使用 TCP（而不是 UDP）作为它的支撑运输层协议。其默认工作在 TCP 协议 80 端口，HTTP 客户机发起一个与服务器的 TCP 连接，一旦连接建立，浏览器和服务器进程就可以通过套接字接口访问 TCP。客户机从套接字接口发送 HTTP 请求报文和接收 HTTP 响应报文。类似地，服务器也是从套接字接口接收 HTTP 请求报文和发送 HTTP 响应报文。其通信内容以明文的方式发送，不通过任何方式的数据加密。当通信结束时，客户端与服务器关闭连接。</p>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>HTTPS 协议基本流程：</p>
<ol>
<li><p>客户端<strong>向服务器索要并验证服务器的公钥</strong>。</p>
</li>
<li><p><strong>双⽅协商⽣产「会话秘钥」</strong>。</p>
</li>
<li><p><strong>双⽅采⽤「会话秘钥」进⾏加密通信</strong>。</p>
</li>
</ol>
<h4 id="SSL-TLS-建立过程"><a href="#SSL-TLS-建立过程" class="headerlink" title="SSL/TLS 建立过程"></a>SSL/TLS 建立过程</h4><p>前两步也就是 SSL/TLS 的建⽴过程，也就是握⼿阶段。</p>
<p>SSL/TLS 的「握⼿阶段」涉及四次通信，可⻅下图：</p>
<p><img src="/2021/11/26/HTTP/SSL.png"></p>
<p>SSL/TLS 协议建⽴的详细流程：</p>
<p><em>1. ClientHello</em></p>
<p>⾸先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求。</p>
<p>在这⼀步，客户端主要向服务器发送以下信息：</p>
<p>（1）客户端⽀持的 SSL/TLS 协议版本，如 TLS 1.2 版本。</p>
<p>（2）客户端⽣产的随机数（ Client Random ），后⾯⽤于⽣产「会话秘钥」。</p>
<p>（3）客户端⽀持的密码套件列表，如 RSA 加密算法。</p>
<p><em>2. SeverHello</em></p>
<p>服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello 。服务器回应的内容有如下内容：</p>
<p>（1）确认 SSL/ TLS 协议版本，如果浏览器不⽀持，则关闭加密通信。</p>
<p>（2）服务器⽣产的随机数（ Server Random ），后⾯⽤于⽣产「会话秘钥」。</p>
<p>（3）确认的密码套件列表，如 RSA 加密算法。</p>
<p>（4）<strong>服务器的数字证书</strong>。</p>
<p><em>3.</em> 客户端回应</p>
<p>客户端收到服务器的回应之后，<strong>⾸先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性</strong>。</p>
<p>如果证书没有问题，客户端会<strong>从数字证书中取出服务器的公钥</strong>，然后<strong>使⽤它加密报⽂</strong>，向服务器发送如下信息：</p>
<p>（1）<strong>⼀个随机数（ pre-master key ）</strong>。该随机数会被服务器公钥加密。</p>
<p>（2）<strong>加密通信算法改变通知，表示随后的信息都将⽤「会话秘钥」加密通信。</strong></p>
<p>（3）客户端握⼿结束通知，表示客户端的握⼿阶段已经结束。这⼀项同时<strong>把之前所有内容的发⽣的数据做个摘</strong></p>
<p><strong>要，⽤来供服务端校验</strong>。</p>
<p>上⾯第⼀项的随机数是整个握⼿阶段的第三个随机数，这样<strong>服务器和客户端就同时有三个随机数</strong>，接着就⽤<strong>双⽅协商的加密算法，各⾃⽣成本次通信的「会话秘钥」</strong>。</p>
<p><em>4.</em> 服务器的最后回应</p>
<p>服务器收到客户端的第三个随机数（ pre-master key ）之后，通过协商的加密算法，计算出<strong>本次通信的「会话秘</strong></p>
<p><strong>钥」</strong>。然后，向客户端发⽣最后的信息：</p>
<p>（1）<strong>加密通信算法改变通知，表示随后的信息都将⽤「会话秘钥」加密通信。</strong></p>
<p>（2）服务器握⼿结束通知，表示服务器的握⼿阶段已经结束。这⼀项同时<strong>把之前所有内容的发⽣的数据做个摘</strong></p>
<p><strong>要，⽤来供客户端校验</strong>。</p>
<p>⾄此，整个 SSL/TLS 的握⼿阶段全部结束。接下来，客户端与服务器进⼊加密通信，就完全是使⽤普通的 HTTP</p>
<p>协议，只不过⽤「会话秘钥」加密内容。</p>
<h1 id="HTTP-1-1、HTTP-2、HTTP-3-演变"><a href="#HTTP-1-1、HTTP-2、HTTP-3-演变" class="headerlink" title="HTTP/1.1、HTTP/2、HTTP/3 演变"></a>HTTP/1.1、HTTP/2、HTTP/3 演变</h1><h2 id="HTTP-1-1-和-HTTP-1-0-的区别"><a href="#HTTP-1-1-和-HTTP-1-0-的区别" class="headerlink" title="HTTP/1.1 和 HTTP/1.0 的区别"></a>HTTP/1.1 和 HTTP/1.0 的区别</h2><ol>
<li><p><strong>缓存处理</strong>：在 HTTP/1.0 中主要使用 header 里的 if-modified-Since, Expries 来做缓存判断的标准。而 HTTP/1.1 请求头中添加了更多与缓存相关的字段，从而支持更为灵活的缓存策略，例如 <code>Entity-tag</code>,<code> If-Unmodified-Since</code>, <code>If-Match</code>,<code> If-None-Match</code> 等可供选择的缓存头来控制缓存策略。</p>
</li>
<li><p>节约带宽： 当客户端请求某个资源时，HTTP/1.0 默认将该资源相关的整个对象传送给请求方，但很多时候可能客户端并不需要对象的所有信息。而在 HTTP/1.1 的请求头中引入了 range 头域，它允许只请求部分资源，其使得开发者可以多线程请求某一资源，从而充分的利用带宽资源，实现高效并发。</p>
</li>
<li><p>错误通知的管理：HTTP/1.1 在 1.0 的基础上新增了 24 个错误状态响应码，例如 414 表示客户端请求中所包含的 URL 地址太长，以至于服务器无法处理；410 表示所请求的资源已经被永久删除。</p>
</li>
<li><p>Host 请求头：早期 HTTP/1.0 中认为每台服务器都绑定一个唯一的 IP 地址并提供单一的服务，请求消息中的 URL 并没有传递主机名。而随着虚拟主机的出现，<strong>一台物理服务器上可以存在多个虚拟主机，并且它们共享同一个 IP 地址</strong>。为了支持虚拟主机，HTTP/1.1 中添加了 host 请求头，请求消息和响应消息中应声明这个字段，若请求消息中缺少该字段时服务端会响应一个 404 错误状态码。</p>
</li>
<li><p><strong>长连接</strong>：HTTP/1.0 默认浏览器和服务器之间保持短暂连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，服务器完成后立即断开 TCP 连接。HTTP/1.1 默认使用的是持久连接，其支持在同一个 TCP 请求中传送多个 HTTP 请求和响应。此之前的 HTTP 版本的默认连接都是使用非持久连接，如果想要在旧版本的 HTTP 协议上维持持久连接，则需要指定 Connection 的首部字段的值为 Keep-Alive。</p>
</li>
<li><p><strong>管道（pipeline）⽹络传输</strong>，只要第⼀个请求发出去了，不必等其回来，就可以发第⼆个请求出去，可以减少整体的响应时间。</p>
</li>
</ol>
<h2 id="HTTP-1-X-和-HTTP-2-0-的区别"><a href="#HTTP-1-X-和-HTTP-2-0-的区别" class="headerlink" title="HTTP/1.X 和 HTTP/2.0 的区别"></a>HTTP/1.X 和 HTTP/2.0 的区别</h2><p>但 HTTP/1.1 还是有性能瓶颈 : </p>
<ul>
<li><p>请求 / 响应头部（Header）未经压缩就发送，⾸部信息越多延迟越⼤。只能压缩 Body 的部分；</p>
</li>
<li><p>发送冗⻓的⾸部。每次互相发送相同的⾸部造成的浪费较多；</p>
</li>
<li><p>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端⼀直请求不到数据，也就是<strong>队头阻塞；</strong></p>
</li>
<li><p>请求只能从客户端开始，<strong>服务器只能被动响应</strong>。</p>
</li>
</ul>
<p>HTTP/2 协议是基于 HTTPS 的，所以 HTTP/2 的安全性也是有保障的。</p>
<h3 id="1-头部压缩"><a href="#1-头部压缩" class="headerlink" title="1. 头部压缩"></a>1. 头部压缩</h3><p>HTTP/2 会压缩头（Header）如果你同时发出多个请求，他们的头是⼀样的或是相似的，那么，协议会帮你消除重复的部分。<br>这就是所谓的 HPACK 算法：在客户端和服务器同时维护⼀张头信息表，所有字段都会存⼊这个表，⽣成⼀个索引号，以后就不发送同样字段了，只发送索引号，这样就提⾼速度了。</p>
<h3 id="2-⼆进制格式"><a href="#2-⼆进制格式" class="headerlink" title="2. ⼆进制格式"></a>2. ⼆进制格式</h3><p>HTTP/2 不再像 HTTP/1.1 ⾥的纯⽂本形式的报⽂，⽽是全⾯采⽤了⼆进制格式，头信息和数据体都是⼆进制，并且统称为帧（frame）：头信息帧和数据帧。</p>
<p><img src="/2021/11/26/HTTP/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%A0%BC%E5%BC%8F.png"></p>
<p>这样虽然对⼈不友好，但是对计算机⾮常友好，因为计算机只懂⼆进制，那么收到报⽂后，⽆需再将明⽂的报⽂转<br>成⼆进制，⽽是直接解析⼆进制报⽂，这<strong>增加了数据传输的效率</strong>。</p>
<h3 id="3-数据流"><a href="#3-数据流" class="headerlink" title="3. 数据流"></a>3. 数据流</h3><p>HTTP/2 的数据包不是按顺序发送的，同⼀个连接⾥⾯连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。<br>每个请求或回应的所有数据包，称为⼀个数据流（ Stream ）。每个数据流都标记着⼀个独⼀⽆⼆的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数</p>
<p>客户端还可以<strong>指定数据流的优先级</strong>。优先级⾼的请求，服务器就先响应该请求。</p>
<h3 id="4-多路复⽤"><a href="#4-多路复⽤" class="headerlink" title="4. 多路复⽤"></a>4. 多路复⽤</h3><p>HTTP/2 是可以<strong>在⼀个连接中并发多个请求或回应，⽽不⽤按照顺序⼀⼀对应</strong>。</p>
<p>移除了 HTTP/1.1 中的串⾏请求，不需要排队等待，也就<strong>解决了「队头阻塞」问题，降低了延迟</strong>，⼤幅度提⾼</p>
<p>了连接的利⽤率。</p>
<p>举例来说，在⼀个 TCP 连接⾥，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程⾮常耗时，于是就</p>
<p>回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分。</p>
<p><img src="/2021/11/26/HTTP/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png"></p>
<h3 id="5-服务器推送"><a href="#5-服务器推送" class="headerlink" title="5. 服务器推送"></a>5. 服务器推送</h3><p>HTTP/2 还在⼀定程度上改善了传统的「请求 - 应答」⼯作模式，服务不再是被动地响应，也可以主动向客户端发</p>
<p>送消息。举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会⽤到的 JS、CSS ⽂件等静态资源主动发给客户端，减少延时的等待，也就是服务器推送（Server Push，也叫 Cache Push）。</p>
<h2 id="HTTP-2-0-和-HTTP-3-0-的区别"><a href="#HTTP-2-0-和-HTTP-3-0-的区别" class="headerlink" title="HTTP/2.0 和 HTTP/3.0 的区别"></a>HTTP/2.0 和 HTTP/3.0 的区别</h2><p>HTTP/2 主要的问题在于，多个 HTTP 请求在复⽤⼀个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求<br>的。所以⼀旦发⽣了丢包现象，就会触发 TCP 的重传机制，这样在⼀个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来。</p>
<ul>
<li><strong>队头阻塞问题</strong>：HTTP/1.1 中的管道（ pipeline）传输中如果有⼀个请求阻塞了，那么队列后请求也统统被阻塞住了</li>
<li><strong>复用TCP的丢包问题</strong>：HTTP/2 多个请求复⽤⼀个TCP连接，⼀旦发⽣丢包，就会阻塞住所有的 HTTP 请求。</li>
</ul>
<p>这都是基于 TCP 传输层的问题，所以 HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！</p>
<img src="http3.0.png" style="zoom:70%;" />





<blockquote>
<p>⼤家都知道 UDP 是不可靠传输的，但基于 UDP 的 <strong>QUIC</strong> 协议 可以实现类似 TCP 的可靠性传输。</p>
<p>QUIC 有⾃⼰的⼀套机制可以保证传输的可靠性的。当某个流发⽣丢包时，只会阻塞这个流，其他流不会受到</p>
<p>影响。</p>
<p>TLS3 升级成了最新的 1.3 版本，头部压缩算法也升级成了 QPack 。</p>
<p>HTTPS 要建⽴⼀个连接，要花费 6 次交互，先是建⽴三次握⼿，然后是 TLS/1.3 的三次握⼿。QUIC 直接</p>
<p>把以往的 TCP 和 TLS/1.3 的 6 次交互合并成了 <strong>3</strong> 次，减少了交互次数。</p>
<p>所以， QUIC 是⼀个在 UDP 之上的伪 TCP + TLS + HTTP/2 的多路复⽤的协议。</p>
<p>QUIC 是新协议，对于很多⽹络设备，根本不知道什么是 QUIC，只会当做 UDP，这样会出现新的问题。所以</p>
<p>HTTP/3 现在普及的进度⾮常的缓慢，不知道未来 UDP 是否能够逆袭 TCP。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如下为HTTP协议族的网络协议层架构：</p>
<img src="http123.png" style="zoom:80%;" />






<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">超文本传输协议 - 维基百科，自由的百科全书</a></p>
<p><a href="https://www.ruanyifeng.com/blog/2016/08/http.html">HTTP 协议入门</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html">数字签名是什么？</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>IP-互联网协议</title>
    <url>/2021/12/04/IP/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>互联网协议提供了“不可靠的”数据包传输机制（也称“尽力而为”或“尽最大努力交付”）；</p>
<p>也就是说，它不保证数据能准确的传输。数据包在到达的时候可能已经</p>
<p>1.损坏，2.顺序错乱，3.产生冗余包，或者 4.直接丢失。如果应用需要保证可靠性，一般需要采取其他的方法，例如利用IP的上层协议控制。</p>
<p>网络层和传输层协议的区别：网络层协议负责提供主机间的逻辑通信；运输层协议负责提供进程间的逻辑通信。</p>
<h1 id="IP-协议的定义和作用"><a href="#IP-协议的定义和作用" class="headerlink" title="IP 协议的定义和作用"></a>IP 协议的定义和作用</h1><p>IP 协议（Internet Protocol）又称互联网协议，是支持网间互联的数据包协议。该协议工作在网络层，主要目的就是为了提高网络的可扩展性，和传输层 TCP 相比，IP 协议提供一种无连接/不可靠、尽力而为的数据报传输服务，其与TCP协议（传输控制协议）一起构成了TCP/IP 协议族的核心。IP 协议主要有以下几个作用：</p>
<ul>
<li><strong>寻址和路由</strong>：在IP 数据包中会携带源 IP 地址和目的 IP 地址来标识该数据包的源主机和目的主机。IP 数据报在传输过程中，每个<strong>中间节点（IP 网关、路由器）</strong>只根据网络地址进行转发，如果中间节点是路由器，则路由器会根据路由表选择合适的路径。<strong>IP 协议根据路由选择协议提供的路由信息对 IP 数据报进行转发，直至抵达目的主机</strong>。</li>
</ul>
<ul>
<li><strong>分段与重组</strong>：IP 数据包在传输过程中可能会经过不同的网络，<strong>在不同的网络中数据包的最大长度限制是不同的</strong>，IP 协议通过<strong>给每个 IP 数据包分配一个标识符以及分段与组装的相关信息</strong>，<strong>使得数据包在不同的网络中能够传输</strong>，被分段后的 IP 数据报可以独立地在网络中进行转发，在到达目的主机后由目的主机完成重组工作，恢复出原来的 IP 数据包。</li>
</ul>
<h3 id="路由器和交换机的区别"><a href="#路由器和交换机的区别" class="headerlink" title="路由器和交换机的区别"></a>路由器和交换机的区别</h3><ul>
<li>交换机：交换机用于局域网，利用主机的物理地址（MAC 地址）确定数据转发的目的地址，它工作于数据链路层。</li>
<li>路由器：路由器通过数据包中的目的 IP 地址识别不同的网络从而确定数据转发的目的地址，网络号是唯一的。路由器根据路由选择协议和路由表信息从而确定数据的转发路径，直到到达目的网络，它工作于网络层。</li>
</ul>
<h1 id="IPV4"><a href="#IPV4" class="headerlink" title="IPV4"></a>IPV4</h1><p>Pv4是一种无连接的协议，操作在使用<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2">分组交换</a>的链路层（如<a href="https://zh.wikipedia.org/wiki/%E4%BB%A5%E5%A4%AA%E7%BD%91">以太网</a>）上。此协议会尽最大努力交付数据包，意即它不保证任何数据包均能送达目的地，也不保证所有数据包均按照正确的顺序无重复地到达。这些方面是由上层的传输协议（如<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE">传输控制协议</a>）处理的。</p>
<h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>IP地址最初被描述为包含两部分：网络地址和主机地址。这种区分在IP网络里的路由中使用。</p>
<h3 id="私有IP和公有IP"><a href="#私有IP和公有IP" class="headerlink" title="私有IP和公有IP"></a>私有IP和公有IP</h3><p>IP地址分公有 IP 地址和私有 IP 地址。</p>
<ul>
<li><p>公有地址(Public Address)由Inter NIC（Internet Network Information Center）负责。这些IP地址分配给注册并向Inter NIC提出申请的组织机构。通过它直接访问互联网。</p>
</li>
<li><p>私有IP就是在本地局域网上的IP 与之对应的是公有IP（在互联网上的IP）<br>随着私有IP网络的发展，为节省可分配的注册IP地址，有一组IP地址被拿出来专门用于私有IP网络，称为私有IP地址。</p>
</li>
</ul>
<p>私有ip属于非注册地址，专门为组织机构内部使用。RFC1918定义了私有IP地址范围：</p>
<table class="wikitable">
<tbody><tr>
<th>名字</th>
<th>地址范围</th>
<th>地址数量</th>
<th>有类别的描述</th>
<th>最大的CIDR地址块
</th></tr>
<tr>
<td>24位块</td>
<td>10.0.0.0–10.255.255.255</td>
<td>16,777,216</td>
<td>一个A类</td>
<td>10.0.0.0/8
</td></tr>
<tr>
<td>20位块</td>
<td>172.16.0.0–172.31.255.255</td>
<td>1,048,576</td>
<td>连续的16个B类</td>
<td>172.16.0.0/12
</td></tr>
<tr>
<td>16位块</td>
<td>192.168.0.0–192.168.255.255</td>
<td>65,536</td>
<td>连续的256个C类</td>
<td>192.168.0.0/16
</td></tr></tbody></table>



<p>这些地址是不会被Internet分配的，它们在Internet上也不会被路由，虽然它们不能直接和Internet网连接，但通过技术手段仍旧可以和 Internet通讯（<strong>NAT技术</strong>）。我们可以根据需要来选择适当的地址类，在内部局域网中将这些地址像公用IP地址一样地使用。</p>
<blockquote>
<p> 在Internet上，有些不需要与 Internet通讯的设备，如打印机、可管理集线器集线器)等也可以使用这些地址，以节省IP地址资源。</p>
</blockquote>
<h3 id="IP地址的常规分类"><a href="#IP地址的常规分类" class="headerlink" title="IP地址的常规分类"></a>IP地址的常规分类</h3><blockquote>
<p>此种划分方式早已过时，目前使用的是CIDR（无类域间路由）</p>
</blockquote>
<table class="wikitable mw-collapsible mw-made-collapsible">
<caption>IPv4地址分类
<span class="mw-collapsible-toggle mw-collapsible-toggle-default" role="button" tabindex="0" aria-expanded="true"><a class="mw-collapsible-text">折叠</a></span></caption>
<tbody><tr>
<th>
</th>
<th><b>A类IPv4地址</b>
</th>
<th><b>B类IPv4地址</b>
</th>
<th><b>C类IPv4地址</b>
</th>
<th><b>D类IPv4地址</b>
</th>
<th><b>E类IPv4地址</b>
</th></tr>
<tr>
<th><b>网络标志位</b>
</th>
<td>0
</td>
<td>10
</td>
<td>110
</td>
<td>1110
</td>
<td>11110
</td></tr>
<tr>
<th><b>IP地址范围</b>
</th>
<td>0.0.0.0~127.255.255.255
</td>
<td>128.0.0.0~191.255.255.255
</td>
<td>192.0.0.0~223.255.255.255
</td>
<td>224.0.0.0~239.255.255.255
</td>
<td>240.0.0.0~255.255.255.255
</td></tr>
<tr>
<th><b>可用IP地址范围</b>
</th>
<td>1.0.0.1~127.255.255.254
</td>
<td>128.0.0.1~191.255.255.254
</td>
<td>192.0.0.1~223.255.255.254
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<th><b>是否可以分配给主机使用</b>
</th>
<td>是
</td>
<td>是
</td>
<td>是
</td>
<td>否
</td>
<td>否
</td></tr>
<tr>
<th><b>网络数量（个）</b>
</th>
<td>126   (2<sup>7</sup>-2)
</td>
<td>16384   (2<sup>14</sup>)
</td>
<td>2097152   (2<sup>21</sup>)
</td>
<td>---
</td>
<td>---
</td></tr>
<tr>
<th><b>每个网络中可容纳主机数（个）</b>
</th>
<td>16777214   (2<sup>24</sup>-2)
</td>
<td>65534   (2<sup>16</sup>-2)
</td>
<td>254   (2<sup>8</sup>-2)
</td>
<td>---
</td>
<td>---
</td></tr>
<tr>
<th><b>适用范围</b>
</th>
<td>大量主机的大型网络
</td>
<td>中等规模主机数的网络
</td>
<td>小型局域网
</td>
<td>留给Internet体系结构委员会(IAB)使用
<p><a href="/wiki/%E7%B5%84%E6%92%AD" class="mw-redirect" title="组播">组播</a>地址
</p>
</td>
<td>保留，仅作为搜索、Internet的实验和开发用
</td></tr>
<tr>
<th>备注
</th>
<td>0.0.0.0为特殊地址，表示本网主机
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>255.255.255.255为特殊地址，用于定向广播
</td></tr></tbody></table>




<p>IP地址一共分为5类，即A～E，它们分类的依据是其net-id所占的字节长度以及网络号前几位。</p>
<ul>
<li>A类地址:网络号占1个字节。网络号的第一位固定为0。</li>
<li>B类地址：网络号占2个字节。网络号的前两位固定为10。</li>
<li>C类地址：网络号占3个字节。网络号的前三位固定位110。</li>
<li>D类地址：前四位是1110，用于多播(multicast)，即一对多通信。</li>
<li>E类地址：前四位是1111，保留为以后使用。</li>
</ul>
<p>其中，ABC三类地址为单播地址（unicast),用于一对一通信，是最常用的。</p>
<img src="ip-addr.png" style="zoom:45%;" />



<p><strong>说明</strong></p>
<ol>
<li><p>D类与E类IPv4地址不区分网络地址与主机地址</p>
</li>
<li><p>为什么要减 2 呢？因为在 IP 地址中，有两个 IP 是特殊的，分别是主机号全为 1 和 全为 0 地址。</p>
<p><strong>主机号全为 1 指定某个⽹络下的所有主机，⽤于⼴播</strong>;  <strong>主机号全为 0 指定某个⽹络</strong>。</p>
</li>
</ol>
<h3 id="特殊IP地址"><a href="#特殊IP地址" class="headerlink" title="特殊IP地址"></a>特殊IP地址</h3><table class="wikitable">
<caption>特殊IP地址
</caption>
<tbody><tr>
<th>网络号
</th>
<th>主机号
</th>
<th>是否可以作为源地址
</th>
<th>是否可以作为目的地址
</th>
<th>备注/描述
</th></tr>
<tr>
<td>全为0
</td>
<td>全为0
</td>
<td>允许
</td>
<td>禁止
</td>
<td>本网络上的本机（其实，更好的理解是“未指定（即无效的，无意义的）地址”，用作无法使用具体IP情况下的占位符）
</td></tr>
<tr>
<td>全为0
</td>
<td>Host ID
</td>
<td>允许
</td>
<td>禁止
</td>
<td>本地网络的主机（同上）
</td></tr>
<tr>
<td>全为1
</td>
<td>全为1
</td>
<td>禁止
</td>
<td>允许
</td>
<td>在本地网络广播（发到该地址的数据包不能转发到源地址所在网络之外）
</td></tr>
<tr>
<td>127
</td>
<td>任意合法的值
</td>
<td>允许
</td>
<td>允许
</td>
<td>回环地址，用于本地测试（永远都不能出现在主机外部的网络中）
</td></tr>
<tr>
<td>Network ID
</td>
<td>全为1
</td>
<td>禁止
</td>
<td>允许
</td>
<td>在远程网络广播
</td></tr></tbody></table>




<h3 id="CIDR"><a href="#CIDR" class="headerlink" title="CIDR"></a>CIDR</h3><p><strong>无类别域间路由</strong>（Classless Inter-Domain Routing、<strong>CIDR</strong>）是一个用于给用户分配IP地址以及在互联网上有效地路由IP数据包的对IP地址进行归类的方法。</p>
<p>无类别域间路由是基于<strong>可变长子网掩码（VLSM）</strong>来进行任意长度的前缀的分配的。CIDR包括：</p>
<ul>
<li>指定任意长度的前缀的可变长子网掩码技术。遵从CIDR规则的地址有一个后缀说明<strong>前缀的位数</strong>，例如：192.168.0.0/16。这使得对日益缺乏的IPv4地址的使用更加有效。</li>
<li>将多个连续的前缀聚合成超网。以及，在互联网中，只要有可能，就显示为一个聚合的网络，因此在总体上可以减少路由表的表项数目。这个过程叫<strong>路由聚合</strong>。</li>
<li>根据机构的实际需要和短期预期需要而不是分类网络中所限定的过大或过小的地址块来管理IP地址的分配的过程。</li>
</ul>
<h3 id="IPV4-地址不够如何解决"><a href="#IPV4-地址不够如何解决" class="headerlink" title="IPV4 地址不够如何解决"></a>IPV4 地址不够如何解决</h3><ol>
<li><strong>DHCP：动态主机配置协议</strong>。动态分配 IP 地址，只给接入网络的设备分配IP地址，因此同一个 MAC 地址的设备，每次接入互联网时，得到的IP地址不一定是相同的，<strong>该协议使得空闲的 IP 地址可以得到充分利用</strong>。</li>
<li><strong>CIDR</strong>：无类别域间路由。CIDR 消除了传统的 A 类、B 类、C 类地址以及划分子网的概念，因而<strong>更加有效的分配 IPv4 的地址空间</strong>，但无法从根本上解决地址耗尽问题。</li>
<li><strong>NAT：网络地址转换协议</strong>。我们知道属于不同局域网的主机可以使用相同的 IP 地址，从而一定程度上缓解了 IP 资源枯竭的问题。然而主机在局域网中使用的 IP 地址是不能在公网中使用的，当局域网主机想要与公网进行通信时， NAT 方法可以将该主机 IP 地址转换成全球 IP 地址。该协议能够有效解决 IP 地址不足的问题。</li>
<li><strong>IPv6</strong> ：作为接替 IPv4 的下一代互联网协议，其可以实现 2 的 128 次方个地址，而这个数量级，即使是给地球上每一颗沙子都分配一个IP地址，该协议能够从根本上解决 IPv4 地址不够用的问题。</li>
</ol>
<h2 id="IP报文结构"><a href="#IP报文结构" class="headerlink" title="IP报文结构"></a>IP报文结构</h2><p>IP报文包含IP首部和数据部分</p>
<p>IPv4报文的首部包含14个字段，其中13个是必须的，第14个是可选的（红色标出），并命名为：“选项”字段。</p>
<p>如下图</p>
<p><img src="/2021/12/04/IP/ipv4.png"></p>
<ul>
<li><p>版本（Version）</p>
<p>版本字段占4bit，通信双方使用的版本必须一致。对于IPv4，字段的值是4。</p>
</li>
<li><p>首部长度（Internet Header Length， IHL）</p>
<p>占4bit，首部长度说明首部有多少32位字（4字节）。由于IPv4首部可能包含数目不定的选项，这个字段也用来确定数据的偏移量。这个字段的最小值是5（二进制0101），相当于5*4=20字节（<a href="https://tools.ietf.org/html/rfc791">RFC 791</a>），最大十进制值是15。</p>
</li>
<li><p>区分服务（Differentiated Services，DS）</p>
<p>占6bit，最初被定义为<strong>服务类型</strong>字段，实际上并未使用，但1998年被IETF重定义为区分服务RFC 2474。只有在使用区分服务时，这个字段才起作用，在一般的情况 下都不使用这个字段。</p>
</li>
<li><p>显式拥塞通告（ Explicit Congestion Notification，ECN）</p>
<p>在RFC 3168中定义，允许在不丢弃报文的同时通知对方网络拥塞的发生。<strong>ECN是一种可选的功能，仅当两端都支持并希望使用，且底层网络支持时才被使用</strong>。</p>
</li>
<li><p>全长（Total Length）</p>
<p>这个16位字段定义了报文总长，包含首部和数据，单位为字节。这个字段的最小值是20（20字节首部+0字节数据），最大值是$2^{16}-1=65,535$。<strong>IP规定所有主机都必须支持最小576字节的报文</strong>，这是假定上层数据长度512字节，加上最长IP首部60字节，加上4字节富裕量，得出576字节，但大多数现代主机支持更大的报文。<strong>当下层的数据链路协议的最大传输单元（MTU）字段的值小于IP报文长度时，报文就必须被分片</strong>，详细见下个标题。</p>
</li>
<li><p>标识符（Identification）</p>
<p>占16位，<strong>这个字段主要被用来唯一地标识一个报文的所有分片</strong>，因为分片不一定按序到达，所以在重组时需要知道分片所属的报文。每产生一个数据报，计数器加1，并赋值给此字段。一些实验性的工作建议将此字段用于其它目的，例如增加报文跟踪信息以协助探测伪造的源地址。</p>
</li>
<li><p>标志 （Flags）（<strong>分片相关</strong>）</p>
<p>这个3位字段用于控制和识别分片，它们是：位0：保留，必须为0；位1：<strong>禁止分片</strong>（Don’t Fragment，<strong>DF</strong>），当DF=0时才允许分片；位2：<strong>更多分片</strong>（More Fragment，<strong>MF</strong>），MF=1代表后面还有分片，MF=0 代表已经是最后一个分片。</p>
<p>如果DF标志被设置为1，但路由要求必须分片报文，此报文会被丢弃。这个标志可被用于发往没有能力组装分片的主机。</p>
<p>当一个报文被分片，除了最后一片外的所有分片都设置MF为1。最后一个片段具有非零片段偏移字段，将其与未分片数据包区分开，未分片的偏移字段为0。</p>
</li>
<li><p><strong>分片偏移</strong> （Fragment Offset）</p>
<p>这个13位字段指明了每个分片相对于原始报文开头的偏移量，<strong>以8字节作单位</strong>。</p>
</li>
<li><p>存活时间（Time To Live，TTL）</p>
<p>这个8位字段避免报文在互联网中永远存在（例如陷入路由环路）。存活时间以秒为单位，但小于一秒的时间均向上取整到一秒。<strong>在现实中，这实际上成了一个跳数计数器</strong>：报文经过的每个路由器都将此字段减1，当此字段等于0时，报文不再向下一跳传送并被丢弃，最大值是255。常规地，一份<a href="https://zh.wikipedia.org/wiki/ICMP">ICMP</a>报文被发回到源端说明其发送的报文已被丢弃。这也是<a href="https://zh.wikipedia.org/wiki/Traceroute">traceroute</a>的核心原理（详见ICMP）。</p>
</li>
<li><p>协议 （Protocol）</p>
<p>占8bit，这个字段定义了该报文数据区使用的协议，然后交给对应的传输进程。</p>
</li>
<li><p>首部检验和 （Header Checksum）</p>
<p><strong>这个16位检验和字段，只对首部查错，不包括数据部分</strong>。在每一跳，路由器都要重新计算出的首部检验和并与此字段进行比对，如果不一致，此报文将会被丢弃。重新计算的必要性是因为每一跳的一些首部字段（如TTL、Flag、Offset等）都有可能发生变化，<strong>不检查数据部分是为了减少工作量</strong>。<strong>数据区的错误留待上层协议处理</strong>——用户数据报协议（UDP）和传输控制协议（TCP）都有检验和字段。此处的检验计算方法不使用CRC。</p>
</li>
<li><p>源地址（Source address）</p>
<p>一个IPv4地址由四个字节共32位构成，此字段的值是将每个字节转为二进制并拼在一起所得到的32位值。</p>
<p>例如，10.9.8.7是00001010000010010000100000000111。</p>
<p>但请注意，<strong>因为NAT的存在，这个地址并不总是报文的真实发送端</strong>，因此发往此地址的报文会被送往NAT设备，并由它被翻译为真实的地址。</p>
</li>
<li><p>目的地址（Destination address）<br>与源地址格式相同，但指出报文的接收端。</p>
</li>
<li><p>选项（Options）<br>附加的首部字段可能跟在目的地址之后，但这并不被经常使用，从1到40个字节不等。请注意首部长度字段必须包括足够的32位字来放下所有的选项（首部长度必须能被32位整除，不够就填充）。<strong>IP选项使用的并不多</strong>。</p>
</li>
</ul>
<h2 id="分片和组装"><a href="#分片和组装" class="headerlink" title="分片和组装"></a>分片和组装</h2><p>每种数据链路的最⼤传输单元 MTU 都是不相同的，如 FDDI 数据链路 MTU 4352、以太⽹的 MTU 是 1500 字节</p>
<p>等。</p>
<p>每种数据链路的 MTU 之所以不同，是因为每个不同类型的数据链路的使⽤⽬的不同。使⽤⽬的不同，可承载的</p>
<p>MTU 也就不同。</p>
<p>其中，我们最常⻅数据链路是<strong>以太⽹，它的 MTU 是 1500 字节</strong>。</p>
<p>那么当 IP 数据包⼤⼩⼤于 MTU 时， IP 数据包就会被分⽚。</p>
<p><strong>经过分⽚之后的 IP 数据报在被重组的时候，只能由⽬标主机进⾏，路由器是不会进⾏重组的</strong>。</p>
<blockquote>
<p>（详见 P334 分段和重组的两种方式）</p>
</blockquote>
<p>假设发送⽅发送⼀个 4000 字节的⼤数据报，若要传输在以太⽹链路，则需要把数据报分⽚成 3 个⼩数据报进⾏传</p>
<p>输，再交由接收⽅重组成⼤数据报。</p>
<p>在分⽚传输中，⼀旦某个分⽚丢失，则会造成整个 IP 数据报作废，<strong>所以 TCP 引⼊了 MSS 也就是在 TCP 层进⾏分⽚不由 IP 层分⽚</strong>，那么对于 UDP 我们尽量不要发送⼀个⼤于 MTU 的数据报⽂。</p>
<blockquote>
<p>详见 ”路径 MTU 发现“，避免IP分组。</p>
</blockquote>
<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>当设备收到IP报文时，分析其目的地址并决定要在哪个链路上发送它。<strong>MTU决定了数据载荷的最大长度，如IP报文长度比MTU大，则IP数据包必须进行分片。每一片的长度都小于等于MTU减去IP首部长度</strong>。接下来每一片均被放到独立的IP报文中，并进行如下修改：</p>
<ul>
<li>总长字段被修改为此分片的长度；</li>
<li>更多分片（MF）标志被设置，除了最后一片；</li>
<li>分片偏移量字段被调整为合适的值；</li>
<li>首部检验和被重新计算。</li>
</ul>
<p>例如，对于一个长20字节的首部和一个MTU为1,500的以太网，分片偏移量将会是：0、(1480/8)=185、(2960/8)=370、(4440/8)=555、(5920/8)=740、等等。</p>
<p>比如，一个4,500字节的数据载荷被封装进了一个没有选项的IP报文（即总长为4,520字节），并在MTU为2,500字节的链路上传输，那么它会被破成如下两个分片：</p>
<table>
<tbody><tr>
<th rowspan="2">#
</th>
<th colspan="2" width="200">总长
</th>
<th rowspan="2">更多分片（MF）？
</th>
<th rowspan="2">DF
</th>
<th rowspan="2">分片偏移量
</th></tr>
<tr>
<th width="100">首部
</th>
<th width="100">数据
</th></tr>
<tr>
<td rowspan="2">1</td>
<td colspan="2">2500</td>
<td rowspan="2" class="table-yes" style="text-align:center; background:#90FF90">是
</td>
<td rowspan="2">0</td>
<td rowspan="2">0
</td></tr>
<tr>
<td>20</td>
<td>2480
</td></tr>
<tr>
<td rowspan="2">2</td>
<td colspan="2">2040</td>
<td rowspan="2" class="table-no" style="text-align:center; background:#FF9090">否
</td>
<td rowspan="2">0</td>
<td rowspan="2">310
</td></tr>
<tr>
<td>20</td>
<td>2020
</td></tr></tbody></table>





<h3 id="重组"><a href="#重组" class="headerlink" title="重组"></a>重组</h3><p>当一个接收者发现IP报文的下列项目之一为真时：</p>
<ul>
<li>DF标志为0（也就是允许分段）；</li>
<li>分片偏移量字段不为0。<br>它便知道这个报文已被分片，并随即将数据、标识符字段、分片偏移量和更多分片标志一起储存起来。</li>
</ul>
<p>当接受者收到了更多分片标志未被设置的分片时，它便知道原始数据载荷的总长。</p>
<p>一旦它收齐了所有的分片，它便可以将所有片按照正确的顺序（通过分片偏移量）组装起来，并交给上层协议栈。</p>
<blockquote>
<p>参考 </p>
<p><a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE">网际协议</a></p>
</blockquote>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>IP</tag>
      </tags>
  </entry>
  <entry>
    <title>进程间通信IPC</title>
    <url>/2021/11/27/IPC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>进程间通信（IPC：interprocess communication）是一种涉及一个进程与另一个进程的通信的机制。 这通常只发生在一个系统中。</p>
<p>沟通可以有两种类型 -</p>
<ul>
<li>在仅从一个进程启动的相关进程之间，例如父进程和子进程。</li>
<li>在不相关的进程之间，或两个或多个不同的进程之间。</li>
</ul>
<p>具体来说，有下面三大类形式：</p>
<p><img src="/2021/11/27/IPC/ipc.png"></p>
<p>按照《UNIX网络编程 卷2：进程间通信》的目录分类：</p>
<ol>
<li>消息传递（管道、FIFO、消息队列）</li>
<li>同步（互斥锁和条件变量、读写锁、信号量）</li>
<li>共享内存（匿名的、具名的）</li>
</ol>
<h1 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h1><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p><strong>管道是两个或多个相关或相互关联的过程之间的通信媒介。</strong></p>
<p>它可以在一个进程内，也可以在子进程和父进程之间进行通信。 通信也可以是多层次的，例如父母，孩子和孙子之间的通信等。通过写入管道的一个过程和管道的其他读取来实现通信。 </p>
<p><strong>要实现管道系统调用，请创建两个文件，一个用于写入文件，另一个用于从文件中读取。</strong></p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> pipedes[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>

<p>该系统调用将创建用于单向通信的管道，即，它创建两个描述符，第一个连接到管道读取而另一个连接以写入管道。</p>
<p>描述符pipedes [0]用于读取，pipedes [1]用于写入。 无论写入管道[1]是什么都可以从pipedes [0]中读取。</p>
<p>此调用在成功时返回零，在失败时返回-1。 要了解失败的原因，请使用errno variable或perror（）函数进行检查。</p>
<p>如下图这是使用管道进行双向通信的常见做法：</p>
<p><img src="/2021/11/27/IPC/pipe_with_two.jpg" alt="img"></p>
<h3 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用两个单工的管道实现双向通信</span></span><br><span class="line">    <span class="keyword">int</span> pipefds1[<span class="number">2</span>], pipefds2[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> returnstatus1, returnstatus2;</span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="keyword">char</span> pipe1writemessage[<span class="number">20</span>] = <span class="string">&quot;Hi&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> pipe2writemessage[<span class="number">20</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> readmessage[<span class="number">20</span>];</span><br><span class="line">    returnstatus1 = pipe(pipefds1);</span><br><span class="line">    <span class="keyword">if</span> (returnstatus1 == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Unable to create pipe 1 \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    returnstatus2 = pipe(pipefds2);</span><br><span class="line">    <span class="keyword">if</span> (returnstatus2 == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Unable to create pipe 2 \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid != <span class="number">0</span>) &#123; <span class="comment">// Parent process </span></span><br><span class="line">        close(pipefds1[<span class="number">0</span>]); <span class="comment">// Close the unwanted pipe1 read side</span></span><br><span class="line">        close(pipefds2[<span class="number">1</span>]); <span class="comment">// Close the unwanted pipe2 write side</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;In Parent: Writing to pipe 1 – Message is %s\n&quot;</span>, pipe1writemessage);</span><br><span class="line">        write(pipefds1[<span class="number">1</span>], pipe1writemessage, <span class="keyword">sizeof</span>(pipe1writemessage));</span><br><span class="line">        read(pipefds2[<span class="number">0</span>], readmessage, <span class="keyword">sizeof</span>(readmessage));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;In Parent: Reading from pipe 2 – Message is %s\n&quot;</span>, readmessage);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//child process</span></span><br><span class="line">        close(pipefds1[<span class="number">1</span>]); <span class="comment">// Close the unwanted pipe1 write side</span></span><br><span class="line">        close(pipefds2[<span class="number">0</span>]); <span class="comment">// Close the unwanted pipe2 read side</span></span><br><span class="line">        read(pipefds1[<span class="number">0</span>], readmessage,</span><br><span class="line">             <span class="keyword">sizeof</span>(readmessage));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;In Child: Reading from pipe 1 – Message is %s\n&quot;</span>, readmessage);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;In Child: Writing to pipe 2 – Message is %s\n&quot;</span>, pipe2writemessage);</span><br><span class="line">        write(pipefds2[<span class="number">1</span>], pipe2writemessage,</span><br><span class="line">              <span class="keyword">sizeof</span>(pipe2writemessage));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h2><p>暂略</p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>当我们已经拥有共享内存时，为什么我们需要消息队列？ 这将有多种原因，让我们试着将其分解为多个点以简化 -</p>
<ul>
<li>如所理解的，一<strong>旦进程接收到消息，它将不再可用于任何其他过程</strong>。 而在共享内存中，数据可供多个进程访问。</li>
<li>如果我们想要与小消息格式进行通信。</li>
<li>当多个进程同时通信时，<strong>共享内存数据需要通过同步进行保护</strong>。</li>
<li>使用共享内存的写入和读取频率很高，但<strong>实现该功能将非常复杂</strong>。 在这种情况下使用不值得。</li>
<li>如果<strong>并不是所有进程都需要访问共享内存</strong>，那么使用消息队列实现会更好。</li>
<li>如果我们想要<strong>与不同的数据包进行通信</strong>，则说过程A将消息类型1发送到进程B，消息类型10发送到进程C，消息类型20发送到进程D.在这种情况下，使用消息队列实现更简单。 为了将给定的消息类型简化为1,10,20，它可以是0或+ ve或-ve，如下所述。</li>
<li>当然，<strong>消息队列的顺序是FIFO</strong>（先进先出）。 插入队列中的第一条消息是第一个要检索的消息。</li>
</ul>
<ol>
<li>通过一个进程写入共享内存并通过另一个进程从共享内存中读取。 我们知道，阅读也可以通过多个流程完成</li>
</ol>
<p><img src="/2021/11/27/IPC/message_queue.jpg" alt="消息队列"></p>
<ol start="2">
<li>一个进程使用不同的数据包写入共享内存，并通过多个进程从中读取，即按消息类型。</li>
</ol>
<p><img src="/2021/11/27/IPC/multiple_message_queue.jpg" alt="多个消息队列"></p>
<h3 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h3><p>这里以POSIX的接口为实例</p>
<table>
<thead>
<tr>
<th>API</th>
<th>API 作用</th>
</tr>
</thead>
<tbody><tr>
<td>mqd_t mq_open(const char <em>name, int oflag, mode_t mode, struct mq_attr</em> attr)</td>
<td>创建命名消息队列</td>
</tr>
<tr>
<td>mqd_t mq_close(mqd_t mqdes)</td>
<td>结束到开放式消息队列的连接</td>
</tr>
<tr>
<td>mqd_t mq_unlink(const char *name)</td>
<td>结束到开放式消息队列的连接，并在最后一个进程关闭此队列时将其删除</td>
</tr>
<tr>
<td>mqd_t mq_send(mqd_t mqdes, const char *msg_ptr, size_t msg_len, unsigned msg_prio)</td>
<td>将消息放入队列</td>
</tr>
<tr>
<td>ssize_t mq_receive(mqd_t mqdes, char <em>msg_ptr, size_t msg_len, unsigned</em> msg_prio)</td>
<td>在队列中接收消息</td>
</tr>
<tr>
<td>mqd_t mq_notify(mqd_t mqdes, const struct sigevent *notification)</td>
<td>通知进程或线程消息已存在于队列中</td>
</tr>
<tr>
<td>mqd_t mq_getattr(mqd_t mqdes, struct mq_attr <em>attr) 、mqd_t mq_setattr(mqd_t mqdes, struct mq_attr</em> newattr, struct mq_attr *oldattr)</td>
<td>设置或获取消息队列属性</td>
</tr>
</tbody></table>
<h1 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h1><h2 id="互斥锁与条件变量"><a href="#互斥锁与条件变量" class="headerlink" title="互斥锁与条件变量"></a>互斥锁与条件变量</h2><p>这里互斥锁和条件变量的使用，与Java的<code>synchronized+wait+notify</code>以及<code>Lock+Condition</code> 机制在语义上和使用上十分相似，就不详细介绍了。</p>
<h3 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法"></a>使用方法</h3><blockquote>
<p>linux c版本的条件变量和互斥锁(mutex)，不是C++的。</p>
</blockquote>
<ol>
<li>互斥锁的初始化</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>互斥锁的销毁</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>加锁与解锁</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure>



<ol start="4">
<li>条件变量的函数</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure>





<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>基本上信号量分为两种类型 -</p>
<p><strong>Binary Semaphores</strong> - 只有两个状态0和1，即锁定/解锁或可用/不可用，Mutex实现。</p>
<p><strong>Counting Semaphores</strong> - 允许任意资源计数的信号量称为计数信号量。</p>
<h3 id="使用方法-3"><a href="#使用方法-3" class="headerlink" title="使用方法"></a>使用方法</h3><table>
<thead>
<tr>
<th>API</th>
<th>API 作用</th>
</tr>
</thead>
<tbody><tr>
<td>sem_t *sem_open(const char  *name, int oflag, mode_t mode, unsigned int value)</td>
<td>创建命名信号量</td>
</tr>
<tr>
<td>int sem_init(sem_t *sem, int pshared, unsigned int value)</td>
<td>初始化信号量结构</td>
</tr>
<tr>
<td>int sem_close(sem_t *sem)</td>
<td>结束到开放式信号量的连接</td>
</tr>
<tr>
<td>int sem_unlink(const char *name)</td>
<td>结束到开放式信号量的连接，并在最后一个进程关闭此信号量时将其删除</td>
</tr>
<tr>
<td>int sem_getvalue(sem_t <em>sem, int</em> sval)</td>
<td>将信号量的值复制到指定整数中</td>
</tr>
<tr>
<td>int sem_wait(sem_t *sem)</td>
<td>递减信号量计数，当其他进程拥有信号量时进行阻塞，或者当其他进程拥有信号量时返回错误（aka P 操作）</td>
</tr>
<tr>
<td>int sem_post(sem_t *sem)</td>
<td>递增信号量计数（aka V 操作）</td>
</tr>
</tbody></table>
<h1 id="共享内存相关"><a href="#共享内存相关" class="headerlink" title="共享内存相关"></a>共享内存相关</h1><h2 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h2><p>mmap()系统调用在调用进程的虚拟地址空间中提供映射，该映射将文件或设备映射到内存中。 这有两种类型 -</p>
<p><strong>File mapping or File-backed mapping</strong> - 此映射将进程的虚拟内存区域映射到文件。 这意味着读取或写入这些内存区域会导致文件被读取或写入。 这是默认的映射类型。</p>
<p><strong>Anonymous mapping</strong> - 此映射映射进程的虚拟内存区域，不受任何文件的支持。 内容初始化为零。 此映射类似于动态内存分配（malloc()），并在某些malloc()实现中用于某些分配。</p>
<p>当两个或多个进程共享相同的页面时，每个进程可以根据映射类型查看其他进程所做的页面内容的更改。 映射类型可以是私有的也可以是共享的 -</p>
<p><strong>Private Mapping (MAP_PRIVATE)</strong> - 对此映射内容的修改对其他进程不可见，并且映射不会传送到基础文件。</p>
<p><strong>Shared Mapping (MAP_SHARED)</strong> - 对此映射内容的修改对其他进程可见，并且映射将传送到基础文件。</p>
<h3 id="使用方法-4"><a href="#使用方法-4" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数</li>
</ul>
<p>虚拟地址addr可以是用户指定的，也可以是内核生成的（将addr作为NULL传递）;</p>
<p>字段length需要以字节为单位的映射大小;</p>
<p>字段prot表示存储器保护值，例如PROT_NONE，PROT_READ，PROT_WRITE，PROT_EXEC，分别用于可能无法访问，读取，写入或执行的区域。 该值可以是单个（PROT_NONE），也可以与三个标志中的任何一个（最后3个）进行OR运算;</p>
<p>字段flags指示映射类型或MAP_PRIVATE或MAP_SHARED;</p>
<p>字段fd表示标识要映射的文件的文件描述符;</p>
<p>字段offset表示文件的起始点，如果需要映射整个文件，则偏移量应为零。</p>
<ul>
<li>返回值</li>
</ul>
<p>在成功时返回映射的起始地址，或者在出错时返回MAP_FAILED。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>

<p>执行已映射内存映射区域的取消映射。</p>
<p>字段addr表示映射的起始地址，length表示要取消映射的映射的字节大小。</p>
<h3 id="实例代码-1"><a href="#实例代码-1" class="headerlink" title="实例代码"></a>实例代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Filename: mmap_test.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_mmap_sample_data</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">mmapstat</span>;</span></span><br><span class="line">    <span class="keyword">char</span> *data;</span><br><span class="line">    <span class="keyword">int</span> minbyteindex;</span><br><span class="line">    <span class="keyword">int</span> maxbyteindex;</span><br><span class="line">    <span class="keyword">int</span> offset;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> unmapstatus;</span><br><span class="line">    write_mmap_sample_data();</span><br><span class="line">    <span class="keyword">if</span> (stat(<span class="string">&quot;MMAP_DATA.txt&quot;</span>, &amp;mmapstat) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;stat failure&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((fd = open(<span class="string">&quot;MMAP_DATA.txt&quot;</span>, O_RDONLY)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open failure&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    data = mmap((<span class="keyword">caddr_t</span>) <span class="number">0</span>, mmapstat.st_size, PROT_READ, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (data == (<span class="keyword">caddr_t</span>) (<span class="number">-1</span>)) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap failure&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    minbyteindex = <span class="number">0</span>;</span><br><span class="line">    maxbyteindex = mmapstat.st_size - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Enter -1 to quit or &quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;enter a number between %d and %d: &quot;</span>, minbyteindex, maxbyteindex);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;offset);</span><br><span class="line">        <span class="keyword">if</span> ((offset &gt;= <span class="number">0</span>) &amp;&amp; (offset &lt;= maxbyteindex))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Received char at %d is %c\n&quot;</span>, offset, data[offset]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (offset != <span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Received invalid index %d\n&quot;</span>, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (offset != <span class="number">-1</span>);</span><br><span class="line">    unmapstatus = munmap(data, mmapstat.st_size);</span><br><span class="line">    <span class="keyword">if</span> (unmapstatus == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;munmap failure&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    system(<span class="string">&quot;rm -f MMAP_DATA.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_mmap_sample_data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">textfilestat</span>;</span></span><br><span class="line">    fd = open(<span class="string">&quot;MMAP_DATA.txt&quot;</span>, O_CREAT | O_TRUNC | O_WRONLY, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;File open error &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Write A to Z</span></span><br><span class="line">    ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">        write(fd, &amp;ch, <span class="keyword">sizeof</span>(ch));</span><br><span class="line">        ch++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Write 0 to 9</span></span><br><span class="line">    ch = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        write(fd, &amp;ch, <span class="keyword">sizeof</span>(ch));</span><br><span class="line">        ch++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Write a to z</span></span><br><span class="line">    ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt;= <span class="string">&#x27;z&#x27;</span>) &#123;</span><br><span class="line">        write(fd, &amp;ch, <span class="keyword">sizeof</span>(ch));</span><br><span class="line">        ch++;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>共享内存是两个或多个进程之间共享的内存。 但是，为什么我们需要共享内存或其他一些通信方式？</p>
<p>重申一下，每个进程都有自己的地址空间，如果任何进程想要将自己的地址空间中的某些信息与其他进程通信，那么只有IPC（进程间通信）技术才有可能。 我们已经知道，沟通可以在相关或不相关的流程之间进行。</p>
<h3 id="Posix-版本"><a href="#Posix-版本" class="headerlink" title="Posix 版本"></a>Posix 版本</h3><table>
<thead>
<tr>
<th>API</th>
<th>API 作用</th>
</tr>
</thead>
<tbody><tr>
<td>int shm_open(const char *name, int oflag, mode_t mode)</td>
<td>创建共享内存，成功返回描述符</td>
</tr>
<tr>
<td>int shm_unlink(const char *name)</td>
<td>结束到共享内存的连接，并在最后一个进程关闭它时将其删除</td>
</tr>
<tr>
<td>void <em>mmap(void</em> addr, size_t length, int prot, int flags, int fd, off_t offset)</td>
<td>映射内存</td>
</tr>
</tbody></table>
<p>Posix的共享内存区构筑在<code>mmap</code>之上。</p>
<h3 id="SystemV-版本"><a href="#SystemV-版本" class="headerlink" title="SystemV 版本"></a>SystemV 版本</h3><p>相关函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建或分配System V共享内存段, 成功时返回有效的共享内存标识符（用于进一步调用共享内存）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> shmflg)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 为System V共享内存段执行共享内存操作，即将共享内存段附加到调用进程的地址空间。成功时返回附加共享内存段的地址。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span> *shmaddr, <span class="keyword">int</span> shmflg)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从调用进程的地址空间中分离共享内存段的System V共享内存段。将在成功时返回0，在失败时返回-1</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *shmaddr)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 执行System V共享内存段的控制操作</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">int</span> cmd, struct shmid_ds *buf)</span>  </span></span><br></pre></td></tr></table></figure>





<blockquote>
<p>参考链接</p>
<p>《UNIX网络编程 卷2：进程间通信》</p>
<p><a href="https://iowiki.com/inter_process_communication/inter_process_communication_index.html">WIKI教程</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>IPC</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC之AQS源码解析与使用</title>
    <url>/2021/11/13/JUC%E4%B9%8BAQS%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="从自己实现一把锁说起"><a href="#从自己实现一把锁说起" class="headerlink" title="从自己实现一把锁说起"></a>从自己实现一把锁说起</h1><p>《操作系统概念》一书中在第6章”同步“中，以CAS这样的原子命令实现了锁的语义，并且以它为基础实现了非忙等（busy waiting）的锁。</p>
<p>下面我们在Java中使用<code>AtomicBoolean</code>这个原子更新类实现</p>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>众所周知，<code>i++</code>是经典的读改写操作，它不是原子的。</p>
<p>下面的代码在多线程环境下将一个数<code>x</code>自增N次，并观察在加锁和不加锁的情况下的结果。</p>
<p>结果，显示如果使用我们自己的实现的互斥锁，<code>x</code>最终等于N，也说明锁生效了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockByCAS</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean isLocked = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInteger</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyInteger</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.x = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">incr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            x++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MyInteger integer = <span class="keyword">new</span> MyInteger(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">1000000</span>;</span><br><span class="line">        Lock lock = <span class="keyword">new</span> SimpleMutex();</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(N);</span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            pool.submit(() -&gt; &#123;</span><br><span class="line">                <span class="comment">// 你可以去掉这个，看看结果</span></span><br><span class="line">                lock.lock();</span><br><span class="line">                integer.incr();</span><br><span class="line">                lock.unlock();</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await(); <span class="comment">// just wait all tasks to finish</span></span><br><span class="line">        pool.shutdown();</span><br><span class="line">        System.out.println(integer.getX());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// busy waiting</span></span><br><span class="line">        <span class="keyword">while</span> (isLocked.compareAndExchange(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isLocked.set(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 省略其他接口的方法 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>需要注意的是<code>compareAndSet</code>和<code>compareAndExchange</code>的区别，<code>compareAndExchange</code>的返回值是旧值，</p>
<p>而<code>compareAndSet</code>的返回值是CAS是否成功。</p>
<p>所以，如果在Java8中，使用<code>compareAndSet</code>可以使用下面的代码代替上面的循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* notice that compareAndExchange is different from compareAndSet*/</span></span><br><span class="line">        <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">            <span class="comment">// CAS succeed to jump the loop</span></span><br><span class="line">            <span class="keyword">if</span>(isLocked.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>来总结一下自己实现的锁的缺点。</p>
<ol>
<li>使用<code>while</code>+<code>yield</code>，实际上就是忙等，在线程竞争非常剧烈的时候，CPU资源被大大浪费。不好，我们后面会用<code>wait</code>+<code>notify</code>的范式解决这个问题，使得线程没有获得锁的时候可以放弃CPU资源。</li>
<li>使用了<code>AtomicBoolean</code>，以及编写了一些自旋锁实现的模板代码。如果要实现其它的同步工具，这样的模板代码还要再写一遍。况且，<code>AtomicBoolean</code>自己是怎么实现的呢？</li>
</ol>
<blockquote>
<p>实际上面的痛点也正是由AQS(抽象队列同步器)所要解决的问题了。</p>
</blockquote>
<p>我们不妨看一看使用AQS实现一个非忙等的互斥锁有多简单，再开始我们对AQS的介绍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMutex</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Our internal helper class</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Acquires the lock if state is zero</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> compareAndSetState(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Releases the lock by setting state to zero</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            setState(<span class="number">0</span>); <span class="comment">// no need to use cas</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Provides a Condition</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AbstractQueuedSynchronizer.ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The sync object does all the hard work. We just forward to it.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 还有其他的加锁方法，这里省略。下面的 Mutex 会有完整的实现。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过继承AQS并重写一些方法，就可以实现一份非忙等的锁（不过这个锁还有一些锁语义的检查没有实现，这里仅仅作一个展示罢了）。</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><code>AbstractQueuedSynchronizer</code>抽象队列同步器（简称<strong>队列同步器</strong>），是用来构建锁、信号量等同步组件的一个基础模板类，它使用了一个int成员变量来表示同步状态，通过内置的FIFO队，来完成对那些因为竞争资源（这里的资源形式各式各样，比如锁就是一个典型的竞争资源）而等待的线程的排队工作。</p>
<h2 id="如何使用AQS"><a href="#如何使用AQS" class="headerlink" title="如何使用AQS"></a>如何使用AQS</h2><p>AQS是一个抽象类，因此必须有子类去实现它的抽象方法。</p>
<p>设计模式告诉我们，聚合由于继承。</p>
<p>所以常见的使用方式是：</p>
<p>在自定义的同步组件中，用一个静态内部类去继承AQS，实现它的抽象方法。自定义的同步组件使用这个AQS的子类去实现high-level的同步语义。</p>
<p>要将此类用作同步器的基础，请根据适用情况重新定义以下方法，</p>
<ol>
<li><code>tryAcquire</code></li>
<li><code>tryRelease</code></li>
<li><code>tryAcquireShared</code></li>
<li><code>tryReleaseShared</code></li>
<li><code>isHeldExclusively</code></li>
</ol>
<p>默认情况下，这些方法中的每一个都会抛出<code>UnsupportedOperationException </code>。 这些方法的实现必须是内部线程安全的，并且通常应该是立即返回的而不是阻塞的。</p>
<p>override这些方法是使用此类的唯一支持方式。 所有其他方法都被声明为final因为都是模板类的模板方法，无需也不能重写。</p>
<p>重写同步器指定的方法时,需要使用<code>getState</code> 、 <code>setState()</code>、<code>compareAndSetState</code>来检查或修改同步器的状态。</p>
<h2 id="AQS和同步组件的关系"><a href="#AQS和同步组件的关系" class="headerlink" title="AQS和同步组件的关系"></a>AQS和同步组件的关系</h2><p>同步组件面向同步组件的使用者，比如<code>ReentrantLock</code> ；</p>
<p>而AQS构建同步组件的实现者，它隐藏了很多实现具体的实现细节，实现者只需要实现AQS的若干方法即可。</p>
<p>锁和同步器很好地隔离了使用者和实现者所需关注的领域。同时省去实现者对大量模板方法的编写。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h3 id="AQS用于访问和修改同步状态的方法"><a href="#AQS用于访问和修改同步状态的方法" class="headerlink" title="AQS用于访问和修改同步状态的方法"></a>AQS用于访问和修改同步状态的方法</h3><ul>
<li><code>getState()</code> : 获取当前同步状态；</li>
<li><code>setState(int newState)</code> 设置当前同步状态；</li>
<li><code>compareAndSetState(int expect, int update)</code>使用CAS设置当前的状态，该方法是原子的。 </li>
</ul>
<h2 id="AQS的可重写的方法"><a href="#AQS的可重写的方法" class="headerlink" title="AQS的可重写的方法"></a>AQS的可重写的方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 独占式获取同步状态，该方法应该查询对象的状态是否符合预期，如果允许，再进行CAS设置同步状态；</span></span><br><span class="line"><span class="comment">// 如果此方法返回失败，acquire 方法可能会将线程排队（如果它尚未排队），直到收到来自某个其他线程的释放信号。 </span></span><br><span class="line"><span class="comment">// 获取到同步状态返回 true, 否则返回 false</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 独占式释放同步状态，其他在等待获取同步状态的线程将有机会获取同步状态</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享式获取同步状态，该方法应该查询对象的状态是否允许在共享模式下获取它，如果允许则获取它。</span></span><br><span class="line"><span class="comment">// 如果此方法返回失败，acquire 方法可能会将线程排队（如果它尚未排队），直到收到来自某个其他线程的释放信号。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享式释放同步状态</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询同步器是否在独占模式下被线程使用，一般该方法表示同步器是否被该线程独占（参考线程获取到锁的状态）</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="AQS提供的模板方法"><a href="#AQS提供的模板方法" class="headerlink" title="AQS提供的模板方法"></a>AQS提供的模板方法</h2><p>独占式和共享式获取的区别在于<strong>同一时刻能否有多个线程同时获取的同步状态</strong>。</p>
<p>（比如读写锁中，读-读共享，实际上就是因为可以同时共享的获取到同步状态）。</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>独占式的获取释放同步状态</strong></td>
<td>~</td>
</tr>
<tr>
<td>void acquire(int arg)</td>
<td>独占式获取同步状态，调用重写的<code>tryAcquire</code>后如果成功直接返回，否则进入同步队列等待。</td>
</tr>
<tr>
<td>void acquireInterruptibly(int arg)</td>
<td>与<code>acquire</code>类似，不过该方法响应中断。在当前线程在同步队列等待的时候，如果它被中断，则该方法会抛出`InterruptedException·。</td>
</tr>
<tr>
<td>boolean tryAcquireNanos(int arg, long nanosTimeout)</td>
<td>在<code>acquireInterruptibly</code>的基础上加了超时限制，如果没有在限制时间内获取到同步状态，返回false。</td>
</tr>
<tr>
<td>boolean release(int arg)</td>
<td>独占式的释放同步状态，该方法会在释放同步状态后，将同步队列中第一个节点包含的线程唤醒。该方法会调用重写的<code>tryRelease</code></td>
</tr>
<tr>
<td><strong>共享式的获取释放同步状态</strong></td>
<td>~</td>
</tr>
<tr>
<td>void acquireShared(int arg)</td>
<td>共享式获取同步状态，如果不能获取到同步状态，进入同步队列等待，和独占式获取的主要区别在于同一时刻可以有多个线程获取到同步状态。</td>
</tr>
<tr>
<td>void acquireSharedInterruptibly(int arg)</td>
<td></td>
</tr>
<tr>
<td>boolean tryAcquireSharedNanos(int arg, long nanosTimeout)</td>
<td></td>
</tr>
<tr>
<td>boolean releaseShared(int arg)</td>
<td></td>
</tr>
<tr>
<td><strong>查询同步队列的情况</strong></td>
<td>~</td>
</tr>
<tr>
<td>boolean hasQueuedThreads()</td>
<td>查询是否有线程在等待获取</td>
</tr>
<tr>
<td>getFirstQueuedThread</td>
<td>返回队列中的第一个（等待时间最长的）线程，如果当前没有线程排队，则返回null 。</td>
</tr>
<tr>
<td>boolean isQueued(Thread thread)</td>
<td>如果给定线程当前正在排队，则返回 true。<br/>此实现遍历队列以确定给定线程的存在。</td>
</tr>
<tr>
<td>Collection<code>&lt;Thread&gt;</code>getQueuedThreads()</td>
<td>返回一个包含可能正在等待获取的线程的集合。</td>
</tr>
</tbody></table>
<h1 id="使用AQS实现简单的同步工具"><a href="#使用AQS实现简单的同步工具" class="headerlink" title="使用AQS实现简单的同步工具"></a>使用AQS实现简单的同步工具</h1><h2 id="不可重入的独占锁Mutex"><a href="#不可重入的独占锁Mutex" class="headerlink" title="不可重入的独占锁Mutex"></a>不可重入的独占锁Mutex</h2><p>这个 <code>Mutex</code> 就是对上面的 <em>自己实现锁</em> 的句号了，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Our internal helper class</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Acquires the lock if state is zero</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">assert</span> acquires == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 设置当前拥有独占访问权限的线程。</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Releases the lock by setting state to zero</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">assert</span> releases == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())  <span class="comment">// 只有抢到锁的才能释放锁</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// a data race, but safe due to out-of-thin-air guarantees</span></span><br><span class="line">            <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reports whether in locked state</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Provides a Condition</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AbstractQueuedSynchronizer.ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The sync object does all the hard work. We just forward to it.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isLocked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHeldByCurrentThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.hasQueuedThreads();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="简易的发令枪-BooleanLatch"><a href="#简易的发令枪-BooleanLatch" class="headerlink" title="简易的发令枪 BooleanLatch"></a>简易的发令枪 BooleanLatch</h2><p>如下图实现的是一个简单的<code>CountDownLatch</code>,</p>
<p>不过只需要调用<code>fire</code>就可以唤醒所有那些因为它而等待的线程。</p>
<p>值得注意的是，因为唤醒的时候是全部都要唤醒，并且完全可以有多个线程同时去调用<code>fire()</code>，</p>
<p>所以<strong>下面的对于同步状态的获取和释放都是共享式的</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BooleanLatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">isSignalled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> ignore)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> isSignalled() ? <span class="number">1</span> : -<span class="number">1</span>; <span class="comment">// &gt;= 0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> ignore)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">assert</span> ignore == <span class="number">1</span>; <span class="comment">// just use state 1</span></span><br><span class="line">            setState(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        BooleanLatch booleanLatch = <span class="keyword">new</span> BooleanLatch();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    booleanLatch.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; start&quot;</span>);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;倒计时&quot;</span> + (<span class="number">3</span> - i));</span><br><span class="line">        &#125;</span><br><span class="line">        booleanLatch.fire();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最多两个线程同时获得锁-TwinsLock"><a href="#最多两个线程同时获得锁-TwinsLock" class="headerlink" title="最多两个线程同时获得锁 TwinsLock"></a>最多两个线程同时获得锁 TwinsLock</h2><p>因为允许多个线程同时获取锁，所以这里的对于同步状态的获取都是共享式的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwinsLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Sync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            setState(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123; <span class="comment">// 直到成功或者当前不可获取锁（不可获取锁就要去等待）</span></span><br><span class="line">                <span class="keyword">int</span> count = getState();</span><br><span class="line">                <span class="keyword">int</span> newCount = count - arg;</span><br><span class="line">                <span class="keyword">if</span> (newCount &lt; <span class="number">0</span> || compareAndSetState(count, newCount)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> newCount;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">int</span> count = getState();</span><br><span class="line">                <span class="keyword">int</span> newCount = count + arg;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(count, newCount)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireShared(<span class="number">1</span>) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(time);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> TwinsLock();</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">                TwinsLock.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        Worker worker = <span class="keyword">new</span> Worker();</span><br><span class="line">        worker.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        worker.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>








<h1 id="AQS源码分析"><a href="#AQS源码分析" class="headerlink" title="AQS源码分析"></a>AQS源码分析</h1><h1 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** Marker to indicate a node is waiting in shared mode */</span></span><br><span class="line">        <span class="comment">// 共享等待模式</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">        <span class="comment">/** Marker to indicate a node is waiting in exclusive mode */</span></span><br><span class="line">        <span class="comment">// 独占等待模式</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** waitStatus value to indicate thread has cancelled */</span></span><br><span class="line">        <span class="comment">// 表明：由于在同步队列中等待的线程等待超时或被中断，需要从队列中取消等待，节点进入此状态就不再变化</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** waitStatus value to indicate successor&#x27;s thread needs unparking */</span></span><br><span class="line">        <span class="comment">// 后继节点正在等待，而当前线程释放了同步状态或取消，会通知后继节点</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** waitStatus value to indicate thread is waiting on condition */</span></span><br><span class="line">        <span class="comment">// 节点当在等待队列里，节点相关的线程正在因某个Condition等待</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 表明下一次共享式同步状态获取将会无条件的传播下去</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尽可取为上述的枚举状态和初始化状态 0 ;</span></span><br><span class="line">        <span class="comment">// waitStatus &lt; 0, 表明需要给Node发信号做一些事情，反之无需</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前驱</span></span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line">        <span class="comment">// 后继</span></span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line">        <span class="comment">// 在构造时初始化并在使用后置 null</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该字段的含义被复用：</span></span><br><span class="line">        <span class="comment">// 1. </span></span><br><span class="line">        Node nextWaiter;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否是共享式等待的节点类型</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns previous node, or throws NullPointerException if null.</span></span><br><span class="line"><span class="comment">         * Use when predecessor cannot be null.  The null check could</span></span><br><span class="line"><span class="comment">         * be elided, but is present to help the VM.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> the predecessor of this node</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">            Node p = prev;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">            <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">            <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 懒初始化，仅通过 setHead 修改（除了初始化的时候）</span></span><br><span class="line">    <span class="comment">// 首节点，总是获取同步状态成功的节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾节点，懒初始化，仅通过 enq 修改</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure>



<h2 id="独占式同步状态的获取与释放"><a href="#独占式同步状态的获取与释放" class="headerlink" title="独占式同步状态的获取与释放"></a>独占式同步状态的获取与释放</h2><ul>
<li>同步器的独占式同步状态的获取：<code>acquire(int arg)</code></li>
</ul>
<p>先尝试一下获取同步状态，失败后线程安全地将节点加入<strong>同步队列</strong> (调用addWaiter)。</p>
<p>然后进入同步队列的那些节点而言，就进入了一个自旋过程，该节点以”死循环“的方式获取同步状态（调用acquireQueued）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 先尝试一下获取同步状态，失败后</span></span><br><span class="line">       <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">           acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">           selfInterrupt(); <span class="comment">// </span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>





<ul>
<li>为当前线程和给定模式创建和排队节点。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">        <span class="comment">// 先快速尝试一下</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123; <span class="comment">// cas 设置尾巴</span></span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果上面的 cas 失败再调用 enq(node);</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>将节点插入队列，必要时进行初始化。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回入队节点 node 的前驱</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>对于进入同步队列的节点，会进入一个自旋的过程：</p>
<p>在<strong>前驱为head</strong>时，尝试获取同步状态（调用tryAcquire）,如果获取到同步状态，则退出自旋；</p>
<p>否则进入阻塞（调用parkAndCheckInterrupt）。</p>
<p>再它被唤醒的时候再次进行上面的尝试，一直这样循环下去。</p>
<img src="aqs-acquire.png" alt="aqs-acquire" style="zoom:50%;" />



<ul>
<li>以独占不响应中断的模式获取同步状态</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 如果在等待时中断，则返回true</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>头结点的线程释放了同步状态之后，将唤醒其后继节点，后继节点的线程被唤醒之后在去尝试获取同步状态。</p>
<p>不过需要注意，一定要有<code>p == head </code>的测试，<strong>因为只有首节点才拥有同步状态，但是非首节点有可能因为中断而被唤醒</strong>（也就是说要防止过早通知的情况）。</p>
<ul>
<li>可中断的获取同步状态</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和上面的并没有什么差别，只是会直接抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException(); <span class="comment">// 如果在等待中被中断，直接抛出 InterruptedException</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="共享式同步状态的获取与释放"><a href="#共享式同步状态的获取与释放" class="headerlink" title="共享式同步状态的获取与释放"></a>共享式同步状态的获取与释放</h2><p>先挖个坑。。。</p>
]]></content>
      <categories>
        <category>JUC</category>
      </categories>
      <tags>
        <tag>JUC</tag>
        <tag>Java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC之Lock、Condition接口与实现原理</title>
    <url>/2021/11/13/JUC%E4%B9%8BLock%E3%80%81Condition%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h1><h2 id="Lock接口的API"><a href="#Lock接口的API" class="headerlink" title="Lock接口的API"></a>Lock接口的API</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent.locks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取锁，如果不能立即获取，阻塞，获取到锁之后从该方法返回</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取锁，相比lock()方法，它可以相应中断</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非阻塞的尝试获取锁，如果能立即获取并返回true，否则立即返回false</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带超时的获取锁，发生下列情况之一时返回</span></span><br><span class="line">    <span class="comment">// 1. 获取到锁</span></span><br><span class="line">    <span class="comment">// 2. 超时</span></span><br><span class="line">    <span class="comment">// 3. 被中断</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取通知组件，该组件和该lock实例（监视器的概念）绑定</span></span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如何使用它</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="Lock和synchronized的联系与区别"><a href="#Lock和synchronized的联系与区别" class="headerlink" title="Lock和synchronized的联系与区别"></a>Lock和synchronized的联系与区别</h2><p><strong>共同点</strong></p>
<p>都是Java中常用的同步工具，都实现了锁的语义，都有预期配套的监视器方法。</p>
<p><strong>Lock相比于synchronized的特性</strong></p>
<ol>
<li>相比于<code>synchronized</code>隐式地获取、释放锁，Lock放弃了这一小小的便利性，让程序员自己获取和释放锁，控制的粒度细很多，尤其是在多把锁的有序性获取和释放时，更是<code>synchronized</code>做不到的；</li>
<li>可中断的获取锁；</li>
<li>提供尝试性的获取锁</li>
<li>可以超时获取锁</li>
</ol>
<h1 id="Condition接口"><a href="#Condition接口" class="headerlink" title="Condition接口"></a>Condition接口</h1><p>任何一个Java类都隐式继承了<code>java.lang.Object</code>,Obejct中的<code>wait()</code>、<code>wait(long timeout)</code>、<code>notify()</code>、<code>notifyAll()</code>方法。这些方法和<code>syschrinized</code>关键字配合就可以实现经典的<strong>等待-通知模式</strong></p>
<p><code>Condition</code>接口也提供了类似Object的监视器方法，与<code>Lock</code>配合也能实现上述的效果，并且功能更完整。</p>
<p>对比</p>
<h2 id="Condition接口的API"><a href="#Condition接口的API" class="headerlink" title="Condition接口的API"></a>Condition接口的API</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent.locks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使当前线程等待，直到它被唤醒或被中断。</span></span><br><span class="line">    <span class="comment">// 在此方法可以返回当前线程之前，必须重新获取与此条件关联的锁,当线程返回时，它保证持有这个锁。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使当前线程等待，直到它被唤醒（不受中断影响）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进入等待状态直到被通知、中断、超时（时间单位是纳秒）</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与上面类似，不过可以指定时间单位</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与上面类似，不过直接指定终点时间</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒一个等待在Condition上的线程，该线程从等待方法返回前必须获得与Condition相关联的锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒所有等待在Condition上的线程，该线程从等待方法返回前必须获得与Condition相关联的锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="Condition的实现分析"><a href="#Condition的实现分析" class="headerlink" title="Condition的实现分析"></a>Condition的实现分析</h2><img src="LockAndCondition.png" style="zoom:25%;" />





<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只截取部分部分</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ConditionObject</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Internal methods</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Adds a new waiter to wait queue.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> its new wait node</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            Node t = lastWaiter;</span><br><span class="line">            <span class="comment">// If lastWaiter is cancelled, clean out.</span></span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">                t = lastWaiter;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Node node = <span class="keyword">new</span> Node(Node.CONDITION);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">                firstWaiter = node;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                t.nextWaiter = node;</span><br><span class="line">            lastWaiter = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Removes and transfers nodes until hit non-cancelled one or</span></span><br><span class="line"><span class="comment">         * null. Split out from signal in part to encourage compilers</span></span><br><span class="line"><span class="comment">         * to inline the case of no waiters.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> first (non-null) the first node on condition queue</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">                    lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">                first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">                     (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Removes and transfers all nodes.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> first (non-null) the first node on condition queue</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignalAll</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">            lastWaiter = firstWaiter = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                Node next = first.nextWaiter;</span><br><span class="line">                first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">                transferForSignal(first);</span><br><span class="line">                first = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (first != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Unlinks cancelled waiter nodes from condition queue.</span></span><br><span class="line"><span class="comment">         * Called only while holding lock. This is called when</span></span><br><span class="line"><span class="comment">         * cancellation occurred during condition wait, and upon</span></span><br><span class="line"><span class="comment">         * insertion of a new waiter when lastWaiter is seen to have</span></span><br><span class="line"><span class="comment">         * been cancelled. This method is needed to avoid garbage</span></span><br><span class="line"><span class="comment">         * retention in the absence of signals. So even though it may</span></span><br><span class="line"><span class="comment">         * require a full traversal, it comes into play only when</span></span><br><span class="line"><span class="comment">         * timeouts or cancellations occur in the absence of</span></span><br><span class="line"><span class="comment">         * signals. It traverses all nodes rather than stopping at a</span></span><br><span class="line"><span class="comment">         * particular target to unlink all pointers to garbage nodes</span></span><br><span class="line"><span class="comment">         * without requiring many re-traversals during cancellation</span></span><br><span class="line"><span class="comment">         * storms.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Node t = firstWaiter;</span><br><span class="line">            Node trail = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Node next = t.nextWaiter;</span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">                    t.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (trail == <span class="keyword">null</span>)</span><br><span class="line">                        firstWaiter = next;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        trail.nextWaiter = next;</span><br><span class="line">                    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                        lastWaiter = trail;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    trail = t;</span><br><span class="line">                t = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// public methods</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Moves the longest-waiting thread, if one exists, from the</span></span><br><span class="line"><span class="comment">         * wait queue for this condition to the wait queue for the</span></span><br><span class="line"><span class="comment">         * owning lock.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> IllegalMonitorStateException if &#123;<span class="doctag">@link</span> #isHeldExclusively&#125;</span></span><br><span class="line"><span class="comment">         *         returns &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            Node first = firstWaiter;</span><br><span class="line">            <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">                doSignal(first);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Moves all threads from the wait queue for this condition to</span></span><br><span class="line"><span class="comment">         * the wait queue for the owning lock.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> IllegalMonitorStateException if &#123;<span class="doctag">@link</span> #isHeldExclusively&#125;</span></span><br><span class="line"><span class="comment">         *         returns &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            Node first = firstWaiter;</span><br><span class="line">            <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">                doSignalAll(first);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Implements uninterruptible condition wait.</span></span><br><span class="line"><span class="comment">         * &lt;ol&gt;</span></span><br><span class="line"><span class="comment">         * &lt;li&gt;Save lock state returned by &#123;<span class="doctag">@link</span> #getState&#125;.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt;Invoke &#123;<span class="doctag">@link</span> #release&#125; with saved state as argument,</span></span><br><span class="line"><span class="comment">         *     throwing IllegalMonitorStateException if it fails.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt;Block until signalled.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt;Reacquire by invoking specialized version of</span></span><br><span class="line"><span class="comment">         *     &#123;<span class="doctag">@link</span> #acquire&#125; with saved state as argument.</span></span><br><span class="line"><span class="comment">         * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Node node = addConditionWaiter();</span><br><span class="line">            <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (acquireQueued(node, savedState) || interrupted)</span><br><span class="line">                selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * For interruptible waits, we need to track whether to throw</span></span><br><span class="line"><span class="comment">         * InterruptedException, if interrupted while blocked on</span></span><br><span class="line"><span class="comment">         * condition, versus reinterrupt current thread, if</span></span><br><span class="line"><span class="comment">         * interrupted while blocked waiting to re-acquire.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Mode meaning to reinterrupt on exit from wait */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REINTERRUPT =  <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** Mode meaning to throw InterruptedException on exit from wait */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THROW_IE    = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Checks for interrupt, returning THROW_IE if interrupted</span></span><br><span class="line"><span class="comment">         * before signalled, REINTERRUPT if after signalled, or</span></span><br><span class="line"><span class="comment">         * 0 if not interrupted.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Thread.interrupted() ?</span><br><span class="line">                (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class="line">                <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Throws InterruptedException, reinterrupts current thread, or</span></span><br><span class="line"><span class="comment">         * does nothing, depending on mode.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportInterruptAfterWait</span><span class="params">(<span class="keyword">int</span> interruptMode)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (interruptMode == THROW_IE)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (interruptMode == REINTERRUPT)</span><br><span class="line">                selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Implements interruptible condition wait.</span></span><br><span class="line"><span class="comment">         * &lt;ol&gt;</span></span><br><span class="line"><span class="comment">         * &lt;li&gt;If current thread is interrupted, throw InterruptedException.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt;Save lock state returned by &#123;<span class="doctag">@link</span> #getState&#125;.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt;Invoke &#123;<span class="doctag">@link</span> #release&#125; with saved state as argument,</span></span><br><span class="line"><span class="comment">         *     throwing IllegalMonitorStateException if it fails.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt;Block until signalled or interrupted.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt;Reacquire by invoking specialized version of</span></span><br><span class="line"><span class="comment">         *     &#123;<span class="doctag">@link</span> #acquire&#125; with saved state as argument.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt;If interrupted while blocked in step 4, throw InterruptedException.</span></span><br><span class="line"><span class="comment">         * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            Node node = addConditionWaiter();</span><br><span class="line">            <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">            <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">                interruptMode = REINTERRUPT;</span><br><span class="line">            <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">            <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">                reportInterruptAfterWait(interruptMode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Implements timed condition wait.</span></span><br><span class="line"><span class="comment">         * &lt;ol&gt;</span></span><br><span class="line"><span class="comment">         * &lt;li&gt;If current thread is interrupted, throw InterruptedException.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt;Save lock state returned by &#123;<span class="doctag">@link</span> #getState&#125;.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt;Invoke &#123;<span class="doctag">@link</span> #release&#125; with saved state as argument,</span></span><br><span class="line"><span class="comment">         *     throwing IllegalMonitorStateException if it fails.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt;Block until signalled, interrupted, or timed out.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt;Reacquire by invoking specialized version of</span></span><br><span class="line"><span class="comment">         *     &#123;<span class="doctag">@link</span> #acquire&#125; with saved state as argument.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt;If interrupted while blocked in step 4, throw InterruptedException.</span></span><br><span class="line"><span class="comment">         * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            <span class="comment">// We don&#x27;t check for nanosTimeout &lt;= 0L here, to allow</span></span><br><span class="line">            <span class="comment">// awaitNanos(0) as a way to &quot;yield the lock&quot;.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">            <span class="keyword">long</span> initialNanos = nanosTimeout;</span><br><span class="line">            Node node = addConditionWaiter();</span><br><span class="line">            <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">            <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                    transferAfterCancelledWait(node);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nanosTimeout &gt; SPIN_FOR_TIMEOUT_THRESHOLD)</span><br><span class="line">                    LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">                <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">                interruptMode = REINTERRUPT;</span><br><span class="line">            <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">            <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">                reportInterruptAfterWait(interruptMode);</span><br><span class="line">            <span class="keyword">long</span> remaining = deadline - System.nanoTime(); <span class="comment">// avoid overflow</span></span><br><span class="line">            <span class="keyword">return</span> (remaining &lt;= initialNanos) ? remaining : Long.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Implements absolute timed condition wait.</span></span><br><span class="line"><span class="comment">         * &lt;ol&gt;</span></span><br><span class="line"><span class="comment">         * &lt;li&gt;If current thread is interrupted, throw InterruptedException.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt;Save lock state returned by &#123;<span class="doctag">@link</span> #getState&#125;.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt;Invoke &#123;<span class="doctag">@link</span> #release&#125; with saved state as argument,</span></span><br><span class="line"><span class="comment">         *     throwing IllegalMonitorStateException if it fails.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt;Block until signalled, interrupted, or timed out.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt;Reacquire by invoking specialized version of</span></span><br><span class="line"><span class="comment">         *     &#123;<span class="doctag">@link</span> #acquire&#125; with saved state as argument.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt;If interrupted while blocked in step 4, throw InterruptedException.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt;If timed out while blocked in step 4, return false, else true.</span></span><br><span class="line"><span class="comment">         * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> abstime = deadline.getTime();</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            Node node = addConditionWaiter();</span><br><span class="line">            <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">            <span class="keyword">boolean</span> timedout = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (System.currentTimeMillis() &gt;= abstime) &#123;</span><br><span class="line">                    timedout = transferAfterCancelledWait(node);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                LockSupport.parkUntil(<span class="keyword">this</span>, abstime);</span><br><span class="line">                <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">                interruptMode = REINTERRUPT;</span><br><span class="line">            <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">            <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">                reportInterruptAfterWait(interruptMode);</span><br><span class="line">            <span class="keyword">return</span> !timedout;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Implements timed condition wait.</span></span><br><span class="line"><span class="comment">         * &lt;ol&gt;</span></span><br><span class="line"><span class="comment">         * &lt;li&gt;If current thread is interrupted, throw InterruptedException.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt;Save lock state returned by &#123;<span class="doctag">@link</span> #getState&#125;.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt;Invoke &#123;<span class="doctag">@link</span> #release&#125; with saved state as argument,</span></span><br><span class="line"><span class="comment">         *     throwing IllegalMonitorStateException if it fails.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt;Block until signalled, interrupted, or timed out.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt;Reacquire by invoking specialized version of</span></span><br><span class="line"><span class="comment">         *     &#123;<span class="doctag">@link</span> #acquire&#125; with saved state as argument.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt;If interrupted while blocked in step 4, throw InterruptedException.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt;If timed out while blocked in step 4, return false, else true.</span></span><br><span class="line"><span class="comment">         * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> nanosTimeout = unit.toNanos(time);</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            <span class="comment">// We don&#x27;t check for nanosTimeout &lt;= 0L here, to allow</span></span><br><span class="line">            <span class="comment">// await(0, unit) as a way to &quot;yield the lock&quot;.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">            Node node = addConditionWaiter();</span><br><span class="line">            <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">            <span class="keyword">boolean</span> timedout = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                    timedout = transferAfterCancelledWait(node);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nanosTimeout &gt; SPIN_FOR_TIMEOUT_THRESHOLD)</span><br><span class="line">                    LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">                <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">                interruptMode = REINTERRUPT;</span><br><span class="line">            <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">            <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">                reportInterruptAfterWait(interruptMode);</span><br><span class="line">            <span class="keyword">return</span> !timedout;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  support for instrumentation</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns true if this condition was created by the given</span></span><br><span class="line"><span class="comment">         * synchronization object.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if owned</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOwnedBy</span><span class="params">(AbstractQueuedSynchronizer sync)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> sync == AbstractQueuedSynchronizer.<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Queries whether any threads are waiting on this condition.</span></span><br><span class="line"><span class="comment">         * Implements &#123;<span class="doctag">@link</span> AbstractQueuedSynchronizer#hasWaiters(ConditionObject)&#125;.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if there are any waiting threads</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> IllegalMonitorStateException if &#123;<span class="doctag">@link</span> #isHeldExclusively&#125;</span></span><br><span class="line"><span class="comment">         *         returns &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            <span class="keyword">for</span> (Node w = firstWaiter; w != <span class="keyword">null</span>; w = w.nextWaiter) &#123;</span><br><span class="line">                <span class="keyword">if</span> (w.waitStatus == Node.CONDITION)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns an estimate of the number of threads waiting on</span></span><br><span class="line"><span class="comment">         * this condition.</span></span><br><span class="line"><span class="comment">         * Implements &#123;<span class="doctag">@link</span> AbstractQueuedSynchronizer#getWaitQueueLength(ConditionObject)&#125;.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> the estimated number of waiting threads</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> IllegalMonitorStateException if &#123;<span class="doctag">@link</span> #isHeldExclusively&#125;</span></span><br><span class="line"><span class="comment">         *         returns &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getWaitQueueLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (Node w = firstWaiter; w != <span class="keyword">null</span>; w = w.nextWaiter) &#123;</span><br><span class="line">                <span class="keyword">if</span> (w.waitStatus == Node.CONDITION)</span><br><span class="line">                    ++n;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns a collection containing those threads that may be</span></span><br><span class="line"><span class="comment">         * waiting on this Condition.</span></span><br><span class="line"><span class="comment">         * Implements &#123;<span class="doctag">@link</span> AbstractQueuedSynchronizer#getWaitingThreads(ConditionObject)&#125;.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> the collection of threads</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> IllegalMonitorStateException if &#123;<span class="doctag">@link</span> #isHeldExclusively&#125;</span></span><br><span class="line"><span class="comment">         *         returns &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Collection&lt;Thread&gt; <span class="title">getWaitingThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            ArrayList&lt;Thread&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (Node w = firstWaiter; w != <span class="keyword">null</span>; w = w.nextWaiter) &#123;</span><br><span class="line">                <span class="keyword">if</span> (w.waitStatus == Node.CONDITION) &#123;</span><br><span class="line">                    Thread t = w.thread;</span><br><span class="line">                    <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                        list.add(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>JUC</category>
      </categories>
      <tags>
        <tag>JUC</tag>
        <tag>Java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE基础 —— 代理模式、Java中的动态代理、Proxy源码分析、实例分析</title>
    <url>/2021/10/02/JavaSE%E5%9F%BA%E7%A1%80%20%E2%80%94%E2%80%94%20%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E3%80%81Java%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E3%80%81Proxy%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%81%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><ul>
<li>目的：为其他对象提供一种代理以控制对这个对象的访问，可以增强、可以削弱。</li>
<li>应用实例：Spring中的<strong>AOP</strong></li>
<li>代理的分类：<strong>静态代理</strong>、<strong>动态代理</strong><br>其中静态代理、动态代理的区别在于代理的生成时期不同 —— 前者在编译前就已经编写好代理类，后者在运行时动态生成代理类。</li>
<li>Java中代理的具体实现，依赖于接口实现(JDK实现的代理)、依赖于继承实现(CGLIB实现的代理)。</li>
</ul>
<h2 id="Java中的动态代理"><a href="#Java中的动态代理" class="headerlink" title="Java中的动态代理"></a>Java中的动态代理</h2><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>JDK原生支持的代理依靠一个InvocationHandler接口和一个类Proxy。<br>先把API放出来。</p>
<ul>
<li><code>java.lang.reflect.InvocationHandler</code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span>;</span><br></pre></td></tr></table></figure>
使用method句柄调用<strong>被代理对象</strong>的方法，方法参数是args,返回值 Object<br>(需要强转，但是不需要我们自己强转)。<br>注意，这里的<code>proxy</code>是生成的代理对象，不是我们希望被代理的真实的对象，而真实的对象需要在<code>InvocationHandler</code>接口的实现里，将它传进去。</li>
</ul>
<p><strong>这个接口也就是我们在实现代理的时候关注最多的方法，对它的实现，决定了我们究竟完成了对目标对象怎样的控制。</strong></p>
<ul>
<li><code>java.lang.reflect.Proxy</code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回代理类的类类型（不过已被废弃，不建议使用）</span></span><br><span class="line"><span class="keyword">static</span> Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces);</span><br><span class="line"><span class="comment">// 通过类加载器(这个参数暂时可以忽略)，代理类需要实现的接口、调用处理器生成代理类的实例</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,Class&lt;?&gt;[] interfaces ,InvocationHandler handler)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 判断类类型是否是代理类</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isProxyClass</span><span class="params">(Class&lt;?&gt; cl)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>在前面的叙述中，我们知道想要生成一个代理类需要提供三样东西，</p>
<ol>
<li>类加载器</li>
<li>接口组</li>
<li>调用处理</li>
</ol>
<p>下面实操一下。<br>（例子来源于《Java核心技术卷1》）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> about_proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Song yang Ji</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ProjectName</span>: learnJavaSE</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 使用代理完成对Comparable方法调用的跟踪</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceUsingProxy</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">// 调用处理器	</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 被代理的对象</span></span><br><span class="line">        <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TraceHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.target = target;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> proxy  代理的对象</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> method 方法句柄</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> args   方法参数</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> method方法的返回值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="comment">// 输出方法的调用信息</span></span><br><span class="line">            System.out.print(target + <span class="string">&quot;.&quot;</span> + method.getName() + <span class="string">&quot;(&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) System.out.print(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">                    System.out.print(args[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">            <span class="comment">// 调用 target 对象的 method 方法，参数是 args</span></span><br><span class="line">            <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.getProperties().put(<span class="string">&quot;jdk.proxy.ProxyGenerator.saveGeneratedFiles&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">1000</span>;</span><br><span class="line">        Object[] proxyInteger = <span class="keyword">new</span> Object[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            proxyInteger[i] = Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), <span class="keyword">new</span> Class[]&#123;</span><br><span class="line">                    Comparable.class</span><br><span class="line">            &#125;, <span class="keyword">new</span> TraceHandler(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> key = <span class="keyword">new</span> Random().nextInt(N);</span><br><span class="line">        <span class="keyword">int</span> res = Arrays.binarySearch(proxyInteger, key);</span><br><span class="line">        System.out.printf(<span class="string">&quot;key %d is at %d\n&quot;</span>, key, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代理类的特性"><a href="#代理类的特性" class="headerlink" title="代理类的特性"></a>代理类的特性</h2><ol>
<li>代理类是在运行时动态生成的，但是一旦生成，就是个普通类，在jvm眼里和其他类没有任何不同。</li>
<li>所有的代理类都继承自<code>Proxy</code>。</li>
<li>生成的代理类的名字往往是$Proxy开头的，但默认不可见，运行后即销毁。</li>
<li>代理类Proxy及具体的代理类都只有一个实例字段，就是<code>InvocationHandler</code>的实例，所有对被代理对象的控制都在这里完成。</li>
<li>生成代理类除了会override掉你指定的接口，还会覆盖Object里的<code>toString</code>、<code>equals</code>,<code>hashCode</code>方法。（后面会用代码说明）</li>
<li>对于一个特定的类加载器和预设的一组接口来说，只会生成一个代理类。<br>也就是通过<code>getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces)</code>;获得的代理类。</li>
</ol>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>想要看到动态生成的代理类。你可以在代码的开头加上：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.getProperties().put(<span class="string">&quot;jdk.proxy.ProxyGenerator.saveGeneratedFiles&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> about_proxy;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.getProperties().put(<span class="string">&quot;jdk.proxy.ProxyGenerator.saveGeneratedFiles&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">		<span class="comment">// 实现了众多接口的一个代理类</span></span><br><span class="line">        Object proxy = Proxy.newProxyInstance(Test.class.getClassLoader(), <span class="keyword">new</span> Class[]&#123;</span><br><span class="line">                Serializable.class, Comparable.class, List.class, Runnable.class</span><br><span class="line">        &#125;, (proxy1, method, args1) -&gt; <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(proxy.getClass().getName());</span><br><span class="line">		<span class="comment">// 没有实现任何接口的代理类</span></span><br><span class="line">        Object proxy2 = Proxy.newProxyInstance(Test.class.getClassLoader(), <span class="keyword">new</span> Class[]&#123;</span><br><span class="line">        &#125;, (proxy1, method, args1) -&gt; <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(proxy2.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行它，看一下生成的类的代码，分析一下内在机制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Comparable</span>, <span class="title">List</span>, <span class="title">Runnable</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m4;</span><br><span class="line">    <span class="comment">// ...... 还有其他Method句柄</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method mxx;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 调用父类的构造函数，传入唯一的实例字段</span></span><br><span class="line">    <span class="keyword">public</span> $Proxy1(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 下面三个是覆盖Object的三个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">     <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这个是覆盖List接口里的add方法，具体方法的调用就要到InvocationHandler去实现</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> var1, Object var2)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m4, <span class="keyword">new</span> Object[]&#123;var1, var2&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var4;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var5);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 还有其他方法的override</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 静态代码段，初始化所有的Method对象。</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        	<span class="comment">// </span></span><br><span class="line">            m1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;equals&quot;</span>, Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">            m4 = Class.forName(<span class="string">&quot;java.util.List&quot;</span>).getMethod(<span class="string">&quot;add&quot;</span>, Integer.TYPE, Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>));</span><br><span class="line">            <span class="comment">// ... </span></span><br><span class="line">            <span class="comment">// 下面还有其他Method对象的生成，方法与上面的类似</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE基础 —— 反射的基础、Class、Field、Method、Constructor类</title>
    <url>/2021/09/25/JavaSE%E5%9F%BA%E7%A1%80%20%E2%80%94%E2%80%94%20%E5%8F%8D%E5%B0%84%E7%9A%84%E5%9F%BA%E7%A1%80%E3%80%81Class%E3%80%81Field%E3%80%81Method%E3%80%81Constructor%E7%B1%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>简单的介绍一下反射的概念。为框架的学习打下基础。</p>
</blockquote>
<h1 id="反射概念"><a href="#反射概念" class="headerlink" title="反射概念"></a>反射概念</h1><p>反射可以在运行时动态分析类，解析一个类的构造器、字段、方法、接口等等。<br>反射有何作用，或者说为什么要学习反射？<br>作为应用程序员，一般情况下，并不直接使用反射，它更多在构建系统级程序时发挥用处，如实现Java的Spring框架、持久层框架Mybatis时，反射的使用处处可见。Java的其他特性或技术也依赖于反射，如代理（Proxy）等等。</p>
<p>所以，学习反射，很大程度上并不是让我们直接使用反射，而是更好地理解框架的实现，更好地操纵框架。</p>
<h1 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a>Class 类</h1><p>我们知道一个类有一些基本要素构成，如<br><strong>构造器、成员变量（字段）、成员方法</strong>等等。<br>那么这些信息如何描述呢？或者说，一个类本身的信息用什么类去描述呢？</p>
<p><strong>Class类就是用来描述类本身的信息的</strong>。</p>
<p>因为一个类的信息有很多，这里就不把Class类完整的分析一下了。<br>这里这分析最易理解，也是类的最基本的元素信息。</p>
<p>源码分析。</p>
<p>下面是<code>Class</code>类中的一些方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回类的名字</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>;</span><br><span class="line"><span class="comment">// 获取类及超类的公共字段、方法、构造器</span></span><br><span class="line"><span class="keyword">public</span> Field[] getFields();</span><br><span class="line"><span class="keyword">public</span> Method[] getMethods();</span><br><span class="line"><span class="keyword">public</span> Constructor[] getConstructors();</span><br><span class="line"><span class="comment">// 返回特定的字段、方法、构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Field <span class="title">getField</span><span class="params">(String name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Constructor&lt;T&gt; <span class="title">getConstructor</span><span class="params">(Class&lt;?&gt;... parameterTypes)</span></span>;</span><br></pre></td></tr></table></figure>

<p>既然Class是一个类，如何获得它的实例对象。</p>
<ol>
<li><p>object.getClass()</p>
</li>
<li><p>T.class</p>
</li>
<li><p>Class.forName(className)</p>
</li>
</ol>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student student;</span><br><span class="line">Class studentClass1 = student.getClass();</span><br><span class="line">Class studentClass2 = Student.class;</span><br><span class="line">Class studentClass3 = Class.forName(<span class="string">&quot;Student&quot;</span>);</span><br></pre></td></tr></table></figure>


<p>在<code>java.lang.reflect</code>包里，有三个类值得关注，就Class描述类本身信息类似，也许有特定的三个类去描述<strong>构造器、字段、方法</strong>。</p>
<p>而且这三个类具有共性,因为其实都是类的成员。<br>所以类中的方法都类似。</p>
<p><img src="/2021/09/25/JavaSE%E5%9F%BA%E7%A1%80%20%E2%80%94%E2%80%94%20%E5%8F%8D%E5%B0%84%E7%9A%84%E5%9F%BA%E7%A1%80%E3%80%81Class%E3%80%81Field%E3%80%81Method%E3%80%81Constructor%E7%B1%BB/extends.png" alt="类图"></p>
<p>实现的<code>Member</code>接口中的部分方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回声明这个字段、构造器、方法的类</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; getDeclaringClass();</span><br><span class="line"><span class="comment">// 返回这个字段、构造器、方法的名字</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 返回这个字段、构造器、方法的修饰符</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getModifiers</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="Field-类"><a href="#Field-类" class="headerlink" title="Field 类"></a>Field 类</h2><p>三个很重要的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回字段类型</span></span><br><span class="line"><span class="function">Class <span class="title">getType</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 返回字段名字（标识符）</span></span><br><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 返回某个对象的这个字段的值。</span></span><br><span class="line"><span class="function">Object <span class="title">get</span><span class="params">(obj)</span></span>;</span><br><span class="line"><span class="comment">// 给对象赋值</span></span><br><span class="line">set(Object obj,Object value);</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 这里必须是public,否则是不可达的（当然也可以强制设置为accessible）</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student(<span class="string">&quot;Mike&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        Class cl = Student.class;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field nameField = cl.getField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;字段名字: &quot;</span> + nameField.getName());</span><br><span class="line">            Class fieldType = nameField.getType();</span><br><span class="line">            System.out.println(<span class="string">&quot;字段类型: &quot;</span> + fieldType);</span><br><span class="line">            Object filedValue = nameField.get(student);</span><br><span class="line">            System.out.println(<span class="string">&quot;字段的值: &quot;</span> + filedValue);</span><br><span class="line">            nameField.set(student,<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">            System.out.println(student.name);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在c/c++语言中，有方法指针（其实就是函数的入口地址）传给函数做参数。<br>但是Java的设计者认为这是不安全的，所以没有显示的方法指针。</p>
<p>Java提供的解决方案是接口和lambda表达式。</p>
<p>但是这里的Method对象，也可以提供像函数指针的效果。</p>
<h2 id="Method-类"><a href="#Method-类" class="headerlink" title="Method 类"></a>Method 类</h2><p>与上面类似，有几个关键的方法值得注意。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据方法名和参数列表获得方法句柄</span></span><br><span class="line"><span class="function">Method <span class="title">getMethod</span><span class="params">(String name,Class... parameterTypes)</span></span>;</span><br><span class="line"><span class="comment">// 第一个参数为隐式参数，后面的方法的显示参数</span></span><br><span class="line"><span class="comment">// 如果是静态方法，第一个参数为null即可</span></span><br><span class="line">invoke(Object obj,Object... args);</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show information&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student(<span class="string">&quot;Mike&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        Class cl = Student.class;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 实例有参方法</span></span><br><span class="line">            Method setAgeMethod = cl.getMethod(<span class="string">&quot;setAge&quot;</span>, <span class="keyword">int</span>.class) ;</span><br><span class="line">            setAgeMethod.invoke(student,<span class="number">28</span>);</span><br><span class="line">            System.out.println(student.age);</span><br><span class="line">            <span class="comment">// 静态无参方法</span></span><br><span class="line">            Method showMethod = cl.getMethod(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">            showMethod.invoke(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法调用的缺点是明显的。<br>一是，参数和返回值都是Object，需要来回强制转换。<br>二是，这样调用方法本身就是兜了个圈子，很耗时。</p>
<p>与Method对象类似，Constructor不过是一种特殊的方法。</p>
<h2 id="Constructor-类"><a href="#Constructor-类" class="headerlink" title="Constructor 类"></a>Constructor 类</h2><p>几个重要的方法原型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Constructor&lt;T&gt; <span class="title">getConstructor</span><span class="params">(Class&lt;?&gt;... parameterTypes)</span></span>;</span><br><span class="line"><span class="comment">// 根据构造器生成实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(Object ... initargs)</span></span></span><br></pre></td></tr></table></figure>
<p>举例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class cl = Student.class;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Constructor constructor = cl.getConstructor(String.class,<span class="keyword">int</span>.class);</span><br><span class="line">            Student student = (Student) constructor.newInstance(<span class="string">&quot;Jack&quot;</span>,<span class="number">18</span>);</span><br><span class="line">            System.out.println(student);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException | IllegalAccessException | InstantiationException | InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>附：《Java核心技术卷》书上的源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> about_reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassAnalyzer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class cl;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassAnalyzer</span><span class="params">(Class clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cl = clazz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出所有的构造器（包括 private 、 protected）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printConstructors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Constructor[] constructors = cl.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span>(Constructor c:constructors)&#123;</span><br><span class="line">            String name = c.getName();</span><br><span class="line">            System.out.print(<span class="string">&quot;    &quot;</span>);</span><br><span class="line">            String modifiers = Modifier.toString(c.getModifiers());</span><br><span class="line">            <span class="keyword">if</span>(modifiers.length()&gt;<span class="number">0</span>) System.out.print(modifiers+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            System.out.print(name+<span class="string">&quot;(&quot;</span>);</span><br><span class="line"></span><br><span class="line">            Class[] paramTypes = c.getParameterTypes();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;paramTypes.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;<span class="number">0</span>) System.out.print(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">                System.out.print(paramTypes[j].getName());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;);&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出在这个类中的所有的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMethods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Method[] methods = cl.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span>(Method m:methods)&#123;</span><br><span class="line">            Class retype = m.getReturnType();</span><br><span class="line">            String methodName = m.getName();</span><br><span class="line">            System.out.print(<span class="string">&quot;    &quot;</span>);</span><br><span class="line">            String modifiers = Modifier.toString(m.getModifiers());</span><br><span class="line">            <span class="keyword">if</span>(modifiers.length()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.print(modifiers+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(retype.getName()+<span class="string">&quot; &quot;</span>+methodName+<span class="string">&quot;(&quot;</span>);</span><br><span class="line">            Class[] params = m.getParameterTypes();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;params.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;<span class="number">0</span>) System.out.print(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">                System.out.print(params[j].getName());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;);&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出在这个类中的所有的字段</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printFields</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Field[] fields = cl.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span>(Field field:fields) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;    &quot;</span>);</span><br><span class="line">            Class type = field.getType();</span><br><span class="line">            String modifiers = Modifier.toString(field.getModifiers());</span><br><span class="line">            <span class="keyword">if</span>(modifiers.length()&gt;<span class="number">0</span>) System.out.print(modifiers+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            System.out.println(type.getName()+<span class="string">&quot; &quot;</span>+field.getName()+<span class="string">&quot;;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Class supercl = cl.getSuperclass();</span><br><span class="line">        String modifiers = Modifier.toString(cl.getModifiers());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(modifiers.length()&gt;<span class="number">0</span>) System.out.print(modifiers+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;class &quot;</span>+cl.getName());</span><br><span class="line">        <span class="keyword">if</span>(supercl != <span class="keyword">null</span> &amp;&amp; supercl != Object.class)&#123;</span><br><span class="line">            System.out.print(<span class="string">&quot; extends &quot;</span>+supercl.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot; &#123;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        printFields();</span><br><span class="line"></span><br><span class="line">        printConstructors();</span><br><span class="line"></span><br><span class="line">        printMethods();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> about_reflect.ClassAnalyzer;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(<span class="keyword">var</span> in = <span class="keyword">new</span> Scanner(System.in))&#123;</span><br><span class="line">            ClassAnalyzer classAnalyzer;</span><br><span class="line">            String classname = in.next();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                classAnalyzer = <span class="keyword">new</span> ClassAnalyzer(Class.forName(classname));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;此类未找到&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            classAnalyzer.display();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 运行结果为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.String</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> [B value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span> coder;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> COMPACT_STRINGS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> [Ljava.io.ObjectStreamField; serialPersistentFields;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> java.util.Comparator CASE_INSENSITIVE_ORDER;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> LATIN1;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> UTF16;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> java.lang.String([B);</span><br><span class="line">    <span class="keyword">public</span> java.lang.String([B, <span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">public</span> java.lang.String([B, java.nio.charset.Charset);</span><br><span class="line">    <span class="keyword">public</span> java.lang.String([B, java.lang.String);</span><br><span class="line">    <span class="keyword">public</span> java.lang.String([B, <span class="keyword">int</span>, <span class="keyword">int</span>, java.nio.charset.Charset);</span><br><span class="line">    java.lang.String([C, <span class="keyword">int</span>, <span class="keyword">int</span>, java.lang.Void);</span><br><span class="line">    java.lang.String(java.lang.AbstractStringBuilder, java.lang.Void);</span><br><span class="line">    <span class="keyword">public</span> java.lang.String(java.lang.StringBuilder);</span><br><span class="line">    <span class="keyword">public</span> java.lang.String(java.lang.StringBuffer);</span><br><span class="line">    java.lang.String([B, <span class="keyword">byte</span>);</span><br><span class="line">    <span class="keyword">public</span> java.lang.String([C, <span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">public</span> java.lang.String([C);</span><br><span class="line">    <span class="keyword">public</span> java.lang.String(java.lang.String);</span><br><span class="line">    <span class="keyword">public</span> java.lang.String();</span><br><span class="line">    <span class="keyword">public</span> java.lang.String([B, <span class="keyword">int</span>, <span class="keyword">int</span>, java.lang.String);</span><br><span class="line">    <span class="keyword">public</span> java.lang.String([B, <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">public</span> java.lang.String([B, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">public</span> java.lang.String([I, <span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">    [<span class="function">B <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(java.lang.Object)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getChars</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, [C, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(java.lang.String)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(java.lang.Object)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(java.lang.String, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">([B, <span class="keyword">byte</span>, <span class="keyword">int</span>, java.lang.String, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(java.lang.String)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkIndex</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> java.lang.<span class="function">String <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> java.lang.<span class="function">String <span class="title">valueOf</span><span class="params">(<span class="keyword">float</span>)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> java.lang.<span class="function">String <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span>)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> java.lang.<span class="function">String <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span>)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> java.lang.<span class="function">String <span class="title">valueOf</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> java.lang.<span class="function">String <span class="title">valueOf</span><span class="params">(java.lang.Object)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> java.lang.<span class="function">String <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span>)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> java.lang.<span class="function">String <span class="title">valueOf</span><span class="params">([C)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> java.lang.<span class="function">String <span class="title">valueOf</span><span class="params">([C, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">byte</span> <span class="title">coder</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> java.lang.<span class="function">Void <span class="title">rangeCheck</span><span class="params">([C, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> java.util.stream.<span class="function">IntStream <span class="title">codePoints</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">codePointAt</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">codePointBefore</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">codePointCount</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">offsetByCodePoints</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> [<span class="function">B <span class="title">getBytes</span><span class="params">(java.nio.charset.Charset)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getBytes</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, [B, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> [<span class="function">B <span class="title">getBytes</span><span class="params">(java.lang.String)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> [<span class="function">B <span class="title">getBytes</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getBytes</span><span class="params">([B, <span class="keyword">int</span>, <span class="keyword">byte</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contentEquals</span><span class="params">(java.lang.StringBuffer)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contentEquals</span><span class="params">(java.lang.CharSequence)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">nonSyncContentEquals</span><span class="params">(java.lang.AbstractStringBuilder)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(java.lang.String)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareToIgnoreCase</span><span class="params">(java.lang.String)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">regionMatches</span><span class="params">(<span class="keyword">boolean</span>, <span class="keyword">int</span>, java.lang.String, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">regionMatches</span><span class="params">(<span class="keyword">int</span>, java.lang.String, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(java.lang.String)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(java.lang.String, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(java.lang.String)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">([B, <span class="keyword">byte</span>, <span class="keyword">int</span>, java.lang.String, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(java.lang.String, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(java.lang.String)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">CharSequence <span class="title">subSequence</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">concat</span><span class="params">(java.lang.String)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">replace</span><span class="params">(java.lang.CharSequence, java.lang.CharSequence)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">replace</span><span class="params">(<span class="keyword">char</span>, <span class="keyword">char</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(java.lang.String)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(java.lang.CharSequence)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">replaceFirst</span><span class="params">(java.lang.String, java.lang.String)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">replaceAll</span><span class="params">(java.lang.String, java.lang.String)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> [Ljava.lang.String; split(java.lang.String);</span><br><span class="line">    <span class="keyword">public</span> [Ljava.lang.String; split(java.lang.String, <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">transient</span> java.lang.<span class="function">String <span class="title">join</span><span class="params">(java.lang.CharSequence, [Ljava.lang.CharSequence;)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> java.lang.<span class="function">String <span class="title">join</span><span class="params">(java.lang.CharSequence, java.lang.Iterable)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">toLowerCase</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">toLowerCase</span><span class="params">(java.util.Locale)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">toUpperCase</span><span class="params">(java.util.Locale)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">toUpperCase</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">trim</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">strip</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">stripLeading</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">stripTrailing</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBlank</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">indexOfNonWhitespace</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">public</span> java.util.stream.<span class="function">Stream <span class="title">lines</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">public</span> java.util.stream.<span class="function">IntStream <span class="title">chars</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">public</span> [<span class="function">C <span class="title">toCharArray</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">transient</span> java.lang.<span class="function">String <span class="title">format</span><span class="params">(java.lang.String, [Ljava.lang.Object;)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">transient</span> java.lang.<span class="function">String <span class="title">format</span><span class="params">(java.util.Locale, java.lang.String, [Ljava.lang.Object;)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> java.lang.<span class="function">String <span class="title">copyValueOf</span><span class="params">([C, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> java.lang.<span class="function">String <span class="title">copyValueOf</span><span class="params">([C)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> java.lang.<span class="function">String <span class="title">intern</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">repeat</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isLatin1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkOffset</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkBoundsOffCount</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkBoundsBeginEnd</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="keyword">static</span> java.lang.<span class="function">String <span class="title">valueOfCodePoint</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>


<p>先介绍这么多，以后再补。</p>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的volatile关键字、JMM、happen-before</title>
    <url>/2021/11/12/Java%E4%B8%AD%E7%9A%84volatile%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%81JMM%E3%80%81happen-before/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="并发编程中的三个主要问题"><a href="#并发编程中的三个主要问题" class="headerlink" title="并发编程中的三个主要问题"></a>并发编程中的三个主要问题</h1><h2 id="可见性问题"><a href="#可见性问题" class="headerlink" title="可见性问题"></a>可见性问题</h2><p>当一个线程修改共享变量的值的时候，其他能否立即得知这个修改，这是第一个问题。</p>
<h2 id="原子性问题"><a href="#原子性问题" class="headerlink" title="原子性问题"></a>原子性问题</h2><p>这里的原子性，有两个尺度。</p>
<ol>
<li>小的尺度上，对于单个变量（主要对long、double而言）的修改是否具有原子性。</li>
<li>大的尺度上，对于一个方法或者代码块的原子性如何保证。</li>
</ol>
<h2 id="有序性问题"><a href="#有序性问题" class="headerlink" title="有序性问题"></a>有序性问题</h2><p>有序性问题在并发编程时是最令人困惑的。</p>
<p>这里先指明，<strong>如果没有作出一些合理的同步工作</strong>，那么<strong>在单个线程中执行顺序具有顺序性</strong>， 但是<strong>在一个线程中观察另一个线程的操作都是不具有有序性的</strong>。</p>
<blockquote>
<p> 正由于上面的问题，才有了这篇文章，其中有的问题这篇文章已经可以回答，有的还不能（主要是对<strong>锁的内存语义</strong>没有阐述）。</p>
</blockquote>
<h1 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h1><p>Java线程之间的通信由Java内存模型（也就是JMM）来控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。</p>
<p>从抽象的角度看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main memory）中，每个线程都有一个私有的本地内存（Local memory），本地内存存储了线程读写共享变量的副本。本地内存是JMM的一个抽象，它涵盖cache、store buffer、寄存器以及其他的硬件和编译器优化。</p>
<p><img src="/2021/11/12/Java%E4%B8%AD%E7%9A%84volatile%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%81JMM%E3%80%81happen-before/main-local.png"></p>
<h2 id="重排序和内存屏障"><a href="#重排序和内存屏障" class="headerlink" title="重排序和内存屏障"></a>重排序和内存屏障</h2><h3 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h3><p>在执行程序的过程中，为了提高性能，编译器和处理器通常会对指令进行重排序。重排序主要分为三类。</p>
<ol>
<li><p>编译器优化的重排序：编译器在不改变单线程语义的情况下，会对执行语句进行重新排序；</p>
</li>
<li><p>指令集重排序：现代操作系统中的处理器都是并行的，如果执行语句之间不存在数据依赖性，处理器可以改变语句的执行顺序；</p>
</li>
<li><p>内存重排序：由于处理器会使用读/写缓冲区，出于性能的原因，内存会对读/写进行重排序；</p>
</li>
</ol>
<p>上述的 1 属于编译器重排序，2、3属于处理器重排序。这些重排序会导致多线程程序出现内存可见性问题。</p>
<p>对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序；</p>
<p>对于处理器，JMM的处理器重排序规则会要求Java编译器生成指令序列的时插入特定的内存屏障（Memory barrier、Memory fence）。</p>
<h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><blockquote>
<p>这里我们先来了解一下内存屏障的概念。</p>
</blockquote>
<p>内存屏障也叫做<code>栅栏</code>，它是一种底层原语。它使得 CPU 或编译器在对内存进行操作的时候, 要严格按照一定的顺序来执行, 也就是说在 memory barrier 之前的指令和 memory barrier 之后的指令不会由于系统优化等原因而导致乱序。</p>
<p>内存屏障提供了两个功能。首先，它们通过确保从另一个 CPU 来看屏障的两边的所有指令都是正确的程序顺序；其次它们可以实现内存数据可见性，确保内存数据会同步到 CPU 缓存子系统。</p>
<p>不同计算机体系结构下面的内存屏障也不一样，通常需要认真研读硬件手册来确定，所以我们的主要研究对象是基于 x86 的内存屏障，通常情况下，硬件为我们提供了四种类型的内存屏障。</p>
<ul>
<li><strong>LoadLoad</strong> 屏障</li>
</ul>
<p>它的执行顺序是 Load1 ； LoadLoad ；Load2 ，其中的 Load1 和 Load2 都是加载指令。LoadLoad 指令能够确保执行顺序是在 Load1 之后，Load2 之前，LoadLoad 指令是一个比较有效的防止看到旧数据的指令。</p>
<ul>
<li><strong>StoreStore</strong> 屏障</li>
</ul>
<p>它的执行顺序是 Store1 ；StoreStore ；Store2 ，和上面的 LoadLoad 屏障的执行顺序相似，它也能够确保执行顺序是在 Store1 之后，Store2 之前。</p>
<ul>
<li><strong>LoadStore</strong> 屏障</li>
</ul>
<p>它的执行顺序是 Load1 ； StoreLoad ； Store2 ，保证 Load1 的数据被加载在与这数据相关的 Store2 和之后的 store 指令之前。</p>
<ul>
<li><strong>StoreLoad</strong> 屏障</li>
</ul>
<p>它的执行顺序是 Store1 ； StoreLoad ； Load2 ，确保 Store1 数据对其他处理器可见先于 Load2 及所有后续的访存指令。该屏障会使的此屏障前所有的访存指令完成之后，才会执行此屏障之后的访存指令。</p>
<p>其中<strong>StoreLoad</strong>是一个全能屏障，同时具有其他3个屏障的效果。</p>
<p>此屏障的开销很大，往往需要把写缓冲区（store buffer）中的所有数据全部刷新到主存中（Buffer fully flush）。</p>
<p>也正因此，x86处理器禁止了所有的Load-Load、Store-Store、Load-Store重排序，所以说它具有较强的处理器内存模型。不过对于Store-Load并没有在处理器层面“一棒子打死”，而是把禁止Store-Load重排序的责任交给了更上层，禁止Store-Load重排序的方式就是使用<strong>StoreLoad</strong> 内存屏障。</p>
<h3 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h3><p>正如前面所说，为了提高程序的运行的效率，即使是单线程的程序，每行代码的执行顺序也并非如我们想的那样，完全是顺序的执行的，这好几个步骤的指令重排。</p>
<p>但是，为什么在单线程编程环境下，我们从来没有关心过这些重排序带来的问题。</p>
<p>这就是as-if-serial语义带来的效果，不管编译器、处理器为了提高并行度做出怎样的重排序，单线程程序的结果不能被改变，就好像代码就是真的就是顺序执行的一样。</p>
<p>as-if-serial语义为单线程编程环境下的程序员创造了一个幻觉：单线程程序是按程序的顺序执行的，无心担心内存可见性等问题。</p>
<h3 id="重排序对多线程程序的影响"><a href="#重排序对多线程程序的影响" class="headerlink" title="重排序对多线程程序的影响"></a>重排序对多线程程序的影响</h3><p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = x; <span class="comment">// i 可能等于 0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在单线程下执行，当然不会有任何异常，原因正如上面的as-if-serial;</p>
<p>但是在多线程下，由于重排序，在read()方法的if代码块中，可能没能读到最新的 x 值。</p>
<p>比如说，A线程先执行 write方法，修改了 flag值，但是此时还没有修改x的值（指令重拍），或者修改了x但是还没有刷回到主存，这个时候B线程执行了read方法，通过率 if的判断条件，但是读 x 的值还是 0 。</p>
<p>这个时候，在多线程程序中，对存在控制依赖的操作重排序，可能改变程序的执行结果。</p>
<p>这是另一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryReorderingExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            x = <span class="number">0</span>;</span><br><span class="line">            y = <span class="number">0</span>;</span><br><span class="line">            a = <span class="number">0</span>;</span><br><span class="line">            b = <span class="number">0</span>;</span><br><span class="line">            Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                a = <span class="number">1</span>;</span><br><span class="line">                x = b;</span><br><span class="line">            &#125;);</span><br><span class="line">            Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                b = <span class="number">1</span>;</span><br><span class="line">                y = a;</span><br><span class="line">            &#125;);</span><br><span class="line">            t1.start();</span><br><span class="line">            t2.start();</span><br><span class="line">            t1.join();</span><br><span class="line">            t2.join();</span><br><span class="line">            String result = <span class="string">&quot;第&quot;</span> + i + <span class="string">&quot;次(&quot;</span> + x + <span class="string">&quot;,&quot;</span> + y + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h1 id="volatile的内存语义"><a href="#volatile的内存语义" class="headerlink" title="volatile的内存语义"></a>volatile的内存语义</h1><p>volatile: 为了确保共享变量能被准确和一致地更新，线程应该确保通过排它锁单独的更改这个变量。</p>
<p>Java提供了 <code>volatile</code>，它在多线程中保证了共享变量的可见性——一个线程修改一个共享变量时，另一个线程能读到这个修改值。</p>
<p>它某种程度上是一个轻量级的<code>synchronized</code>。</p>
<p><strong>volatile的特性</strong>：</p>
<ol>
<li>保证共享变量的可见性；</li>
<li>禁止指令重排序的优化；</li>
<li>对单个变量的读写的原子性。</li>
</ol>
<p>下面会对此分别作出解释。</p>
<h2 id="volatile的读-写内存语义"><a href="#volatile的读-写内存语义" class="headerlink" title="volatile的读-写内存语义"></a>volatile的读-写内存语义</h2><ul>
<li>volatile写的内存语义：当写一个volatile变量时，JMM会把该线程的本地内存中的共享变量值刷新到主内存。</li>
</ul>
<ul>
<li>volatile读的内存语义：当读一个volatile变量时，如果此共享变量值已被另一个线程修改，JMM会把线程对应的本地内存置为无效，然后会从主内存中读取共享变量。</li>
</ul>
<p>一个关于可见性的测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVolatile</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> finished = <span class="keyword">false</span>; <span class="comment">// 去掉 volatile 再看看执行效果</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!finished) &#123;</span><br><span class="line">            ++x;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;x is &quot;</span>+x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        finished = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TestVolatile test = <span class="keyword">new</span> TestVolatile();</span><br><span class="line">        <span class="keyword">new</span> Thread(test::doWork).start();</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(test::done).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="volatile的禁止重排序规则"><a href="#volatile的禁止重排序规则" class="headerlink" title="volatile的禁止重排序规则"></a>volatile的禁止重排序规则</h2><p>为了优化代码执行顺序，前面提到过编译器和处理器的重排序。</p>
<p>为了实现volatile的语义，JMM会限制这两种类型的重排序类型。</p>
<p><strong>JMM规则</strong>:</p>
<ol>
<li><p>当第二个操作是volatile写时，不管第一个操作是什么，都不允许重排序；</p>
</li>
<li><p>当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序；</p>
</li>
<li><p>第一个操作是volatile写，第二个操作是volatile读时，不允许重排序。</p>
</li>
</ol>
<p>其中，第1条保证，在volatile写之前的所有的普通写在执行完 volatile写后都会被刷新到主内存，换言之，如果volatile写没有执行，前面的普通写也不会产生影响（也就是说其他线程不可见）。这个性质对于普通是不具备的（下面会举个例子）</p>
<p>其中，第2条保证，在volatile读之前，下面的普通读不会执行，直到volatile读执行完，才能执行下面的普通读。</p>
<p>其中，第3条的保证是自然要有的。</p>
<p>值得注意的是，第1条、第2条实际上让<strong>volatile写-读</strong>在内存读写顺序上具有<strong>锁的释放-获取</strong>语义。</p>
<p>volatile写对应锁的释放，volatile读对应锁的获取。</p>
<p>注意一定只有在一个线程在将锁释放之后，另一个线程可以获取锁。</p>
<p>这让 volatile 具有一定的有序性。</p>
<blockquote>
<p>注意，上述的性质是在JSR-133标准（JDK-5）发布之后才有的语义，之前的volatile的语义比较弱，而这会给程序员带来了很多违反直觉的结果。</p>
</blockquote>
<p>举例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVolatile</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">// #1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> y = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            y = x; <span class="comment">// #2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在多线程环境下，#2处 y 一定为 1 吗？答案是不确定的。这就是违反程序员直觉的结果。</p>
<p>因为程序没有得到正确的同步处理，所以多线程并发下的结果很可能是混乱的。</p>
<p>同步的方法有很多，比如给<code>write()</code>、<code>read()</code>加上<code>synchronized</code>修饰。</p>
<p>不过这里还有更高效的同步方法，就是在#1处用<code>volatile</code>修饰flag变量，根据volatile的指令重排序规则，</p>
<p>一样可以做到访问变量的有序性，此时#1出y的值必然是 1 。</p>
<h2 id="volatile对非原子性约定的修正"><a href="#volatile对非原子性约定的修正" class="headerlink" title="volatile对非原子性约定的修正"></a>volatile对非原子性约定的修正</h2><p>首先讲一个冷知识，在32位机器上，java对64位长度的数据类型（double、long）的读写<strong>可能不是原子性的</strong>。</p>
<p>换言之，<strong>有可能</strong>一个线程在读写double、long变量读的结果既不是自己修改的也不是其它线程修改的，而是一个错误的混乱的值（比如其中前32位来自一个线程，后32位来自另一个线程）。这就带来了一定的风险（虽然这个风险很小很小）。</p>
<p>所以，如果确保一定没有这样的风险，就需要使用volatile修饰double、long变量。</p>
<p>因为，<strong>对于任何单个volatile变量的读写是具有原子性的</strong>。（注意，i++这种经典的<strong>读改写操作</strong>可不是原子的）</p>
<h2 id="volatile内存语义的实现"><a href="#volatile内存语义的实现" class="headerlink" title="volatile内存语义的实现"></a>volatile内存语义的实现</h2><h3 id="共享内存的可见性"><a href="#共享内存的可见性" class="headerlink" title="共享内存的可见性"></a>共享内存的可见性</h3><p>volatile的两条实现原则：</p>
<ol>
<li><p>lock前缀指令会让处理器缓存写回到主内存。</p>
<p>锁住总线：从而独占任何共享内存。</p>
<p>锁住缓存：锁定某块共享内存的缓存并写回到内存，并用缓存一致性协议（MESI）确保修改的原子性，这常常称为”缓存锁定“。</p>
<p>缓存一致性机制会阻止同时修改由两个处理器缓存的内存区域数据。</p>
</li>
<li><p>一个处理器的缓存会写到内存的操作会导致其他处理器的缓存无效。</p>
<p>每个处理器通过嗅探在总线上传播来的数据来检查自己的缓存值是不是已经过期了，当处理器发现自己缓存行对应中有内存地址对应的数据被修改，就会把该缓存行（cache line）设置为无效，需要这个值时重新到主存中获取。</p>
</li>
</ol>
<p>比如<code>lock addl $0x0,(%esp)</code>就是实际上的有lock前缀的汇编命令（这是个空操纵，因为不允许单独使用lock）。</p>
<h3 id="禁止指令优化重排序"><a href="#禁止指令优化重排序" class="headerlink" title="禁止指令优化重排序"></a>禁止指令优化重排序</h3><p>正如上面所言，我们需要使用内存屏障来禁止重排序。</p>
<p>具体的，基于保守策略的JMM按如下规则插入内存屏障：</p>
<ol>
<li>每个volatile写前面插入StoreStore屏障；</li>
<li>每个volatile写后面插入StoreLoad屏障；</li>
<li>每个volatile读后面插入LoadLoad屏障；</li>
<li>每个volatile读后面插入LoadStore屏障；</li>
</ol>
<p>在上面说到，x86机器本身就有着较为安全的内存模型，在处理器层面就禁止了Store-Store、Load-Load、Load-Store 重排序。</p>
<p>所以，在x86机器上，仅仅需要在每个volatile写后面插入StoreLoad屏障即可。</p>
<p>那么这个内存屏障究竟是什么呢？</p>
<p>实际上仍然依赖使用带有Lock前缀的汇编代码来完成。</p>
<h1 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h1><h2 id="happen-before的作用"><a href="#happen-before的作用" class="headerlink" title="happen-before的作用"></a>happen-before的作用</h2><p>我们先不讲happen-before的定义和规则，先旗帜鲜明地指出<strong>happen-before的价值</strong>。</p>
<p>正因为上面的一系列的内存屏障等等底层的细节，让Java工作组觉得对于开发者极不友好，很难在跨平台的编程环境中编写出可靠的多线程程序，他们提出了happen-before这个规则， 或者说是工具，帮助程序在不了解内存屏障这些概念的情况下依旧可以对他们的程序的执行顺序有个清醒的判断。</p>
<h2 id="happen-before的定义"><a href="#happen-before的定义" class="headerlink" title="happen-before的定义"></a>happen-before的定义</h2><p>JSR-133中对Java内存模型<strong>happen-before</strong>的定义如下：</p>
<p><code>happen-before</code>是 Java 模型中定义的两项操作的偏序关系。</p>
<ol>
<li>如果一个操作happen-before另一个操作，那么<strong>第一个操作的执行结果将对第二个操作可见</strong>，而且<strong>第一个操作的执行顺序可认为排在第二个操作之前</strong>。</li>
<li>两个操作之间存在happen-before关系，并不意味着Java平台具体实现必须要按照happen-before关系指定的顺序来执行，如果重排序之后的结果，与按happen-before关系来执行的结果一致，那么这种重排序也是合理的，JMM并不禁止。</li>
</ol>
<blockquote>
<p>注意第二个含义，是“可以认为”第一个执行顺序排在第二个操作“，意思是，即使由于重排序导致时间上第二个操作排在第一个操作之前，它的执行效果也可以等同于”第一个执行顺序排在第二个操作“。</p>
</blockquote>
<p>上面的(1)是对程序员的承诺：如果 A happens-before B，那么A的操作结果将对 B 可见，并且执行结果正如A的执行顺序在B之前那样。</p>
<p>上面的(2)是对编译器和处理器排序的约束原则：在不改变程序的语义的情况下，编译器和处理器怎么优化都是可以的。</p>
<h2 id="happen-before的规则"><a href="#happen-before的规则" class="headerlink" title="happen-before的规则"></a>happen-before的规则</h2><ul>
<li>程序次序规则：一个线程内，按照执行流顺序，书写在前面的操作先行发生于书写在后面的操作;</li>
<li>锁定规则：一个 unLock 操作先行发生于后面对同一个锁的 lock 操作，注意这个后面指的是”时间上的先后“；</li>
<li>volatile 变量规则：对一个volatile变量的写操作先行发生于后面对这个volatile变量的读操作，注意这个后面指的是”时间上的先后“;</li>
<li>传递规则：如果操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，则可以得出操作 A 先行发生于操作C;</li>
<li>线程启动规则：Thread 对象的 <code>start()</code> 方法先行发生于此线程的每个一个动作;</li>
<li>线程中断规则：对线程<code>interrupt()</code>方法的调用先行发生于被中断线程的代码检测到中断事件的发生;</li>
<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过 <code>Thread.join()</code> 方法结束、<code>Thread.isAlive()</code>的返回值手段检测到线程已经终止执行;</li>
<li>对象终结规则：一个对象的初始化完成先行发生于他的<code>finalize()</code>方法的开始。</li>
</ul>
<blockquote>
<p>这 8 条原则摘自《深入理解Java虚拟机》。</p>
</blockquote>
<p>其中第三条规则，尤其需要注意一下。</p>
<p>这 8 条规则中，前 4 条规则是比较重要的，后 4 条规则都是显而易见的。</p>
<p>所以，只有在可以使用上面的8条规则的前提下，才能使用happen-before的规则， 进而判断程序的执行顺序。</p>
<p>否则不能仅靠你的直觉判断，那完全不可信。</p>
<h2 id="happen-before与时间上的先后顺序的关系"><a href="#happen-before与时间上的先后顺序的关系" class="headerlink" title="happen-before与时间上的先后顺序的关系"></a>happen-before与时间上的先后顺序的关系</h2><p>先说答案，二者之间没有必然的关系。</p>
<p>一一解释。</p>
<ol>
<li><p>A happen-before B, A 在时间上就排在B前面吗？</p>
<p>不一定。前面已经说了，在单线程中as-serial就是来确保这个事情的，就是两个无数据依赖关系的变量的读写顺序可以被交换，但是仍然具有happen-before关系。</p>
</li>
<li><p>A 在时间上就排在B前面，A 就 happen-before B 吗?</p>
<p>happen-before的定义要求中有<strong>操作的可见性</strong>，但是在多线程中，如果有正确的同步操作（synchronized、volatile等），那么先发生的操作也不一定对发生的操作可见。</p>
</li>
</ol>
<h2 id="使用happen-before解释DoubleCheckLock"><a href="#使用happen-before解释DoubleCheckLock" class="headerlink" title="使用happen-before解释DoubleCheckLock"></a>使用happen-before解释DoubleCheckLock</h2><p>下面是使用双重检查锁实现单例的经典代码。（为什么这么写，就不细讲了）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//懒汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(singleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>这里我只讲为什么 <code>volatile</code>可以实现代码重排序的效果。</p>
<p>使用的工具正是happen-before。</p>
<p><img src="/2021/11/12/Java%E4%B8%AD%E7%9A%84volatile%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%81JMM%E3%80%81happen-before/dlc.png"></p>
<p>根据happe-before的第一条规则（<strong>程序次序规则</strong>），可以得到各个线程内的蓝色线（代表happen-before的偏序关系）。</p>
<p>根据<strong>volatile 变量规则</strong>，可以得到红色的那条线。</p>
<p>最后根据<strong>传递性规则</strong>，可以得出5个操作的全序关系，这就做到了对象的安全访问。</p>
<p>（多说一句，本质上volatile是通过禁止线程A的2、3的重排序实现happen-before的）。</p>
<p>反过来，如果没有volatile修饰，那么那条红色的线也就不复存在，自然操作5完全可能排在操作2的前面，从而导致对象的不安全访问。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.zhihu.com/question/296949412">既然CPU有缓存一致性协议（MESI），为什么JMM还需要volatile关键字？</a></p>
<p><a href="https://blog.csdn.net/xiaowenmu1/article/details/89705740">MESI（缓存一致性协议）</a></p>
<p><a href="https://zh.wikipedia.org/zh-hans/MESI%E5%8D%8F%E8%AE%AE">MESI协议-wiki</a></p>
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java多线程</tag>
        <tag>JMM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java对象的四种引用方式</title>
    <url>/2021/12/07/Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Reference</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//引用的对象</span></span><br><span class="line">    <span class="keyword">private</span> T referent;        </span><br><span class="line">    <span class="comment">//回收队列，由使用者在Reference的构造函数中指定</span></span><br><span class="line">    <span class="keyword">volatile</span> ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; queue;</span><br><span class="line">     <span class="comment">//当该引用被加入到queue中的时候，该字段被设置为queue中的下一个元素，以形成链表结构</span></span><br><span class="line">    <span class="keyword">volatile</span> Reference next;</span><br><span class="line">    <span class="comment">//在GC时，JVM底层会维护一个叫DiscoveredList的链表，存放的是Reference对象，discovered字段指向的就是链表中的下一个元素，由JVM设置</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">private</span> Reference&lt;T&gt; discovered;  </span><br><span class="line">    <span class="comment">//进行线程同步的锁对象</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> Lock();</span><br><span class="line">    <span class="comment">//等待加入queue的Reference对象，在GC时由JVM设置，会有一个java层的线程(ReferenceHandler)源源不断的从pending中提取元素加入到queue</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Reference&lt;Object&gt; pending = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>一个Reference对象的生命周期如下：</p>
<p><img src="/2021/12/07/Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E6%96%B9%E5%BC%8F/java-ref.png"></p>
<h1 id="1-强引用"><a href="#1-强引用" class="headerlink" title="1.强引用"></a>1.强引用</h1><p>我们平日里面的用到的new了一个对象就是强引用，例如 <code>Object obj = new Object();</code></p>
<p>当JVM的内存空间不足时，宁愿抛出OutOfMemoryError使得程序异常终止也不愿意回收具有<strong>强引用的存活着的对象</strong>！</p>
<p>回收的时间是不一定的，具体得看GC回收策略。</p>
<h1 id="2-软引用"><a href="#2-软引用" class="headerlink" title="2.软引用"></a>2.软引用</h1><p>软引用的生命周期比强引用短一些。软引用是通过<code>SoftReference</code>类实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">SoftReference softObj = <span class="keyword">new</span> SoftReference(obj);</span><br><span class="line">obj = <span class="keyword">null</span>； <span class="comment">//去除强引用</span></span><br></pre></td></tr></table></figure>



<p>这样就是一个简单的软引用使用方法。通过<code>get()</code>方法获取对象。</p>
<p><strong>当JVM认为内存空间不足时，就回去试图回收软引用指向的对象</strong>，也就是说在JVM抛出<code>OutOfMemoryError</code>之前，会去清理软引用对象。</p>
<p>软引用可以与引用队列<code>(ReferenceQueue)</code>联合使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">ReferenceQueue queue = <span class="keyword">new</span> ReferenceQueue();</span><br><span class="line">SoftReference softObj = <span class="keyword">new</span> SoftReference(obj,queue);</span><br><span class="line">obj = <span class="keyword">null</span>； <span class="comment">//去除强引用</span></span><br></pre></td></tr></table></figure>



<p>当<code>softObj</code>软引用的<code>obj</code>被GC回收之后，<code>softObj</code> 对象就会被塞到<code>queue</code>中，之后我们可以通过这个队列的<code>poll()</code>来检查你关心的对象是否被回收了，如果队列为空，就返回一个<code>null</code>。反之就返回软引用对象也就是<code>softObj</code>。</p>
<p><strong>软引用一般用来实现内存敏感的缓存</strong>，如果有空闲内存就可以保留缓存，当内存不足时就清理掉，这样就保证使用缓存的同时不会耗尽内存。例如图片缓存框架中缓存图片就是通过软引用的。</p>
<h1 id="3-弱引用"><a href="#3-弱引用" class="headerlink" title="3.弱引用"></a>3.弱引用</h1><p>弱引用是通过<code>WeakReference</code>类实现的，它的生命周期比软引用还要短, 也是通过<code>get()</code>方法获取对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">WeakReference&lt;Object&gt; weakObj = <span class="keyword">new</span> WeakReference&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>； <span class="comment">//去除强引用</span></span><br></pre></td></tr></table></figure>



<p><strong>在GC的时候，JVM 不管内存空间足不足都会回收这个对象</strong>，同样也可以配合<code>ReferenceQueue</code> 使用，也同样适用于内存敏感的缓存。</p>
<p><code>ThreadLocal</code>中的<code>Entry</code>就是继承了<code>WeakReference</code>类，这<code>Entry</code>弱引用着<code>ThreadLocal</code>。</p>
<h1 id="4-幻象引用"><a href="#4-幻象引用" class="headerlink" title="4.幻象引用"></a>4.幻象引用</h1><p>也称虚引用，是通过<code>PhantomReference</code>类实现的。任何时候可能被GC回收,就像没有引用一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">ReferenceQueue queue = <span class="keyword">new</span> ReferenceQueue();</span><br><span class="line">PhantomReference&lt;Object&gt; phantomObj = <span class="keyword">new</span> PhantomReference&lt;Object&gt;(obj , queue);</span><br><span class="line">obj = <span class="keyword">null</span>； <span class="comment">//去除强引用</span></span><br></pre></td></tr></table></figure>



<p>不过<strong>无法通过虚引用访问对象的任何属性或者函数</strong>。</p>
<p>那就要问了要它有什么用？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhantomReference</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Reference</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 永远返回 null</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>虚引用仅仅只是提供了一种确保对象被<code>finalize</code>以后来做某些事情的机制。比如说这个对象被回收之后发一个系统通知啊啥的。虚引用是必须配合<code>ReferenceQueue</code> 使用的，具体使用方法和上面提到软引用的一样。主要用来跟踪对象被垃圾回收的活动。</p>
<p>一个错误认知：</p>
<blockquote>
<p>严格的说，<strong>虚引用是会影响对象生命周期的</strong>，如果不做任何处理，只要虚引用不被回收，那其引用的对象永远不会被回收。所以一般来说，从ReferenceQueue中获得PhantomReference对象后，如果PhantomReference对象不会被回收的话（比如被其他GC ROOT可达的对象引用），需要调用clear方法解除PhantomReference和其引用对象的引用关系。</p>
</blockquote>
<blockquote>
<p><a href="https://segmentfault.com/a/1190000039994284"><a href="https://segmentfault.com/a/1190000039994284">Java四种引用类型原理你真的搞明白了吗？五分钟带你深入理解！</a></a></p>
</blockquote>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Jmeter使用</title>
    <url>/2021/11/29/Jmeter%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Add-Threads（Users）添加线程组"><a href="#Add-Threads（Users）添加线程组" class="headerlink" title="Add Threads（Users）添加线程组"></a>Add Threads（Users）添加线程组</h2><p><strong>线程组主要参数详解</strong></p>
<ol>
<li>线程数：虚拟用户数。一个虚拟用户占用一个进程或线程。模拟多少用户访问也就填写多少个线程数量。</li>
<li>Ramp-Up时间(秒)：设置的虚拟用户数需要多长时间全部启动。如果线程数为<code>100</code>，准备时长为<code>5</code>，那么需要<code>5</code>秒钟启动<code>100</code>个线程，也就是每秒钟启动<code>20</code>个线程。 相当于每秒模拟<code>20</code>个用户进行访问，设置为零我理解为并发访问。</li>
<li>循环次数：如果线程数为<code>100</code>，循环次数为<code>100</code>。那么总请求数为<code>100*100=10000</code> 。如果勾选了“永远”，那么所有线程会一直发送请求，直到选择停止运行脚本。</li>
</ol>
<h2 id="Add-Sample-添加取样器（）"><a href="#Add-Sample-添加取样器（）" class="headerlink" title="Add Sample 添加取样器（）"></a>Add Sample 添加取样器（）</h2><h3 id="Add-Sample-HTTP-Request-添加http接口测试（）"><a href="#Add-Sample-HTTP-Request-添加http接口测试（）" class="headerlink" title="Add Sample HTTP Request 添加http接口测试（）"></a>Add Sample HTTP Request 添加http接口测试（）</h3><p><strong>Http请求主要参数详解</strong></p>
<ul>
<li>协议：向目标服务器发送HTTP请求协议，可以是<code>HTTP</code>或<code>HTTPS</code>，默认为<code>HTTP</code>。</li>
<li>服务器名称或IP ：<code>HTTP</code>请求发送的目标服务器名称或<code>IP</code>。</li>
<li>端口号：目标服务器的端口号，默认值为80</li>
<li>方法：发送<code>HTTP</code>请求的方法，可用方法包括<code>GET</code>、<code>POST</code>、<code>HEAD</code>、<code>PUT</code>、<code>OPTIONS</code>、<code>TRACE</code>、<code>DELETE</code>等。</li>
<li>路径：目标<code>URL</code>路径（<code>URL</code>中去掉服务器地址、端口及参数后剩余部分）。</li>
<li>字符集编码：编码方式，默认为<code>ISO-8859-1</code>编码，这里配置为<code>utf-8</code>。</li>
<li>参数：同请求一起发送参数 ，在请求中发送的<code>URL</code>参数，用户可以将<code>URL</code>中所有参数设置在本表中，表中每行为一个参数（对应<code>URL</code>中的 <code>key=value</code>），注意参数传入中文时需要勾选“编码”。</li>
</ul>
<h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><h3 id="Add-Assertions-Json-Assertion-添加Json断言（）"><a href="#Add-Assertions-Json-Assertion-添加Json断言（）" class="headerlink" title="Add Assertions Json Assertion 添加Json断言（）"></a>Add Assertions Json Assertion 添加Json断言（）</h3><h3 id="Add-Listener-Assertion-Results-添加断言结果（）"><a href="#Add-Listener-Assertion-Results-添加断言结果（）" class="headerlink" title="Add Listener Assertion Results 添加断言结果（）"></a>Add Listener Assertion Results 添加断言结果（）</h3><h2 id="结果报告"><a href="#结果报告" class="headerlink" title="结果报告"></a>结果报告</h2><h3 id="Add-Listener-View-Results-Tree-添加察看结果树（）"><a href="#Add-Listener-View-Results-Tree-添加察看结果树（）" class="headerlink" title="Add Listener View Results Tree 添加察看结果树（）"></a>Add Listener View Results Tree 添加察看结果树（）</h3><h3 id="Add-Listener-Aggregate-Report-添加聚合报告（）"><a href="#Add-Listener-Aggregate-Report-添加聚合报告（）" class="headerlink" title="Add Listener Aggregate Report 添加聚合报告（）"></a>Add Listener Aggregate Report 添加聚合报告（）</h3><p><strong>聚合报告参数详解</strong></p>
<ol>
<li>Label：每个 <code>JMeter</code> 的 <code>element</code>（例如我这里只有一个 <code>Spring WebFlux</code>）都有一个 <code>Name</code> 属性，这里显示的就是 <code>Name</code> 属性的值。</li>
<li>样本(Samples)：请求数——表示这次测试中一共发出了多少个请求，我这里模拟了<code>100</code>个用户循环<code>6</code>次也就为<code>100*6=600</code>。</li>
<li>平均值(Average)：平均响应时间 (单位:<code>ms</code>)。默认是单个<code>Request</code>的平均响应时间，当使用了<code>Transaction Controller</code>时，也可以是<code>Transaction</code>为单位显示平均响应时间。</li>
<li>中位数(Median)： 50％ 用户的响应时间。</li>
<li>90% 百分位(Line)：90％用户的响应时间。相邻几个<code>*%</code>同意。</li>
<li>最小值(Min)：最小响应时间。</li>
<li>最大值(Max)：最大响应时间。</li>
<li>异常(Error) %：错误率——错误请求数/请求总数。</li>
<li>吞吐量(Throughput)：吞吐量——默认情况下表示每秒完成的请求数（<code>Request per Second</code>），当使用了 <code>Transaction Controller</code> 时，也可以表示类似 <code>LoadRunner</code> 的 <code>Transaction per Second</code> 数 。</li>
<li>接收 KB/Sec：每秒从服务器端接收到的数据量，相当于<code>LoadRunner</code>中的<code>Throughput/Sec</code>。</li>
<li>发送 KB/Sec：每秒向服务器发送的数据量，相当于<code>LoadRunner</code>中的<code>Throughput/Sec</code>。</li>
</ol>
<blockquote>
<p>一般而言，性能测试中我们需要重点关注的数据有： Samples、Average、Min、Max、Error、Throughput。</p>
</blockquote>
<blockquote>
<p><a href="https://www.jianshu.com/p/6bc152ca6126">Apache JMeter 入门教程</a></p>
</blockquote>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>Jmeter</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程池原理与使用</title>
    <url>/2021/10/15/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="使用线程池的好处"><a href="#使用线程池的好处" class="headerlink" title="使用线程池的好处"></a>使用线程池的好处</h1><p>首先，回答这个问题，要先回答为什么要使用多线程。<br>其次再是为什么要使用线程池。<br>使用多线程的好处及必要性就不说了。</p>
<p><strong>使用线程池的好处：</strong></p>
<ol>
<li>提高响应速度：通过复用线程可以消除线程创建销毁带来的延迟，提示响应速度</li>
<li>降低资源消耗线程池可以统筹内存和CPU的使用，避免资源使用不当，线程池会根据配置和任务数量灵活控制线程数量，不够就创建，多了就回收，避免线程过多导致内存溢出，过少导致资源浪费</li>
<li>提高线程可管理行线程池可以统一管理资源，统一进行分配、调优、监控。</li>
</ol>
<h1 id="线程池工作原理"><a href="#线程池工作原理" class="headerlink" title="线程池工作原理"></a>线程池工作原理</h1><p>将任务传递给线程池，而不是为每个任务启动一个新线程来并发执行。<br>一旦池中有任何空闲线程，任务就会分配给其中之一并执行。<br>在内部，任务被插入到一个阻塞队列中，然后池中的空闲线程从该队列中取出任务并执行。</p>
<p><img src="/2021/10/15/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%BF%E7%94%A8/thread-pools.png" alt="线程池的原理"></p>
<p>不过在JDK提供的线程池的原理比这个还要复杂些（真实的往往是复杂的）。</p>
<p><img src="/2021/10/15/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%BF%E7%94%A8/pool2.jpg" alt="工作流程图"></p>
<h1 id="自己实现一个简单的线程池"><a href="#自己实现一个简单的线程池" class="headerlink" title="自己实现一个简单的线程池"></a>自己实现一个简单的线程池</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: SongyangJi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2021/10/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; taskQueue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;PooledThread&gt; threads = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isStopped = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> numOfThreads  工作线程数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxNumOfTasks 缓冲队列最多预存任务数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPool</span><span class="params">(<span class="keyword">int</span> numOfThreads, <span class="keyword">int</span> maxNumOfTasks)</span> </span>&#123;</span><br><span class="line">        taskQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(maxNumOfTasks);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numOfThreads; i++) &#123;</span><br><span class="line">            threads.add(<span class="keyword">new</span> PooledThread(taskQueue));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (PooledThread thread : threads) &#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isStopped) <span class="keyword">throw</span></span><br><span class="line">                <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;ThreadPool is stopped&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.taskQueue.put(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.isStopped = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (PooledThread thread : threads) &#123;</span><br><span class="line">            thread.toStop();</span><br><span class="line">        &#125;</span><br><span class="line">        taskQueue.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PooledThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; taskQueue;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isStopped = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PooledThread</span><span class="params">(BlockingQueue&lt;Runnable&gt; queue)</span> </span>&#123;</span><br><span class="line">            taskQueue = queue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!isStopped) &#123;</span><br><span class="line">                Runnable runnable;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    runnable = taskQueue.take();</span><br><span class="line">                    runnable.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            isStopped = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">this</span>.interrupt(); <span class="comment">// 中断当前线程（但可能不被响应）</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        ThreadPool threadPool = <span class="keyword">new</span> ThreadPool(<span class="number">3</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> id = i;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(random.nextInt(<span class="number">3000</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.printf(<span class="string">&quot;task %d finished in %s\n&quot;</span>, id,Thread.currentThread().getName());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">        threadPool.shutDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h1 id="ThreadPoolExecutor工作机制"><a href="#ThreadPoolExecutor工作机制" class="headerlink" title="ThreadPoolExecutor工作机制"></a>ThreadPoolExecutor工作机制</h1><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, </span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>



<h2 id="构造参数的含义"><a href="#构造参数的含义" class="headerlink" title="构造参数的含义"></a>构造参数的含义</h2><table>
<thead>
<tr>
<th>序号</th>
<th>名称</th>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>corePoolSize</td>
<td>int</td>
<td>核心线程池大小</td>
</tr>
<tr>
<td>2</td>
<td>maximumPoolSize</td>
<td>int</td>
<td>最大线程池大小</td>
</tr>
<tr>
<td>3</td>
<td>keepAliveTime</td>
<td>long</td>
<td>线程最大空闲时间</td>
</tr>
<tr>
<td>4</td>
<td>unit</td>
<td>TimeUnit</td>
<td>时间单位</td>
</tr>
<tr>
<td>5</td>
<td>workQueue</td>
<td>BlockingQueue</td>
<td>线程等待队列</td>
</tr>
<tr>
<td>6</td>
<td>threadFactory</td>
<td>ThreadFactory</td>
<td>线程创建工厂</td>
</tr>
<tr>
<td>7</td>
<td>handler</td>
<td>RejectedExecutionHandler</td>
<td>拒绝策略</td>
</tr>
</tbody></table>
<h2 id="内部机制"><a href="#内部机制" class="headerlink" title="内部机制"></a>内部机制</h2><ol>
<li><p>如果当前线程池的线程数还没有达到基本大小(poolSize &lt; corePoolSize)，无论是否有空闲的线程新增一个线程处理新提交的任务；</p>
</li>
<li><p>如果当前线程池的线程数大于或等于基本大小(poolSize &gt;= corePoolSize) 且任务队列未满时，就将新提交的任务提交到阻塞队列排队，等候处理workQueue.offer(command)；</p>
</li>
<li><p>如果当前线程池的线程数大于或等于基本大小(poolSize &gt;= corePoolSize) 且任务队列满时；</p>
<ul>
<li>当前poolSize&lt;maximumPoolSize，那么就新增线程来处理任务；</li>
<li>当前poolSize=maximumPoolSize，那么意味着线程池的处理能力已经达到了极限，此时需要拒绝新增加的任务。至于如何拒绝处理新增的任务，取决于线程池的饱和策略RejectedExecutionHandler。</li>
</ul>
</li>
</ol>
<p>描述为如下的工作流程图：</p>
<p><img src="/2021/10/15/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%BF%E7%94%A8/pool1.jpg" alt="线程池对任务的处理流程"></p>
<p>这里有一篇讲的很好的、可视化线程池工作机制的文章<a href="https://zhuanlan.zhihu.com/p/112527671">&gt;&gt;传送门</a>。</p>
<h2 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h2><p>拒绝策略是RejectedExecutionHandler的实现类；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// r - 请求执行的可运行任务</span></span><br><span class="line"><span class="comment">// executor – 尝试执行此任务的执行器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当要创建的线程数量大于线程池的最大线程数的时候，新的任务就会被拒绝，就会调用这个接口里的这个方法。</p>
<p>下面介绍 ThreadPoolExecutor 中已经实现的四种策略。</p>
<h3 id="AbortPolicy"><a href="#AbortPolicy" class="headerlink" title="AbortPolicy"></a>AbortPolicy</h3><p>这也是默认的拒绝策略（保守的策略）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">&quot;Task &quot;</span> + r.toString() +</span><br><span class="line">                                         <span class="string">&quot; rejected from &quot;</span> +</span><br><span class="line">                                         e.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DiscardPolicy"><a href="#DiscardPolicy" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h3><p>很潇洒，啥也不做。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DiscardOldestPolicy"><a href="#DiscardOldestPolicy" class="headerlink" title="DiscardOldestPolicy"></a>DiscardOldestPolicy</h3><p>丢弃最早的未处理请求，然后去执行这个现在的任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">        e.getQueue().poll();</span><br><span class="line">        e.execute(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="CallerRunsPolicy"><a href="#CallerRunsPolicy" class="headerlink" title="CallerRunsPolicy"></a>CallerRunsPolicy</h3><p>在任务被拒绝添加后，会调用当前线程池的所在的线程去执行被拒绝的任务。</p>
<p>也就是说，自己的活自己做，不要让线程池去做了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">        r.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>阻塞队列的选取可以参考在JUC中BlockingQueue的几种实现类，这里不再赘述。</p>
<h1 id="Executor框架-——-JDK提供的线程池家族"><a href="#Executor框架-——-JDK提供的线程池家族" class="headerlink" title="Executor框架 —— JDK提供的线程池家族"></a>Executor框架 —— JDK提供的线程池家族</h1><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="/2021/10/15/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%BF%E7%94%A8/ThreadPoolExecutor.png" alt="ThreadPoolExecutor"></p>
<h2 id="几种开箱即用的线程池"><a href="#几种开箱即用的线程池" class="headerlink" title="几种开箱即用的线程池"></a>几种开箱即用的线程池</h2><h3 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h3><p>构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>特点：</p>
<ul>
<li><p>workQueue 为LinkedBlockingQueue（<strong>无界阻塞队列</strong>），队列最大值为Integer.MAX_VALUE。如果任务提交速度持续大余任务处理速度，会造成队列大量阻塞。因为队列基本上是无穷大，很有可能在拒绝策略前，内存溢出。由于队列容量无穷大，所以实际上maximumPoolSize是无效参数。</p>
</li>
<li><p>corePoolSize与maximumPoolSize相等，即其线程全为核心线程，是一个固定大小的线程池；</p>
</li>
<li><p>keepAliveTime = 0 表明多余的线程会被立即终止，但是由于默认情况下这不对核心线程起作用，又由于队列容量无穷大，所以这个参数实际上也是无效的。（因为在核心线程池满之后，就不再被销毁，除非你<code>allowCoreThreadTimeOut(true)</code>）</p>
</li>
<li><p>由于第一点，没有设置拒绝策略，设置了也是无效的。</p>
</li>
</ul>
<p>适用场景：</p>
<p>计算重量级的任务。</p>
<h3 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h3><p>构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>corePoolSize = 0，maximumPoolSize = Integer.MAX_VALUE，即线程数量几乎无限制；</p>
</li>
<li><p>keepAliveTime = 60s，线程空闲60s后自动结束，因此长时间保持空闲的CachedThreadPool不占用资源。</p>
</li>
<li><p>workQueue 为 SynchronousQueue 为无容量的同步队列，这个队列类似于一个接力棒，入队出队必须同时传递，所以当核心线程池已满的时候，会直接创建一个新的线程；</p>
</li>
</ul>
<p>适用场景：快速处理大量耗时较短的任务，如Netty的NIO接受请求时，可使用CachedThreadPool。</p>
<h3 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上就是 Executors.newFixedThreadPool(1)的包装。</p>
<p>线程池一旦接受了一个任务，就保持一个线程去接受任务。</p>
<h1 id="合理配置线程池大小"><a href="#合理配置线程池大小" class="headerlink" title="合理配置线程池大小"></a>合理配置线程池大小</h1><h2 id="任务的不同角度的分类"><a href="#任务的不同角度的分类" class="headerlink" title="任务的不同角度的分类"></a>任务的不同角度的分类</h2><p>合理的配置线程池的大小，从以下几个角度分析任务的特性：</p>
<ul>
<li>任务的性质：CPU密集型任务、IO密集型任务、混合型任务。</li>
</ul>
<ul>
<li>任务的优先级：高、中、低。</li>
</ul>
<ul>
<li>任务的执行时间：长、中、短。</li>
<li>任务的依赖性：是否依赖其他系统资源，如数据库连接等。 </li>
</ul>
<p>性质不同的任务可以交给不同规模的线程池执行</p>
<ul>
<li><p>CPU密集型任务应配置尽可能小的线程，如配置CPU个数+1的线程数;</p>
</li>
<li><p>IO密集型任务应配置尽可能多的线程，因为IO操作不占用CPU，不要让CPU闲下来，应加大线程数量，如配置两倍CPU个数+1;</p>
</li>
<li><p>混合型的任务，如果可以拆分，拆分成IO密集型和CPU密集型分别处理，前提是两者运行的时间是差不多的，如果处理时间相差很大，则没必要拆分了。</p>
</li>
</ul>
<h2 id="一个经验公式"><a href="#一个经验公式" class="headerlink" title="一个经验公式"></a>一个经验公式</h2><p><em><em>最佳线程数目 = （（线程等待时间+线程CPU时间）/线程CPU时间 ）</em> CPU数目</em>*</p>
<p>比如平均每个线程CPU运行时间为0.5s，而线程等待时间（非CPU运行时间，比如IO）为1.5s，CPU核心数为8，那么根据上面这个公式估算得到：((0.5+1.5)/0.5)*8=32。这个公式进一步转化为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">最佳线程数目 &#x3D; （线程等待时间&#x2F;线程CPU时间+ 1）* CPU</span><br></pre></td></tr></table></figure>


<p>可以得出一个结论： 线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程。 以上公式与CPU和IO密集型任务设置线程数基本吻合。</p>
<h2 id="实践配置"><a href="#实践配置" class="headerlink" title="实践配置"></a>实践配置</h2><p>高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？  </p>
<ol>
<li><p>高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换</p>
</li>
<li><p>并发不高、任务执行时间长的业务要区分开看：</p>
</li>
</ol>
<ul>
<li>假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以适当加大线程池中的线程数目，让CPU处理更多的业务 　　</li>
<li>假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换</li>
</ul>
<ol start="3">
<li><p>并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考（2）。</p>
<p>最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦</p>
</li>
</ol>
<blockquote>
<p>参考链接</p>
<p><a href="http://tutorials.jenkov.com/java-concurrency/thread-pools.html">Thread Pools</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/112527671">线程池工作原理可视化</a></p>
<p><a href="https://www.jianshu.com/p/0d5604152b97">本以为“线程池”很简单，没想到第一问就被干趴下了！</a></p>
<p>《Java 并发编程的艺术》</p>
</blockquote>
]]></content>
      <categories>
        <category>JUC</category>
      </categories>
      <tags>
        <tag>JUC</tag>
        <tag>Java多线程</tag>
        <tag>线程/进程调度相关</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合类接口设计</title>
    <url>/2021/07/23/Java%E9%9B%86%E5%90%88%E7%B1%BB%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本篇博客本着<strong>面向接口编程</strong>的思想，整理了Java集合类的接口设计UML图，<br>然后根据官方文档摘取了笔者觉得比较重要的API，这对增强Java集合类的整体认识无疑是很有帮助的。<br>不过，这样一篇整理+搬运的博客也仅仅是对笔者自己有帮助罢了。</p>
<h1 id="接口设计UML图"><a href="#接口设计UML图" class="headerlink" title="接口设计UML图"></a>接口设计UML图</h1><p><img src="/2021/07/23/Java%E9%9B%86%E5%90%88%E7%B1%BB%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1/Collection.png" alt="集合框架中的接口"></p>
<h1 id="迭代模式的实现"><a href="#迭代模式的实现" class="headerlink" title="迭代模式的实现"></a>迭代模式的实现</h1><p>Java类库实现的 <strong>迭代器模式</strong>。</p>
<h2 id="迭代器：Iterator"><a href="#迭代器：Iterator" class="headerlink" title="迭代器：Iterator"></a>迭代器：<code>Iterator</code></h2><table>
<thead>
<tr>
<th align="left">Modifier and Type</th>
<th align="left">Method and Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>boolean</code></td>
<td align="left"><code>hasNext()</code>如果迭代具有更多元素，则返回 <code>true</code> 。</td>
</tr>
<tr>
<td align="left"><code>E</code></td>
<td align="left"><code>next()</code>返回迭代中的下一个元素。</td>
</tr>
<tr>
<td align="left"><code>default void</code></td>
<td align="left"><code>remove()</code>从底层集合中删除此迭代器返回的最后一个元素（可选操作）。</td>
</tr>
</tbody></table>
<h2 id="可迭代对象：Iterable"><a href="#可迭代对象：Iterable" class="headerlink" title="可迭代对象：Iterable"></a>可迭代对象：<code>Iterable</code></h2><table>
<thead>
<tr>
<th align="left">Modifier and Type</th>
<th align="left">Method and Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>default void</code></td>
<td align="left"><code>forEach(Consumer&lt;? super T&gt; action)</code>对 <code>Iterable</code>的每个元素执行给定的操作，直到所有元素都被处理或动作引发异常。</td>
</tr>
<tr>
<td align="left"><code>Iterator&lt;T&gt;</code></td>
<td align="left"><code>iterator()</code>返回类型为 <code>T</code>元素的迭代器。</td>
</tr>
</tbody></table>
<h1 id="一元集合"><a href="#一元集合" class="headerlink" title="一元集合"></a>一元集合</h1><p> <code>Collection</code></p>
<table>
<thead>
<tr>
<th align="left">Modifier and Type</th>
<th align="left">Method and Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>boolean</code></td>
<td align="left"><code>add(E e)</code>确保此集合包含指定的元素（可选操作）。</td>
</tr>
<tr>
<td align="left"><code>boolean</code></td>
<td align="left"><code>addAll(Collection&lt;? extends E&gt; c)</code>将指定集合中的所有元素添加到此集合（可选操作）。</td>
</tr>
<tr>
<td align="left"><code>void</code></td>
<td align="left"><code>clear()</code>从此集合中删除所有元素（可选操作）。</td>
</tr>
<tr>
<td align="left"><code>boolean</code></td>
<td align="left"><code>contains(Object o)</code>如果此集合包含指定的元素，则返回 <code>true</code> 。</td>
</tr>
<tr>
<td align="left"><code>boolean</code></td>
<td align="left"><code>containsAll(Collection&lt;?&gt; c)</code>如果此集合包含指定 <code>集合</code>中的所有元素，则返回true。</td>
</tr>
<tr>
<td align="left"><code>boolean</code></td>
<td align="left"><code>isEmpty()</code>如果此集合不包含元素，则返回 <code>true</code> 。</td>
</tr>
<tr>
<td align="left"><code>Iterator&lt;E&gt;</code></td>
<td align="left"><code>iterator()</code>返回此集合中的元素的迭代器。</td>
</tr>
<tr>
<td align="left"><code>boolean</code></td>
<td align="left"><code>remove(Object o)</code>从该集合中删除指定元素的单个实例（如果存在）（可选操作）。</td>
</tr>
<tr>
<td align="left"><code>boolean</code></td>
<td align="left"><code>removeAll(Collection&lt;?&gt; c)</code>删除指定集合中包含的所有此集合的元素（可选操作）。</td>
</tr>
<tr>
<td align="left"><code>int</code></td>
<td align="left"><code>size()</code>返回此集合中的元素数。</td>
</tr>
<tr>
<td align="left"><code>Object[]</code></td>
<td align="left"><code>toArray()</code>返回一个包含此集合中所有元素的数组。</td>
</tr>
<tr>
<td align="left"><code>&lt;T&gt; T[]</code></td>
<td align="left"><code>toArray(T[] a)</code>返回包含此集合中所有元素的数组; 返回的数组的运行时类型是指定数组的运行时类型。</td>
</tr>
</tbody></table>
<h2 id="线性集合"><a href="#线性集合" class="headerlink" title="线性集合"></a>线性集合</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a><code>List</code></h3><p>拓展了Collection接口，所以只列出多出的方法。</p>
<table>
<thead>
<tr>
<th align="left">Modifier and Type</th>
<th align="left">Method and Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>void</code></td>
<td align="left"><code>add(int index, E element)</code>将指定的元素插入此列表中的指定位置（可选操作）。</td>
</tr>
<tr>
<td align="left"><code>E</code></td>
<td align="left"><code>get(int index)</code>返回此列表中指定位置的元素。</td>
</tr>
<tr>
<td align="left"><code>int</code></td>
<td align="left"><code>indexOf(Object o)</code>返回此列表中指定元素的第一次出现的索引，如果此列表不包含元素，则返回-1。</td>
</tr>
<tr>
<td align="left"><code>int</code></td>
<td align="left"><code>lastIndexOf(Object o)</code>返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。</td>
</tr>
<tr>
<td align="left"><code>E</code></td>
<td align="left"><code>remove(int index)</code>删除该列表中指定位置的元素（可选操作）。</td>
</tr>
<tr>
<td align="left"><code>E</code></td>
<td align="left"><code>set(int index, E element)</code>用指定的元素（可选操作）替换此列表中指定位置的元素。</td>
</tr>
<tr>
<td align="left"><code>default void</code></td>
<td align="left"><code>sort(Comparator&lt;? super E&gt; c)</code>使用随附的 <code>Comparator</code>排序此列表来比较元素。</td>
</tr>
<tr>
<td align="left"><code>List&lt;E&gt;</code></td>
<td align="left"><code>subList(int fromIndex, int toIndex)</code>返回此列表中指定的 <code>fromIndex</code> （含）和 <code>toIndex</code>之间的视图。</td>
</tr>
</tbody></table>
<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a><code>Queue</code></h3><table>
<thead>
<tr>
<th align="left">Modifier and Type</th>
<th align="left">Method and Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>boolean</code></td>
<td align="left"><code>add(E e)</code>将指定的元素插入到此队列中，如果可以立即执行此操作，而不会违反容量限制， <code>true</code>在成功后返回 <code>IllegalStateException</code>如果当前没有可用空间，则抛出IllegalStateException。</td>
</tr>
<tr>
<td align="left"><code>boolean</code></td>
<td align="left"><code>offer(E e)</code>如果在不违反容量限制的情况下立即执行，则将指定的元素插入到此队列中。</td>
</tr>
<tr>
<td align="left"><code>E</code></td>
<td align="left"><code>remove()</code>检索并删除此队列的头。如果队列对空，抛出异常NoSuchElementException。</td>
</tr>
<tr>
<td align="left"><code>E</code></td>
<td align="left"><code>poll()</code>检索并删除此队列的头，如果此队列为空，则返回 <code>null</code> 。</td>
</tr>
<tr>
<td align="left"><code>E</code></td>
<td align="left"><code>element()</code>检索但不删除这个队列的头。如果队列为空，抛出异常NoSuchElementException。</td>
</tr>
<tr>
<td align="left"><code>E</code></td>
<td align="left"><code>peek()</code>检索但不删除此队列的头，如果此队列为空，则返回 <code>null</code> 。</td>
</tr>
</tbody></table>
<p>要注意这三对方法的差别。</p>
<h3 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a><code>Deque</code></h3><table>
<thead>
<tr>
<th align="left">Modifier and Type</th>
<th align="left">Method and Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>void</code></td>
<td align="left"><code>addFirst(E e)</code>插入此双端队列的前面，如果它是立即可行且不会违反容量限制，抛出一个指定的元素 <code>IllegalStateException</code>如果当前没有空间可用。</td>
</tr>
<tr>
<td align="left"><code>void</code></td>
<td align="left"><code>addLast(E e)</code>在插入如果它是立即可行且不会违反容量限制，抛出此双端队列的末尾指定元素 <code>IllegalStateException</code>如果当前没有空间可用。</td>
</tr>
<tr>
<td align="left"><code>boolean</code></td>
<td align="left"><code>offerFirst(E e)</code>在此deque的前面插入指定的元素，除非它会违反容量限制。</td>
</tr>
<tr>
<td align="left"><code>boolean</code></td>
<td align="left"><code>offerLast(E e)</code>在此deque的末尾插入指定的元素，除非它会违反容量限制。</td>
</tr>
<tr>
<td align="left"><code>E</code></td>
<td align="left"><code>getFirst()</code>检索，但不删除，这个deque的第一个元素。如果为空，抛出抛出异常NoSuchElementException。</td>
</tr>
<tr>
<td align="left"><code>E</code></td>
<td align="left"><code>getLast()</code>检索，但不删除，这个deque的最后一个元素。如果为空，抛出抛出异常NoSuchElementException。</td>
</tr>
<tr>
<td align="left"><code>E</code></td>
<td align="left"><code>peekFirst()</code>检索，但不删除，此deque的第一个元素，或返回 <code>null</code>如果这个deque是空的。</td>
</tr>
<tr>
<td align="left"><code>E</code></td>
<td align="left"><code>peekLast()</code>检索但不删除此deque的最后一个元素，如果此deque为空，则返回 <code>null</code> 。</td>
</tr>
<tr>
<td align="left"><code>E</code></td>
<td align="left"><code>removeFirst()</code>检索并删除此deque的第一个元素。如果为空，抛出抛出异常NoSuchElementException</td>
</tr>
<tr>
<td align="left"><code>E</code></td>
<td align="left"><code>removeLast()</code>检索并删除此deque的最后一个元素。如果为空，抛出抛出异常NoSuchElementException</td>
</tr>
<tr>
<td align="left"><code>E</code></td>
<td align="left"><code>pollFirst()</code>检索并删除此deque的第一个元素，如果此deque为空，则返回 <code>null</code> 。</td>
</tr>
<tr>
<td align="left"><code>E</code></td>
<td align="left"><code>pollLast()</code>检索并删除此deque的最后一个元素，如果此deque为空，则返回 <code>null</code> 。</td>
</tr>
</tbody></table>
<p>和Queue的方法几乎一致，主要是双端队列在两端都可以进出。<br>所以，在各方法后面加上了 First、Last修饰（事实上，还有缺省First、Last的方法，但是考虑到会引起歧义，所以干脆不用）。</p>
<p><code>Deque</code>接口实际上既可以作为Queue，也可以作为Stack来使用。</p>
<p>push、pop是针对栈而言的。</p>
<p>offer、poll是针对队列而言的。</p>
<p>其中 jdk的设计是，push、pop实际上都是对队列的第一个元素的操作。</p>
<p>offer向队尾加入元素，poll从队首移除元素。</p>
<h2 id="唯一性集合"><a href="#唯一性集合" class="headerlink" title="唯一性集合"></a>唯一性集合</h2><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a><code>Set</code></h3><p>Set接口与之相同（仅仅是接口定义约束的不同），略去。</p>
<h3 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a><code>SortedSet</code></h3><table>
<thead>
<tr>
<th align="left">Modifier and Type</th>
<th align="left">Method and Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>E</code></td>
<td align="left"><code>first()</code>返回此集合中当前的第一个（最低）元素。</td>
</tr>
<tr>
<td align="left"><code>E</code></td>
<td align="left"><code>last()</code>返回此集合中当前的最后（最高）元素。</td>
</tr>
<tr>
<td align="left"><code>SortedSet&lt;E&gt;</code></td>
<td align="left"><code>headSet(E toElement)</code>返回该集合的部分的视图，其元素严格小于 <code>toElement</code> 。</td>
</tr>
<tr>
<td align="left"><code>SortedSet&lt;E&gt;</code></td>
<td align="left"><code>tailSet(E fromElement)</code>返回此组件的元素大于或等于 <code>fromElement</code>的部分的视图。</td>
</tr>
<tr>
<td align="left"><code>SortedSet&lt;E&gt;</code></td>
<td align="left"><code>subSet(E fromElement, E toElement)</code>返回该集合的部分的视图，其元素的范围为 <code>fromElement</code> （含），为 <code>toElement</code> ，独占。</td>
</tr>
</tbody></table>
<h3 id="NavigableSet"><a href="#NavigableSet" class="headerlink" title="NavigableSet"></a><code>NavigableSet</code></h3><table>
<thead>
<tr>
<th align="left">Modifier and Type</th>
<th align="left">Method and Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>E</code></td>
<td align="left"><code>ceiling(E e)</code>返回此集合中最小元素大于或等于给定元素，如果没有此元素则返回 <code>null</code> 。</td>
</tr>
<tr>
<td align="left"><code>E</code></td>
<td align="left"><code>floor(E e)</code>返回该集合中最大的元素小于或等于给定元素，如果没有这样的元素，则返回 <code>null</code> 。</td>
</tr>
<tr>
<td align="left"><code>E</code></td>
<td align="left"><code>higher(E e)</code>返回这个集合中的最小元素严格大于给定的元素，如果没有这样的元素，则返回 <code>null</code> 。</td>
</tr>
<tr>
<td align="left"><code>E</code></td>
<td align="left"><code>lower(E e)</code>返回该集合中最大的元素严格小于给定的元素，如果没有这样的元素，则返回 <code>null</code> 。</td>
</tr>
<tr>
<td align="left"><code>E</code></td>
<td align="left"><code>pollFirst()</code>检索并删除第一个（最低）元素，如果此集合为空，则返回 <code>null</code> 。</td>
</tr>
<tr>
<td align="left"><code>E</code></td>
<td align="left"><code>pollLast()</code>检索并删除最后一个（最高）元素，如果此集合为空，则返回 <code>null</code> 。</td>
</tr>
<tr>
<td align="left"><code>Iterator&lt;E&gt;</code></td>
<td align="left"><code>iterator()</code>以升序返回此集合中的元素的迭代器。</td>
</tr>
<tr>
<td align="left"><code>Iterator&lt;E&gt;</code></td>
<td align="left"><code>descendingIterator()</code>以降序返回该集合中的元素的迭代器。</td>
</tr>
</tbody></table>
<h1 id="二元集合（映射）"><a href="#二元集合（映射）" class="headerlink" title="二元集合（映射）"></a>二元集合（映射）</h1><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a><code>Map</code></h2><table>
<thead>
<tr>
<th align="left">Modifier and Type</th>
<th align="left">Method and Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>boolean</code></td>
<td align="left"><code>containsKey(Object key)</code>如果此映射包含指定键的映射，则返回 <code>true</code> 。</td>
</tr>
<tr>
<td align="left"><code>boolean</code></td>
<td align="left"><code>containsValue(Object value)</code>如果此地图将一个或多个键映射到指定的值，则返回 <code>true</code> 。</td>
</tr>
<tr>
<td align="left"><code>Set&lt;K&gt;</code></td>
<td align="left"><code>keySet()</code>返回此地图中包含的键的视图。</td>
</tr>
<tr>
<td align="left"><code>Collection&lt;V&gt;</code></td>
<td align="left"><code>values()</code>返回此地图中包含的值的视图。</td>
</tr>
<tr>
<td align="left"><code>Set&lt;Map.Entry&lt;K,V&gt;&gt;</code></td>
<td align="left"><code>entrySet()</code>返回此地图中包含的映射的视图。</td>
</tr>
<tr>
<td align="left"><code>V</code></td>
<td align="left"><code>get(Object key)</code>返回到指定键所映射的值，或 <code>null</code>如果此映射包含该键的映射。</td>
</tr>
<tr>
<td align="left"><code>default V</code></td>
<td align="left"><code>getOrDefault(Object key, V defaultValue)</code>返回到指定键所映射的值，或 <code>defaultValue</code>如果此映射包含该键的映射。</td>
</tr>
<tr>
<td align="left"><code>V</code></td>
<td align="left"><code>put(K key, V value)</code>将指定的值与该映射中的指定键相关联（可选操作）。</td>
</tr>
<tr>
<td align="left"><code>default V</code></td>
<td align="left"><code>putIfAbsent(K key, V value)</code>如果指定的键尚未与某个值相关联（或映射到 <code>null</code> ）将其与给定值相关联并返回 <code>null</code> ，否则返回当前值。</td>
</tr>
<tr>
<td align="left"><code>default V</code></td>
<td align="left"><code>replace(K key, V value)</code>只有当目标映射到某个值时，才能替换指定键的条目。</td>
</tr>
<tr>
<td align="left"><code>default boolean</code></td>
<td align="left"><code>replace(K key, V oldValue, V newValue)</code>仅当前映射到指定的值时，才能替换指定键的条目。</td>
</tr>
<tr>
<td align="left"><code>V</code></td>
<td align="left"><code>remove(Object key)</code>如果存在（从可选的操作），从该地图中删除一个键的映射。</td>
</tr>
<tr>
<td align="left"><code>default boolean</code></td>
<td align="left"><code>remove(Object key, Object value)</code>仅当指定的密钥当前映射到指定的值时删除该条目。</td>
</tr>
</tbody></table>
<p>需要注意 replace 和 putIfAbsent 的区别。</p>
<h2 id="Map-Entry"><a href="#Map-Entry" class="headerlink" title="Map.Entry"></a><code>Map.Entry</code></h2><p>它的角色类似于迭代器的角色，不过是二元的。</p>
<table>
<thead>
<tr>
<th align="left">Modifier and Type</th>
<th align="left">Method and Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>K</code></td>
<td align="left"><code>getKey()</code>返回与此条目相对应的键。</td>
</tr>
<tr>
<td align="left"><code>V</code></td>
<td align="left"><code>getValue()</code>返回与此条目相对应的值。</td>
</tr>
<tr>
<td align="left"><code>V</code></td>
<td align="left"><code>setValue(V value)</code>用指定的值替换与该条目相对应的值（可选操作）。</td>
</tr>
</tbody></table>
<blockquote>
<p>参考资料</p>
<p><a href="https://docs.oracle.com/javase/8/docs/api/">Overview (Java Platform SE 8 </a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java集合类</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Java集合类</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP算法 —— 知识点、模板、 应用</title>
    <url>/2021/11/12/KMP%E7%AE%97%E6%B3%95%20%E2%80%94%E2%80%94%20%E7%9F%A5%E8%AF%86%E7%82%B9%E3%80%81%E6%A8%A1%E6%9D%BF%E3%80%81%20%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>这里并不打算去详细推导KMP的原理，以及精髓。只是整理了一下KMP算法的模板、应用、理解的关键点。</p>
</blockquote>
<h1 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h1><p>KMP算法最基本的应用就是字符串的匹配——给定一个text串，一个pattern串，询问pattern串在text串中是否出现，以及出现几次、位置等等。</p>
<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KMP</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> pattern;</span><br><span class="line">    <span class="keyword">int</span> len ;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next;  <span class="comment">// 这里的next数组是从1开始的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也叫失配数组,next[i] 表示以第i位结尾的子串与模式串的前缀相同的最大长度（但不能是自身），也就是所谓的最长公共前后缀</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span></span>&#123;</span><br><span class="line">        next.resize(len+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; pattern[i] != pattern[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pattern[i] == pattern[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    KMP(<span class="keyword">const</span> <span class="built_in">string</span> &amp;pattern) &#123;</span><br><span class="line">        len = pattern.size();</span><br><span class="line">        <span class="keyword">this</span>-&gt;pattern = <span class="string">&quot; &quot;</span> + pattern; </span><br><span class="line">        Next();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubstringOfText</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getPositions(text).size() &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计模式串在文本串出现的次数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getTimes</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getPositions(text).size();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 统计模式串在文本串的出现的次数</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getPositions</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; text)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(text.size()  &lt; len) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; text.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; text[i] != pattern[j + <span class="number">1</span>])&#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(text[i] == pattern[j + <span class="number">1</span>])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j == len)&#123;</span><br><span class="line">                <span class="comment">// i 是匹配时文本串的位置（从0开始）</span></span><br><span class="line">                res.push_back(i);</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求数组f[] 其中 f[i] 表示文本串以i结尾的子串与 pattern 串的前缀相同的最大长度（这里也是从1开始计数）</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getFArray</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = text.size(), j = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(m+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span> ;i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; (j == len || text[i] != pattern[j + <span class="number">1</span>])) &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(text[i] == pattern[j + <span class="number">1</span>])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            f[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="title">getNext</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul>
<li>失配数组的求法以及含义。<code>next[]</code></li>
<li>模式匹配的结果数组。<code>f[]</code></li>
<li>从DFA(有限状态自动)的角度去理解。(对后面的AC自动机的理解大有裨益)</li>
</ul>
<h1 id="典型应用"><a href="#典型应用" class="headerlink" title="典型应用"></a>典型应用</h1><ul>
<li>模式串和文本串的模式匹配。</li>
<li>处理和前缀和后缀有关的问题。</li>
<li>处理循环节方面的问题。</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>字符串算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka基本概念</title>
    <url>/2021/11/24/Kafka-1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Kafka-名词术语"><a href="#Kafka-名词术语" class="headerlink" title="Kafka 名词术语"></a>Kafka 名词术语</h1><ul>
<li>服务器：Broker, 接收客户端发送过来的消息，对消息进行持久化，进行消息的推送等等功能。</li>
<li>主题：Topic。<strong>主题是承载消息的逻辑容器</strong>，在实际使用中多用来区分具体的业务。</li>
<li>分区：Partition。一个有序的消息序列。每个主题下可以有多个分区。分区在业务上并没有太多意义。</li>
<li>消息：Message。由消息头（CRC、版本号、属性、时间戳等等）、消息键（KEY）、消息体（VALUE）、时间戳（TIMESTAMP）等组成。</li>
<li>消息位移：Offset。<strong>表示分区中每条消息的位置信息</strong>，是一个随着消息单调递增且一旦确定就不变的值（对弈某条消息而言）。</li>
<li>副本：Replica。<strong>Kafka 中同一条消息能够被拷贝到多个地方以提供数据冗余，这些地方就是所谓的副本</strong>。副本还分为领导者副本（leader replica）和追随者副本（foller replica），各自有不同的角色划分。每个分区可配置多个副本实现高可用。一个分区的N个副本一定在N个不同的Broker上。</li>
<li>生产者：Producer。向主题发布新消息的应用程序。</li>
<li>消费者：Consumer。从主题订阅新消息的应用程序。</li>
<li>消费者位移：Consumer Offset。表示消费者消费进度，<strong>每个消费者都有自己的消费者位移</strong>。offset保存在broker端的内部topic中（老版本存储在zookeeper集群），不是在clients中保存。</li>
<li>消费者组：Consumer Group。<strong>多个消费者实例共同组成的一个组，同时消费某个主题的多个分区</strong>以实现高吞吐。</li>
<li>重平衡：Rebalance。消费者组内某个消费者实例挂掉后，其他消费者实例自动重新分配订阅主题分区</li>
</ul>
<h2 id="topic-和-partition"><a href="#topic-和-partition" class="headerlink" title="topic 和 partition"></a>topic 和 partition</h2><img src="Kafka-1/topic-partion.png" style="zoom:30%;" />

<p>partition上的每一条消息都会被分配一个序列号，该序列号被称为位移。</p>
<p>每条消息在某个消息的位移是固定的（不要和消费者的位移产生混淆）。</p>
<p>所以，kafka中的每一条消息都可以由&lt;topic,partition,offset&gt;这个三元组位移确定。</p>
<h2 id="replica"><a href="#replica" class="headerlink" title="replica"></a>replica</h2><p>副本分为leader副本和follower副本。<br>这个主从结构并不是一回事。一般情况下，在主从结构中，主提供写，主从都可以提供读。</p>
]]></content>
      <categories>
        <category>消息中间件</category>
      </categories>
      <tags>
        <tag>Message Queue</tag>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka初探</title>
    <url>/2021/10/23/Kafka%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="安装、测试"><a href="#安装、测试" class="headerlink" title="安装、测试"></a>安装、测试</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://www.apache.org/dyn/closer.cgi?path=/kafka/3.0.0/kafka_2.13-3.0.0.tgz">下载地址</a></p>
<p>配置相关环境。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$KAFKA_HOME</span></span><br></pre></td></tr></table></figure>

<ul>
<li>启动服务器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo bin/kafka-server-start.sh -daemon config/server.properties</span><br></pre></td></tr></table></figure>



<ul>
<li>创建topic</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 1 --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure>



<ul>
<li>列出topic</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --list --bootstrap-server localhost:9092</span><br></pre></td></tr></table></figure>



<ul>
<li>查看某个 topic</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --describe --topic <span class="built_in">test</span> --bootstrap-server localhost:9092</span><br></pre></td></tr></table></figure>



<ul>
<li>发布消息</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/kafka-console-producer.sh --topic <span class="built_in">test</span> --bootstrap-server localhost:9092</span><br></pre></td></tr></table></figure>



<ul>
<li>消费消息</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --topic <span class="built_in">test</span> --from-beginning --bootstrap-server localhost:9092</span><br></pre></td></tr></table></figure>



<p>能够呈现出来的效果就是，在<strong>发布消息的console</strong>中发布一条消息（enter分割），在<strong>消费消息的console</strong>中就会输出一条消息。</p>
<h2 id="SpringBoot-Quick-Start"><a href="#SpringBoot-Quick-Start" class="headerlink" title="SpringBoot Quick Start"></a>SpringBoot Quick Start</h2><ul>
<li>yml配置</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">bootstrap-servers:</span> <span class="string">localhost:9092</span></span><br><span class="line">    <span class="attr">consumer:</span></span><br><span class="line">      <span class="attr">group-id:</span> <span class="string">foo</span></span><br><span class="line">      <span class="attr">auto-offset-reset:</span> <span class="string">earliest</span></span><br></pre></td></tr></table></figure>





<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> KafkaTemplate&lt;String, String&gt; template;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">(KafkaTemplate&lt;String, String&gt; template)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.template = template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String topicName = <span class="string">&quot;myTopic&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(fixedRate = 1000)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx++ &gt; <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        template.send(topicName, String.valueOf(idx));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@KafkaListener(topics = topicName)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(ConsumerRecord&lt;String, String&gt; cr)</span> </span>&#123;</span><br><span class="line">        System.out.println(cr);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ConsumerRecord(topic &#x3D; myTopic, partition &#x3D; 0, leaderEpoch &#x3D; 0, offset &#x3D; 2, CreateTime &#x3D; 1635125751646, serialized key size &#x3D; -1, serialized value size &#x3D; 1, headers &#x3D; RecordHeaders(headers &#x3D; [], isReadOnly &#x3D; false), key &#x3D; null, value &#x3D; 1)</span><br><span class="line"></span><br><span class="line">ConsumerRecord(topic &#x3D; myTopic, partition &#x3D; 0, leaderEpoch &#x3D; 0, offset &#x3D; 3, CreateTime &#x3D; 1635125752304, serialized key size &#x3D; -1, serialized value size &#x3D; 1, headers &#x3D; RecordHeaders(headers &#x3D; [], isReadOnly &#x3D; false), key &#x3D; null, value &#x3D; 2)</span><br><span class="line"></span><br><span class="line">ConsumerRecord(topic &#x3D; myTopic, partition &#x3D; 0, leaderEpoch &#x3D; 0, offset &#x3D; 4, CreateTime &#x3D; 1635125753302, serialized key size &#x3D; -1, serialized value size &#x3D; 1, headers &#x3D; RecordHeaders(headers &#x3D; [], isReadOnly &#x3D; false), key &#x3D; null, value &#x3D; 3)</span><br><span class="line"></span><br><span class="line">ConsumerRecord(topic &#x3D; myTopic, partition &#x3D; 0, leaderEpoch &#x3D; 0, offset &#x3D; 5, CreateTime &#x3D; 1635125754303, serialized key size &#x3D; -1, serialized value size &#x3D; 1, headers &#x3D; RecordHeaders(headers &#x3D; [], isReadOnly &#x3D; false), key &#x3D; null, value &#x3D; 4)</span><br><span class="line"></span><br><span class="line">ConsumerRecord(topic &#x3D; myTopic, partition &#x3D; 0, leaderEpoch &#x3D; 0, offset &#x3D; 6, CreateTime &#x3D; 1635125755300, serialize</span><br></pre></td></tr></table></figure>



<p>可以看到消息的各种属性，如主题、分区、偏移量、时间戳、键、值等等。</p>
]]></content>
      <categories>
        <category>消息中间件</category>
      </categories>
      <tags>
        <tag>Message Queue</tag>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda表达式</title>
    <url>/2021/11/28/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="C-中lambda表达式"><a href="#C-中lambda表达式" class="headerlink" title="C++中lambda表达式"></a>C++中lambda表达式</h1><p>Lambda表达式包含一个函数对象参数</p>
<p>标识一个 Lambda 表达式的开始，这部分必须存在，不能省略。函数对象参数是传递给编译器自动生成的函数对象类的构造函数的。函数对象参数只能使用那些到定义 Lambda 为止时 Lambda 所在作用范围内可见的局部变量(包括 Lambda 所在类<br>的 this)。函数对象参数有以下形式：</p>
<ul>
<li>空。没有任何函数对象参数。</li>
<li>=。函数体内可以使用 Lambda 所在范围内所有可见的局部变量（包括 Lambda 所在类的 this），并且是值传递方式（相当于编译器自动为我们按值传递了所有局部变量）。</li>
<li>&amp;。函数体内可以使用 Lambda 所在范围内所有可见的局部变量（包括 Lambda 所在类的 this），并且是引用传递方式（相当于是编译器自动为我们按引用传递了所有局部变量）。</li>
<li>this。函数体内可以使用 Lambda 所在类中的成员变量。</li>
</ul>
<p>具体的使用方法示例：</p>
<ul>
<li><code>a</code>。将 a 按值进行传递。按值进行传递时，函数体内不能修改传递进来的 a 的拷贝，因为默认情况下函数是 const 的，要<br>修改传递进来的拷贝，可以添加 mutable 修饰符。</li>
<li><code>&amp;a</code>。将 a 按引用进行传递。</li>
<li><code>a，&amp;b</code>。将 a 按值传递，b 按引用进行传递。</li>
<li><code>[=]，&amp;a，&amp;b</code>。除 a 和 b 按引用进行传递外，其他参数都按值进行传递。</li>
<li><code>[&amp;]，a，b</code>。除 a 和 b 按值进行传递外，其他参数都按引用进行传递</li>
</ul>
<p>sort使用lambda表达式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; allCellsDistOrder(<span class="keyword">int</span> R, <span class="keyword">int</span> C, <span class="keyword">int</span> r0, <span class="keyword">int</span> c0) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; j++) &#123;</span><br><span class="line">                ret.push_back(&#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(ret.begin(), ret.end(), [=](<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b) &#123;<span class="comment">//因为r0,c0是当前函数的局部变量，所以只能使用值传递而不能使用引用传递造成指针混乱</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(a[<span class="number">0</span>] - r0) + <span class="built_in">abs</span>(a[<span class="number">1</span>] - c0) &lt; <span class="built_in">abs</span>(b[<span class="number">0</span>] - r0) + <span class="built_in">abs</span>(b[<span class="number">1</span>] - c0);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>LinkLayer</title>
    <url>/2021/12/10/LinkLayer/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
  </entry>
  <entry>
    <title>LeetCode 卖股票六道题</title>
    <url>/2021/12/08/LeetCode-%E5%8D%96%E8%82%A1%E7%A5%A8%E5%85%AD%E9%81%93%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121.买卖股票的最佳时机"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/submissions/">121.买卖股票的最佳时机</a></h1><p>DP的阶段就是天数，记录下历史最低价格，用新出现的价格更新答案，并更新历史最小值。<br>时间复杂度：<br>$O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, m = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prices.size();i++)&#123;</span><br><span class="line">            ans = max(ans,prices[i]-m);</span><br><span class="line">            m = min(m,prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里提供一个更直观的解法。<br>时间复杂度：$O(n*log(n))$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; ms;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:prices)&#123;</span><br><span class="line">            ms.insert(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prices.size();i++)&#123;</span><br><span class="line">            ms.erase(ms.find(prices[i]));</span><br><span class="line">            <span class="keyword">if</span>(!ms.empty()) ans = max(ans,*ms.rbegin()-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h1><p>累积每个单调升序端一头一尾的差值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span> , n = a.size();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&lt;a[i<span class="number">-1</span>])&#123;</span><br><span class="line">                ans += a[i<span class="number">-1</span>]-a[l];</span><br><span class="line">                l = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += max(<span class="number">0</span>,a[n<span class="number">-1</span>]-a[l]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>有点<strong>差分</strong>的感觉。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;a.size();i++)&#123;</span><br><span class="line">            ans += max(<span class="number">0</span>,a[i]-a[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>DP<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.size();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]+a[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">0</span>]-a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714. 买卖股票的最佳时机含手续费"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. 买卖股票的最佳时机含手续费</a></h1><p>上一问的DP的延续。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.size();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]+a[i]-fee);</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">0</span>]-a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h1 id="123-买卖股票的最佳时机-III"><a href="#123-买卖股票的最佳时机-III" class="headerlink" title="123. 买卖股票的最佳时机 III"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a></h1><p>自己的代码，但是思路并不是很清晰，还WA了好几次，主要是初值设置。</p>
<ul>
<li>截取了一段网友的思路，很清晰：<br>一天结束时，可能有持股、可能未持股、可能卖出过1次、可能卖出过2次、也可能未卖出过<br>所以定义状态转移数组dp[天数][当前是否持股][卖出的次数]</li>
</ul>
<p>具体一天结束时的6种状态：<br>① 未持股，未卖出过股票：说明从未进行过买卖，利润为0<br>$dp[i][0][0]=0$<br>② 未持股，卖出过1次股票：可能是今天卖出，也可能是之前卖的（昨天也未持股且卖出过）<br>$dp[i][0][1]=max(dp[i-1][1][0]+prices[i],dp[i-1][0][1])$<br>③ 未持股，卖出过2次股票:可能是今天卖出，也可能是之前卖的（昨天也未持股且卖出过）<br>$dp[i][0][2]=max(dp[i-1][1][1]+prices[i],dp[i-1][0][2])$<br>④ 持股，未卖出过股票：可能是今天买的，也可能是之前买的（昨天也持股）<br>$dp[i][1][0]=max(dp[i-1][0][0]-prices[i],dp[i-1][1][0])$<br>⑤ 持股，卖出过1次股票：可能是今天买的，也可能是之前买的（昨天也持股）<br>$dp[i][1][1]=max(dp[i-1][0][1]-prices[i],dp[i-1][1][1])$<br>⑥ 持股，卖出过2次股票：最多交易2次，这种情况不存在<br>$dp[i][1][2]=float(‘-inf’)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.size();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; dp(n,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(<span class="number">2</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">3</span>,<span class="number">0</span>)));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>] = -a[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">-1e9</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">2</span>] = <span class="number">-1e9</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">2</span>;k++)&#123;</span><br><span class="line">                dp[i][<span class="number">0</span>][k+<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>][k+<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>][k]+a[i]);</span><br><span class="line">                dp[i][<span class="number">1</span>][k] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>][k],dp[i<span class="number">-1</span>][<span class="number">0</span>][k]-a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(max(dp[n<span class="number">-1</span>][<span class="number">0</span>][<span class="number">1</span>],dp[n<span class="number">-1</span>][<span class="number">0</span>][<span class="number">2</span>]),<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h1 id="188-买卖股票的最佳时机-IV"><a href="#188-买卖股票的最佳时机-IV" class="headerlink" title="188. 买卖股票的最佳时机 IV"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV</a></h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> K, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.size();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(K&gt;=n/<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> maxProfit(a);</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; dp(n,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(<span class="number">2</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(K+<span class="number">1</span>,<span class="number">0</span>)));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>] = -a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=K;k++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">1</span>][k] = <span class="number">-1e9</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;K;k++)&#123;</span><br><span class="line">                dp[i][<span class="number">0</span>][k+<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>][k+<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>][k]+a[i]);</span><br><span class="line">                dp[i][<span class="number">1</span>][k] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>][k],dp[i<span class="number">-1</span>][<span class="number">0</span>][k]-a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=K;k++)&#123;</span><br><span class="line">            ans = max(ans,dp[n<span class="number">-1</span>][<span class="number">0</span>][k]);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;a.size();i++)&#123;</span><br><span class="line">            ans += max(<span class="number">0</span>,a[i]-a[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h1 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309.最佳买卖股票时机含冷冻期"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309.最佳买卖股票时机含冷冻期</a></h1><p>用<code>dp[i][j][k]</code>其中i是角标;<br>j为0或1——表示这一天结束时是否拥有股票;<br>k也为0或1，表示这一天是否是交易日。<br>初始化为负无穷大。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.size();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; dp(n,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(<span class="number">2</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>,<span class="number">-1e9</span>)));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>] = -a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">// 买股票</span></span><br><span class="line">            dp[i][<span class="number">1</span>][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">0</span>][<span class="number">0</span>]-a[i]);</span><br><span class="line">            <span class="comment">// 卖股票</span></span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>]+a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(dp[n<span class="number">-1</span>][<span class="number">0</span>][<span class="number">0</span>],dp[n<span class="number">-1</span>][<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>很明显空间可以进行一下压缩。但是可读性有点差了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.size();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp00 = <span class="number">0</span>,dp10 = -a[<span class="number">0</span>],dp01=<span class="number">-1e9</span>,dp_00,dp_01,dp_10;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">// 买股票</span></span><br><span class="line">            dp_10 = max(dp10,dp00-a[i]);</span><br><span class="line">            <span class="comment">// 卖股票</span></span><br><span class="line">            dp_00 = max(dp00,dp01);</span><br><span class="line">            dp_01 = dp10+a[i];</span><br><span class="line">            dp10 = dp_10;</span><br><span class="line">            dp00 = dp_00;</span><br><span class="line">            dp01 = dp_01;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(dp00,dp01);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令 —— 网络监控</title>
    <url>/2021/11/27/Linux%E5%91%BD%E4%BB%A4-%E2%80%94%E2%80%94-%E7%BD%91%E7%BB%9C%E7%9B%91%E6%8E%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
  </entry>
  <entry>
    <title>Linux命令 —— 进程、线程监控</title>
    <url>/2021/11/27/Linux%E5%91%BD%E4%BB%A4-%E2%80%94%E2%80%94-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9B%91%E6%8E%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
  </entry>
  <entry>
    <title>Linux命令 —— 内存监控</title>
    <url>/2021/11/27/Linux%E5%91%BD%E4%BB%A4-%E2%80%94%E2%80%94-%E5%86%85%E5%AD%98%E7%9B%91%E6%8E%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
  </entry>
  <entry>
    <title>Linux多进程、多线程编程</title>
    <url>/2021/11/20/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="进程-线程相关"><a href="#进程-线程相关" class="headerlink" title="进程/线程相关"></a>进程/线程相关</h1><h2 id="线程相关"><a href="#线程相关" class="headerlink" title="线程相关"></a>线程相关</h2><h2 id="background-information"><a href="#background-information" class="headerlink" title="background information"></a>background information</h2><p>线程和进程的理论概念不再赘述。<br>Linux 中，系统是不认识线程还是进程的，它只认识 task。</p>
<blockquote>
<p>下面的阐述都是 Unix like 下的有关线程的语义。</p>
</blockquote>
<p>主线程和子线程</p>
<ul>
<li>共享： 用户区内，除了栈区是不共享的，其余都是共享的。</li>
<li>不共享： 栈区（当有 1 主 + 4 子线程时候，栈区会被平分为 5 份）</li>
</ul>
<p>多进程共享的资源（fork、clone出的子进程和父进程）：</p>
<ul>
<li>代码</li>
<li>文件描述符</li>
<li>内存映射区 –mmap</li>
</ul>
<p>多线程共享的资源：</p>
<ul>
<li><p>堆</p>
</li>
<li><p>全局变量 </p>
</li>
<li><p>线程号和线程 ID 是有区别的<br>查看方式： 找到程序的进程 ID后， <code>ps -Lf $(pid)</code>，LWP那一列即为线程ID。</p>
</li>
</ul>
<h3 id="pthread-create"><a href="#pthread-create" class="headerlink" title="pthread_create"></a>pthread_create</h3><ul>
<li><p>头文件:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>pthread非linux系统的默认库， 需手动链接-线程库 -lpthread</p>
</li>
<li><p>函数说明:<br>返回成功时，由 tidp 指向的内存单元被设置为新创建线程的线程ID。a<br>ttr参数用于指定各种不同的线程属性。<br>新创建的线程从start_rtn函数的地址开始运行，该函数只有一个万能指针参数arg。<br>如果需要向start_rtn函数传递的参数不止一个，那么需要把这些参数放到一个结构体中，然后把这个结构的地址作为arg的参数传入。</p>
</li>
<li><p>函数定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *tidp,<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">void</span> *(*start_rtn)(<span class="keyword">void</span>*),<span class="keyword">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>参数说明：<br>第一个参数为指向线程标识符的指针。<br>第二个参数用来设置线程属性。<br>第三个参数是线程运行函数的起始地址。<br>最后一个参数是运行函数的参数。</p>
</li>
<li><p>返回值<br>若线程创建成功，则返回0。若线程创建失败，则返回出错编号，并且*thread中的内容是未定义的。</p>
</li>
<li><p>代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">13</span>; <span class="comment">//设置为全局变量，在全局区域，共享</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">myfun</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* p = (<span class="keyword">void</span> *)&amp;num;  <span class="comment">//传一个地址进去（voi* 也是 4 个字节）</span></span><br><span class="line">    <span class="keyword">pthread_t</span> id[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_create(&amp;(id[i]), <span class="literal">NULL</span>, myfun, p);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d, thread id: %ld\n&quot;</span>, i, id[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">myfun</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %d, child thread id: %ld\n&quot;</span>, (*((<span class="keyword">int</span> *)arg))++, pthread_self());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>参考链接<br><a href="https://man7.org/linux/man-pages/man3/pthread_create.3.html">pthread_create(3) — Linux manual page</a><br><a href="https://xmuli.tech/posts/28f8209f/">Linux中创建多线程实例pthread_create()</a></p>
</li>
</ul>
<h3 id="pthread-join"><a href="#pthread-join" class="headerlink" title="pthread_join"></a>pthread_join</h3><p>pthread_join()即是子线程合入主线程，主线程阻塞等待子线程结束，然后回收子线程资源。</p>
<p>注意，默认情况下，资源是不会随着子线程的exit或return而回收的。</p>
<ul>
<li><p>头文件:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>函数说明:<br>thread_join()函数，以阻塞的方式等待thread指定的线程结束。当函数返回时，被等待线程的资源被收回。<br>如果线程已经结束，那么该函数会立即返回。并且thread指定的线程必须是 joinable 的。</p>
</li>
<li><p>函数定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span> **retval)</span></span>;</span><br></pre></td></tr></table></figure>
<p>thread: 线程标识符，即线程ID，标识唯一线程。<br>retval: 用户定义的指针，用来存储被等待线程的返回值。</p>
</li>
<li><p>返回值<br>0代表成功。 失败，返回的则是错误号。</p>
</li>
</ul>
<ul>
<li>示例代码：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_function</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread working... %d \n&quot;</span>, i);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> mythread;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;mythread, <span class="literal">NULL</span>, thread_function, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error creating thread.&quot;</span>);</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pthread_join(mythread, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error join thread.&quot;</span>);</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread done! \n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 输出</span></span><br><span class="line"><span class="comment">Thread working...! 0 </span></span><br><span class="line"><span class="comment">Thread working...! 1 </span></span><br><span class="line"><span class="comment">Thread working...! 2 </span></span><br><span class="line"><span class="comment">Thread working...! 3 </span></span><br><span class="line"><span class="comment">Thread working...! 4 </span></span><br><span class="line"><span class="comment">Thread working...! 5 </span></span><br><span class="line"><span class="comment">Thread working...! 6 </span></span><br><span class="line"><span class="comment">Thread working...! 7 </span></span><br><span class="line"><span class="comment">thread done! </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>如果去掉<code>pthread_join</code>的调用的话，<br>输出为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">thread done! </span><br><span class="line">Thread working... 0 </span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<p>也就是说，子线程来不及执行它的函数，就因为父线程的死亡而被迫终结了。</p>
<h3 id="pthread-detach"><a href="#pthread-detach" class="headerlink" title="pthread_detach"></a>pthread_detach</h3><ul>
<li><p>头文件:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>函数说明:<br>pthread_join()函数的替代函数，可回收创建时detachstate属性设置为PTHREAD_CREATE_JOINABLE的线程的存储空间。<br>该函数不会阻塞父线程。<br>pthread_join()函数用于只是应用程序在线程tid终止时回收其存储空间。</p>
</li>
<li><p>函数定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> tid)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>返回值<br>thread_detach() 在调用成功完成之后返回零。其他任何返回值都表示出现了错误。</p>
</li>
</ul>
<p>注意，即使如此，父线程退出时，子线程仍然会强制退出。</p>
<h3 id="pthread-cancel"><a href="#pthread-cancel" class="headerlink" title="pthread_cancel"></a>pthread_cancel</h3><ul>
<li><p>函数说明：<br>发送终止信号给thread线程，如果成功则返回0，否则为非0值。发送成功并不意味着thread会终止。</p>
</li>
<li><p>函数定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @Author: 吉松阳</span></span><br><span class="line"><span class="comment"> * @Date: 2021/9/26</span></span><br><span class="line"><span class="comment"> * @Description: </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_message_function</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread1;</span><br><span class="line">    pthread_create(&amp;thread1, <span class="literal">NULL</span>, (<span class="keyword">void</span> *) &amp;print_message_function, (<span class="keyword">void</span> *) <span class="number">0</span>);</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread\n&quot;</span>);</span><br><span class="line">    pthread_cancel(thread1);</span><br><span class="line">    sleep(<span class="number">7</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_message_function</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">    pthread_detach(pthread_self());</span><br><span class="line">    sleep(<span class="number">6</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread\n&quot;</span>);</span><br><span class="line">    pthread_exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实验证明 pthread_exit 确实起作用了</span></span><br></pre></td></tr></table></figure></li>
<li><p>参考链接：<br><a href="https://www.cnblogs.com/lijunamneg/archive/2013/01/25/2877211.html">线程取消(pthread_cancel)</a></p>
</li>
</ul>
<h2 id="信号处理相关"><a href="#信号处理相关" class="headerlink" title="信号处理相关"></a>信号处理相关</h2><h3 id="raise"><a href="#raise" class="headerlink" title="raise"></a>raise</h3><ul>
<li><p>头文件:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>函数说明:<br>C 库函数, 会促使生成信号 sig。sig 参数与 SIG 宏兼容。</p>
</li>
<li><p>函数定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sig -- 要发送的信号码。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>查看所有信号：使用 <code>kill -l</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">songyangji@SongyangJi-Ubuntu-DeskStop:~$ kill -l</span><br><span class="line"> 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP</span><br><span class="line"> 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1</span><br><span class="line">11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM</span><br><span class="line">16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP</span><br><span class="line">21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR</span><br><span class="line">31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2</span><br></pre></td></tr></table></figure>

<p>值得注意的是，<br>当一个进程调用fork时，因为子进程在开始时复制父进程的存储映像，信号捕捉函数的地址在子进程中是有意义的，所以子进程继承父进程的信号处理方式。<br>但是当子进程调用exec后，因为exec运行新的程序后会覆盖从父进程继承来的存储映像。<br>那么信号捕捉函数在新程序中已无意义，所以exec会将原先设置为要捕捉的信号都更改为默认动作。</p>
<ul>
<li>返回值<br>如果成功该函数返回零，否则返回非零。</li>
</ul>
<h3 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h3><ul>
<li>头文件:<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>函数说明:<br>C 库函数,设置一个函数来处理信号，即带有 sig 参数的信号处理程序。</p>
</li>
<li><p>函数定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (*signal(<span class="keyword">int</span> sig, <span class="keyword">void</span> (*func)(<span class="keyword">int</span>)))(<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>参数说明：</p>
<ul>
<li>sig – 在信号处理程序中作为变量使用的信号码。下面是一些重要的标准信号常量</li>
<li>func – 一个指向函数的指针。它可以是一个由程序定义的函数，也可以是下面预定义函数之一。<ul>
<li>SIG_DFL    默认的信号处理程序。</li>
<li>SIG_IGN    忽视信号。</li>
</ul>
</li>
</ul>
<ul>
<li>返回值<br>该函数返回之前的信号处理程序</li>
</ul>
<ul>
<li>实例代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal_catchfunc</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    signal(SIGINT, signal_catchfunc);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;开始生成一个信号\n&quot;</span>);</span><br><span class="line">    ret = raise(SIGINT);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;错误，不能生成SIGINT信号\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;退出....\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal_catchfunc</span><span class="params">(<span class="keyword">int</span> signal)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕获信号\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sandbox使用的信号"><a href="#sandbox使用的信号" class="headerlink" title="sandbox使用的信号"></a>sandbox使用的信号</h3><p>信号的共达60余个，这里只介绍一下sandbox中使用的信号。</p>
<h3 id="SIGUSR1-SIGUSR2"><a href="#SIGUSR1-SIGUSR2" class="headerlink" title="SIGUSR1/SIGUSR2"></a>SIGUSR1/SIGUSR2</h3><p>SIGUSR1 用户自定义信号 默认处理：进程终止;<br>SIGUSR2 用户自定义信号默认处理：进程终止。</p>
<h3 id="SIGSEGV"><a href="#SIGSEGV" class="headerlink" title="SIGSEGV"></a>SIGSEGV</h3><p>在POSIX兼容的平台上，SIGSEGV是当一个进程<strong>执行了一个无效的内存引用</strong>，或<strong>发生段错误</strong>时发送给它的信号。<br>SIGSEGV的符号常量在头文件<code>signal.h</code>中定义。<br>因为在不同平台上，信号数字可能变化，因此最好使用符号信号名。通常，它是信号#11。<br><a href="https://zh.wikipedia.org/wiki/SIGSEGV">SIGSEGV维基百科</a></p>
<h2 id="execXX-函数组"><a href="#execXX-函数组" class="headerlink" title="execXX 函数组"></a>execXX 函数组</h2><p>exec函数族提供了一个在进程中启动另一个程序执行的方法。它可以根据指定的文件名或目录名找到可执行文件，<br>并用它来取代原调用进程的数据段、代码段和堆栈段，在执行完之后，原调用进程的内容除了进程号外，其他全部被新的进程替换了。<br>另外，这里的可执行文件既可以是二进制文件，也可以是Linux下任何可执行的脚本文件。</p>
<p>exec函数一共有六个，其中execve为内核级系统调用，<br>其他（execl，execle，execlp，execv，execvp）都是调用execve的库函数。<br>不同之处在于如何找到程序、如何指定参数以及环境来自何处。</p>
<ul>
<li><p>名称中带有 v 的调用，用带有一个数组参数来指定argv[]新程序的数组。数组的最后一个元素为 NULL。</p>
</li>
<li><p>名称中带有 l 的调用，将新程序的参数作为函数本身的可变长度参数列表。参数的结尾为参数指针(char *)NULL。<br>你应该始终进行类型转换，因为NULL实际是整数常量，并且调用可变参数函数时的默认参数转换不会将其转换为指针。</p>
</li>
<li><p>名称中带有 e 的调用，需要一个额外的参数（或l情况下的参数）来提供新程序的环境；否则，程序将继承当前进程的环境。</p>
</li>
</ul>
<h3 id="execve"><a href="#execve" class="headerlink" title="execve"></a>execve</h3><ul>
<li><p>头文件:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>函数说明:<br>pthread_create是类Unix操作系统（Unix、Linux、Mac OS X等）的创建线程的函数。<br>它的功能是创建线程（实际上就是确定调用该线程函数的入口点），在线程创建以后，就开始运行相关的线程函数。</p>
</li>
<li><p>函数定义:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>返回值:<br>如果执行成功则函数不会返回(后面的代码也并不会执行了)，执行失败则直接返回-1，失败原因存于errno 中。</p>
</li>
</ul>
<ul>
<li>示例代码:<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @Author: 吉松阳</span></span><br><span class="line"><span class="comment"> * @Date: 2021/9/22</span></span><br><span class="line"><span class="comment"> * @Description: </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *argv[] = &#123;<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-el&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> *envp[] = &#123;<span class="string">&quot;PATH=/bin&quot;</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    execve(<span class="string">&quot;/bin/ls&quot;</span>, argv, envp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  total 128</span></span><br><span class="line"><span class="comment">  drwxr-xr-x  5 jisongyang  staff    160 Sep 22 22:07 CMakeFiles</span></span><br><span class="line"><span class="comment">  -rw-r--r--  1 jisongyang  staff   6687 Sep 22 22:06 Makefile</span></span><br><span class="line"><span class="comment">  -rw-r--r--  1 jisongyang  staff   1021 Sep 22 22:06 cmake_install.cmake</span></span><br><span class="line"><span class="comment">  -rwxr-xr-x  1 jisongyang  staff  50424 Sep 22 22:22 test_execve</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>参考链接:</p>
<ol>
<li><a href="https://man7.org/linux/man-pages/man2/execve.2.html">execve(2) — Linux manual page</a></li>
<li><a href="https://stackoverflow.com/questions/20823371/what-is-the-difference-between-the-functions-of-the-exec-family-of-system-calls">What is the difference between the functions of the exec family of system calls like exec and execve?</a></li>
</ol>
<h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h3><ul>
<li><p>头文件:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>函数说明:<br>sleep()会令目前的进程暂停, 直到达到参数seconds 所指定的时间, 或是被信号所中断.</p>
</li>
<li><p>函数定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sleep</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>返回值<br>若进程暂停到参数seconds 所指定的时间则返回0, 若有信号中断则返回剩余秒数.</p>
</li>
</ul>
<h2 id="wait-函数组"><a href="#wait-函数组" class="headerlink" title="wait 函数组"></a>wait 函数组</h2><p>进程调用 exit() 退出执行后，被设置为僵死状态。<br>这时父进程可以通过 wait4() 系统调用查询子进程是否终结，之后再进行最后的操作，彻底删除进程所占用的内存资源。<br>wait4() 系统调用由 linux 内核实现。<br>linux 系统通常提供了 wait()、waitpid()、wait3()、wait4() 这四个函数，<br>四个函数的参数不同，语义也有细微的差别，但是都返回关于终止进程的状态信息。</p>
<h3 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h3><ul>
<li><p>头文件:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;        // 提供类型 pid_t 的定义</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>函数说明:<br>当进程调用 wait() 时，会暂停目前进程的执行（即阻塞），由 wait() 来自动分析是否当前进程的某个子进程已经退出，<br>如果找到了这样一个已经变成僵尸进程的子进程，wait 就会收集这个子进程的信息，并将其彻底销毁后返回；<br>如果没有找到这样一个子进程，wait 就会一直阻塞在这里，直到出现<strong>僵尸进程</strong>。</p>
</li>
<li><p>函数定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> *status)</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数 status 保存着子进程退出时的一些状态（包括 task_struct、thread_info及内核栈等）它是一个指向 int 类型的指针；<br>如果不在意子进程的结束状态值，只想把这个僵尸进程消灭掉（实际上，大多数时候都是这样做的），则可以将这个参数设为 NULL。</p>
</li>
</ul>
<p>关于 status参数比较复杂，可以参考这里<br><a href="https://www.ibm.com/developerworks/cn/linux/kernel/syscall/part3/index.html">传送门</a></p>
<ul>
<li>返回值<br>如果 wait() 调用成功，则会返回被收集子进程的进程ID；如果被调用进程没有子进程，则调用失败，返回 -1</li>
</ul>
<h3 id="waitpid"><a href="#waitpid" class="headerlink" title="waitpid"></a>waitpid</h3><ul>
<li><p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> *status,<span class="keyword">int</span> options)</span></span>;</span><br></pre></td></tr></table></figure>
<p>waitpid() 函数的功能与 wait() 的功能类似，不过，它比 wait() 函数多了两个参数：</p>
</li>
<li><p>1）参数 pid 为欲等待的子进程的识别码：<br>pid &lt; -1 ：等待进程组 ID 为 pid 绝对值的进程组中的任何子进程；<br>pid = -1 ：等待任何子进程，此时 waitpid() 相当于 wait()。实际上，wait()就是 pid = -1、options = 0 的waitpid()， 且有：<br>pid = 0 ：等待进程组 ID 与当前进程相同的任何子进程（也就是等待同一个进程组中的任何子进程）；<br>pid &gt; 0 ：等待任何子进程 ID 为 pid 的子进程，只要指定的子进程还没有结束，waitpid() 就会一直等下去。</p>
</li>
<li><p>2）参数 options 提供一些额外的选项来控制 waitpid()：<br>WNOHANG：如果没有任何已经结束了的子进程，则马上返回，不等待；<br>WUNTRACED：如果子进程进入暂停执行的情况，则马上返回，但结束状态不予理会；<br>也可以将这两个选项组合起来使用，使用 OR 操作。如果不想使用这两个选项，也可以直接把 options 设为 0 </p>
</li>
<li><p>3）waitpid() 的返回值，有三种：<br>a）正常返回时，waitpid() 返回收集到的子进程的PID；<br>b）如果设置了 WNOHANG，而调用 waitpid() 时，没有发现已退出的子进程可收集，则返回0；<br>c）如果调用出错，则返回 -1，这时erron 会被设置为相应的值以指示错误所在。（当 pid 所指示的子进程不错在，或此进程存在，但不是调用进程的子进程， waitpid() 就会返回出错，这时 erron 被设置为 ECHILD）</p>
</li>
</ul>
<h3 id="wait3-wait4"><a href="#wait3-wait4" class="headerlink" title="wait3/wait4"></a>wait3/wait4</h3><p>函数原型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/tpyes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait3</span><span class="params">(<span class="keyword">int</span> *status,<span class="keyword">int</span> options,struct rusage *rusage)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait4</span><span class="params">(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> *status,<span class="keyword">int</span> options,struct rusage *rusage)</span></span>;</span><br></pre></td></tr></table></figure>
<p>wait3() 和 wait4() 函数除了可以获得子进程状态信息外，还可以获得子进程的资源使用信息，这些信息是通过参数 <strong>rusage</strong> 得到的。<br>而 wait3() 与 wait4() 之间的区别是，wait3() 等待所有进程，而 wait4() 可以根据 pid 的值选择要等待的子进程。<br>参数 pid 的意义与 waitpid() 函数的一样。</p>
<p>其中，需要注意的是，参数rusage所指向的结构中返回终止子进程的资源使用情况。其中包括进程使用的CPU时间总量以及内存管理的统计数据。<br>如下，为它的结构定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rusage</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">ru_utime</span>;</span> <span class="comment">/* user CPU time used */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">ru_stime</span>;</span> <span class="comment">/* system CPU time used */</span></span><br><span class="line">    <span class="keyword">long</span>   ru_maxrss;        <span class="comment">/* maximum resident set size */</span></span><br><span class="line">    <span class="keyword">long</span>   ru_ixrss;         <span class="comment">/* integral shared memory size */</span></span><br><span class="line">    <span class="keyword">long</span>   ru_idrss;         <span class="comment">/* integral unshared data size */</span></span><br><span class="line">    <span class="keyword">long</span>   ru_isrss;         <span class="comment">/* integral unshared stack size */</span></span><br><span class="line">    <span class="keyword">long</span>   ru_minflt;        <span class="comment">/* page reclaims (soft page faults) */</span></span><br><span class="line">    <span class="keyword">long</span>   ru_majflt;        <span class="comment">/* page faults (hard page faults) */</span></span><br><span class="line">    <span class="keyword">long</span>   ru_nswap;         <span class="comment">/* swaps */</span></span><br><span class="line">    <span class="keyword">long</span>   ru_inblock;       <span class="comment">/* block input operations */</span></span><br><span class="line">    <span class="keyword">long</span>   ru_oublock;       <span class="comment">/* block output operations */</span></span><br><span class="line">    <span class="keyword">long</span>   ru_msgsnd;        <span class="comment">/* IPC messages sent */</span></span><br><span class="line">    <span class="keyword">long</span>   ru_msgrcv;        <span class="comment">/* IPC messages received */</span></span><br><span class="line">    <span class="keyword">long</span>   ru_nsignals;      <span class="comment">/* signals received */</span></span><br><span class="line">    <span class="keyword">long</span>   ru_nvcsw;         <span class="comment">/* voluntary context switches */</span></span><br><span class="line">    <span class="keyword">long</span>   ru_nivcsw;        <span class="comment">/* involuntary context switches */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中比较重要的三项：</p>
<ol>
<li>timeval ru_utime; /* user CPU time used */        用户态CPU使用时间</li>
<li>timeval ru_stime; /* system CPU time used */      内核态CPU使用时间</li>
<li>ru_maxrss;        /* maximum resident set size */ 最大驻留集</li>
</ol>
<p>还可以shell中使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">man getrusage</span><br></pre></td></tr></table></figure>

<h3 id="如何使用int-status"><a href="#如何使用int-status" class="headerlink" title="如何使用int* status"></a>如何使用int* status</h3><p>如果参数status的值不是NULL，wait就会把子进程退出时的状态取出并存入其中，这指向整数值（int），<br>指出了子进程是正常退出还是被非正常结束的，以及正常结束时的返回值，或被哪一个信号结束的等信息。<br>由于这些信息被存放在<strong>一个整数的不同二进制位</strong>中，所以用常规的方法读取会非常麻烦，<br>于是就设计了一套专门的宏来完成这项工作，下面介绍一下其中最常用的几个。</p>
<p>请注意，下面的宏中的 status 虽然名字一样，这里的参数status并不同于wait中的参数<br>一个是指向整数的指针，而是那个指针所指向的整数，切记不要搞混。</p>
<h3 id="WIFEXITED-int-status"><a href="#WIFEXITED-int-status" class="headerlink" title="WIFEXITED(int status)"></a>WIFEXITED(int status)</h3><p>这个宏用来指出进程是否为正常退出的，如果是，它会返回一个非零值。</p>
<h3 id="WEXITSTATUS-status"><a href="#WEXITSTATUS-status" class="headerlink" title="WEXITSTATUS(status)"></a>WEXITSTATUS(status)</h3><p><strong>当WIFEXITED返回非零值时</strong>，可以用这个宏来提取<strong>子进程的返回值</strong>。<br>如果子进程调用exit(5)退出，WEXITSTATUS(status) 就会返回5；如果子进程调用exit(7)，WEXITSTATUS(status)就会返回7。<br>请注意，如果进程不是正常退出的，也就是 说，WIFEXITED返回0，这个值就毫无意义。</p>
<p>所以二者往往这样配合使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正常退出判断</span></span><br><span class="line"><span class="keyword">if</span>(WIFEXITED(status))&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child exit with %d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="WIFSIGNALED-status"><a href="#WIFSIGNALED-status" class="headerlink" title="WIFSIGNALED(status)"></a>WIFSIGNALED(status)</h3><p>这个宏来指出进程是否遇到未处理的信号而意外退出，如果是，返回非零0.</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p><strong>当 WIFSIGNALED 返回非零值时</strong>，此时可通过WTERMSIG(status)获取使得<strong>进程退出的信号编号</strong></p>
<p>所以二者可以这样配合使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//因为某种信号中断获取状态</span></span><br><span class="line"><span class="keyword">if</span>(WIFSIGNALED(status))&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child killed by %d\n&quot;</span>, WTERMSIG(status));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>参考链接<br><a href="https://man7.org/linux/man-pages/man2/wait4.2.html">wait4(2) — Linux manual page</a></li>
</ul>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
        <tag>进程</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux文件描述符的使用与实现</title>
    <url>/2021/11/20/Linux%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="什么是文件描述符"><a href="#什么是文件描述符" class="headerlink" title="什么是文件描述符"></a>什么是文件描述符</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计程序设计)中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p>
<p>每个Unix进程（除了可能的守护进程）应均有三个标准的POSIX文件描述符，对应于三个标准流：</p>
<table>
<thead>
<tr>
<th align="center">整数值</th>
<th align="center">名称</th>
<th align="center">符号常量</th>
<th align="center">文件流</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center"><a href="https://zh.wikipedia.org/wiki/Stdin">Standard input</a></td>
<td align="center">STDIN_FILENO</td>
<td align="center">stdin</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center"><a href="https://zh.wikipedia.org/wiki/Stdout">Standard output</a></td>
<td align="center">STDOUT_FILENO</td>
<td align="center">stdout</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><a href="https://zh.wikipedia.org/wiki/Stderr">Standard error</a></td>
<td align="center">STDERR_FILENO</td>
<td align="center">stderr</td>
</tr>
</tbody></table>
<p>文件描述符的优点主要有两个：</p>
<ul>
<li>基于文件描述符的I/O操作兼容POSIX标准。</li>
<li>在UNIX、Linux的系统调用中，大量的系统调用都是依赖于文件描述符。</li>
</ul>
<p>例如，下面的代码就示范了如何基于文件描述符来读取当前目录下的一个指定文件，并把文件内容打印至Console中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> numbytes;</span><br><span class="line">    <span class="keyword">char</span> path[] = <span class="string">&quot;file&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * O_CREAT:如果文件不存在则创建</span></span><br><span class="line"><span class="comment">     * O_RDONLY:以只读模式打开文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    fd = open(path, O_CREAT | O_RDONLY, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0x00</span>, <span class="number">256</span>);</span><br><span class="line">    <span class="keyword">while</span>((numbytes = read(fd, buf, <span class="number">255</span>)) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d bytes read: %s&quot;</span>, numbytes, buf);</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0x00</span>, <span class="number">256</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close (fd);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="与文件描述符相关的操作"><a href="#与文件描述符相关的操作" class="headerlink" title="与文件描述符相关的操作"></a>与文件描述符相关的操作</h2><h3 id="文件描述符的生成"><a href="#文件描述符的生成" class="headerlink" title="文件描述符的生成"></a>文件描述符的生成</h3><ul>
<li>open(), open64(), creat(), creat64()</li>
<li>socket()</li>
<li>socketpair()</li>
<li>pipe()</li>
</ul>
<h3 id="与单一文件描述符相关的操作"><a href="#与单一文件描述符相关的操作" class="headerlink" title="与单一文件描述符相关的操作"></a>与单一文件描述符相关的操作</h3><ul>
<li>read(), write()</li>
<li>recv(), send()</li>
<li>recvmsg(), sendmsg()</li>
<li>sendfile()</li>
<li>lseek(), lseek64()</li>
<li>fstat(), fstat64()</li>
<li>fchmod()</li>
<li>fchown()</li>
</ul>
<h3 id="与复数文件描述符相关的操作"><a href="#与复数文件描述符相关的操作" class="headerlink" title="与复数文件描述符相关的操作"></a>与复数文件描述符相关的操作</h3><ul>
<li>select(), pselect()</li>
<li>poll(),epoll()</li>
</ul>
<h3 id="与文件描述符表相关的操作"><a href="#与文件描述符表相关的操作" class="headerlink" title="与文件描述符表相关的操作"></a>与文件描述符表相关的操作</h3><ul>
<li>close()</li>
<li>dup()</li>
<li>dup2()</li>
<li>fcntl (F_DUPFD)</li>
<li>fcntl (F_GETFD and F_SETFD)</li>
</ul>
<h3 id="改变进程状态的操作"><a href="#改变进程状态的操作" class="headerlink" title="改变进程状态的操作"></a>改变进程状态的操作</h3><ul>
<li>fchdir()</li>
<li>mmap()</li>
</ul>
<h3 id="与文件加锁的操作"><a href="#与文件加锁的操作" class="headerlink" title="与文件加锁的操作"></a>与文件加锁的操作</h3><ul>
<li>flock()</li>
<li>fcntl (F_GETLK, F_SETLK and F_SETLKW)</li>
<li>lockf()</li>
</ul>
<h3 id="与套接字相关的操作"><a href="#与套接字相关的操作" class="headerlink" title="与套接字相关的操作"></a>与套接字相关的操作</h3><ul>
<li>connect()</li>
<li>bind()</li>
<li>listen()</li>
<li>accept()</li>
<li>getsockname()</li>
<li>getpeername()</li>
<li>getsockopt(), setsockopt()</li>
<li>shutdown()</li>
</ul>
<h1 id="文件描述符的实现"><a href="#文件描述符的实现" class="headerlink" title="文件描述符的实现"></a>文件描述符的实现</h1><p><strong>在内核中每一个打开的文件都需要由3种数据结构来进行维护</strong>。</p>
<p> 根据文中内容，这三种数据结构分别为：</p>
<ol>
<li><p>进程级：每个进程对应一张<strong>打开文件描述符表，</strong>这是<strong>进程级</strong>数据结构，也就是每一个进程都各自有这样一个数据结构；</p>
</li>
<li><p>内核级：内核维持一张<strong>打开文件表，文件表由多个文件表项组成，</strong>这是<strong>系统级</strong>数据结构，也就是说这样的数据结构是针对于整个内核而言的，每个进程都可共享的；</p>
</li>
<li><p>系统级：每个打开的文件对应一个<strong>i节点（i-node）</strong>数据结构（Linux下只有i节点没有v节点），由于这是每一个打开的文件与之对应的，因此这也是一个<strong>系统级</strong>数据结构，存在于内核中，非进程所独有。</p>
</li>
</ol>
<p>那么，这三种数据结构到底是什么呢？</p>
<h2 id="文件描述符表"><a href="#文件描述符表" class="headerlink" title="文件描述符表"></a>文件描述符表</h2><p>在Linux中，对于每一个进程，都会分配一个PCB数据结构，它其中包含了该进程的所有信息，而在代码实现上，这个数据结构名为<strong>task_struct</strong>，在linux源码的<strong>include/linux/sched.h</strong>中可以找到其定义，它是一个很庞大的结构体，部分定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">	......</span><br><span class="line">	<span class="comment">/* CPU-specific state of this task */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span> <span class="title">thread</span>;</span></span><br><span class="line">	<span class="comment">/* filesystem information */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> *<span class="title">fs</span>;</span></span><br><span class="line">	<span class="comment">/* open file information */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span>  <span class="comment">// 注意这个</span></span><br><span class="line">	<span class="comment">/* namespaces */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span> *<span class="title">nsproxy</span>;</span></span><br><span class="line">	<span class="comment">/* signal handlers */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">signal</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span> *<span class="title">sighand</span>;</span></span><br><span class="line">	......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p> 在<strong>task_struct</strong>中，有一个成员变量名为<strong>files</strong>，注释中提到这是一个描述打开文件信息的变量，其类型为<strong>struct files_struct *<strong>，那么现在再接着看</strong>files_struct</strong>，在linux源码的<strong>include/linux/fdtable.h</strong>中可以找到其定义，定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">   * read mostly part</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">	<span class="keyword">atomic_t</span> count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> __<span class="title">rcu</span> *<span class="title">fdt</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> <span class="title">fdtab</span>;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">   * written part on a separate cache line in SMP</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> file_lock ____cacheline_aligned_in_smp;</span><br><span class="line">	<span class="keyword">int</span> next_fd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">embedded_fd_set</span> <span class="title">close_on_exec_init</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">embedded_fd_set</span> <span class="title">open_fds_init</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> __<span class="title">rcu</span> * <span class="title">fd_array</span>[<span class="title">NR_OPEN_DEFAULT</span>];</span></span><br><span class="line">	<span class="comment">//进程级打开文件描述符表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>而这里所要找到的<strong>打开文件描述符表</strong>，实际上就是files_struct 中的成员<strong>struct file * fd_array[NR_OPEN_DEFAULT]<strong>它是一个指针数组，数组每一个元素都是一个指向</strong>file</strong>类型的指针，可想而知，这些指针都会指向一个打开的文件，并且file这一数据结构就是用来描述一个打开的文件的，<strong>而我们所说的文件描述符，实际上就是这个指针数组的索引。</strong>这也是为什么文件描述符是非负整数。</p>
<h2 id="文件表项"><a href="#文件表项" class="headerlink" title="文件表项"></a>文件表项</h2><p>前面说了，每一个打开文件实际上就是用一个<strong>file</strong>结构体进行描述的，在linux源码的<strong>include/linux/fs.h</strong>中可以找到其定义，定义如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * fu_list becomes invalid after file_free is called and queued via</span></span><br><span class="line"><span class="comment">	 * fu_rcuhead for RCU freeing</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">fu_list</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> 	<span class="title">fu_rcuhead</span>;</span></span><br><span class="line">	&#125;f_u;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">path</span>		<span class="title">f_path</span>;</span></span><br><span class="line">	<span class="comment">//文件路径，包括目录项以及i-node</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> f_dentry	f_path.dentry</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> f_vfsmnt	f_path.mnt</span></span><br><span class="line">		<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>	*<span class="title">f_op</span>;</span></span><br><span class="line">	<span class="keyword">spinlock_t</span>		f_lock;</span><br><span class="line">	<span class="comment">/* f_ep_links, f_flags, no IRQ */</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">		<span class="keyword">int</span>			f_sb_list_cpu;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		<span class="keyword">atomic_long_t</span>		f_count;</span><br><span class="line">	<span class="comment">//文件打开次数</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> 		f_flags;</span><br><span class="line">	<span class="comment">//文件打开时的flag，对应于open函数的flag参数</span></span><br><span class="line">	<span class="keyword">fmode_t</span>			f_mode;</span><br><span class="line">	<span class="comment">//文件打开时的mode，对应于open函数的mode参数</span></span><br><span class="line">	<span class="keyword">loff_t</span>			f_pos;</span><br><span class="line">	<span class="comment">//文件偏移位置</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fown_struct</span>	<span class="title">f_owner</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span>	*<span class="title">f_cred</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span>	<span class="title">f_ra</span>;</span></span><br><span class="line">	u64			f_version;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">		<span class="keyword">void</span>			*f_security;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* needed for tty driver, and maybe others */</span></span><br><span class="line">	<span class="keyword">void</span>			*private_data;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_EPOLL</span></span><br><span class="line">	<span class="comment">/* Used by fs/eventpoll.c to link all the hooks to this file */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">f_ep_links</span>;</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span> </span></span><br><span class="line">	<span class="comment">/* #ifdef CONFIG_EPOLL */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>	*<span class="title">f_mapping</span>;</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_WRITECOUNT</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> f_mnt_write_state;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<p>在file结构体中，不得不再说一下它的f_path成员，这是一个<strong>struct path</strong>类型的变量，该类型定义于<strong>include/linux/path.h：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">path</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">mnt</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p> 这里的dentry实际上就指向文件所在的<strong>目录项</strong>了，<strong>struct dentry</strong>的类型定义于<strong>include/linux/dcache.h：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> &#123;</span></span><br><span class="line">	<span class="comment">/* RCU lookup touched fields */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> d_flags;</span><br><span class="line">	<span class="comment">/* protected by d_lock */</span></span><br><span class="line">	<span class="keyword">seqcount_t</span> d_seq;</span><br><span class="line">	<span class="comment">/* per dentry seqlock */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_bl_node</span> <span class="title">d_hash</span>;</span></span><br><span class="line">	<span class="comment">/* lookup hash list */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">d_parent</span>;</span></span><br><span class="line">	<span class="comment">/* parent directory */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">d_name</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">d_inode</span>;</span> <span class="comment">// 注意这个</span></span><br><span class="line">	<span class="comment">/* Where the name belongs to - NULL is</span></span><br><span class="line"><span class="comment">					 * negative */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> d_iname[DNAME_INLINE_LEN];</span><br><span class="line">	<span class="comment">/* small names */</span></span><br><span class="line">	<span class="comment">/* Ref lookup also touches following */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> d_count;</span><br><span class="line">	<span class="comment">/* protected by d_lock */</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> d_lock;</span><br><span class="line">	<span class="comment">/* per dentry lock */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dentry_operations</span> *<span class="title">d_op</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">d_sb</span>;</span></span><br><span class="line">	<span class="comment">/* The root of the dentry tree */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> d_time;</span><br><span class="line">	<span class="comment">/* used by d_revalidate */</span></span><br><span class="line">	<span class="keyword">void</span> *d_fsdata;</span><br><span class="line">	<span class="comment">/* fs-specific data */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_lru</span>;</span></span><br><span class="line">	<span class="comment">/* LRU list */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * d_child and d_rcu can share memory</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_child</span>;</span></span><br><span class="line">		<span class="comment">/* child of parent list */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">d_rcu</span>;</span></span><br><span class="line">	&#125;d_u;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_subdirs</span>;</span></span><br><span class="line">	<span class="comment">/* our children */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_alias</span>;</span></span><br><span class="line">	<span class="comment">/* inode alias list */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在dentry结构体中，描述了根结点、父节点等等信息，尤其还要注意的是<strong>struct inode *d_inode</strong>这一变量，它则是指向了一个<strong>i-node</strong>结点。</p>
<p>再回到file结构体中，有一个<strong>struct file_operations *f_op</strong>变量，其类型定义在<strong>include/linux/fs.h</strong>中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="keyword">loff_t</span> (*llseek) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*read) (struct file *, <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*write) (struct file *, <span class="keyword">const</span> <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*aio_read) (struct kiocb *, <span class="keyword">const</span> struct iovec *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">loff_t</span>);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*aio_write) (struct kiocb *, <span class="keyword">const</span> struct iovec *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">loff_t</span>);</span><br><span class="line">	<span class="keyword">int</span> (*readdir) (struct file *, <span class="keyword">void</span> *, <span class="keyword">filldir_t</span>);</span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*poll)</span> <span class="params">(struct file *, struct poll_table_struct *)</span></span>;</span><br><span class="line">	<span class="keyword">long</span> (*unlocked_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">	<span class="keyword">long</span> (*compat_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">	<span class="keyword">int</span> (*mmap) (struct file *, struct vm_area_struct *);</span><br><span class="line">	<span class="keyword">int</span> (*open) (struct inode *, struct file *);</span><br><span class="line">	<span class="keyword">int</span> (*flush) (struct file *, <span class="keyword">fl_owner_t</span> id);</span><br><span class="line">	<span class="keyword">int</span> (*release) (struct inode *, struct file *);</span><br><span class="line">	<span class="keyword">int</span> (*fsync) (struct file *, <span class="keyword">int</span> datasync);</span><br><span class="line">	<span class="keyword">int</span> (*aio_fsync) (struct kiocb *, <span class="keyword">int</span> datasync);</span><br><span class="line">	<span class="keyword">int</span> (*fasync) (<span class="keyword">int</span>, struct file *, <span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">int</span> (*lock) (struct file *, <span class="keyword">int</span>, struct file_lock *);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*sendpage) (struct file *, struct page *, <span class="keyword">int</span>, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *, <span class="keyword">int</span>);</span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(struct file *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> (*check_flags)(<span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">int</span> (*flock) (struct file *, <span class="keyword">int</span>, struct file_lock *);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*splice_write)(struct pipe_inode_info *, struct file *, <span class="keyword">loff_t</span> *, <span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*splice_read)(struct file *, <span class="keyword">loff_t</span> *, struct pipe_inode_info *, <span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">int</span> (*setlease)(struct file *, <span class="keyword">long</span>, struct file_lock **);</span><br><span class="line">	<span class="keyword">long</span> (*fallocate)(struct file *file, <span class="keyword">int</span> mode, <span class="keyword">loff_t</span> offset,</span><br><span class="line">				  <span class="keyword">loff_t</span> len);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>可见，在该成员中包含了所有文件操作相关的函数指针。</p>
<p>每一个打开的文件都对应于一个file结构体，在该结构体中，f_flags描述了文件标志，f_pos描述了文件的偏移位置，而在f_path中有含有一个指向一个inode结点的指针。</p>
<p>因此可以知道，文件表项的数据结构就是file结构体，而在实际上内核中也并不存在这样一张文件表，只是每个打开的文件都对应一个file结构体，也就是一个文件表项，**打开文件描述符表struct file fd_array[NR_OPEN_DEFAULT]**数组中的每一项都会指向这样一个文件表项，如下图所示：</p>
<img src="fd2.png" style="zoom:80%;" />



<h2 id="Inode"><a href="#Inode" class="headerlink" title="Inode"></a>Inode</h2><p>第三种数据结构就是inode节点，在<strong>include/linux/fs.h</strong>中找到其定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">	<span class="comment">/* RCU path lookup touches following: */</span></span><br><span class="line">	<span class="keyword">umode_t</span>			i_mode;</span><br><span class="line">	<span class="comment">//权限</span></span><br><span class="line">	<span class="keyword">uid_t</span>			i_uid;</span><br><span class="line">	<span class="comment">//用户id</span></span><br><span class="line">	<span class="keyword">gid_t</span>			i_gid;</span><br><span class="line">	<span class="comment">//组id</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span>	*<span class="title">i_op</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span>	*<span class="title">i_sb</span>;</span></span><br><span class="line">	<span class="keyword">spinlock_t</span>		i_lock;</span><br><span class="line">	<span class="comment">/* i_blocks, i_bytes, maybe i_size */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		i_flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">i_mutex</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		i_state;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		dirtied_when;</span><br><span class="line">	<span class="comment">/* jiffies of first dirtying */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>	<span class="title">i_hash</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">i_wb_list</span>;</span></span><br><span class="line">	<span class="comment">/* backing dev IO list */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">i_lru</span>;</span></span><br><span class="line">	<span class="comment">/* inode LRU list */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">i_sb_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">i_dentry</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>		<span class="title">i_rcu</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		i_ino;</span><br><span class="line">	<span class="comment">//inode节点号</span></span><br><span class="line">	<span class="keyword">atomic_t</span>		i_count;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		i_nlink;</span><br><span class="line">	<span class="keyword">dev_t</span>			i_rdev;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		i_blkbits;</span><br><span class="line">	u64			i_version;</span><br><span class="line">	<span class="keyword">loff_t</span>			i_size;</span><br><span class="line">	<span class="comment">//文件大小</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">ifdef</span> __NEED_I_SIZE_ORDERED</span></span><br><span class="line">		<span class="keyword">seqcount_t</span>		i_size_seqcount;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>		<span class="title">i_atime</span>;</span></span><br><span class="line">	<span class="comment">//最后一次访问(access)的时间</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>		<span class="title">i_mtime</span>;</span></span><br><span class="line">	<span class="comment">//最后一次修改(modify)的时间</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>		<span class="title">i_ctime</span>;</span></span><br><span class="line">	<span class="comment">//最后一次改变(change)的时间</span></span><br><span class="line">	<span class="keyword">blkcnt_t</span>		i_blocks;</span><br><span class="line">	<span class="comment">//块数</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span>          i_bytes;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span>	<span class="title">i_alloc_sem</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>	*<span class="title">i_fop</span>;</span></span><br><span class="line">	<span class="comment">/* former -&gt;i_op-&gt;default_file_ops */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_lock</span>	*<span class="title">i_flock</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>	*<span class="title">i_mapping</span>;</span></span><br><span class="line">	<span class="comment">//块地址映射</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>	<span class="title">i_data</span>;</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_QUOTA</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">dquot</span>		*<span class="title">i_dquot</span>[<span class="title">MAXQUOTAS</span>];</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">i_devices</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span>	*<span class="title">i_pipe</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">block_device</span>	*<span class="title">i_bdev</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span>		*<span class="title">i_cdev</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line">	__u32			i_generation;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FSNOTIFY</span></span><br><span class="line">		__u32			i_fsnotify_mask;</span><br><span class="line">	<span class="comment">/* all events this inode cares about */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>	<span class="title">i_fsnotify_marks</span>;</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_IMA</span></span><br><span class="line">		<span class="keyword">atomic_t</span>		i_readcount;</span><br><span class="line">	<span class="comment">/* struct files open RO */</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		<span class="keyword">atomic_t</span>		i_writecount;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">		<span class="keyword">void</span>			*i_security;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FS_POSIX_ACL</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">posix_acl</span>	*<span class="title">i_acl</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">posix_acl</span>	*<span class="title">i_default_acl</span>;</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		<span class="keyword">void</span>			*i_private;</span><br><span class="line">	<span class="comment">/* fs or device private pointer */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p> 代码中只注释了一部分，通过inode结构，可以知道<strong>文件数据块的在磁盘上的位置以及文件大小</strong>等信息，这样才能使得<strong>进程能够通过file结构体来找到磁盘上相应文件的位置</strong>来进行文件读写。</p>
<p> 另外补充一点，关于inode结构体中的<strong>struct inode_operations *i_op</strong>成员，其数据结构定义在<strong>include/linux/fs.h</strong>中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> * (*<span class="title">lookup</span>) (<span class="keyword">struct</span> <span class="title">inode</span> *,<span class="keyword">struct</span> <span class="title">dentry</span> *, <span class="keyword">struct</span> <span class="title">nameidata</span> *);</span></span><br><span class="line">	<span class="keyword">void</span> * (*follow_link) (struct dentry *, struct nameidata *);</span><br><span class="line">	<span class="keyword">int</span> (*permission) (struct inode *, <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">int</span> (*check_acl)(struct inode *, <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">int</span> (*readlink) (struct dentry *, <span class="keyword">char</span> __user *,<span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">void</span> (*put_link) (struct dentry *, struct nameidata *, <span class="keyword">void</span> *);</span><br><span class="line">	<span class="keyword">int</span> (*create) (struct inode *,struct dentry *,<span class="keyword">int</span>, struct nameidata *);</span><br><span class="line">	<span class="keyword">int</span> (*link) (struct dentry *,struct inode *,struct dentry *);</span><br><span class="line">	<span class="keyword">int</span> (*unlink) (struct inode *,struct dentry *);</span><br><span class="line">	<span class="keyword">int</span> (*symlink) (struct inode *,struct dentry *,<span class="keyword">const</span> <span class="keyword">char</span> *);</span><br><span class="line">	<span class="keyword">int</span> (*mkdir) (struct inode *,struct dentry *,<span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">int</span> (*rmdir) (struct inode *,struct dentry *);</span><br><span class="line">	<span class="keyword">int</span> (*mknod) (struct inode *,struct dentry *,<span class="keyword">int</span>,<span class="keyword">dev_t</span>);</span><br><span class="line">	<span class="keyword">int</span> (*rename) (struct inode *, struct dentry *,</span><br><span class="line">				struct inode *, struct dentry *);</span><br><span class="line">	<span class="keyword">void</span> (*truncate) (struct inode *);</span><br><span class="line">	<span class="keyword">int</span> (*setattr) (struct dentry *, struct iattr *);</span><br><span class="line">	<span class="keyword">int</span> (*getattr) (struct vfsmount *mnt, struct dentry *, struct kstat *);</span><br><span class="line">	<span class="keyword">int</span> (*setxattr) (struct dentry *, <span class="keyword">const</span> <span class="keyword">char</span> *,<span class="keyword">const</span> <span class="keyword">void</span> *,<span class="keyword">size_t</span>,<span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*getxattr) (struct dentry *, <span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">void</span> *, <span class="keyword">size_t</span>);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*listxattr) (struct dentry *, <span class="keyword">char</span> *, <span class="keyword">size_t</span>);</span><br><span class="line">	<span class="keyword">int</span> (*removexattr) (struct dentry *, <span class="keyword">const</span> <span class="keyword">char</span> *);</span><br><span class="line">	<span class="keyword">void</span> (*truncate_range)(struct inode *, <span class="keyword">loff_t</span>, <span class="keyword">loff_t</span>);</span><br><span class="line">	<span class="keyword">int</span> (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 start,</span><br><span class="line">			      u64 len);</span><br><span class="line">&#125;____cacheline_aligned;</span><br></pre></td></tr></table></figure>

<p> 可见，在该成员变量所指向的数据结构中，包含了许多函数指针，这些函数指针大多针对于目录、文件操作。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 进程、打开文件描述符表、文件表项和i-node结点关系如图所示。（暂时忽略进程中0、1和2号文件描述符分别默认为标准输入、标准输出和标准错误的情况）</p>
<p><img src="/2021/11/20/Linux%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E5%AE%9E%E7%8E%B0/fd1.png"></p>
<p>通过以上分析，我们可以得出以下结论：</p>
<ol>
<li><p>每启动一个进程都会为其分配一个<code>task_struct</code>结构体，在task_struct结构体中含有一个<code>file_struct</code>结构体指针，其所指向的file_struct结构体中，含有一个file的指针数组<code>fd_array</code>,它就是<strong>打开文件描述符表</strong>，其中<strong>每一个元素都指向一个文件表项</strong>，这个<strong>数组的索引就是文件描述符</strong>。此外，file_struct结构体中的next_fd保存的是下一个分配的文件描述符，它会在调用open和close改变，最终使得每次open返回的都是当前可用的<strong>最小文件描述符</strong>；</p>
</li>
<li><p>每次调用open或者create(内部实际上还是调用的open)，都会对新打开的文件分配一个file结构体，并且将打开文件的标志、状态、权限等信息填入这个file结构体中。<strong>这个file结构体也叫文件表项</strong>；</p>
</li>
<li><p><strong>磁盘中的每个文件都对应一个i-node</strong>，<strong>每一个文件表项都会指向一个文件的i-node</strong>，<strong>但是同一文件的i-node可以对应多个文件表项（</strong>当多次调用open打开同一个文件时就会出现这种情况，不管是同一进程多次打开同一文件（如图中A进程的0号和2号文件描述符对应两个文件表项，但是最终指向同一i-node即同一文件），还是不同进程多次打开同一文件（如图中A进程3号文件描述符和B进程的3号文件描述符））；</p>
</li>
<li><p><strong>同一进程下的不同文件描述符是可以指向同一文件表项</strong>，即最终指向同一文件<strong>（如图中A进程的0号文件描述符和1号文件描述符，使用dup函数即可实现）。</strong></p>
</li>
<li><p>子进程在创建时会拷贝父进程的打开文件描述符表，因此<strong>父子进程是共享文件表项</strong>的。而相互独立的不同进程的打开文件描述符表是相互独立的，因此相互独立的多个进程之间的文件描述符可以相同，但是不同进程的文件描述符是不能指向同一文件表项的（<strong>除非这个文件描述符是从同一个祖先进程中继承得来的</strong>），但是这并不妨碍不同进程访问同一文件（如第3点结论）；</p>
</li>
<li><p>指向同一文件表项的不同文件描述符（不同进程相同数值的文件描述符也看做不同）共享文件标志、文件偏移等信息；</p>
</li>
<li><p>每一个文件表项对应的file结构体中的<code>f_count</code>会记录通过该文件表项打开文件的次数，当<code>f_count</code>计数归0时这个文件表项才会被删除，因此，对于指向同一文件表项的两个不同文件描述符（如子进程所继承的父进程的文件描述符，或同一进程中dup的两个文件描述符指向同一个文件表项），即使其中一个文件描述符关闭了，只要仍然有文件描述符指向这个文件表项，那么就依然能通过这个文件表项访问文件，直到所有指向该文件表项的文件描述符都关闭了才不能再进行访问；</p>
</li>
</ol>
<blockquote>
<p>参考链接</p>
<p><a href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6">文件描述符</a></p>
<p><a href="https://www.cnblogs.com/lwyeric/p/13598704.html">Linux中文件描述符的理解</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>File</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux读写文件相关库函数</title>
    <url>/2021/11/20/Linux%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3%E5%BA%93%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="读写文件相关"><a href="#读写文件相关" class="headerlink" title="读写文件相关"></a>读写文件相关</h2><h3 id="write"><a href="#write" class="headerlink" title="write"></a>write</h3><ul>
<li><p>头文件:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>函数说明:<br>write系统调用，是把缓存区buf中的前nbytes字节写入到与文件描述符有关的文件中。</p>
</li>
<li><p>函数定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参数分别为 文件描述符、缓冲区、</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> flides, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>返回值<br>write系统调用返回的是实际写入到文件中的字节数。</p>
</li>
</ul>
<h3 id="read"><a href="#read" class="headerlink" title="read"></a>read</h3><ul>
<li><p>头文件:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>函数说明:<br>read系统调用，是从与文件描述符flides相关联的文件中读取前nbytes字节的内容，并且写入到数据区buf中。</p>
</li>
<li><p>函数定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> flides, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>返回值<br>read系统调用返回的是实际读入的字节数。</p>
</li>
</ul>
<h3 id="open"><a href="#open" class="headerlink" title="open"></a>open</h3><ul>
<li><p>头文件:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>函数说明:</p>
</li>
</ul>
<ul>
<li>函数定义<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> *path, <span class="keyword">int</span> oflags)</span></span>; <span class="comment">//1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> *path, <span class="keyword">int</span> oflags, <span class="keyword">mode_t</span> mode)</span></span>; <span class="comment">//2</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>参数说明：<br>其中，oflags是由必需文件访问模式和可选模式一起构成的(通过按位或“|”)：<br>必需部分：</p>
<ul>
<li>O_RDONLY———-以只读方式打开</li>
<li>O_WRONLY———以只写方式打开</li>
<li>O_RDWR————以读写方式打开<br>可选部分：</li>
<li>O_CREAT————按照参数mode给出的访问模式创建文件</li>
<li>O_EXCL————–与O_CREAT一起使用，确保创建出文件，避免两个程序同时创建同一个文件，如文件存在则open调用失败 </li>
<li>O_APPEND———-把写入数据追加在文件的末尾</li>
<li>O_TRUNC———–把文件长度设置为0，丢弃原有内容</li>
</ul>
<p>在第一种调用方式上，加上了第三个参数mode，<strong>主要是搭配O_CREAT使用</strong>，同样地，这个参数规定了属主、同组和其他人对文件的文件操作权限。</p>
<ul>
<li>文件属主<ul>
<li>S_IRUSR———-读权限 </li>
<li>S_IWUSR———写权限</li>
<li>S_IXUSR———-执行权限 </li>
</ul>
</li>
<li>文件所属组  <ul>
<li>S_IRGRP———-读权限 </li>
<li>S_IWGRP———写权限 </li>
<li>S_IXGRP———-执行权限</li>
</ul>
</li>
<li>其他人  <ul>
<li>S_IROTH———-读权限 </li>
<li>S_IWOTH———写权限</li>
<li>S_IXOTH———-执行权限 </li>
</ul>
</li>
</ul>
<p>另外，也可以用数字设定法：<br>0 : 无权限；<br>1 : 只执行；<br>2 : 只写；<br>4 : 只读。</p>
<p>这种权限设计实际上就是linux文件权限的设计。</p>
<ul>
<li>返回值<br>open系统调用成功返回一个新的文件描述符，失败返回-1。</li>
</ul>
<h3 id="close"><a href="#close" class="headerlink" title="close"></a>close</h3><ul>
<li><p>函数定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> flides)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>函数说明:<br>终止文件描述符flides与其对应的文件间的联系，文件描述符被释放，可重新使用。<br>使用完文件描述符之后，要记得释放！</p>
</li>
</ul>
<h3 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h3><ul>
<li><p>头文件:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>函数说明:<br>C 库函数,使用给定的模式 mode 打开 filename 所指向的文件。</p>
</li>
<li><p>函数定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span></span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>“r”</th>
<th>打开一个用于读取的文件。该文件必须存在。</th>
</tr>
</thead>
<tbody><tr>
<td>“w”</td>
<td>创建一个用于写入的空文件。如果文件名称与已存在的文件相同，则会删除已有文件的内容，文件被视为一个新的空文件。</td>
</tr>
<tr>
<td>“a”</td>
<td>追加到一个文件。写操作向文件末尾追加数据。如果文件不存在，则创建文件。</td>
</tr>
<tr>
<td>“r+”</td>
<td>打开一个用于更新的文件，可读取也可写入。该文件必须存在。</td>
</tr>
<tr>
<td>“w+”</td>
<td>创建一个用于读写的空文件。</td>
</tr>
<tr>
<td>“a+”</td>
<td>打开一个用于读取和追加的文件。</td>
</tr>
</tbody></table>
</li>
<li><p>返回值<br>该函数返回一个 FILE 指针。否则返回 NULL，且设置全局变量 errno 来标识错误。</p>
</li>
</ul>
<h3 id="fclose"><a href="#fclose" class="headerlink" title="fclose"></a>fclose</h3><ul>
<li><p>头文件:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>函数说明:<br>C 库函数 int fclose(FILE *stream) 关闭流 stream, 并且刷新所有的缓冲区。</p>
</li>
<li><p>函数定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// stream -- 这是指向 FILE 对象的指针，该 FILE 对象指定了要被关闭的流。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE *stream)</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>返回值<br>如果流成功关闭，则该方法返回零。如果失败，则返回 EOF。</p>
</li>
</ul>
<h3 id="fprintf"><a href="#fprintf" class="headerlink" title="fprintf"></a>fprintf</h3><ul>
<li><p>头文件:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>函数说明:<br>C 库函数, 发送格式化输出到流 stream 中。</p>
</li>
<li><p>函数定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>返回值<br>如果成功，则返回写入的字符总数，否则返回一个负数。</p>
</li>
</ul>
<h3 id="flock"><a href="#flock" class="headerlink" title="flock"></a>flock</h3><ul>
<li><p>头文件 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/file.h&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>函数说明 flock()会依参数operation所指定的方式对参数fd所指的文件做各种锁定或解除锁定的动作。<br>此函数只能锁定整个文件，无法锁定文件的某一区域。</p>
</li>
<li><p>函数定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fd 文件描述符、 锁定operation</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">flock</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">int</span> operation)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>参数 operation 有下列四种情况:</p>
<ul>
<li>LOCK_SH 建立共享锁定。多个进程可同时对同一个文件作共享锁定。</li>
<li>LOCK_EX 建立互斥锁定。一个文件同时只有一个互斥锁定。</li>
<li>LOCK_UN 解除文件锁定状态。</li>
<li>LOCK_NB 无法建立锁定时，此操作可不被阻断，马上返回进程。(通常与LOCK_SH或LOCK_EX做OR组合)</li>
</ul>
<ul>
<li>返回值<br>返回0表示成功，若有错误则返回-1，错误代码存于errno。</li>
</ul>
<h3 id="snprintf"><a href="#snprintf" class="headerlink" title="snprintf"></a>snprintf</h3><ul>
<li><p>头文件:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>函数说明:<br>C 库函数，将可变参数(…)按照 format 格式化成字符串，并将字符串复制到 str 中，size 为要写入的字符的最大数目，超过 size 会被截断。</p>
</li>
<li><p>函数定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snprintf</span> <span class="params">(<span class="keyword">char</span> * str, <span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="keyword">char</span> * format, ... )</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>str – 目标字符串。</li>
<li>size – 拷贝字节数(Bytes)。</li>
<li>format – 格式化成字符串。</li>
<li>… – 可变参数。</li>
</ul>
</li>
<li><p>返回值</p>
<ul>
<li>如果格式化后的字符串长度小于等于 size，则会把字符串全部复制到 str 中，并给其后添加一个字符串结束符 \0。<br>返回的实际写入的长度。</li>
<li>如果格式化后的字符串长度大于 size，超过 size 的部分会被截断，只将其中的 (size-1) 个字符复制到 str 中，并给其后添加一个字符串结束符 \0。<br>返回值为欲写入的字符串长度。</li>
</ul>
</li>
</ul>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><h3 id="dup"><a href="#dup" class="headerlink" title="dup"></a>dup</h3><ul>
<li><p>头文件:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>函数说明:<br>dup用来复制参数oldfd所指的文件描述符。<br>返回的新文件描述符和参数oldfd指向同一个文件，这<strong>两个描述符共享同一个数据结构，共享所有的锁定，读写指针和各项标志位</strong>。</p>
</li>
</ul>
<ul>
<li><p>函数定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> oldfd)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>返回值<br>当复制成功是，返回最小的尚未被使用过的文件描述符;<br>若有错误则返回-1。<br>错误代码存入errno中。</p>
</li>
</ul>
<h3 id="dup2"><a href="#dup2" class="headerlink" title="dup2"></a>dup2</h3><ul>
<li><p>头文件:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>函数说明:<br>dup2与dup区别是dup2可以用参数newfd指定新文件描述符的数值。<br>若参数newfd已经被程序使用，则系统就会将newfd所指的文件关闭；<br>若newfd等于oldfd，则返回newfd,而不关闭newfd所指的文件。<br>dup2所复制的文件描述符与原来的文件描述符共享各种文件状态。共享所有的锁定，读写位置和各项权限或flags等.<br>在shell的重定向功能中，(输入重定向”&lt;”和输出重定向”&gt;”)就是通过调用dup或dup2函数对标准输入和标准输出的操作来实现的。</p>
</li>
<li><p>函数定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">int</span> newfd)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>返回值<br>若dup2调用成功则返回新的文件描述符，出错则返回-1。</p>
</li>
</ul>
<ul>
<li>举例：<br>如何使用dup2实现标准输出到文件的重定向？<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldfd;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="string">&quot;This is a test!!!!\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ((oldfd = open(<span class="string">&quot;/Users/jisongyang/CLionProjects/test_syscalls_sandbox/redirect/mine.txt&quot;</span>, O_RDWR | O_CREAT,</span><br><span class="line">                      <span class="number">0644</span>)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fd = dup2(oldfd, STDOUT_FILENO);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dup2 error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fd:%d  STDOUT_FILENO:%d\n&quot;</span>, fd, STDOUT_FILENO);</span><br><span class="line">    &#125;</span><br><span class="line">    t = (<span class="keyword">int</span>) <span class="built_in">strlen</span>(buf);</span><br><span class="line">    <span class="keyword">if</span> (write(fileno(<span class="built_in">stdout</span>), buf, t) != t)<span class="comment">//本应该写入到stdout的信息，但是标准输出已经重定向到目标文件中，故向标准输出写的数据将会写到目标文件中。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fflush(<span class="built_in">stdout</span>); <span class="comment">// printf 是带缓冲的函数，不加这一行代码，printf 的内容不会写到文件里</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>最重要的一行代码：<code>dup2(oldfd, STDOUT_FILENO)</code></p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
        <tag>File</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux时间相关库函数</title>
    <url>/2021/11/20/Linux%E6%97%B6%E9%97%B4%E7%9B%B8%E5%85%B3%E5%BA%93%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="时间相关"><a href="#时间相关" class="headerlink" title="时间相关"></a>时间相关</h2><h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3><ul>
<li>头文件:<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li>函数说明:<br>C 库函数: 返回自纪元 Epoch（1970-01-01 00:00:00 UTC）起经过的时间，以秒为单位。<br>如果 seconds 不为空，则返回值也存储在变量 seconds 中。</li>
<li>函数定义<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">time_t</span> <span class="title">time</span><span class="params">(<span class="keyword">time_t</span> *seconds)</span></span></span><br></pre></td></tr></table></figure></li>
<li>返回值<br>以 time_t 对象返回当前日历时间。</li>
</ul>
<h3 id="localtime"><a href="#localtime" class="headerlink" title="localtime"></a>localtime</h3><ul>
<li><p>头文件:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>函数说明:<br>C 库函数  使用 timer 的值来填充 tm 结构。<br>timer 的值被分解为 tm 结构，并用本地时区表示。</p>
</li>
<li><p>函数定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct tm *<span class="title">localtime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span> *timer)</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>返回值<br>该函数返回指向 tm 结构的指针，该结构带有被填充的时间信息。下面是 tm 结构的细节:</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> tm_sec;         <span class="comment">/* 秒，范围从 0 到 59                */</span></span><br><span class="line"><span class="keyword">int</span> tm_min;         <span class="comment">/* 分，范围从 0 到 59                */</span></span><br><span class="line"><span class="keyword">int</span> tm_hour;        <span class="comment">/* 小时，范围从 0 到 23                */</span></span><br><span class="line"><span class="keyword">int</span> tm_mday;        <span class="comment">/* 一月中的第几天，范围从 1 到 31                    */</span></span><br><span class="line"><span class="keyword">int</span> tm_mon;         <span class="comment">/* 月份，范围从 0 到 11                */</span></span><br><span class="line"><span class="keyword">int</span> tm_year;        <span class="comment">/* 自 1900 起的年数                */</span></span><br><span class="line"><span class="keyword">int</span> tm_wday;        <span class="comment">/* 一周中的第几天，范围从 0 到 6                */</span></span><br><span class="line"><span class="keyword">int</span> tm_yday;        <span class="comment">/* 一年中的第几天，范围从 0 到 365                    */</span></span><br><span class="line"><span class="keyword">int</span> tm_isdst;       <span class="comment">/* 夏令时                        */</span>    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="strftime"><a href="#strftime" class="headerlink" title="strftime"></a>strftime</h3><ul>
<li><p>头文件:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>函数说明:<br>C 库函数,根据 format 中定义的格式化规则，格式化结构 timeptr 表示的时间，并把它存储在 str 中。</p>
</li>
<li><p>函数定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">strftime</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">size_t</span> maxsize, <span class="keyword">const</span> <span class="keyword">char</span> *format, <span class="keyword">const</span> struct tm *timeptr)</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>str – 这是指向目标数组的指针，用来复制产生的 C 字符串。</li>
<li>maxsize – 这是被复制到 str 的最大字符数。</li>
<li>format – 这是 C 字符串，包含了普通字符和特殊格式说明符的任何组合。这些格式说明符由函数替换为表示 tm 中所指定时间的相对应值。<br>具体格式详见：<br><a href="https://www.runoob.com/cprogramming/c-function-strftime.html">参考链接</a></li>
</ul>
<ul>
<li>返回值<br>如果产生的 C 字符串小于 size 个字符（包括空结束字符），则会返回复制到 str 中的字符总数（不包括空结束字符），否则返回零。</li>
</ul>
<h3 id="gettimeofday"><a href="#gettimeofday" class="headerlink" title="gettimeofday"></a>gettimeofday</h3><ul>
<li>头文件:<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li>函数说明:<br>返回当前距离1970年的秒数和微妙数，后面的tz是时区，一般不用（传 NULL 即可）。</li>
<li>函数定义<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gettimeofday</span><span class="params">(struct timeval *tv, struct timezone *tz)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="clock-gettime"><a href="#clock-gettime" class="headerlink" title="clock_gettime"></a>clock_gettime</h3><ul>
<li><p>头文件:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>函数说明:<br>根据时钟模式，获取多种时间。</p>
</li>
<li><p>函数定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clock_gettime</span><span class="params">(<span class="keyword">clockid_t</span> clock_id, struct timespec * tp )</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>CLOCK_REALTIME       0<br>Systemwide realtime clock. 系统实时时间,随系统实时时间改变而改变。<br>即从UTC1970-1-1 0:0:0开始计时,中间时刻如果系统时间被用户该成其他,则对应的时间相应改变</p>
</li>
<li><p>CLOCK_MONOTONIC     1<br>Represents monotonic time. Cannot be set. 从系统启动这一刻起开始计时,不受系统时间被用户改变的影响<br>用的是相对时间，它的时间是通过jiffies值来计算的。该时钟不受系统时钟源的影响，只受jiffies值的影响。<br>也就是说它获得的时间戳是单调的。</p>
</li>
<li><p>CLOCK_PROCESS_CPUTIME_ID    2<br>High resolution per-process timer. 本进程到当前代码系统CPU花费的时间</p>
</li>
<li><p>CLOCK_THREAD_CPUTIME_ID      3<br>Thread-specific timer. 本线程到当前代码系统CPU花费的时间</p>
</li>
<li><p>CLOCK_REALTIME_HR                4<br>High resolution version of CLOCK_REALTIME. 0<br>CLOCK_REALTIME 的 高精度版本</p>
</li>
<li><p>CLOCK_MONOTONIC_HR            5<br>High resolution version of CLOCK_MONOTONIC.<br>CLOCK_MONOTONIC 的高精度版本</p>
</li>
</ul>
<ul>
<li>返回值<br>时间结构<code>struct timespec</code></li>
<li>示例代码<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;gettimeofday : %ld, %d\n&quot;</span>, tv.tv_sec,tv.tv_usec);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">ts</span>;</span></span><br><span class="line">    clock_gettime(CLOCK_REALTIME, &amp;ts);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CLOCK_REALTIME: %ld, %ld\n&quot;</span>, ts.tv_sec, ts.tv_nsec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印出来的时间跟 cat /proc/uptime 第一个参数一样</span></span><br><span class="line">    clock_gettime(CLOCK_MONOTONIC, &amp;ts);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CLOCK_MONOTONIC: %ld, %ld\n&quot;</span>, ts.tv_sec, ts.tv_nsec);</span><br><span class="line"></span><br><span class="line">    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &amp;ts);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CLOCK_PROCESS_CPUTIME_ID: %ld, %ld\n&quot;</span>, ts.tv_sec, ts.tv_nsec);</span><br><span class="line"></span><br><span class="line">    clock_gettime(CLOCK_THREAD_CPUTIME_ID, &amp;ts);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CLOCK_THREAD_CPUTIME_ID: %ld, %ld\n&quot;</span>, ts.tv_sec, ts.tv_nsec);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n%ld\n&quot;</span>, time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>值得一提的是，本项目使用的计时工具不能使用 time 以及 gettimeofday，否则有小概率发生”时间回溯现象”，<br>具体可以参考 <a href="https://song-yang-ji.blog.csdn.net/article/details/115837363">Linux的timedatectl —— 关闭或开启时间同步</a>.<br>必须使用 <code>clock_gettime(CLOCK_MONOTONIC, *timespec);</code> 才可以先后两次拿到的时间戳是递增的。</p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux进程调度那些事</title>
    <url>/2021/10/17/Linux%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Linux进程调度的顶层设计"><a href="#Linux进程调度的顶层设计" class="headerlink" title="Linux进程调度的顶层设计"></a>Linux进程调度的顶层设计</h1><p>进程的调度有多种算法。常见的有：</p>
<ul>
<li>先来先服务（FIFO）</li>
<li>最短作业优先调度（Shortest-Job-First SJF）</li>
<li>优先级调度（Priority-Scheduling）</li>
<li>轮转调度（Round-Robin RR）</li>
</ul>
<p>上述的调度算法在一般的操作系统教科书中都有讲解，不再赘述。</p>
<p>如何合理组织调度算法和调度类呢？</p>
<p>Linux 的进程调度器是以模块化的方式来提供的，这种模块化的结构称之为<strong>调度器类</strong></p>
<h2 id="调度类与调度策略-Scheduling-classes-and-policies"><a href="#调度类与调度策略-Scheduling-classes-and-policies" class="headerlink" title="调度类与调度策略 (Scheduling classes and policies)"></a>调度类与调度策略 (Scheduling classes and policies)</h2><p><strong>每一个调度器类都有一个优先级别，调度器会依次从最高的优先级别的调度器类中选择一个进程去执行。</strong></p>
<p><strong>不同优先级的调度器类中的进程的调度互不干扰，依次属于不同的调度梯队。</strong></p>
<p>进程调度的入口是函数<code>schedule()</code>,定义在<code>kernel/sched.c</code>中，其中它有一个关键的函数<code>pick_next_task()</code></p>
<p>也就是挑选下一个可以执行的进程（task）。</p>
<p>伪代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pick_next_task &#123;</span><br><span class="line">   scheduling_class = sched_class_highest; <span class="comment">// 这是用链表组织起来的 调度器类，优先级别从高到低</span></span><br><span class="line">   <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">       p = scheduling_class-&gt;pick_next_task; <span class="comment">// 从当前最高级别的调度器类中选择一个任务执行，</span></span><br><span class="line">       <span class="keyword">if</span>(p) &#123; <span class="comment">// 如果不为空，直接返回</span></span><br><span class="line">           <span class="keyword">return</span> p;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 如果为空，说明此级别的调度器类已经没有可执行的任务了，那就去看次优先的调度器类</span></span><br><span class="line">       scheduling_class = scheduling_class-&gt;next;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Linux kernel每当需要挑选一个新的task在某个local CPU上运行的时候，就会调用schedule()函数，进而调到pick_next_task()来找到合适的next task。pick_next_task()会利用for_each_class()宏来遍历调度类别链表，先找到有task想要运行的最高优先级的调度类别。等找到task之后，就会返回给函数调用者，让这个task在local CPU上运行。在Idle class里面总是会有一个task的，所以如果没有任何其他task要运行了，就直接执行Idle class里的这个task即可。</p>
</blockquote>
<p><strong>linux实现了很多种”scheduling class”（调度类别），每个class都可以包含一些调度策略。</strong></p>
<p>调度类以及其拥有的调度策略如下，优先级别从低到高：</p>
<ol>
<li><p><strong>Stop</strong> schedulding class</p>
<ul>
<li>无实现的调度策略</li>
</ul>
</li>
<li><p><strong>Deadline</strong> scheduling class</p>
<ul>
<li>SCHED_DEADLINE</li>
</ul>
</li>
<li><p><strong>Realtime</strong> scheduling class</p>
<ul>
<li>SCHED_FIFO</li>
<li>SCHED_RR</li>
</ul>
</li>
<li><p><strong>Completely fair</strong> scheduling class</p>
<ul>
<li>SCHED_NORMAL</li>
<li>SCHEDULE_BATCH</li>
<li>SCHED_IDLE</li>
</ul>
</li>
<li><p><strong>Idle</strong> scheduling class</p>
<ul>
<li>无实现的调度策略</li>
</ul>
</li>
</ol>
<p>下面做一点详细讲解。</p>
<ul>
<li><p><strong>Stop</strong> schedulding class是一个特殊的类别，只在kernel内部使用。其实并没有实现任何针对它的调度策略，也不会有任何用户进程采用这种调度类别。Stop class其实是用作一种强制CPU把手头其他任何工作都停下来从而执行某种特殊任务的机制。因为这是最高优先级的class，因此可以抢占任何其他类别，却不会被任何其他任务抢占。一般是一个CPU想要把另一个CPU停下来执行某些特定功能的时候使用，因此只有SMP系统里才有。Stop class会创建一个per-CPU的内核线程（kthread），名为migration/N，这里N就是CPU编号。这个类别主要用在kernel的task migration, CPU hotplug, RCU, ftrace, clock event等场景。</p>
</li>
<li><p><strong>Deadline</strong> scheduling class只制定了唯一一条调度策略，名为SCHED_DEADLINE，它用在系统里最高优先级的用户进程上。主要是针对那些有明确截止时间的任务，例如视频编码、解码任务。在这种调度策略之下，截止时间最近的任务拥有最高优先级。可以使用sched_setattr()系统调用来把某个进程设置为SCHED_DEADLINE调度策略，同时需要传递三个参数进去：运行时间，截止时间，周期。</p>
</li>
<li><p><strong>Realtime (简称RT) scheduling class</strong>，<strong>主要用在一些耗时很短、对延迟很敏感的task之上</strong>，例如IRQ thread。这是一个拥有固定优先级的类别，高优先级的task都会在低优先级的task之前调度。这个类别里实现了两种调度策略：SCHED_FIFO和SCHED_RR。SCHED_FIFO策略会让一个task持续运行直到它放弃占用CPU，例如它block在某个资源上，或者完成了执行。而SCHED_RR（round robin）策略则会对task持续执行的一个时间片限制最大值，如果task持续占用CPU超过这个时长，仍然没有block住（也就是仍然期望继续占用CPU），调度器就会把它放到拥有相同优先级的round-robin队列的尾部，并换一个task进来执行。这些采用实时策略的task可以使用1（最低）到99（最高）的优先级。</p>
</li>
<li><p><strong>CFS</strong> （completely fair scheduling）class则<strong>包含了绝大多数的用户进程</strong>。CFS实现了三类调度策略：SCHED_NORMAL，SCHEDULE_BATCH，SCHED_IDLE。采用这三者之中任意一种策略的话，进程就只有在没有任何deadline和realtime class的进程在等待执行的情况下才有机会被调度到（当然缺省来说调度器其实保留了5%的CPU时间专用于CFS task）。scheduler会跟踪各个task的vruntime (virtual runtime)，包括那些runnable和blocked状态下的task。一个task的vrtuntime越小，它就越应该优先占用处理器的时间。相应地，CFS会把这些vruntime很低的进程向调度队列的前端移动。<br><strong>这也是本篇文章的重点。</strong></p>
<p><strong>SCHED_NORMAL调度策略（在user space的名字叫做SCHED_OTHER）是用在Linux环境里运行的绝大多数task上的</strong>，例如shell。SCHED_BATCH调度策略则主要用在那些非交互式的任务所需要的批量处理上面，通常这些任务执行中需要一段时间不被打断，因此通常都会在完成所有SCHED_NORMAL工作之后再进行调度切换。SCHED_IDLE调度策略则专用于系统里的低优先级task，他们仅在系统里没有什么需要运行的时候才会执行。尽管实际上说哪怕有其他一些SCHED_NORMAL task，其实SCHED_IDLE task还是会分到一些时间运行的（对于一个nice值为0的task来说大概会有1.4%的时间）。这个调度策略目前用到的很少，有人在试着改进它的工作方式。</p>
</li>
<li><p><strong>Idle</strong> scheduling class（不要跟SCHED_IDLE的调度策略弄混了）。这是最低优先级的调度类别。就跟Stop class类似，Idle class其实不会用在任何用户进程之上，因此并没有实现什么调度策略。它其实仅仅是用在名为swapper/N（N是CPU序号）的一系列per-CPU kthread上。这些kthreads也被称为”idle thread”，用户空间是看不到的。这些线程负责让系统更加省电，主要是通过在没什么事情要做的时候把CPU放到一些deep idle状态来做到的。</p>
</li>
</ul>
<p>在kernel代码里面，scheduling class是用struct sched_class来代表的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> &#123;</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="keyword">void</span> (*enqueue_task) (struct rq *rq, struct task_struct *p, <span class="keyword">int</span> flags);</span><br><span class="line"><span class="keyword">void</span> (*dequeue_task) (struct rq *rq, struct task_struct *p, <span class="keyword">int</span> flags);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *(*<span class="title">pick_next_task</span>) (<span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>, <span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">prev</span>, </span></span><br><span class="line"><span class="class">		    <span class="keyword">struct</span> <span class="title">rq_flags</span> *<span class="title">rf</span>);</span></span><br><span class="line"><span class="comment">/* many fields omitted */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个结构里主要放了一些指向class相关实现的函数指针（回调函数），供scheduler core调用，从而能让scheduler核心代码不用包含任何class相关的代码。这些调度类别放在一个按照优先级排序的单项链表里面，第一项是Stop scheduling class（最高优先级），最后一项是Idle class（最低优先级）。</p>
<p><img src="/2021/10/17/Linux%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E9%82%A3%E4%BA%9B%E4%BA%8B/scheding_class.png" alt="scheding_class"></p>
<h1 id="CFS（普通进程的调度类）"><a href="#CFS（普通进程的调度类）" class="headerlink" title="CFS（普通进程的调度类）"></a>CFS（普通进程的调度类）</h1><h2 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h2><p>CFS——完全公平调度，关于的详细的解析这里就不展开来讲了，可以参看《Linux Kernel Development》这本书，这里只调出关于它的一些设计的关键之处，优秀的调度理念来讲。</p>
<p>CFS的出发点基于一个简单的理念：进程调度的效果应该如果系统具备一个理想的完美多任务处理器。在这种系统中，<strong>每个进程都能获得 1/n 的处理器时间</strong>，n 指可运行的进程数。<br>同时，在任何可度量时间内，每个进程都可以得到相同多的运行时间。<br>当然上述的是理想的模型，实现中当然有贴合实际的处理。</p>
<p>CFS的做法是: <strong>允许每个进程运行一段时间，循环轮转，选择运行最少时间（实际上是虚拟的运行时间）的进程</strong>。</p>
<h2 id="关键问题"><a href="#关键问题" class="headerlink" title="关键问题"></a>关键问题</h2><ol>
<li><p><strong>时间片的长度如何分配？</strong><br> <strong>CFS并没有像RR一样固定的分配一个时间片，也不是根据进程的优先级分配长度不一的时间片。而是根据系统当时的负载情况，为每一个任务分配一个比例的CPU处理时间。</strong>具体的，CFS没有使用离散的时间片，而是采用<strong>目标延迟</strong>（target latency），这是每个可执行任务应当运行一次的时间间隔。</p>
<p> <strong>根据目标延迟，按比例分配CPU时间。</strong></p>
<p> 当然，这个目标延迟有一个默认值、最小值，当然随着系统负载的提高，这个目标延迟还可以延长。</p>
</li>
<li><p><strong>优先级如何影响调度？</strong></p>
<p> CFS没有直接分配优先级（对于普通进程而言）。它通过每个任务的<strong>虚拟运行时间（vruntime）</strong>，进而每个任务运行多久，虚拟运行时间和基于<strong>优先级（nice值）</strong>的衰减因子有关。</p>
<p> 进程的优先级是通过对它的nice值（取值范围-20到+19）加上120而得到的。</p>
<p> 进程的优先级主要是用来调整进程的权重（weight，会影响vruntime增加速率）的，进而会影响到进程的vruntime。<strong>nice值越低，优先级就越高</strong>。task的权重因此也会更加高一些，相应的vruntime则会在task执行时增长得更加缓慢。</p>
</li>
<li><p><strong>如何调度IO密集型、CPU密集型任务？</strong></p>
<p>首先，IO密集型任务需要更频繁的调度，但是每次需要的CPU时间片很短；而CPU密集型任务需要相对更长的时间片，但是调度频率可以较低。</p>
<p>如何解决？显然IO型任务的<strong>vruntime</strong>是比较低的（假定nice值都相同），所以它因为vruntime很小，很快可以得到再次调度，而CPU密集型任务只要得到处理器资源，就可以用完分配给它的时间片。</p>
<p>所以，IO型任务的vruntime总是偏小，所以”优先级“比CPU型任务更高，总是可以得到及时调度。</p>
<p><strong>不过，精妙的是，这样的优先级既不是用户显式指定的，也不是os通过某种方式动态调整，完全是根据进程的自身的行为动态调整的。</strong></p>
</li>
</ol>
<ol start="4">
<li><strong>可运行的进程以何种数据结构组织？</strong><br>在CFS调度类中，所有可执行的任务都放置在红黑树中，键值正是 <strong>vruntime</strong>，如下图。<br><img src="/2021/10/17/Linux%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E9%82%A3%E4%BA%9B%E4%BA%8B/rb-tree.png" alt="红黑树"></li>
</ol>
<p>当进程从可执态到阻塞态时，会从红黑树中删除，当再次可调度的时候，又会加入红黑树。</p>
<h1 id="实时进程的调度类"><a href="#实时进程的调度类" class="headerlink" title="实时进程的调度类"></a>实时进程的调度类</h1><p>实时进程的调度类优先级比CFS调度类要高。</p>
<p>Linux提供两种实时调度策略，FIFO和RR。关于这两种调度策略比较简单，教科书上也都有就不讲了。</p>
<h1 id="与调度相关的系统调用"><a href="#与调度相关的系统调用" class="headerlink" title="与调度相关的系统调用"></a>与调度相关的系统调用</h1><h2 id="chrt"><a href="#chrt" class="headerlink" title="chrt"></a>chrt</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chrt --help</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">songyangji@SongyangJi-Ubuntu-DeskStop:~$ chrt --help</span><br><span class="line">显示或更改某个进程的实时调度属性。</span><br><span class="line"></span><br><span class="line">设置策略：</span><br><span class="line"> chrt [选项] &lt;优先级&gt; &lt;命令&gt; [&lt;参数&gt;...]</span><br><span class="line"> chrt [选项] --pid &lt;优先级&gt; &lt;pid&gt;</span><br><span class="line"></span><br><span class="line">获取策略</span><br><span class="line"> chrt [选项] -p &lt;pid&gt;</span><br><span class="line"></span><br><span class="line">策略选项：</span><br><span class="line"> -b, --batch          将策略设置为 SCHED_BATCH</span><br><span class="line"> -d, --deadline       将策略设置为 SCHED_DEADLINE</span><br><span class="line"> -f, --fifo           将策略设置为 SCHED_FIFO</span><br><span class="line"> -i, --idle           将策略设置为 SCHED_IDLE</span><br><span class="line"> -o, --other          将策略设置为 SCHED_OTHER</span><br><span class="line"> -r, --rr             将策略设置为 SCHED_RR (默认)</span><br><span class="line"></span><br><span class="line">调度选项：</span><br><span class="line"> -R, --reset-on-fork       为 FIFO 或 RR 设置 SCHED_RESET_ON_FORK</span><br><span class="line"> -T, --sched-runtime &lt;ns&gt;  DEADLINE 的运行时参数</span><br><span class="line"> -P, --sched-period &lt;ns&gt;  DEADLINE 的周期参数</span><br><span class="line"> -D, --sched-deadline &lt;ns&gt; DEADLINE 的截止时间参数</span><br><span class="line"></span><br><span class="line">其他选项：</span><br><span class="line"> -a, --all-tasks      对指定 pid 的所有任务(线程) 操作</span><br><span class="line"> -m, --max            显示最小和最大有效优先级</span><br><span class="line"> -p, --pid            对指定且存在的 pid 操作</span><br><span class="line"> -v, --verbose        显示状态信息</span><br><span class="line"></span><br><span class="line"> -h, --help           display this help</span><br><span class="line"> -V, --version        display version</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>查询各调度策略的优先级：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">songyangji@SongyangJi-Ubuntu-DeskStop:~$ chrt -m</span><br><span class="line">SCHED_OTHER 最小/最大优先级	: 0/0</span><br><span class="line">SCHED_FIFO 最小/最大优先级	: 1/99</span><br><span class="line">SCHED_RR 最小/最大优先级	: 1/99</span><br><span class="line">SCHED_BATCH 最小/最大优先级	: 0/0</span><br><span class="line">SCHED_IDLE 最小/最大优先级	: 0/0</span><br><span class="line">SCHED_DEADLINE 最小/最大优先级	: 0/0</span><br><span class="line">songyangji@SongyangJi-Ubuntu-DeskStop:~$ </span><br></pre></td></tr></table></figure>




<h2 id="taskset"><a href="#taskset" class="headerlink" title="taskset"></a>taskset</h2><p><strong>CPU 亲和性</strong>是一个调度程序属性，它将进程“绑定”到系统上的一组给定 CPU。</p>
<p>通过 <code>taskset</code> 命令可将某个进程与某个CPU核心绑定，使得其仅在与之绑定的CPU核心上运行。</p>
<p>不过需要注意的是，这只能此进程绑定到某个cpu核心上，但不是说这个cpu核心只能被这个进程使用，其他进程可以正常使用。(<code>cpuset</code>可以，不过我们可以在自己的程序中控制cpu核心池的调度)</p>
<p>功能:显示或更改某个进程的 CPU 亲和力。</p>
<p>用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">taskset [选项] [掩码 | cpu列表] [pid|命令 [参数...]]</span><br></pre></td></tr></table></figure>



<p>例如，指定某个进程在cpu核心号为0、1上运行:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">taskset -c 0,1 &#123;shell_cmd&#125;</span><br></pre></td></tr></table></figure>





<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote>
<p>《Operating System Concepts》</p>
<p>《Linux Kernel Development》</p>
<p><a href="https://lwn.net/Articles/805317/">Fixing SCHED_IDLE</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>进程/线程</tag>
        <tag>Linux内核</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB 索引</title>
    <url>/2021/11/02/MongoDB%20%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>索引支持在 MongoDB 中高效执行查询。</p>
<p><strong>如果没有索引，MongoDB 必须执行<em>集合扫描</em>，即扫描<em>集合中的</em>每个文档，以选择那些与查询语句匹配的文档</strong>。如果查询存在合适的索引，MongoDB 可以使用该索引来限制它必须检查的文档数量。</p>
<p>索引是特殊的数据结构（<strong>MongoDB 索引使用 B 树数据结构</strong>），它以易于遍历的形式存储集合数据集的一小部分。索引存储特定字段或字段集的值，按字段值排序。索引条目的排序支持高效的等式匹配和基于范围的查询操作。此外，MongoDB 可以使用索引中的排序返回排序结果。</p>
<p>从根本上说，<strong>MongoDB 中的索引类似于其他数据库系统中的索引</strong>（因为数据结构使用的都是B树）。MongoDB 在<strong>集合</strong>级别定义索引，并支持 MongoDB 集合中文档的任何字段或子字段的索引。</p>
<h2 id="默认-id索引"><a href="#默认-id索引" class="headerlink" title="默认_id索引"></a>默认<code>_id</code>索引</h2><p>MongoDB在创建集合期间在<code>_id</code>字段上 创建唯一索引。该索引可防止客户端插入具有相同字段值的两个文档。您不能在字段上删除此索引。</p>
<h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><p>索引一旦创建就不能重命名。相反，您必须删除并使用新名称重新创建索引。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.collection.createIndex( &lt;key and index type specification&gt;, &lt;options&gt; )</span><br></pre></td></tr></table></figure>

<h2 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.collection.getIndexes()</span><br></pre></td></tr></table></figure>




<h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><p>MongoDB 提供了许多不同的索引类型来支持特定类型的数据和查询。</p>
<h3 id="单字段索引"><a href="#单字段索引" class="headerlink" title="单字段索引"></a>单字段索引</h3><p>MongoDB支持在文档的单个字段上创建用户定义的升序/降序索引。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.collection.createIndex( &#123; score: 1 &#125; )</span><br></pre></td></tr></table></figure>



<p><img src="https://docs.mongodb.com/manual/images/index-ascending.bakedsvg.svg"></p>
<h3 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h3><p>MongoDB 还支持多个字段上的用户定义索引，即 <a href="https://docs.mongodb.com/manual/core/index-compound/">复合索引</a>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.collection.createIndex( &#123; userid: 1, score: -1 &#125; )</span><br></pre></td></tr></table></figure>



<p>复合索引中列出的字段顺序很重要。例如，如果复合索引由 组成<code>&#123; userid: 1, score: -1 &#125;</code>，则索引首先按升序排序<code>userid</code>，然后在每个<code>userid</code> 值中按降序排序<code>score</code>。</p>
<p><img src="https://docs.mongodb.com/manual/images/index-compound-key.bakedsvg.svg"></p>
<h3 id="多键索引"><a href="#多键索引" class="headerlink" title="多键索引"></a>多键索引</h3><p>MongoDB 使用<a href="https://docs.mongodb.com/manual/core/index-multikey/">多键索引</a>来索引<strong>存储在数组中的内容</strong>。<br>如果你索引一个包含数组值的字段，MongoDB 会<strong>为数组的每个元素创建单独的索引条目</strong>。这些<a href="https://docs.mongodb.com/manual/core/index-multikey/">多键索引</a>允许查询通过匹配数组的一个或多个元素来选择包含数组的文档。</p>
<p>如果索引字段包含数组值，MongoDB 会自动判断是否创建多键索引；您<strong>不需要显式指定多键类型</strong>。</p>
<p><img src="https://docs.mongodb.com/manual/images/index-multikey.bakedsvg.svg"></p>
<h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>为了支持<a href="https://docs.mongodb.com/manual/core/hashed-sharding/#std-label-sharding-hashed-sharding">基于散列的分片</a>，MongoDB 提供了一种<a href="https://docs.mongodb.com/manual/core/index-hashed/">散列索引</a>类型，它对字段值的散列值进行索引。这些索引在其范围内具有更随机的值分布，但<strong>仅支持相等匹配</strong>，<strong>不支持基于范围的查询</strong>。</p>
<blockquote>
<p><a href="https://docs.mongodb.com/manual/indexes/">官方文档索引</a></p>
</blockquote>
]]></content>
      <categories>
        <category>NoSQL</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>M1 MacOS 下使用Brew安装MongoDB、入门概念</title>
    <url>/2021/10/04/MongoDB%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="下载、配置"><a href="#下载、配置" class="headerlink" title="下载、配置"></a>下载、配置</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装必要的安装包</span></span><br><span class="line">brew tap mongodb/brew</span><br><span class="line">brew install mongodb-community</span><br></pre></td></tr></table></figure>

<p>配置环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可能不一样</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/opt/homebrew/Cellar/mongodb-community/4.4.5/bin</span><br></pre></td></tr></table></figure>

<h1 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h1><ol>
<li>使用 brew<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew services start mongodb-community</span><br></pre></td></tr></table></figure></li>
<li> 开始 mongo 服务<br>(这是个守护进程)<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mongod</span><br></pre></td></tr></table></figure></li>
<li>启动MongoDB的shell<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置好环境之后</span></span><br><span class="line">mongo</span><br><span class="line"></span><br><span class="line"><span class="comment"># MongoDB shell version v4.4.5</span></span><br><span class="line"><span class="comment"># connecting to: mongodb://127.0.0.1:27017/?compressors=disabled&amp;gssapiServiceName=mongodb</span></span><br><span class="line"><span class="comment"># Implicit session: session &#123; &quot;id&quot; : UUID(&quot;0d903bb8-cfb4-4d43-9a60-# c365a1de640a&quot;) &#125;</span></span><br></pre></td></tr></table></figure>
可以看到默认端口号是 27017 。</li>
</ol>
<p><strong>注：</strong><br>mongod是服务端、<br>mongo是客户端。</p>
<p>（就像是mysqld和mysql）</p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><table>
<thead>
<tr>
<th>SQL术语/概念</th>
<th>MongoDB术语/概念</th>
<th>解释/说明</th>
</tr>
</thead>
<tbody><tr>
<td>database</td>
<td>database</td>
<td>数据库</td>
</tr>
<tr>
<td>table</td>
<td>collection</td>
<td>数据库表/集合</td>
</tr>
<tr>
<td>row</td>
<td>document</td>
<td>数据记录行/文档</td>
</tr>
<tr>
<td>column</td>
<td>field</td>
<td>数据字段/域</td>
</tr>
<tr>
<td>index</td>
<td>index</td>
<td>索引</td>
</tr>
<tr>
<td>table  joins</td>
<td>嵌入文档</td>
<td>表连接,MongoDB不支持（DBRef）</td>
</tr>
<tr>
<td>primary key</td>
<td>primary key</td>
<td>主键,MongoDB自动将_id字段设置为主键</td>
</tr>
</tbody></table>
<p><strong>必须指明的是，这只是一种方便理解产生的垂直联系，实际上MongoDB存储的数据是半结构化的，并非RDBMS一样，有着规整的数据结构。</strong><br>比如，在MongoDB中collection里面的document的field可以各不相同，这在关系型数据库是绝不可以的。</p>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>文档是一组键值(key-value)对(即 BSON，即 Binary Json；用起来就像json一样)。MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是 MongoDB 非常突出的特点。<br>注：</p>
<ul>
<li><p><strong>文档中的键/值对是有序的</strong>。</p>
</li>
<li><p><strong>文档的键是字符串。</strong></p>
</li>
</ul>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合就是 MongoDB 文档组，类似于 RDBMS （关系数据库管理系统：Relational Database Management System)中的表格。</p>
<p>集合存在于数据库中，<strong>集合没有固定的结构，这意味着你在对集合可以插入不同格式和类型的数据</strong>，但通常情况下我们插入集合的数据都会有一定的关联性。</p>
<p>当第一个文档插入时，集合就会被创建。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>使用Json作为数据存储方式。<br>查询语言也是Json风格的。</p>
<table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">String</td>
<td align="left">字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。</td>
</tr>
<tr>
<td align="left">Integer</td>
<td align="left">整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。</td>
</tr>
<tr>
<td align="left">Boolean</td>
<td align="left">布尔值。用于存储布尔值（真/假）。</td>
</tr>
<tr>
<td align="left">Double</td>
<td align="left">双精度浮点值。用于存储浮点值。</td>
</tr>
<tr>
<td align="left">Min/Max keys</td>
<td align="left">将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。</td>
</tr>
<tr>
<td align="left">Array</td>
<td align="left">用于将数组或列表或多个值存储为一个键。</td>
</tr>
<tr>
<td align="left">Timestamp</td>
<td align="left">时间戳。记录文档修改或添加的具体时间。</td>
</tr>
<tr>
<td align="left">Object</td>
<td align="left">用于内嵌文档。</td>
</tr>
<tr>
<td align="left">Null</td>
<td align="left">用于创建空值。</td>
</tr>
<tr>
<td align="left">Symbol</td>
<td align="left">符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。</td>
</tr>
<tr>
<td align="left">Date</td>
<td align="left">日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。</td>
</tr>
<tr>
<td align="left">Object ID</td>
<td align="left">对象 ID。用于创建文档的 ID。</td>
</tr>
<tr>
<td align="left">Binary Data</td>
<td align="left">二进制数据。用于存储二进制数据。</td>
</tr>
<tr>
<td align="left">Code</td>
<td align="left">代码类型。用于在文档中存储 JavaScript 代码。</td>
</tr>
<tr>
<td align="left">Regular expression</td>
<td align="left">正则表达式类型。用于存储正则表达式。</td>
</tr>
</tbody></table>
<p>下面说明下几种重要的数据类型。</p>
<h3 id="ObjectId"><a href="#ObjectId" class="headerlink" title="ObjectId"></a>ObjectId</h3><p>ObjectId 类似唯一主键，可以很快的去生成和排序，包含 12 bytes，含义是：</p>
<ul>
<li>前 4 个字节表示创建 <strong>unix</strong> 时间戳,格林尼治时间 <strong>UTC</strong> 时间，比北京时间晚了 8 个小时</li>
<li>接下来的 3 个字节是机器标识码；</li>
<li>紧接的两个字节由进程 id 组成 PID；</li>
<li>最后3个字节是一个自动增加的计数器，确保相同的进程同一秒产生的ObjectId也是不一样的。</li>
</ul>
<p>MongoDB 中存储的文档必须有一个 _id 键。</p>
<p><strong>这个键的值可以是任何类型的</strong>，默认是个 ObjectId 对象</p>
<p>由于 ObjectId 中保存了创建的时间戳，所以你不需要为你的文档保存时间戳字段，你可以通过 getTimestamp 函数来获取文档的创建时间。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> var newObject = ObjectId()</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> newObject.getTimestamp()</span></span><br><span class="line">ISODate(&quot;2021-10-19T00:45:32Z&quot;)</span><br></pre></td></tr></table></figure>



<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://docs.mongodb.com/">docs</a></p>
<p><a href="https://docs.mongodb.com/manual/reference/">reference</a></p>
]]></content>
      <categories>
        <category>NoSQL</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux的mmap概念、原理、使用</title>
    <url>/2021/11/22/Linux%E7%9A%84mmap%E6%A6%82%E5%BF%B5%E3%80%81%E5%8E%9F%E7%90%86%E3%80%81%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="mmap基础概念"><a href="#mmap基础概念" class="headerlink" title="mmap基础概念"></a>mmap基础概念</h1><p><code>mmap</code>是一种<strong>内存映射文件</strong>的方法，即<strong>将一个文件或者其它对象映射到进程的地址空间</strong>，<strong>实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系</strong>。</p>
<p>实现这样的映射关系后<strong>，进程就可以采用指针的方式读写操作这一段内存</strong>，而<strong>系统会自动回写脏页面到对应的文件磁盘上</strong>，即完成了对文件的操作而不必再调用read,write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现<strong>不同进程间的文件共享</strong>。</p>
<p>如下图所示：</p>
<p><img src="/2021/11/22/Linux%E7%9A%84mmap%E6%A6%82%E5%BF%B5%E3%80%81%E5%8E%9F%E7%90%86%E3%80%81%E4%BD%BF%E7%94%A8/mmap1.png"></p>
<p>由上图可以看出，进程的虚拟地址空间，由多个虚拟内存区域构成。虚拟内存区域是进程的虚拟地址空间中的一个同质区间，即具有同样特性的连续地址范围。上图中所示的text数据段（代码段）、初始数据段、BSS数据段、堆、栈和内存映射，都是一个独立的虚拟内存区域。而为内存映射服务的地址空间处在堆栈之间的空余部分。</p>
<p>linux内核使用<code>vm_area_struct</code>结构来表示<strong>一个独立的虚拟内存区域</strong>，由于每个不同质的虚拟内存区域功能和内部机制都不同，因此一<strong>个进程使用多个vm_area_struct结构来分别表示不同类型的虚拟内存区域</strong>。</p>
<p>各个vm_area_struct结构使用链表或者树形结构链接，方便进程快速访问，如下图所示：</p>
<p><img src="/2021/11/22/Linux%E7%9A%84mmap%E6%A6%82%E5%BF%B5%E3%80%81%E5%8E%9F%E7%90%86%E3%80%81%E4%BD%BF%E7%94%A8/mmap2.png"></p>
<p>vm_area_struct结构中包含区域起始和终止地址以及其他相关信息，同时也包含一个vm_ops指针，其内部可引出所有针对这个区域可以使用的系统调用函数。这样，进程对某一虚拟内存区域的任何操作需要用要的信息，都可以从vm_area_struct中获得。</p>
<p><strong>mmap函数就是要创建一个新的vm_area_struct结构，并将其与文件的物理磁盘地址相连。</strong></p>
<h1 id="mmap内存映射步骤和原理"><a href="#mmap内存映射步骤和原理" class="headerlink" title="mmap内存映射步骤和原理"></a>mmap内存映射步骤和原理</h1><h2 id="内存映射步骤"><a href="#内存映射步骤" class="headerlink" title="内存映射步骤"></a>内存映射步骤</h2><p>mmap内存映射的实现过程，总的来说可以分为三个阶段：</p>
<p><strong>（一）进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域</strong></p>
<ol>
<li>进程在用户空间调用库函数mmap，</li>
</ol>
<p>原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *start, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>在当前进程的虚拟地址空间中，寻找一段空闲的满足要求的连续的虚拟地址;</p>
</li>
<li><p>为此虚拟区分配一个vm_area_struct结构，接着对这个结构的各个域进行了初始化</p>
</li>
<li><p>将新建的虚拟区结构（vm_area_struct）插入进程的虚拟地址区域链表或树中</p>
</li>
</ol>
<p><strong>（二）调用内核空间的系统调用函数mmap（不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射关系</strong></p>
<p>5、为映射分配了新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，通过文件描述符，链接到内核“已打开文件集”中该文件的文件结构体（struct file），每个文件结构体维护着和这个已打开文件相关各项信息。</p>
<p>6、通过该文件的文件结构体，链接到file_operations模块，调用内核函数mmap，其原型为：int mmap(struct file *filp, struct vm_area_struct *vma)，不同于用户空间库函数。</p>
<p>7、内核mmap函数通过虚拟文件系统inode模块定位到文件磁盘物理地址。</p>
<p>8、通过remap_pfn_range函数建立页表，即实现了文件地址和虚拟地址区域的映射关系。此时，这片虚拟地址并没有任何数据关联到主存中。</p>
<p><strong>（三）进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝</strong></p>
<p>注：前两个阶段仅在于创建虚拟区间并完成地址映射，但是并没有将任何文件数据的拷贝至主存。真正的文件读取是当进程发起读或写操作时。</p>
<p>9、进程的读或写操作访问虚拟地址空间这一段映射地址，通过查询页表，发现这一段地址并不在物理页面上。因为目前只建立了地址映射，真正的硬盘数据还没有拷贝到内存中，因此引发缺页异常。</p>
<p>10、缺页异常进行一系列判断，确定无非法操作后，内核发起请求调页过程。</p>
<p>11、调页过程先在交换缓存空间（swap cache）中寻找需要访问的内存页，如果没有则调用nopage函数把所缺的页从磁盘装入到主存中。</p>
<p>12、之后进程即可对这片主存进行读或者写的操作，如果写操作改变了其内容，一定时间后系统会自动回写脏页面到对应磁盘地址，也即完成了写入到文件的过程。</p>
<p>注：修改过的脏页面并不会立即更新回文件中，而是有一段时间的延迟，可以调用msync()来强制同步, 这样所写的内容就能立即保存到文件里了。</p>
<h3 id="内核怎样保证各个进程寻址到同一个共享内存区域的内存页面"><a href="#内核怎样保证各个进程寻址到同一个共享内存区域的内存页面" class="headerlink" title="内核怎样保证各个进程寻址到同一个共享内存区域的内存页面"></a>内核怎样保证各个进程寻址到同一个共享内存区域的内存页面</h3><ol>
<li><p> page cache及swap cache中页面的区分：一个被访问文件的物理页面都驻留在page cache或swap cache中，一个页面的所有信息由struct page来描述。struct page中有一个域为指针mapping ，它指向一个struct address_space类型结构。page cache或swap cache中的所有页面就是根据address_space结构以及一个偏移量来区分的。</p>
</li>
<li><p>文件与 address_space结构的对应：一个具体的文件在打开后，内核会在内存中为之建立一个struct inode结构，其中的i_mapping域指向一个address_space结构。这样，一个文件就对应一个address_space结构，一个 address_space与一个偏移量能够确定一个page cache 或swap cache中的一个页面。因此，当要寻址某个数据时，很容易根据给定的文件及数据在文件内的偏移量而找到相应的页面。</p>
</li>
<li><p><strong>进程调用mmap()时，只是在进程空间内新增了一块相应大小的缓冲区，并设置了相应的访问标识</strong>，但并没有建立进程空间到物理页面的映射。因此，第一次访问该空间时，会引发一个缺页异常。</p>
</li>
<li><p>对于共享内存映射情况，缺页异常处理程序首先在swap cache中寻找目标页（符合address_space以及偏移量的物理页），如果找到，则直接返回地址；如果没有找到，则判断该页是否在交换区 (swap area)，如果在，则执行一个换入操作；如果上述两种情况都不满足，处理程序将分配新的物理页面，并把它插入到page cache中。进程最终将更新进程页表。<br>注：对于映射普通文件情况（非共享映射），缺页异常处理程序首先会在page cache中根据address_space以及数据偏移量寻找相应的页面。如果没有找到，则说明文件数据还没有读入内存，处理程序会从磁盘读入相应的页 面，并返回相应地址，同时，进程页表也会更新。</p>
</li>
<li><p>所有进程在映射同一个共享内存区域时，情况都一样，在建立线性地址与物理地址之间的映射之后，不论进程各自的返回地址（实际上各进程返回的地址为各进程的虚拟地址，虚拟地址自然就会不一样，而它们映射的物理地址是相同的）如何，实际访问的必然是同一个共享内存区域对应的物理页面。<br>注：一个共享内存区域可以看作是特殊文件系统shm中的一个文件，shm的安装点在交换区上。</p>
</li>
</ol>
<h1 id="mmap相关函数"><a href="#mmap相关函数" class="headerlink" title="mmap相关函数"></a>mmap相关函数</h1><p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *start, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>返回说明</strong></p>
<p>成功执行时，mmap()返回被映射区的指针;</p>
<p>失败时，mmap()返回MAP_FAILED[其值为(void *)]， error被设为以下的某个值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 EACCES：访问出错</span><br><span class="line"> 2 EAGAIN：文件已被锁定，或者太多的内存已被锁定</span><br><span class="line"> 3 EBADF：fd不是有效的文件描述词</span><br><span class="line"> 4 EINVAL：一个或者多个参数无效</span><br><span class="line"> 5 ENFILE：已达到系统对打开文件的限制</span><br><span class="line"> 6 ENODEV：指定文件所在的文件系统不支持内存映射</span><br><span class="line"> 7 ENOMEM：内存不足，或者进程已超出最大内存映射数量</span><br><span class="line"> 8 EPERM：权能不足，操作不允许</span><br><span class="line"> 9 ETXTBSY：已写的方式打开文件，同时指定MAP_DENYWRITE标志</span><br><span class="line">10 SIGSEGV：试着向只读区写入</span><br><span class="line">11 SIGBUS：试着访问不属于进程的内存区</span><br></pre></td></tr></table></figure>



<p><strong>参数</strong></p>
<p>start：映射区的开始地址</p>
<p>length：映射区的长度</p>
<p>prot：期望的内存保护标志，不能与文件的打开模式冲突, 是以下的某个值，可以通过or运算合理地组合在一起</p>
<table>
<thead>
<tr>
<th>prot参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>PROT_READ</td>
<td>内存段可读</td>
</tr>
<tr>
<td>PROT_WRITE</td>
<td>内存段可写</td>
</tr>
<tr>
<td>PROT_EXEC</td>
<td>内存段可执行</td>
</tr>
<tr>
<td>PROT_NONE</td>
<td>内存段不能被访问</td>
</tr>
</tbody></table>
<p>flags：指定映射对象的类型，映射选项和映射页是否可以共享。它的值可以是一个或者多个以下位的组合体</p>
<table>
<thead>
<tr>
<th>flags参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>MAP_SHARED</td>
<td>进程间共享内存，对该内存段修改反映到映射文件中。提供了POSIX共享内存</td>
</tr>
<tr>
<td>MAP_PRIVATE</td>
<td>内存段为调用进程所私有。对该内存段的修改不会反映到映射文件</td>
</tr>
<tr>
<td>MAP_ANNOYMOUS</td>
<td>这段内存不是从文件映射而来的。内容被初始化为全0</td>
</tr>
<tr>
<td>MAP_FIXED</td>
<td>内存段必须位于start参数指定的地址处，start必须是页大小的整数倍（4K整数倍）</td>
</tr>
<tr>
<td>MAP_HUGETLB</td>
<td>按照大内存页面来分配内存空间</td>
</tr>
</tbody></table>
<p>fd：有效的文件描述符。如果MAP_ANONYMOUS被设定，为了兼容问题，其值应为-1；</p>
<p>offset：被映射对象内容的起点；</p>
<p><strong>相关函数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">( <span class="keyword">void</span> * addr, <span class="keyword">size_t</span> len )</span> </span></span><br></pre></td></tr></table></figure>

<p>成功执行时，munmap()返回0。失败时，munmap返回-1，error返回标志和mmap一致；</p>
<p>该调用在进程地址空间中解除一个映射关系，addr是调用mmap()时返回的地址，len是映射区的大小；</p>
<p>当映射关系解除后，对原来映射地址的访问将导致段错误发生。 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msync</span><span class="params">( <span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags )</span></span></span><br></pre></td></tr></table></figure>

<p>一般说来，进程在映射空间的对共享内容的改变并不直接写回到磁盘文件中，往往在调用munmap()后才执行该操作。</p>
<p>可以通过调用msync()实现磁盘上文件内容与共享内存区的内容一致, 也就是内存同步到磁盘上。</p>
<h1 id="mmap和常规文件操作的区别"><a href="#mmap和常规文件操作的区别" class="headerlink" title="mmap和常规文件操作的区别"></a>mmap和常规文件操作的区别</h1><p>参考文章<a href="http://47.117.127.179/2021/11/20/Linux%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E5%AE%9E%E7%8E%B0/">《Linux文件描述符的使用与实现》</a>。</p>
<p>我们首先简单的回顾一下常规文件系统操作（调用read/fread等类函数）中，函数的调用过程：</p>
<ol>
<li><p>进程发起读文件请求;</p>
</li>
<li><p>内核通过查找进程文件符表（<code>fd_array</code>），定位到内核已打开文件集上的文件信息，从而找到此文件的<code>inode</code>;</p>
</li>
<li><p>inode在address_space上查找要请求的文件页是否已经缓存在页缓存中。如果存在，则直接返回这片文件页的内容。</p>
</li>
<li><p>如果不存在，则通过inode定位到文件磁盘地址，将数据从磁盘复制到页缓存。之后再次发起读页面过程，进而将页缓存中的数据发给用户进程。</p>
</li>
</ol>
<p>总结来说，常规文件操作为了提高读写效率和保护磁盘，使用了<strong>页缓存机制</strong>。</p>
<p>这样造成读文件时<strong>需要先将文件页从磁盘拷贝到页缓存中</strong>，由于<strong>页缓存处在内核空间</strong>，不能被用户进程直接寻址，所以<strong>还需要将页缓存中数据页再次拷贝到内存对应的用户空间中</strong>。这样，<strong>通过了两次数据拷贝过程，才能完成进程对文件内容的获取任务</strong>。写操作也是一样，待写入的buffer在内核空间不能直接访问，必须要先拷贝至内核空间对应的主存，再写回磁盘中（延迟写回），也是需要两次数据拷贝。</p>
<p>而使用mmap操作文件时，创建新的虚拟内存区域和建立文件磁盘地址和虚拟内存区域映射这两步，没有任何文件拷贝操作，而之后<strong>访问数据时发现内存中并无数据而发起的缺页异常过程</strong>，<strong>可以通过已经建立好的映射关系，只使用一次数据拷贝，就从磁盘中将数据传入内存的用户空间中</strong>，供进程使用。</p>
<p><strong>总而言之，常规文件操作需要从磁盘到页缓存再到用户主存的两次数据拷贝，</strong></p>
<p><strong>而mmap操控文件，只需要从磁盘到用户主存的一次数据拷贝过程。</strong></p>
<p>说白了，mmap的关键点是<strong>实现了用户空间和内核空间的数据直接交互而省去了空间不同数据不通的繁琐过程</strong>。因此mmap效率更高。</p>
<h1 id="mmap优点"><a href="#mmap优点" class="headerlink" title="mmap优点"></a>mmap优点</h1><p>由上文讨论可知，mmap优点共有一下几点：</p>
<ol>
<li><p><strong>对文件的读取操作跨过了页缓存</strong>，减少了数据的拷贝次数，<strong>用内存读写取代I/O读写</strong>，提高了文件读取效率。</p>
</li>
<li><p>实现了用户空间和内核空间的高效交互方式。<strong>两空间的各自修改操作可以直接反映在映射的区域内，从而被对方空间及时捕捉</strong>。</p>
</li>
<li><p>提供<strong>进程间共享内存及相互通信</strong>的方式。不管是父子进程还是无亲缘关系的进程，都可以<strong>将自身用户空间映射到同一个文件或匿名映射到同一片区域</strong>。从而通过各自对映射区域的改动，达到进程间通信和进程间共享的目的。同时，如果进程A和进程B都映射了区域C，当A第一次读取C时通过缺页从磁盘复制文件页到内存中；但当B再读C的相同页面时，虽然也会产生缺页异常，但是不再需要从磁盘中复制文件过来，而可直接使用已经保存在内存中的文件数据。</p>
</li>
<li><p><strong>可用于实现高效的大规模数据传输</strong>。内存空间不足，是制约大数据操作的一个方面，解决方案往往是借助硬盘空间协助操作，补充内存的不足。但是进一步会造成大量的文件I/O操作，极大影响效率。这个问题可以通过mmap映射很好的解决。换句话说，但凡是需要用磁盘空间代替内存的时候，mmap都可以发挥其功效。</p>
</li>
</ol>
<h1 id="mmap用途"><a href="#mmap用途" class="headerlink" title="mmap用途"></a>mmap用途</h1><ol>
<li><p>共享内存：可以说是最有用的进程间通信方式，也是最快的IPC形式。两个不同进程A、B共享内存的意思是，同一块物理内存被映射到进程A、B各自的进程地址空 间。进程A可以即时看到进程B对共享内存中数据的更新，反之亦然。由于多个进程共享同一块内存区域，必然需要某种同步机制，互斥锁和信号量都可以。</p>
<p>Linux的2.2.x内核支持多种共享内存方式，如<strong>1) mmap()系统调用，2) Posix共享内存，以及3) System V共享内存</strong>。linux发行版本如Redhat 8.0支持mmap()系统调用及System V共享内存，但还没实现Posix共享内存。</p>
</li>
<li><p>文件访问方式：mmap函数是unix/linux下的系统调用，mmap系统调用并不是完全为了用于共享内存而设计的。它本身提供了不同于一般对普通文件的访问方式，进程可以像读写内存一样对普通文件的操作。而Posix或系统V的共享内存IPC则纯粹用于共享目的，当然mmap()实现共享内存也是其主要应用之一。</p>
</li>
</ol>
<p>mmap系统调用使得进程之间通过映射同一个普通文件实现共享内存。普通文件被映射到进程地址空间后，进程可以像访问普通内存一样对文件进行访问，不必再调用read()，write()等操作。<br>我们的程序中大量运用了mmap，用到的正是mmap的这种“像访问普通内存一样对文件进行访问”的功能。实践证明，<strong>当要对一个文件频繁的进行访问，并且指针来回移动时</strong>，调用mmap比用常规的方法快很多</p>
<h1 id="mmap使用细节"><a href="#mmap使用细节" class="headerlink" title="mmap使用细节"></a>mmap使用细节</h1><ol>
<li><p>使用mmap需要注意的一个关键点是，<strong>mmap映射区域大小必须是物理页大小(page_size)的整倍数</strong>（32位系统中通常是4k字节）。原因是，内存的最小粒度是页，而进程虚拟地址空间和内存的映射也是以页为单位。为了匹配内存的操作，mmap从磁盘到虚拟地址空间的映射也必须是页。</p>
</li>
<li><p>内核可以跟踪被内存映射的底层对象（文件）的大小，<strong>进程可以合法的访问在当前文件大小以内且在内存映射区以内的那些字节</strong>。也就是说，<strong>如果文件的大小一直在扩张，只要在映射区域范围内的数据，进程都可以合法得到</strong>，这和映射建立时文件的大小无关。具体情形参见<em>情形三</em>。</p>
</li>
<li><p><strong>映射建立之后，即使文件关闭，映射依然存在</strong>。因为映射的是磁盘的地址，不是文件本身，和文件句柄无关。同时可用于进程间通信的有效地址空间不完全受限于被映射文件的大小，因为是按页映射。</p>
</li>
</ol>
<p>在上面的知识前提下，我们下面看看如果大小不是页的整倍数的具体情况：</p>
<p><strong>情形一：一个文件的大小是5000字节，mmap函数从一个文件的起始位置开始，映射5000字节到虚拟内存中。</strong></p>
<p>分析：因为单位物理页面的大小是4096字节，虽然被映射的文件只有5000字节，但是对应到进程虚拟地址区域的大小需要满足整页大小，因此mmap函数执行后，实际映射到虚拟内存区域8192个 字节，5000~8191的字节部分用零填充。映射后的对应关系如下图所示：</p>
<p>​        <img src="/2021/11/22/Linux%E7%9A%84mmap%E6%A6%82%E5%BF%B5%E3%80%81%E5%8E%9F%E7%90%86%E3%80%81%E4%BD%BF%E7%94%A8/mmap3.png" alt="img"></p>
<p>此时：</p>
<p>（1）读/写前5000个字节（0~4999），会返回操作文件内容。</p>
<p>（2）读字节5000-8191时，结果全为0。写5000~8191时，进程不会报错，但是所写的内容不会写入原文件中 。</p>
<p>（3）读/写8192以外的磁盘部分，会返回一个<code>SIGSECV</code>错误（无效的内存引用）。</p>
<p><strong>情形二：一个文件的大小是5000字节，mmap函数从一个文件的起始位置开始，映射15000字节到虚拟内存中，即映射大小超过了原始文件的大小。</strong></p>
<p>分析：由于文件的大小是5000字节，和情形一一样，其对应的两个物理页。那么这两个物理页都是合法可以读写的，只是超出5000的部分不会体现在原文件中。由于程序要求映射15000字节，而文件只占两个物理页，因此8192字节~15000字节都不能读写，操作时会返回异常。如下图所示：</p>
<p>​         <img src="/2021/11/22/Linux%E7%9A%84mmap%E6%A6%82%E5%BF%B5%E3%80%81%E5%8E%9F%E7%90%86%E3%80%81%E4%BD%BF%E7%94%A8/mmap4.png" alt="img"></p>
<p>此时：</p>
<p>（1）进程可以正常读/写被映射的前5000字节(0~4999)，写操作的改动会在一定时间后反映在原文件中。</p>
<p>（2）对于5000~8191字节，进程可以进行读写过程，不会报错。但是内容在写入前均为0，另外，写入后不会反映在文件中。</p>
<p>（3）对于8192~14999字节，进程不能对其进行读写，会报<code>SIGBUS</code>错误（指针所对应的地址是有效地址，但总线不能正常使用该 指针，通常是未对齐的数据访问所致）。</p>
<p>（4）对于15000以外的字节，进程不能对其读写，会引发<code>SIGSEGV</code>错误。</p>
<p><strong>情形三：一个文件初始大小为0，使用mmap操作映射了1000*4K的大小，即1000个物理页大约4M字节空间，mmap返回指针ptr。</strong></p>
<p>分析：如果在映射建立之初，就对文件进行读写操作，由于文件大小为0，并没有合法的物理页对应，如同情形二一样，会返回SIGBUS错误。</p>
<p>但是如果每次操作ptr读写前，<strong>先增加文件的大小？</strong>，那么ptr在文件大小内部的操作就是合法的。例如，文件扩充4096字节，ptr就能操作ptr  [ (char)ptr + 4095]的空间。只要文件扩充的范围在1000个物理页（映射范围）内，ptr都可以对应操作相同的大小。</p>
<p>这样，方便随时扩充文件空间，随时写入文件，不造成空间浪费。</p>
<blockquote>
<p>mmap针对Windows和Unix的版本在具体实现上有所不同，对于Windows版本，当length参数比file本身size大的时候，会自动扩展file为指定length大小；而Unix版本不支持自动扩展，即length只能小于等于size of file，如果超出size，则会报错。</p>
</blockquote>
<p><a href="https://www.cnblogs.com/alantu2018/p/8506381.html">https://www.cnblogs.com/alantu2018/p/8506381.html</a></p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB 进阶(聚合)</title>
    <url>/2021/10/19/MongoDB-%E8%BF%9B%E9%98%B6(%E8%81%9A%E5%90%88)/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h1><p>什么是聚合管道？</p>
<ul>
<li><strong>聚合管道是基于数据处理管道概念建模的数据聚合框架</strong>。</li>
<li>文档进入<strong>多阶段管道</strong>，将文档转换为聚合结果。</li>
<li>MongoDB 聚合管道由<strong>阶段</strong>组成。每个阶段都会在文档通过管道时对其进行转换。</li>
<li>管道阶段可以在管道中多次出现，但<a href="https://docs.mongodb.com/manual/reference/operator/aggregation/out/#mongodb-pipeline-pipe.-out"><code>$out</code></a>，<a href="https://docs.mongodb.com/manual/reference/operator/aggregation/merge/#mongodb-pipeline-pipe.-merge"><code>$merge</code></a>、 和 <a href="https://docs.mongodb.com/manual/reference/operator/aggregation/geoNear/#mongodb-pipeline-pipe.-geoNear"><code>$geoNear</code></a>阶段除外。（相当于 Java 流式计算的的最后一步归约操作）。</li>
</ul>
<p><strong>语法</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.collection.aggregate( [ &#123; &lt;stage&gt; &#125;, ... ] )</span><br></pre></td></tr></table></figure>



<h2 id="聚合管道的阶段"><a href="#聚合管道的阶段" class="headerlink" title="聚合管道的阶段"></a>聚合管道的阶段</h2><p>这里只列出最常用的，完整请看参考文档。</p>
<table>
<thead>
<tr>
<th align="left">阶段</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/addFields/#mongodb-pipeline-pipe.-addFields"><code>$addFields</code></a></td>
<td align="left">向文档添加新字段。类似于 <a href="https://docs.mongodb.com/manual/reference/operator/aggregation/project/#mongodb-pipeline-pipe.-project"><code>$project</code></a>，<a href="https://docs.mongodb.com/manual/reference/operator/aggregation/addFields/#mongodb-pipeline-pipe.-addFields"><code>$addFields</code></a>对流中的每个文档进行整形；具体来说，通过向包含输入文档中现有字段和新添加字段的输出文档添加新字段。<a href="https://docs.mongodb.com/manual/reference/operator/aggregation/set/#mongodb-pipeline-pipe.-set"><code>$set</code></a>是 的别名<a href="https://docs.mongodb.com/manual/reference/operator/aggregation/addFields/#mongodb-pipeline-pipe.-addFields"><code>$addFields</code></a>。</td>
</tr>
<tr>
<td align="left"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/count/#mongodb-pipeline-pipe.-count"><code>$count</code></a></td>
<td align="left">返回聚合管道此阶段的文档数计数。与<a href="https://docs.mongodb.com/manual/reference/operator/aggregation/count-accumulator/#mongodb-group-grp.-count"><code>$count</code></a>聚合累加器不同。</td>
</tr>
<tr>
<td align="left"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/group/#mongodb-pipeline-pipe.-group"><code>$group</code></a></td>
<td align="left">按指定的标识符表达式对输入文档进行分组，并将累加器表达式（如果指定）应用于每个组。使用所有输入文档并为每个不同的组输出一个文档。输出文档仅包含标识符字段和累积字段（如果指定）。</td>
</tr>
<tr>
<td align="left"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/limit/#mongodb-pipeline-pipe.-limit"><code>$limit</code></a></td>
<td align="left">将未修改的前<em>n 个</em>文档传递到管道，其中<em>n</em>是指定的限制。对于每个输入文档，输出一个文档（对于前<em>n 个</em>文档）或零个文档（在前<em>n 个</em>文档之后）。</td>
</tr>
<tr>
<td align="left"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/lookup/#mongodb-pipeline-pipe.-lookup"><code>$lookup</code></a></td>
<td align="left">对<em>同一</em>数据库中的另一个集合执行左外部 联接，以从“联接”集合中过滤文档以进行处理。</td>
</tr>
<tr>
<td align="left"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/match/#mongodb-pipeline-pipe.-match"><code>$match</code></a></td>
<td align="left">过滤文档流以只允许匹配的文档未经修改地传递到下一个管道阶段。 <a href="https://docs.mongodb.com/manual/reference/operator/aggregation/match/#mongodb-pipeline-pipe.-match"><code>$match</code></a>使用标准的 MongoDB 查询。对于每个输入文档，输出一个文档（匹配）或零个文档（不匹配）。</td>
</tr>
<tr>
<td align="left"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/merge/#mongodb-pipeline-pipe.-merge"><code>$merge</code></a></td>
<td align="left">将聚合管道的结果文档写入集合。该阶段可以将（插入新文档、合并文档、替换文档、保留现有文档、操作失败、使用自定义更新管道处理文档）结果合并到输出集合中。要使用该<a href="https://docs.mongodb.com/manual/reference/operator/aggregation/merge/#mongodb-pipeline-pipe.-merge"><code>$merge</code></a>阶段，它必须是管道中的最后一个阶段。<em>4.2版中的新功能</em>。</td>
</tr>
<tr>
<td align="left"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/out/#mongodb-pipeline-pipe.-out"><code>$out</code></a></td>
<td align="left">将聚合管道的结果文档写入集合。要使用该<a href="https://docs.mongodb.com/manual/reference/operator/aggregation/out/#mongodb-pipeline-pipe.-out"><code>$out</code></a>阶段，它必须是管道中的最后一个阶段。</td>
</tr>
<tr>
<td align="left"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/planCacheStats/#mongodb-pipeline-pipe.-planCacheStats"><code>$planCacheStats</code></a></td>
<td align="left">返回集合的<a href="https://docs.mongodb.com/manual/core/query-plans/">计划缓存</a>信息。</td>
</tr>
<tr>
<td align="left"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/project/#mongodb-pipeline-pipe.-project"><code>$project</code></a></td>
<td align="left">重塑流中的每个文档，例如通过添加新字段或删除现有字段。对于每个输入文档，输出一个文档。另请参阅<a href="https://docs.mongodb.com/manual/reference/operator/aggregation/unset/#mongodb-pipeline-pipe.-unset"><code>$unset</code></a>删除现有字段。</td>
</tr>
<tr>
<td align="left"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/replaceWith/#mongodb-pipeline-pipe.-replaceWith"><code>$replaceWith</code></a></td>
<td align="left">用指定的嵌入文档替换文档。该操作替换输入文档中的所有现有字段，包括该<code>_id</code>字段。指定嵌入在输入文档中的文档以将嵌入的文档提升到顶级。<a href="https://docs.mongodb.com/manual/reference/operator/aggregation/replaceWith/#mongodb-pipeline-pipe.-replaceWith"><code>$replaceWith</code></a>是<a href="https://docs.mongodb.com/manual/reference/operator/aggregation/replaceRoot/#mongodb-pipeline-pipe.-replaceRoot"><code>$replaceRoot</code></a>stage的别名 。</td>
</tr>
<tr>
<td align="left"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/sample/#mongodb-pipeline-pipe.-sample"><code>$sample</code></a></td>
<td align="left">从其输入中随机选择指定数量的文档。</td>
</tr>
<tr>
<td align="left"><a href="https://docs.atlas.mongodb.com/reference/atlas-search/query-syntax/#mongodb-pipeline-pipe.-search"><code>$search</code></a></td>
<td align="left">对<a href="https://docs.atlas.mongodb.com/reference/atlas-search/query-syntax/">Atlas</a> 集合中的一个或多个字段执行全文搜索 。笔记<code>$search</code> 仅适用于 MongoDB Atlas 集群，不适用于自管理部署。</td>
</tr>
<tr>
<td align="left"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/set/#mongodb-pipeline-pipe.-set"><code>$set</code></a></td>
<td align="left">向文档添加新字段。类似于 <a href="https://docs.mongodb.com/manual/reference/operator/aggregation/project/#mongodb-pipeline-pipe.-project"><code>$project</code></a>，<a href="https://docs.mongodb.com/manual/reference/operator/aggregation/set/#mongodb-pipeline-pipe.-set"><code>$set</code></a>对流中的每个文档进行整形；具体来说，通过向包含输入文档中现有字段和新添加字段的输出文档添加新字段。<a href="https://docs.mongodb.com/manual/reference/operator/aggregation/set/#mongodb-pipeline-pipe.-set"><code>$set</code></a>是<a href="https://docs.mongodb.com/manual/reference/operator/aggregation/addFields/#mongodb-pipeline-pipe.-addFields"><code>$addFields</code></a>stage的别名。</td>
</tr>
<tr>
<td align="left"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/skip/#mongodb-pipeline-pipe.-skip"><code>$skip</code></a></td>
<td align="left">跳过前<em>n 个</em>文档，其中<em>n</em>是指定的跳过编号，并将未修改的剩余文档传递到管道。对于每个输入文档，输出零个文档（对于前<em>n 个</em>文档）或一个文档（如果在前<em>n 个</em>文档之后）。</td>
</tr>
<tr>
<td align="left"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/sort/#mongodb-pipeline-pipe.-sort"><code>$sort</code></a></td>
<td align="left">按指定的排序键对文档流重新排序。只是顺序变了；文件保持不变。对于每个输入文档，输出一个文档。</td>
</tr>
<tr>
<td align="left"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/unionWith/#mongodb-pipeline-pipe.-unionWith"><code>$unionWith</code></a></td>
<td align="left">执行两个集合的并集；ie 将来自两个集合的管道结果合并为一个结果集。<em>4.4版中的新功能</em>。</td>
</tr>
<tr>
<td align="left"><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/unset/#mongodb-pipeline-pipe.-unset"><code>$unset</code></a></td>
<td align="left">从文档中删除/排除字段。<a href="https://docs.mongodb.com/manual/reference/operator/aggregation/unset/#mongodb-pipeline-pipe.-unset"><code>$unset</code></a>是<a href="https://docs.mongodb.com/manual/reference/operator/aggregation/project/#mongodb-pipeline-pipe.-project"><code>$project</code></a>删除字段的阶段的别名。</td>
</tr>
</tbody></table>
<p><a href="https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/">参考文档</a></p>
<h2 id="聚合管道表达式"><a href="#聚合管道表达式" class="headerlink" title="聚合管道表达式"></a>聚合管道表达式</h2><p><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/">参考文档</a></p>
]]></content>
      <categories>
        <category>NoSQL</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis文档摘要</title>
    <url>/2021/08/06/MyBatis%E6%96%87%E6%A1%A3%E6%91%98%E8%A6%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>MyBatis 的配置文件的层次结构：</p>
<ul>
<li>configuration（配置）<ul>
<li>properties（属性）</li>
<li>settings（设置）</li>
<li>typeAliases（类型别名）</li>
<li>typeHandlers（类型处理器）</li>
<li>objectFactory（对象工厂）</li>
<li>plugins（插件）</li>
<li>environments（环境配置）<ul>
<li>environment（环境变量）<ul>
<li>transactionManager（事务管理器）</li>
<li>dataSource（数据源）</li>
</ul>
</li>
</ul>
</li>
<li>databaseIdProvider（数据库厂商标识）</li>
<li>mappers（映射器）</li>
</ul>
</li>
</ul>
<h2 id="属性（properties）"><a href="#属性（properties）" class="headerlink" title="属性（properties）"></a>属性（properties）</h2><h2 id="设置（settings）"><a href="#设置（settings）" class="headerlink" title="设置（settings）"></a>设置（settings）</h2><h3 id="对象关系映射相关"><a href="#对象关系映射相关" class="headerlink" title="对象关系映射相关"></a>对象关系映射相关</h3><table>
<thead>
<tr>
<th align="left">设置名</th>
<th align="left">描述</th>
<th align="left">有效值</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">autoMappingBehavior</td>
<td align="left">指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示关闭自动映射；PARTIAL 只会自动映射没有定义嵌套结果映射的字段。 FULL 会自动映射任何复杂的结果集（无论是否嵌套）。</td>
<td align="left">NONE, PARTIAL, FULL</td>
<td align="left">PARTIAL</td>
</tr>
<tr>
<td align="left">mapUnderscoreToCamelCase</td>
<td align="left">是否开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn。</td>
<td align="left">true | false</td>
<td align="left">False</td>
</tr>
<tr>
<td align="left">autoMappingUnknownColumnBehavior</td>
<td align="left">指定发现自动映射目标未知列（或未知属性类型）的行为。<code>NONE</code>: 不做任何反应<code>WARNING</code>: 输出警告日志（<code>&#39;org.apache.ibatis.session.AutoMappingUnknownColumnBehavior&#39;</code> 的日志等级必须设置为 <code>WARN</code>）<code>FAILING</code>: 映射失败 (抛出 <code>SqlSessionException</code>)</td>
<td align="left">NONE, WARNING, FAILING</td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="缓存相关"><a href="#缓存相关" class="headerlink" title="缓存相关"></a>缓存相关</h3><table>
<thead>
<tr>
<th align="left">设置名</th>
<th align="left">描述</th>
<th align="left">有效值</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">cacheEnabled</td>
<td align="left">全局性地开启或关闭所有映射器配置文件中已配置的任何缓存。</td>
<td align="left">true | false</td>
<td>true</td>
</tr>
<tr>
<td align="left">localCacheScope</td>
<td align="left">MyBatis 利用本地缓存机制（Local Cache）防止循环引用和加速重复的嵌套查询。 默认值为 SESSION，会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地缓存将仅用于执行语句，对相同 SqlSession 的不同查询将不会进行缓存。</td>
<td align="left">SESSION | STATEMENT</td>
<td>SESSION</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td></td>
</tr>
</tbody></table>
<h3 id="数据库连接与执行器相关"><a href="#数据库连接与执行器相关" class="headerlink" title="数据库连接与执行器相关"></a>数据库连接与执行器相关</h3><table>
<thead>
<tr>
<th align="left">设置名</th>
<th align="left">描述</th>
<th align="left">有效值</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">defaultStatementTimeout</td>
<td align="left">设置超时时间，它决定数据库驱动等待数据库响应的秒数。</td>
<td align="left">任意正整数</td>
<td>未设置 (null)</td>
</tr>
<tr>
<td align="left">defaultExecutorType</td>
<td align="left">配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（PreparedStatement）； BATCH 执行器不仅重用语句还会执行批量更新。</td>
<td align="left">SIMPLE REUSE BATCH</td>
<td>SIMPLE</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td></td>
</tr>
</tbody></table>
<h3 id="日志相关"><a href="#日志相关" class="headerlink" title="日志相关"></a>日志相关</h3><table>
<thead>
<tr>
<th align="left">设置名</th>
<th align="left">描述</th>
<th align="left">有效值</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">logPrefix</td>
<td align="left">指定 MyBatis 增加到日志名称的前缀。</td>
<td align="left">任何字符串</td>
<td>未设置</td>
</tr>
<tr>
<td align="left">logImpl</td>
<td align="left">指定 MyBatis 所用日志的具体实现，未指定时将自动查找。</td>
<td align="left">SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING</td>
<td>未设置</td>
</tr>
</tbody></table>
<h2 id="类型别名（typeAliases）"><a href="#类型别名（typeAliases）" class="headerlink" title="类型别名（typeAliases）"></a>类型别名（typeAliases）</h2><h2 id="类型处理器（typeHandlers）"><a href="#类型处理器（typeHandlers）" class="headerlink" title="类型处理器（typeHandlers）"></a>类型处理器（typeHandlers）</h2>]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>文档系列</tag>
      </tags>
  </entry>
  <entry>
    <title>List实现类源码分析 —— LinkedList、ArrayList</title>
    <url>/2021/07/24/List%E5%AE%9E%E7%8E%B0%E7%B1%BB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20%E2%80%94%E2%80%94%20LinkedList%E3%80%81ArrayList/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>系列的其他文章：</p>
<p><a href="http://47.117.127.179/categories/Java%E9%9B%86%E5%90%88%E7%B1%BB/">Java集合类</a></p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><p>可见LinkedList既是List接口的实现也是Queue的实现（Deque），故其和ArrayList相比LinkedList支持的功能更多，其可视作队列来使用。</p>
<p><img src="/2021/07/24/List%E5%AE%9E%E7%8E%B0%E7%B1%BB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20%E2%80%94%E2%80%94%20LinkedList%E3%80%81ArrayList/LinkedList.png" alt="LinkedList"></p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>也很简单，和我们自己实现的链表没什么差异。</p>
<p>为什么都被标记为<code>transient</code>呢 ？因为序列化以及反序列话的时候不需要真实的序列化Node节点，只需要序列化存储的真实的元素即可，然后反序列化的时候在new出Node节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 头尾节点</span></span><br><span class="line"><span class="comment">// 在列表空的时候，都为 null</span></span><br><span class="line"> <span class="keyword">transient</span> Node&lt;E&gt; first; <span class="comment">// 链表头</span></span><br><span class="line"> <span class="keyword">transient</span> Node&lt;E&gt; last;  <span class="comment">// 链表尾</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">     E item;       <span class="comment">// 真实元素</span></span><br><span class="line">     Node&lt;E&gt; next; <span class="comment">// 后继</span></span><br><span class="line">     Node&lt;E&gt; prev; <span class="comment">// 前驱</span></span><br><span class="line"></span><br><span class="line">     Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">         <span class="keyword">this</span>.item = element;</span><br><span class="line">         <span class="keyword">this</span>.next = next;</span><br><span class="line">         <span class="keyword">this</span>.prev = prev;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>值得一提的是，jdk实现中并没有使用一个始终存在的哑巴节点。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>这个构造函数没什么可说的。</p>
<h3 id="操作的时间复杂度"><a href="#操作的时间复杂度" class="headerlink" title="操作的时间复杂度"></a>操作的时间复杂度</h3><p>无论是get还是set等等，都是先查询对应的node，然后对它进行操作。</p>
<p>根据index要么从前面开始，要么从后面开始遍历链表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据下标返回Node, 这是链表使用下标访问的基本方法。</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据位置，从头或者从尾开始查找</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)。</p>
<p>所以说，<strong>LinkedList不适合随机读取，而时候在靠近头和尾的地方进行添加和删除（这是它最擅长的地方，所以用它来实现Deque很适合）</strong>。</p>
<h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><p>很简单。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="改"><a href="#改" class="headerlink" title="改"></a>改</h4><p>和上面是一样的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    E oldVal = x.item;</span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，如果不是靠近头尾的添加元素，虽然避免了在数组中移动元素，但是<code>node(index)</code>的开销仍然是O(n)的。</p>
<h4 id="删"><a href="#删" class="headerlink" title="删"></a>删</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用了<code>unlink</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next; <span class="comment">// 拿到后继</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev; <span class="comment">// 拿到前驱</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也很简单。</p>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><h3 id="继承关系-1"><a href="#继承关系-1" class="headerlink" title="继承关系"></a>继承关系</h3><p>如下图，<code>ArrayList</code>实现类List接口，注意其中有一个<code>RandomAccess</code>接口表明ArrayList支持随机访问。</p>
<p><img src="/2021/07/24/List%E5%AE%9E%E7%8E%B0%E7%B1%BB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20%E2%80%94%E2%80%94%20LinkedList%E3%80%81ArrayList/ArrayList.png" alt="ArrayList"></p>
<p>可见LinkedList既是List接口的实现也是Queue的实现（Deque），故其和ArrayList相比LinkedList支持的功能更多，其可视作队列来使用。</p>
<h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><p>很简单，和我们自己实现的vector啊之类的一样，数组保存真实结构，size保存个数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存储真实元素的数组缓冲区（这个数组的length也就是ArrayList的capacity）</span></span><br><span class="line"><span class="comment">// 注意它被 transient 修饰, 在序列化/反序列化的时候，需要手动处理数据的序列化 </span></span><br><span class="line"><span class="comment">// 而且注意到，这里不是泛型数组，因为处理泛型数组不方便, 比如上面的 EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储的元素的个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure>

<h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><p>默认情况下，会初始化为<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>，特点是一开始数组不占空间（当然除了数组对象本身占的空间），然后在第一次添加元素的时候一下子扩容到10。</p>
<p>那为什么又可以指定<code>initialCapacity</code>呢？</p>
<p>这是因为可以让程序员自己根据自己要处理数据的规模，提前一次性分配数组，防止反复扩容带来的性能开销。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 带初始化容量的构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    <span class="comment">// 可以显式的设置为0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认的初始化容量为 10, 但是为了防止空间浪费,所以在第一次添加元素的时才夸大容量至10</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="操作的时间复杂度-1"><a href="#操作的时间复杂度-1" class="headerlink" title="操作的时间复杂度"></a>操作的时间复杂度</h3><p>数据结构无外乎增删改查，依次来看就好。</p>
<h4 id="查-1"><a href="#查-1" class="headerlink" title="查"></a>查</h4><p>检查下标的合法性，取出元素强转即可，很简单。</p>
<p>时间复杂度O(1)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"> <span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// getter</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">     rangeCheck(index);</span><br><span class="line">     <span class="keyword">return</span> elementData(index);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h4 id="改-1"><a href="#改-1" class="headerlink" title="改"></a>改</h4><p>和上面一样的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// setter</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">      rangeCheck(index);</span><br><span class="line"></span><br><span class="line">      E oldValue = elementData(index);</span><br><span class="line">      elementData[index] = element;</span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<h4 id="增-1"><a href="#增-1" class="headerlink" title="增"></a>增</h4><p>分两种情况。</p>
<p><strong>直接添加</strong></p>
<p>很简单，数组末尾加一个元素即可。</p>
<p>时间复杂度：O(1)</p>
<p>其中<code>ensureCapacityInternal</code>是一个和扩容有关的函数，后面还会详解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add元素，可能需要扩容</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>在数组中间添加</strong></p>
<p>先将后面的元素挪一下，然后set元素。</p>
<p><img src="/2021/07/24/List%E5%AE%9E%E7%8E%B0%E7%B1%BB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20%E2%80%94%E2%80%94%20LinkedList%E3%80%81ArrayList/add.jpg" alt="add"></p>
<p>时间复杂度：O(n)，（小心使用，尤其在做算法题时）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 批量移动</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意使用这个native的方法移动数组元素而不是自己写java代码（内部实现更快）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Object dest, <span class="keyword">int</span> destPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure>



<h4 id="删-1"><a href="#删-1" class="headerlink" title="删"></a>删</h4><p>这个逻辑和上面也是类似的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><p>关于扩容，有这么几个方法<code>ensureCapacityInternal</code>,<code>calculateCapacity</code>,<code>ensureExplicitCapacity</code>,<code>grow</code>,</p>
<p><code>hugeCapacity</code>。</p>
<p>不过最核心的扩容方法是<code>grow</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 扩容的核心函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// 每次至少扩容至 1.5倍，所以不会出现每次 add 操作都要扩容复制的情况</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">// 此时1.5*oldCapacity 已超过 MAX_ARRAY_SIZE</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity); <span class="comment">// 每一次扩容都会复制原来的数组，开销很大</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>那么反复添加元素导致数组扩容之后又去删除元素导致数组大量闲置空间怎么办，</p>
<p>有这么个方法，<code>trimToSize()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将 elementData 的大小缩小至 size，以节省空间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">        elementData = (size == <span class="number">0</span>)</span><br><span class="line">          ? EMPTY_ELEMENTDATA</span><br><span class="line">          : Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过需要注意的是，这个方法内部从未调用（原因也很好理解，要是每次remove之后都去trimsize然后又add扩容不是反复横跳了吗），所以此方法只供程序员自己显式调用。</p>
<h1 id="源码要点"><a href="#源码要点" class="headerlink" title="源码要点"></a>源码要点</h1><h2 id="关于GC"><a href="#关于GC" class="headerlink" title="关于GC"></a>关于GC</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes all of the elements from this list.</span></span><br><span class="line"><span class="comment"> * The list will be empty after this call returns.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Clearing all of the links between nodes is &quot;unnecessary&quot;, but:</span></span><br><span class="line">    <span class="comment">// - helps a generational GC if the discarded nodes inhabit</span></span><br><span class="line">    <span class="comment">//   more than one generation</span></span><br><span class="line">    <span class="comment">// - is sure to free memory even if there is a reachable Iterator</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">        Node&lt;E&gt; next = x.next;</span><br><span class="line">        x.item = <span class="keyword">null</span>;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">        x = next;</span><br><span class="line">    &#125;</span><br><span class="line">    first = last = <span class="keyword">null</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        elementData[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="序列化-反序列化"><a href="#序列化-反序列化" class="headerlink" title="序列化/反序列化"></a>序列化/反序列化</h2><h3 id="LinkedList的序列化实现"><a href="#LinkedList的序列化实现" class="headerlink" title="LinkedList的序列化实现"></a>LinkedList的序列化实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Write out any hidden serialization magic</span></span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out size</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">        s.writeObject(x.item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// Read in any hidden serialization magic</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in size</span></span><br><span class="line">    <span class="keyword">int</span> size = s.readInt();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        linkLast((E)s.readObject());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ArrayList的序列化实现"><a href="#ArrayList的序列化实现" class="headerlink" title="ArrayList的序列化实现"></a>ArrayList的序列化实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in capacity</span></span><br><span class="line">    s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">        <span class="keyword">int</span> capacity = calculateCapacity(elementData, size);</span><br><span class="line">        SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);</span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="迭代器实现"><a href="#迭代器实现" class="headerlink" title="迭代器实现"></a>迭代器实现</h2><h3 id="LinkedList的迭代器实现"><a href="#LinkedList的迭代器实现" class="headerlink" title="LinkedList的迭代器实现"></a>LinkedList的迭代器实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 省略了一些方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Node&lt;E&gt; lastReturned;</span><br><span class="line">        <span class="keyword">private</span> Node&lt;E&gt; next;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> nextIndex;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">        ListItr(<span class="keyword">int</span> index) &#123;</span><br><span class="line">            <span class="comment">// assert isPositionIndex(index);</span></span><br><span class="line">            next = (index == size) ? <span class="keyword">null</span> : node(index);</span><br><span class="line">            nextIndex = index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nextIndex &lt; size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">if</span> (!hasNext())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"></span><br><span class="line">            lastReturned = next;</span><br><span class="line">            next = next.next;</span><br><span class="line">            nextIndex++;</span><br><span class="line">            <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">if</span> (lastReturned == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line"></span><br><span class="line">            Node&lt;E&gt; lastNext = lastReturned.next;</span><br><span class="line">            unlink(lastReturned);</span><br><span class="line">            <span class="keyword">if</span> (next == lastReturned)</span><br><span class="line">                next = lastNext;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nextIndex--;</span><br><span class="line">            lastReturned = <span class="keyword">null</span>;</span><br><span class="line">            expectedModCount++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="ArrayList的迭代器实现"><a href="#ArrayList的迭代器实现" class="headerlink" title="ArrayList的迭代器实现"></a>ArrayList的迭代器实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    Itr() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">int</span> i = cursor;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        cursor = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        checkForComodification(); <span class="comment">// remove 操作会检查mod-count以支持支持fast-fail机制</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">            cursor = lastRet;</span><br><span class="line">            lastRet = -<span class="number">1</span>;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// modCount 计数器检查，支持 fail-fast 机制</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="源码阅读笔记"><a href="#源码阅读笔记" class="headerlink" title="源码阅读笔记"></a>源码阅读笔记</h1><h2 id="LinkedList-1"><a href="#LinkedList-1" class="headerlink" title="LinkedList"></a>LinkedList</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现了 List 接口、Deque接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  	</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">  	<span class="comment">// 头尾节点</span></span><br><span class="line">  	<span class="comment">// 在列表空的时候，都为 null</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"> 	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 用一个集合初始化LinkedList</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将 e 插入表头</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">        first = newNode;</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span>) <span class="comment">// 此时 first,last 都为 null</span></span><br><span class="line">            last = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            f.prev = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 e 插入表尾</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">        last = newNode;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将元素 e 插入非null节点之前</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert succ != null;</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">        succ.prev = newNode;</span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   	<span class="comment">// 移除首节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">        <span class="keyword">final</span> E element = f.item;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">        f.item = <span class="keyword">null</span>;</span><br><span class="line">        f.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">        first = next;</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">            last = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            next.prev = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   	<span class="comment">// 移除尾节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert l == last &amp;&amp; l != null;</span></span><br><span class="line">        <span class="keyword">final</span> E element = l.item;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">        l.item = <span class="keyword">null</span>;</span><br><span class="line">        l.prev = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">        last = prev;</span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</span><br><span class="line">            first = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            prev.next = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除中间节点</span></span><br><span class="line">    <span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert x != null;</span></span><br><span class="line">        <span class="keyword">final</span> E element = x.item;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">            first = next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev.next = next;</span><br><span class="line">            x.prev = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            last = prev;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next.prev = prev;</span><br><span class="line">            x.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        x.item = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> f.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> l.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        linkFirst(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        linkLast(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> indexOf(o) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        linkLast(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表删除equals o 的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过Collection的toArray方法，将 c 包含的元素加入链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">        <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        Node&lt;E&gt; pred, succ;</span><br><span class="line">        <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">            succ = <span class="keyword">null</span>;</span><br><span class="line">            pred = last;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            succ = node(index);</span><br><span class="line">            pred = succ.prev;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> E e = (E) o;</span><br><span class="line">            Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">                first = newNode;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pred.next = newNode;</span><br><span class="line">            pred = newNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">            last = pred;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pred.next = succ;</span><br><span class="line">            succ.prev = pred;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        size += numNew;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes all of the elements from this list.</span></span><br><span class="line"><span class="comment">     * The list will be empty after this call returns.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Clearing all of the links between nodes is &quot;unnecessary&quot;, but:</span></span><br><span class="line">        <span class="comment">// - helps a generational GC if the discarded nodes inhabit</span></span><br><span class="line">        <span class="comment">//   more than one generation</span></span><br><span class="line">        <span class="comment">// - is sure to free memory even if there is a reachable Iterator</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">            Node&lt;E&gt; next = x.next;</span><br><span class="line">            x.item = <span class="keyword">null</span>;</span><br><span class="line">            x.next = <span class="keyword">null</span>;</span><br><span class="line">            x.prev = <span class="keyword">null</span>;</span><br><span class="line">            x = next;</span><br><span class="line">        &#125;</span><br><span class="line">        first = last = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于位置的随机访问，依赖 node(int index)方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        <span class="keyword">return</span> node(index).item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        Node&lt;E&gt; x = node(index);</span><br><span class="line">        E oldVal = x.item;</span><br><span class="line">        x.item = element;</span><br><span class="line">        <span class="keyword">return</span> oldVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index == size)</span><br><span class="line">            linkLast(element);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            linkBefore(element, node(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元素的合法下标</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isElementIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt; size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 操作位置的合法下标</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 报错信息</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">outOfBoundsMsg</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Index: &quot;</span>+index+<span class="string">&quot;, Size: &quot;</span>+size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对判定的方法的调用，抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkElementIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isElementIndex(index))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对判定的方法的调用，抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isPositionIndex(index))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据下标返回Node, 这是链表使用下标访问的基本方法。</span></span><br><span class="line">    <span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据位置，从头或者从尾开始查找</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">            Node&lt;E&gt; x = first;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">                x = x.next;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;E&gt; x = last;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">                x = x.prev;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 遍历即可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 倒过来遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = size;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">                index--;</span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">                index--;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Queue 的方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">element</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getFirst();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> add(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Deque 的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        addFirst(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        addLast(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : l.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkLast(l);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        addFirst(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除第一次出现的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeFirstOccurrence</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> remove(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除最后一次出现的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeLastOccurrence</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListItr(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        省略了 ListIterator 的实现代码</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">  	<span class="comment">// 私有静态内部类 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        E item; <span class="comment">// 真实元素</span></span><br><span class="line">        Node&lt;E&gt; next; <span class="comment">// 前驱</span></span><br><span class="line">        Node&lt;E&gt; prev; <span class="comment">// 后继</span></span><br><span class="line">				<span class="comment">// 前驱、元素、后继</span></span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.item = element;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">            <span class="keyword">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">		<span class="comment">// 返回包含所有元素数组		</span></span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">        Object[] result = <span class="keyword">new</span> Object[size];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">            result[i++] = x.item;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   	<span class="comment">// 通过反射的方式根据传入泛型数组的对象类型来返回一个泛型数组</span></span><br><span class="line">  	<span class="comment">// 和上面的toArray()的区别在于泛型的引入，以及这个方法可能会改变 泛型数组a </span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">            a = (T[])java.lang.reflect.Array.newInstance(</span><br><span class="line">                                a.getClass().getComponentType(), size);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        Object[] result = a;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">            result[i++] = x.item;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">            a[size] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">876323262645176354L</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ArrayList-1"><a href="#ArrayList-1" class="headerlink" title="ArrayList"></a>ArrayList</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现了List接口，但它没有实现 Deque接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认的初始化数组容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也是空数组，但是可以在第一次添加元素的时候，扩容至10（DEFAULT_CAPACITY</span></span><br><span class="line">）</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储真实元素的数组缓冲区（这个数组的length也就是ArrayList的capacity）</span></span><br><span class="line">    <span class="comment">// 注意它被 transient 修饰, 在序列化/反序列化的时候，需要手动处理数据的序列化 </span></span><br><span class="line">    <span class="comment">// 而且注意到，这里不是泛型数组，因为处理泛型数组不方便, 比如上面的 EMPTY_ELEMENTDATA</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储的元素的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带初始化容量的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        <span class="comment">// 可以显式的设置为0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认的初始化容量为 10, 但是为了防止空间浪费,所以在第一次添加元素的时才夸大容量至10</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 Arrays.copyOf 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="keyword">if</span> ((size = a.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c.getClass() == ArrayList.class) &#123;</span><br><span class="line">                elementData = a;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 调用 Arrays 的静态方法</span></span><br><span class="line">                elementData = Arrays.copyOf(a, size, Object[].class);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// replace with empty array.</span></span><br><span class="line">            elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 elementData 的大小缩小至 size，以节省空间</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">            elementData = (size == <span class="number">0</span>)</span><br><span class="line">              ? EMPTY_ELEMENTDATA</span><br><span class="line">              : Arrays.copyOf(elementData, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公有的、扩大容量的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">            <span class="comment">// any size if not default element table</span></span><br><span class="line">            ? <span class="number">0</span></span><br><span class="line">            <span class="comment">// larger than default for default empty table. It&#x27;s already</span></span><br><span class="line">            <span class="comment">// supposed to be at default size.</span></span><br><span class="line">            : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">            ensureExplicitCapacity(minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算最小容量</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用下面的方法，供内部调用, 确保至少 minCapacity 的容量（在扩容时需要）</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 grow 方法，而且此方法 modCount++</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容的核心函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="comment">// 每次至少扩容至 1.5倍，所以不会出现每次 add 操作都要扩容复制的情况</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="comment">// 此时1.5*oldCapacity 已超过 MAX_ARRAY_SIZE</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 克隆数组，但是数组元素本身还是浅拷贝</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">            v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">            v.modCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="comment">// this shouldn&#x27;t happen, since we are Cloneable</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能直接提供 elementData</span></span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在a容量不够时，创建一个新数组；否则原地复制</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">            <span class="comment">// Make a new array of a&#x27;s runtime type, but my contents:</span></span><br><span class="line">            <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">        System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">        <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">            a[size] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据位置来访问</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 Object 到泛型的强转</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> elementData(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setter</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add元素，可能需要扩容</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 批量移动</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                         size - index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 批量移动, 注意GC问题</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear to let GC do its work</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            elementData[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先扩容，再复制</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                             numMoved);</span><br><span class="line"></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除对应区间的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">int</span> numMoved = size - toIndex;</span><br><span class="line">        System.arraycopy(elementData, toIndex, elementData, fromIndex,</span><br><span class="line">                         numMoved);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear to let GC do its work</span></span><br><span class="line">        <span class="keyword">int</span> newSize = size - (toIndex-fromIndex);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = newSize; i &lt; size; i++) &#123;</span><br><span class="line">            elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size = newSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 检查下标的合法范围</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同上</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">outOfBoundsMsg</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Index: &quot;</span>+index+<span class="string">&quot;, Size: &quot;</span>+size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取ArrayList的子区间的视图，注意它返回的是仅是List接口的SubList内部类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">        subListRangeCheck(fromIndex, toIndex, size);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SubList(<span class="keyword">this</span>, <span class="number">0</span>, fromIndex, toIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 传入比较器，进行排序，如果 c == null,就将元素强转为</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">        Arrays.sort((E[]) elementData, <span class="number">0</span>, size, c);</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java集合类</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Java集合类</tag>
        <tag>源码系列</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis源码剖析 —— executor 包相关之Executor、Statement</title>
    <url>/2021/08/08/MyBatis%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%20%E2%80%94%E2%80%94%20executor%20%E5%8C%85%E7%9B%B8%E5%85%B3%20%E2%80%94%E2%80%94%20Executor%E3%80%81Statement/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Executor相关"><a href="#Executor相关" class="headerlink" title="Executor相关"></a>Executor相关</h1><p>只列出了两个有代表性的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.ibatis.executor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey cacheKey, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法参数里，有一个重要的 MappedStatement， 这个实际上就是在<strong>xml里写的sql语句的包装类</strong>。</p>
<p>来看一看它的实现类</p>
<h2 id="BaseExecutor"><a href="#BaseExecutor" class="headerlink" title="BaseExecutor"></a>BaseExecutor</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.ibatis.executor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> Transaction transaction;</span><br><span class="line">  <span class="keyword">protected</span> Executor wrapper;</span><br><span class="line">  <span class="keyword">protected</span> Configuration configuration;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// executor 的 commmit、rollback 都去调 transaction 的 commit()、rollback()</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (required) &#123;</span><br><span class="line">      transaction.commit();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"> 		 <span class="comment">// ...    </span></span><br><span class="line">          transaction.rollback();</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 增删改查最终都调用这两个方法，具体实现由 ExecutorType 这个枚举量决定</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">doUpdate</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="SimpleExecutor"><a href="#SimpleExecutor" class="headerlink" title="SimpleExecutor"></a>SimpleExecutor</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.ibatis.executor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleExecutor</span> <span class="keyword">extends</span> <span class="title">BaseExecutor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SimpleExecutor</span><span class="params">(Configuration configuration, Transaction transaction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(configuration, transaction);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doUpdate</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Configuration configuration = ms.getConfiguration();</span><br><span class="line">      <span class="comment">// 获取 Statement 处理器， 注意这里传入了参数 MappedStatement，parameter</span></span><br><span class="line">      StatementHandler handler = configuration.newStatementHandler(<span class="keyword">this</span>, ms, parameter, RowBounds.DEFAULT, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">      stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">      <span class="comment">// 最终用 Statement处理器去处理 Statement</span></span><br><span class="line">      <span class="keyword">return</span> handler.update(stmt);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      closeStatement(stmt);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 与上面一样的做法</span></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Statement <span class="title">prepareStatement</span><span class="params">(StatementHandler handler, Log statementLog)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt;</span><br><span class="line">    Connection connection = getConnection(statementLog);</span><br><span class="line">    stmt = handler.prepare(connection, transaction.getTimeout());</span><br><span class="line">    <span class="comment">// 填充参数（如果是 Prepared型的Statement的话）</span></span><br><span class="line">    handler.parameterize(stmt);</span><br><span class="line">    <span class="keyword">return</span> stmt;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>具体的实现类其实由 ExecutorType 的三种类型确定，可以通过配置文件里的 settings 的 defaultExecutorType 来配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ExecutorType</span> </span>&#123;</span><br><span class="line">  SIMPLE, REUSE, BATCH</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里不再细述其他两种。</p>
<h1 id="Statement相关"><a href="#Statement相关" class="headerlink" title="Statement相关"></a>Statement相关</h1><p>这个不是mybatis里定义的东西，而是<code>java.sql</code>里定义的接口。</p>
<p><strong>用于执行静态 SQL 语句并返回它产生的结果的对象。</strong></p>
<p>它有众多和数据源相关的实现类，比如<code>com.mysql.cj.jdbc.StatementImpl</code>就是和mysql交互的statement。</p>
<h2 id="StatementHandler"><a href="#StatementHandler" class="headerlink" title="StatementHandler"></a>StatementHandler</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.ibatis.executor.statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StatementHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获得Statement，数据库连接、事务超时时间 </span></span><br><span class="line">  <span class="function">Statement <span class="title">prepare</span><span class="params">(Connection connection, Integer transactionTimeout)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 参数化“语句”</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">parameterize</span><span class="params">(Statement statement)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行 Statement 的 update 操作</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(Statement statement)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行 查询操作</span></span><br><span class="line">  &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="function">BoundSql <span class="title">getBoundSql</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">ParameterHandler <span class="title">getParameterHandler</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="BaseStatementHandler"><a href="#BaseStatementHandler" class="headerlink" title="BaseStatementHandler"></a>BaseStatementHandler</h2><p>抽象类，实现了 StatementHandler 部分方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.ibatis.executor.statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseStatementHandler</span> <span class="keyword">implements</span> <span class="title">StatementHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> Configuration configuration;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> ObjectFactory objectFactory;             <span class="comment">// 对象工厂，负责通过反射的方式生成对象</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> TypeHandlerRegistry typeHandlerRegistry; <span class="comment">// 类型处理器工厂</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> ResultSetHandler resultSetHandler;       <span class="comment">// 结果集处理器</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> ParameterHandler parameterHandler;       <span class="comment">// 参数处理器</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> Executor executor;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> MappedStatement mappedStatement;         <span class="comment">// 从 xml 读取来的 sql语句的包装类</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> RowBounds rowBounds;        </span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> BoundSql boundSql;                             <span class="comment">// 处理任何Mybatis的动态sql标签后，从SqlSource获得的实际 SQL 字符串</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="title">BaseStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// ...</span></span><br><span class="line">    <span class="comment">// 从配置类获取</span></span><br><span class="line">    <span class="keyword">this</span>.typeHandlerRegistry = configuration.getTypeHandlerRegistry();</span><br><span class="line">    <span class="keyword">this</span>.objectFactory = configuration.getObjectFactory();</span><br><span class="line">    <span class="keyword">if</span> (boundSql == <span class="keyword">null</span>) &#123; <span class="comment">// issue #435, get the key before calculating the statement</span></span><br><span class="line">      generateKeys(parameterObject);</span><br><span class="line">      boundSql = mappedStatement.getBoundSql(parameterObject);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.boundSql = boundSql;</span><br><span class="line">    <span class="comment">// 从配置类获取</span></span><br><span class="line">    <span class="keyword">this</span>.parameterHandler = configuration.newParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">    <span class="keyword">this</span>.resultSetHandler = configuration.newResultSetHandler(executor, mappedStatement, rowBounds, parameterHandler, resultHandler, boundSql);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Statement <span class="title">prepare</span><span class="params">(Connection connection, Integer transactionTimeout)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">      Statement statement = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// 调用初始化 Statement 参数，传入参数 connection</span></span><br><span class="line">      statement = instantiateStatement(connection);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 设置两个配置参数</span></span><br><span class="line">      setStatementTimeout(statement, transactionTimeout);</span><br><span class="line">      setFetchSize(statement);</span><br><span class="line">      <span class="keyword">return</span> statement;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Statement <span class="title">instantiateStatement</span><span class="params">(Connection connection)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setStatementTimeout</span><span class="params">(Statement stmt, Integer transactionTimeout)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    <span class="comment">// 设置 查询时间、事务时间</span></span><br><span class="line">    StatementUtil.applyTransactionTimeout(stmt, queryTimeout, transactionTimeout);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setFetchSize</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">			<span class="comment">// 调用 stmt.setFetchSize(fetchSize);</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">closeStatement</span><span class="params">(Statement statement)</span> </span>&#123;</span><br><span class="line">       statement.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成主键相关</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">generateKeys</span><span class="params">(Object parameter)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.ibatis.executor.statement;</span><br><span class="line"></span><br><span class="line"><span class="comment">// routing 路由</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoutingStatementHandler</span> <span class="keyword">implements</span> <span class="title">StatementHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> StatementHandler delegate;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RoutingStatementHandler</span><span class="params">(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据 不同的 StatementType 选择相应的StatementHandler接口的实现类 </span></span><br><span class="line">    <span class="keyword">switch</span> (ms.getStatementType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> STATEMENT:</span><br><span class="line">        delegate = <span class="keyword">new</span> SimpleStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> PREPARED:</span><br><span class="line">        delegate = <span class="keyword">new</span> PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> CALLABLE:</span><br><span class="line">        delegate = <span class="keyword">new</span> CallableStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Unknown statement type: &quot;</span> + ms.getStatementType());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.ibatis.executor.statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleStatementHandler</span> <span class="keyword">extends</span> <span class="title">BaseStatementHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    String sql = boundSql.getSql();</span><br><span class="line">    Object parameterObject = boundSql.getParameterObject();</span><br><span class="line">    KeyGenerator keyGenerator = mappedStatement.getKeyGenerator();</span><br><span class="line">    <span class="keyword">int</span> rows;</span><br><span class="line">    <span class="comment">// 调用 Statement的 execute 方法完成任务</span></span><br><span class="line">    <span class="keyword">if</span> (keyGenerator <span class="keyword">instanceof</span> Jdbc3KeyGenerator) &#123;</span><br><span class="line">      statement.execute(sql, Statement.RETURN_GENERATED_KEYS);</span><br><span class="line">      rows = statement.getUpdateCount();</span><br><span class="line">      keyGenerator.processAfter(executor, mappedStatement, statement, parameterObject);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (keyGenerator <span class="keyword">instanceof</span> SelectKeyGenerator) &#123;</span><br><span class="line">      statement.execute(sql);</span><br><span class="line">      rows = statement.getUpdateCount();</span><br><span class="line">      keyGenerator.processAfter(executor, mappedStatement, statement, parameterObject);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      statement.execute(sql);</span><br><span class="line">      rows = statement.getUpdateCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rows;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    String sql = boundSql.getSql();</span><br><span class="line">    <span class="comment">// 这里的sql已经完全是可执行的sql了，无需参数填充</span></span><br><span class="line">    statement.execute(sql);</span><br><span class="line">    <span class="comment">// 用结果集处理器处理 statement.getResultSet()</span></span><br><span class="line">    <span class="keyword">return</span> resultSetHandler.handleResultSets(statement);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 到最后还是要 调用 JDBC 的 Connection 的 createStatement 的方法</span></span><br><span class="line">  <span class="meta">@Override</span> </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Statement <span class="title">instantiateStatement</span><span class="params">(Connection connection)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mappedStatement.getResultSetType() == ResultSetType.DEFAULT) &#123;</span><br><span class="line">      <span class="keyword">return</span> connection.createStatement();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// JDBC 允许返回 ResultSet 的时候指定 ”结果集类型“—— ResultSetType， 这是一个枚举量</span></span><br><span class="line">      <span class="keyword">return</span> connection.createStatement(mappedStatement.getResultSetType().getValue(), ResultSet.CONCUR_READ_ONLY);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parameterize</span><span class="params">(Statement statement)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do none thing (因为这是 ”简单型“的Statement处理器, 没有对占位符#&#123;&#125;进行处理)</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.ibatis.executor.statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreparedStatementHandler</span> <span class="keyword">extends</span> <span class="title">BaseStatementHandler</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 和上面的一样，只不过把关于 keyGenerator的部分放在了 instantiateStatement 罢了</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 和上面的一样</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Statement <span class="title">instantiateStatement</span><span class="params">(Connection connection)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    String sql = boundSql.getSql();</span><br><span class="line">    <span class="keyword">if</span> (mappedStatement.getKeyGenerator() <span class="keyword">instanceof</span> Jdbc3KeyGenerator) &#123;</span><br><span class="line">      String[] keyColumnNames = mappedStatement.getKeyColumns();</span><br><span class="line">      <span class="keyword">if</span> (keyColumnNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> connection.prepareStatement(sql, PreparedStatement.RETURN_GENERATED_KEYS);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> connection.prepareStatement(sql, keyColumnNames);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mappedStatement.getResultSetType() == ResultSetType.DEFAULT) &#123;</span><br><span class="line">      <span class="comment">// 注意 这里的sql 仍然会有 占位符，所以执行流程后面还要调用 parameterize</span></span><br><span class="line">      <span class="keyword">return</span> connection.prepareStatement(sql);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> connection.prepareStatement(sql, mappedStatement.getResultSetType().getValue(), ResultSet.CONCUR_READ_ONLY);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parameterize</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// 相比于 SimpleStatementHandler 多了一个占位符的填充参数</span></span><br><span class="line">    parameterHandler.setParameters((PreparedStatement) statement);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>框架源码系列</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis源码剖析 —— mapping 包相关</title>
    <url>/2021/08/08/MyBatis%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%20%E2%80%94%E2%80%94%20mapping-%E5%8C%85%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.ibatis.mapping;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedStatement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String resource;</span><br><span class="line">  <span class="keyword">private</span> Configuration configuration;</span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line">  <span class="keyword">private</span> Integer fetchSize;</span><br><span class="line">  <span class="keyword">private</span> Integer timeout;</span><br><span class="line">  <span class="keyword">private</span> StatementType statementType;</span><br><span class="line">  <span class="keyword">private</span> ResultSetType resultSetType;</span><br><span class="line">  <span class="keyword">private</span> SqlSource sqlSource;</span><br><span class="line">  <span class="keyword">private</span> Cache cache;</span><br><span class="line">  <span class="keyword">private</span> ParameterMap parameterMap;</span><br><span class="line">  <span class="keyword">private</span> List&lt;ResultMap&gt; resultMaps;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> flushCacheRequired;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> useCache;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> resultOrdered;</span><br><span class="line">  <span class="keyword">private</span> SqlCommandType sqlCommandType;</span><br><span class="line">  <span class="keyword">private</span> KeyGenerator keyGenerator;</span><br><span class="line">  <span class="keyword">private</span> String[] keyProperties;</span><br><span class="line">  <span class="keyword">private</span> String[] keyColumns;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> hasNestedResultMaps;</span><br><span class="line">  <span class="keyword">private</span> String databaseId;</span><br><span class="line">  <span class="keyword">private</span> Log statementLog;</span><br><span class="line">  <span class="keyword">private</span> LanguageDriver lang;</span><br><span class="line">  <span class="keyword">private</span> String[] resultSets;</span><br><span class="line"></span><br><span class="line">  MappedStatement() &#123;</span><br><span class="line">    <span class="comment">// constructor disabled</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MappedStatement mappedStatement = <span class="keyword">new</span> MappedStatement();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(Configuration configuration, String id, SqlSource sqlSource, SqlCommandType sqlCommandType)</span> </span>&#123;</span><br><span class="line">      mappedStatement.configuration = configuration;</span><br><span class="line">      mappedStatement.id = id;</span><br><span class="line">      mappedStatement.sqlSource = sqlSource;</span><br><span class="line">      mappedStatement.statementType = StatementType.PREPARED;</span><br><span class="line">      mappedStatement.resultSetType = ResultSetType.DEFAULT;</span><br><span class="line">      mappedStatement.parameterMap = <span class="keyword">new</span> ParameterMap.Builder(configuration, <span class="string">&quot;defaultParameterMap&quot;</span>, <span class="keyword">null</span>, <span class="keyword">new</span> ArrayList&lt;&gt;()).build();</span><br><span class="line">      mappedStatement.resultMaps = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      mappedStatement.sqlCommandType = sqlCommandType;</span><br><span class="line">      mappedStatement.keyGenerator = configuration.isUseGeneratedKeys() &amp;&amp; SqlCommandType.INSERT.equals(sqlCommandType) ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;</span><br><span class="line">      String logId = id;</span><br><span class="line">      <span class="keyword">if</span> (configuration.getLogPrefix() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        logId = configuration.getLogPrefix() + id;</span><br><span class="line">      &#125;</span><br><span class="line">      mappedStatement.statementLog = LogFactory.getLog(logId);</span><br><span class="line">      mappedStatement.lang = configuration.getDefaultScriptingLanguageInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">resource</span><span class="params">(String resource)</span> </span>&#123;</span><br><span class="line">      mappedStatement.resource = resource;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">id</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> mappedStatement.id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">parameterMap</span><span class="params">(ParameterMap parameterMap)</span> </span>&#123;</span><br><span class="line">      mappedStatement.parameterMap = parameterMap;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">resultMaps</span><span class="params">(List&lt;ResultMap&gt; resultMaps)</span> </span>&#123;</span><br><span class="line">      mappedStatement.resultMaps = resultMaps;</span><br><span class="line">      <span class="keyword">for</span> (ResultMap resultMap : resultMaps) &#123;</span><br><span class="line">        mappedStatement.hasNestedResultMaps = mappedStatement.hasNestedResultMaps || resultMap.hasNestedResultMaps();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">fetchSize</span><span class="params">(Integer fetchSize)</span> </span>&#123;</span><br><span class="line">      mappedStatement.fetchSize = fetchSize;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">timeout</span><span class="params">(Integer timeout)</span> </span>&#123;</span><br><span class="line">      mappedStatement.timeout = timeout;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">statementType</span><span class="params">(StatementType statementType)</span> </span>&#123;</span><br><span class="line">      mappedStatement.statementType = statementType;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">resultSetType</span><span class="params">(ResultSetType resultSetType)</span> </span>&#123;</span><br><span class="line">      mappedStatement.resultSetType = resultSetType == <span class="keyword">null</span> ? ResultSetType.DEFAULT : resultSetType;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">cache</span><span class="params">(Cache cache)</span> </span>&#123;</span><br><span class="line">      mappedStatement.cache = cache;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">flushCacheRequired</span><span class="params">(<span class="keyword">boolean</span> flushCacheRequired)</span> </span>&#123;</span><br><span class="line">      mappedStatement.flushCacheRequired = flushCacheRequired;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">useCache</span><span class="params">(<span class="keyword">boolean</span> useCache)</span> </span>&#123;</span><br><span class="line">      mappedStatement.useCache = useCache;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">resultOrdered</span><span class="params">(<span class="keyword">boolean</span> resultOrdered)</span> </span>&#123;</span><br><span class="line">      mappedStatement.resultOrdered = resultOrdered;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">keyGenerator</span><span class="params">(KeyGenerator keyGenerator)</span> </span>&#123;</span><br><span class="line">      mappedStatement.keyGenerator = keyGenerator;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">keyProperty</span><span class="params">(String keyProperty)</span> </span>&#123;</span><br><span class="line">      mappedStatement.keyProperties = delimitedStringToArray(keyProperty);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">keyColumn</span><span class="params">(String keyColumn)</span> </span>&#123;</span><br><span class="line">      mappedStatement.keyColumns = delimitedStringToArray(keyColumn);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">databaseId</span><span class="params">(String databaseId)</span> </span>&#123;</span><br><span class="line">      mappedStatement.databaseId = databaseId;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">lang</span><span class="params">(LanguageDriver driver)</span> </span>&#123;</span><br><span class="line">      mappedStatement.lang = driver;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">resultSets</span><span class="params">(String resultSet)</span> </span>&#123;</span><br><span class="line">      mappedStatement.resultSets = delimitedStringToArray(resultSet);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Resul sets.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resultSet</span></span><br><span class="line"><span class="comment">     *          the result set</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the builder</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span> Use &#123;<span class="doctag">@link</span> #resultSets&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">resulSets</span><span class="params">(String resultSet)</span> </span>&#123;</span><br><span class="line">      mappedStatement.resultSets = delimitedStringToArray(resultSet);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MappedStatement <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">assert</span> mappedStatement.configuration != <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">assert</span> mappedStatement.id != <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">assert</span> mappedStatement.sqlSource != <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">assert</span> mappedStatement.lang != <span class="keyword">null</span>;</span><br><span class="line">      mappedStatement.resultMaps = Collections.unmodifiableList(mappedStatement.resultMaps);</span><br><span class="line">      <span class="keyword">return</span> mappedStatement;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> KeyGenerator <span class="title">getKeyGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> keyGenerator;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> SqlCommandType <span class="title">getSqlCommandType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sqlCommandType;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> resource;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Configuration <span class="title">getConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> configuration;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNestedResultMaps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hasNestedResultMaps;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Integer <span class="title">getFetchSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fetchSize;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Integer <span class="title">getTimeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> timeout;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> StatementType <span class="title">getStatementType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> statementType;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ResultSetType <span class="title">getResultSetType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> resultSetType;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> SqlSource <span class="title">getSqlSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sqlSource;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ParameterMap <span class="title">getParameterMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> parameterMap;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;ResultMap&gt; <span class="title">getResultMaps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> resultMaps;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Cache <span class="title">getCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFlushCacheRequired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> flushCacheRequired;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUseCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> useCache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isResultOrdered</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> resultOrdered;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getDatabaseId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> databaseId;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String[] getKeyProperties() &#123;</span><br><span class="line">    <span class="keyword">return</span> keyProperties;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String[] getKeyColumns() &#123;</span><br><span class="line">    <span class="keyword">return</span> keyColumns;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Log <span class="title">getStatementLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> statementLog;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> LanguageDriver <span class="title">getLang</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lang;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String[] getResultSets() &#123;</span><br><span class="line">    <span class="keyword">return</span> resultSets;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Gets the resul sets.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the resul sets</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@deprecated</span> Use &#123;<span class="doctag">@link</span> #getResultSets()&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Deprecated</span></span><br><span class="line">  <span class="keyword">public</span> String[] getResulSets() &#123;</span><br><span class="line">    <span class="keyword">return</span> resultSets;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> BoundSql <span class="title">getBoundSql</span><span class="params">(Object parameterObject)</span> </span>&#123;</span><br><span class="line">    BoundSql boundSql = sqlSource.getBoundSql(parameterObject);</span><br><span class="line">    List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">    <span class="keyword">if</span> (parameterMappings == <span class="keyword">null</span> || parameterMappings.isEmpty()) &#123;</span><br><span class="line">      boundSql = <span class="keyword">new</span> BoundSql(configuration, boundSql.getSql(), parameterMap.getParameterMappings(), parameterObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check for nested result maps in parameter mappings (issue #30)</span></span><br><span class="line">    <span class="keyword">for</span> (ParameterMapping pm : boundSql.getParameterMappings()) &#123;</span><br><span class="line">      String rmId = pm.getResultMapId();</span><br><span class="line">      <span class="keyword">if</span> (rmId != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ResultMap rm = configuration.getResultMap(rmId);</span><br><span class="line">        <span class="keyword">if</span> (rm != <span class="keyword">null</span>) &#123;</span><br><span class="line">          hasNestedResultMaps |= rm.hasNestedResultMaps();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> boundSql;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> String[] delimitedStringToArray(String in) &#123;</span><br><span class="line">    <span class="keyword">if</span> (in == <span class="keyword">null</span> || in.trim().length() == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> in.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>框架源码系列</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis源码剖析 —— session 包相关</title>
    <url>/2021/08/06/MyBatis%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%20%E2%80%94%E2%80%94%20session%20%E5%8C%85%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="构建流程"><a href="#构建流程" class="headerlink" title="构建流程"></a>构建流程</h1><p>从 SqlSessionFactoryBuilder 构建 SqlSessionFactory。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream, String environment, Properties properties)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    XMLConfigBuilder parser = <span class="keyword">new</span> XMLConfigBuilder(inputStream, environment, properties);</span><br><span class="line">    <span class="keyword">return</span> build(parser.parse());</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(Configuration config)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSessionFactory(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h1><p><code>SqlSessionFactoryBuilder</code>仅用来构建SqlSessionFactory，</p>
<p>提供了一系列 build 方法（从各种来源，如输入流、配置类）等等构建SqlSessionFactory。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.ibatis.session;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionFactoryBuilder</span> </span>&#123;</span><br><span class="line">  <span class="comment">// build()方法簇</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(..)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="SqlSessionFactory接口、实现类"><a href="#SqlSessionFactory接口、实现类" class="headerlink" title="SqlSessionFactory接口、实现类"></a>SqlSessionFactory接口、实现类</h1><p>SqlSession工厂</p>
<h2 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h2><p>提供了一系列openSession()方法的接口，并接受一些连接属性，如autoCommit（是否自动提交）、TransactionIsolationLevel（事务的隔离级别）等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.ibatis.session;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SqlSessionFactory</span> </span>&#123;</span><br><span class="line">  <span class="comment">// openSession()方法簇</span></span><br><span class="line">  <span class="function">SqlSession <span class="title">openSession</span><span class="params">(..)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="DefaultSqlSessionFactory"><a href="#DefaultSqlSessionFactory" class="headerlink" title="DefaultSqlSessionFactory"></a>DefaultSqlSessionFactory</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.ibatis.session.defaults;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSqlSessionFactory</span> <span class="keyword">implements</span> <span class="title">SqlSessionFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Configuration configuration;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   以上省略实现接口的 openSession(..) 方法，</span></span><br><span class="line"><span class="comment">   均调用了 openSessionFromDataSource openSessionFromConnection 方法</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">    Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> Environment environment = configuration.getEnvironment();</span><br><span class="line">      <span class="comment">// 获取 事务管理器</span></span><br><span class="line">      <span class="keyword">final</span> TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">      <span class="comment">// 指定参数： 数据源、事务隔离级别、是否自动提交，获取事务</span></span><br><span class="line">      tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">      <span class="comment">// 获取 执行器</span></span><br><span class="line">      <span class="keyword">final</span> Executor executor = configuration.newExecutor(tx, execType);</span><br><span class="line">      <span class="comment">// 构造 session 并返回</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      closeTransaction(tx); <span class="comment">// may have fetched a connection so lets call close()</span></span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error opening session.  Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromConnection</span><span class="params">(ExecutorType execType, Connection connection)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 与上面的逻辑几乎一致，不过从 java.sql.Connection 可以获得很多信息如隔离级别、是否自动提交等信息</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据配置信息返回 transactionManager，否则返回默认的 ManagedTransactionFactory </span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> TransactionFactory <span class="title">getTransactionFactoryFromEnvironment</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (environment == <span class="keyword">null</span> || environment.getTransactionFactory() == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ManagedTransactionFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> environment.getTransactionFactory();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h1 id="SqlSession接口、实现类"><a href="#SqlSession接口、实现类" class="headerlink" title="SqlSession接口、实现类"></a>SqlSession接口、实现类</h1><p>SqlSession 接口</p>
<h2 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.ibatis.session;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">只摘取了部分方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SqlSession</span> <span class="keyword">extends</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 各种select语句</span></span><br><span class="line">  &lt;T&gt; <span class="function">T <span class="title">selectOne</span><span class="params">(String statement)</span></span>;</span><br><span class="line">  &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement)</span></span>;</span><br><span class="line">  &lt;K, V&gt; <span class="function">Map&lt;K, V&gt; <span class="title">selectMap</span><span class="params">(String statement, String mapKey)</span></span>;</span><br><span class="line">  &lt;T&gt; <span class="function">Cursor&lt;T&gt; <span class="title">selectCursor</span><span class="params">(String statement)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">select</span><span class="params">(String statement, ResultHandler handler)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 插入、更新、删除</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(String statement)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(String statement)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">delete</span><span class="params">(String statement)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 事务的提交、回滚</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> force)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(<span class="keyword">boolean</span> force)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 绑定到此 SqlSession 的映射器</span></span><br><span class="line">  &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type)</span></span>;</span><br><span class="line"> </span><br><span class="line">  <span class="function">Connection <span class="title">getConnection</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="DefaultSqlSession"><a href="#DefaultSqlSession" class="headerlink" title="DefaultSqlSession"></a>DefaultSqlSession</h2><p>SqlSession的默认实现类，注意此类线程不安全，所以同一个<code>DefaultSqlSession</code>实例不能作为多个线程共享的变量。</p>
<p>有两个重要的成员属性：configuration，executor。</p>
<p>configuration 获取绑定的sql语句，映射器等。</p>
<p>executor用于执行sql任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.ibatis.session.defaults;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 省略了部分字段、接口中的方法，以及异常处理，</span></span><br><span class="line"><span class="comment"> 只留下最关键的方法调用。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSqlSession</span> <span class="keyword">implements</span> <span class="title">SqlSession</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Configuration configuration;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Executor executor;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// select语句最终的实现方法</span></span><br><span class="line">  <span class="keyword">private</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds, ResultHandler handler)</span> </span>&#123;</span><br><span class="line">      MappedStatement ms = configuration.getMappedStatement(statement);</span><br><span class="line">      <span class="keyword">return</span> executor.query(ms, wrapCollection(parameter), rowBounds, handler);    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// update、delete、insert在处理的时候其实不加区分，最后都是调用这个方法（因为不需要对结果集进行对象映射）</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(String statement, Object parameter)</span> </span>&#123;</span><br><span class="line">      dirty = <span class="keyword">true</span>;</span><br><span class="line">      MappedStatement ms = configuration.getMappedStatement(statement);</span><br><span class="line">      <span class="keyword">return</span> executor.update(ms, wrapCollection(parameter));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> force)</span> </span>&#123;</span><br><span class="line">      executor.commit(isCommitOrRollbackRequired(force));</span><br><span class="line">      dirty = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">(<span class="keyword">boolean</span> force)</span> </span>&#123;</span><br><span class="line">      executor.rollback(isCommitOrRollbackRequired(force));</span><br><span class="line">      dirty = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据 xxxMapper.class 获取 xxxMapper的实例（代理生成的对象）</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> configuration.getMapper(type, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="SqlSessionManager"><a href="#SqlSessionManager" class="headerlink" title="SqlSessionManager"></a>SqlSessionManager</h2><p><code>SqlSessionManager</code>相比<code>SqlSession</code>而言，一方面做到了线程安全，另一方面避免了每次都需要 openSession(), 实现了对昂贵对象的复用。</p>
<p>通过 <code>Proxy</code> + <code>ThreadLocal</code> 的方式 代理对 <code>SqlSession</code> 的操作。</p>
<p>SqlSession 的使用要么从线程的本地变量里去取，要么用完即弃。这样，每个线程使用到的都是”独属于自己“的SqlSession了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.ibatis.session;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionManager</span> <span class="keyword">implements</span> <span class="title">SqlSessionFactory</span>, <span class="title">SqlSession</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从配置文件或者Java类生成的</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line">  <span class="comment">// 代理类</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SqlSession sqlSessionProxy;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 线程本地变量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;SqlSession&gt; localSqlSession = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">SqlSessionManager</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sqlSessionFactory = sqlSessionFactory;</span><br><span class="line">    <span class="comment">// Proxy.newProxyInstance</span></span><br><span class="line">    <span class="keyword">this</span>.sqlSessionProxy = (SqlSession) Proxy.newProxyInstance(</span><br><span class="line">        SqlSessionFactory.class.getClassLoader(),</span><br><span class="line">        <span class="keyword">new</span> Class[]&#123;SqlSession.class&#125;,</span><br><span class="line">        <span class="keyword">new</span> SqlSessionInterceptor());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 此方法可以直接绕过 SqlSessionFactoryBuilder的构造</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSessionManager <span class="title">newInstance</span><span class="params">(Reader reader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionManager(<span class="keyword">new</span> SqlSessionFactoryBuilder().build(reader, <span class="keyword">null</span>, <span class="keyword">null</span>));</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 设置线程本地量</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startManagedSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.localSqlSession.set(openSession());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从 threadLocal里去取</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isManagedSessionStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.localSqlSession.get() != <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 用代理对象调用，之后被 SqlSessionInterceptor 拦截</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">selectOne</span><span class="params">(String statement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sqlSessionProxy.selectOne(statement);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionInterceptor</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SqlSessionInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Prevent Synthetic Access</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先从本地拿, 有则直接用, 无则直接用一个新的 session 执行任务</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> SqlSession sqlSession = SqlSessionManager.<span class="keyword">this</span>.localSqlSession.get();</span><br><span class="line">      <span class="comment">// </span></span><br><span class="line">      <span class="keyword">if</span> (sqlSession != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> method.invoke(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">          <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (SqlSession autoSqlSession = openSession()) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Object result = method.invoke(autoSqlSession, args);</span><br><span class="line">            autoSqlSession.commit();</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            autoSqlSession.rollback();</span><br><span class="line">            <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="SqlSessionTemplate"><a href="#SqlSessionTemplate" class="headerlink" title="SqlSessionTemplate"></a>SqlSessionTemplate</h2><p>这个类在 org.mybatis.spring包中，也实现了 SqlSession接口，也是线程安全的。</p>
<p>不过，这个类在获得目标对象 SqlSession 的时候，并不是简单的从ThreadLocal里取，而是借助 <code>TransactionSynchronizationManager</code>去获取<code>SqlSessionHolder</code>再最终获得 <code>SqlSession</code>的。</p>
<p>这里不再赘述，放在spring 的事务管理里细述。</p>
<blockquote>
<p><a href="https://mybatis.org/mybatis-3/zh/getting-started.html">MyBatis 3 文档</a></p>
</blockquote>
]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>框架源码系列</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL系列—— InnoDB的MVCC机制</title>
    <url>/2021/10/31/MySQL%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94-InnoDB%E7%9A%84MVCC%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="事务并发执行时遇到的一致性问题"><a href="#事务并发执行时遇到的一致性问题" class="headerlink" title="事务并发执行时遇到的一致性问题"></a>事务并发执行时遇到的一致性问题</h2><ul>
<li>脏写</li>
</ul>
<p>一个事务修改了另一个未提交事务修改过的数据。</p>
<ul>
<li>脏读</li>
</ul>
<p>一个事务读到了另一个未提交事务修改过的数据。</p>
<ul>
<li>不可重复读</li>
</ul>
<p>一个事务多次读到的同一数据行的值不相同。</p>
<ul>
<li>幻读</li>
</ul>
<p>一个事务多次按照同一个搜索条件，读到了不同的数据行。</p>
<h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p>隔离级别描述了并发事务执行时对竞争数据的互相影响的程度。</p>
<p>最理想化的隔离应该每个事务执行时互不影响，互不干涉，就像数据库此时只为它一个事务使用似的。</p>
<p>不过，一般使用场景下，我们会<strong>舍弃一定的隔离性去换取一部分性能</strong>,</p>
<p>于是SQL标准设立的4个隔离级别，隔离级别越低，越有可能出现数据不一致的情况，不过并发性能也越高。</p>
<blockquote>
<p>注意，这是SQL指定的标准，不是MySQL指定的。</p>
<p>不同DBMS对隔离级别的支持也不一样。</p>
</blockquote>
<table>
<thead>
<tr>
<th>Isolation Level P1（隔离级别）</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>READ UNCOMMITTED （读未提交）</td>
<td>Possible</td>
<td>Possible</td>
<td>Possible</td>
</tr>
<tr>
<td>READ COMMITTED（读已提交）</td>
<td>Not Possible</td>
<td>Possible</td>
<td>Possible</td>
</tr>
<tr>
<td>REPEATABLE READ （可重复读）</td>
<td>Not Possible</td>
<td>Not Possible</td>
<td>Possible</td>
</tr>
<tr>
<td>SERIALIZABLE  （可序列化）</td>
<td>Not Possible</td>
<td>Not Possible</td>
<td>Not Possible</td>
</tr>
</tbody></table>
<p>在任何隔离级别下，脏写都是不可接受的，这是一个对一致性影响极大的操作。</p>
<p>MySQL会用锁去保证不会有两个并发事务同时修改一条记录。</p>
<p><strong>MySQL默认使用的隔离级别是REPEATABLE READ</strong>，而且MySQL的可重复读，可以在很大程度上禁止幻读现象的发生，但不能绝对禁止（后文会给出原因）。</p>
<h1 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h1><p>Multi-Version Concurrency Control（多版本并发控制），MySQL中如何实现？</p>
<p>对于<code>READ UNCOMMITTED </code>直接读取B+树的最新记录就好了，无需任何多余操作，很简单；</p>
<p>对于<code>SERIALIZABLE</code>是通过对select语句加共享锁的方式实现的，后面会详细将锁的实现与使用；</p>
<p>对于<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>的实现是比较复杂的，具体看下面的<strong>版本链+ReadView</strong>。</p>
<h2 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h2><ul>
<li>trx_id</li>
</ul>
<p>一个事务每次对某条聚簇索引进行更改的时候，都会把该事务的事务id赋值给trx_id列。</p>
<ul>
<li>roll_pointer</li>
</ul>
<p>每次对某条聚簇索引记录进行改动时，都会把旧的记录写入到undo日志中，这个隐藏列就相当于一个指针，可以通过它找到修改前的信息。</p>
<p><img src="/2021/10/31/MySQL%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94-InnoDB%E7%9A%84MVCC%E6%9C%BA%E5%88%B6/mvcc.png"></p>
<p>如上图，每一次修改记录，就会产生一条undo日志（当然在具体实现的时候是许多条undo log）,每个undo日志也有一个 roll_pointer，那么对于某一数据行，B+树中的行记录和undo日志就构成一条版本链。</p>
<p>这条版本链在MVCC机制中起到重要作用。</p>
<h2 id="ReadView（一致性视图）"><a href="#ReadView（一致性视图）" class="headerlink" title="ReadView（一致性视图）"></a>ReadView（一致性视图）</h2><p><code>READ COMMITTED</code>和<code>REPEATABLE READ</code>二者的一个共同的问题就是，如何判断版本链中的哪个版本是当前事务可见的。</p>
<p>MySQL设计出ReadView这样的数据结构解决这个问题。</p>
<p>它包括4个比较重要的概念：</p>
<ol>
<li><strong>m_ids</strong> : 生成此ReadView时，当前系统<strong>活跃的</strong>读写事务的事务id列表；</li>
<li><strong>min_trx_id</strong> ：生成此ReadView时，当前系统活跃的读写事务列表中最小的事务id，也就是m_ids中的最小值；</li>
<li><strong>max_trx_id</strong> ：生成此ReadView时，系统应该分配给下一个事务的事务id值；</li>
<li><strong>creator_trx_id</strong> ：生成此ReadView的事务id。</li>
</ol>
<p>有了这个ReadView，在访问某条记录时，采用下面的方式判断即可。</p>
<ol>
<li>如果被访问版本的<strong>trx_id和creator_trx_id相同</strong>，说明这个事务正在访问它自己修改过的记录，所以可见。</li>
<li>如果被访问版本的<strong>trx_id小于min_trx_id</strong>，说明生成此版本的事务在当前事务生成readview之前就已经提交了，自然也是可见的。</li>
<li>如果被访问版本的<strong>trx_id大于等于max_trx_id</strong>，表明生成此版本的事务在当前事务后才开启，所以不可见。</li>
<li>如果被访问版本的<strong>trx_id在min_trx_id-max_trx_id之间</strong>，那么需要判断trx_id是否在m_ids之间。如果在，说明此事务是活跃的，记录不可以被访问；如果不在，说明生成此已经结束，记录可见。</li>
<li>如果某个版本的记录对当前事务不可见，那么就顺着版本链往下找，并按照上面的方式判断可见性，直到遍历到最后一个版本返回空。</li>
</ol>
<p>那么具体怎么实现<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>呢？</p>
<p>实际上二者的区别就在于生成ReadView的时机不同。</p>
<p><code>READ COMMITTED</code>在每次赌球一条记录前都去生成ReadView，</p>
<p><code>REPEATABLE READ</code>则在第一次读取数据的时候生成ReadView（不过可以使用<code>WITH CONSISTENT SANPSHOT</code>指定一开启事务就生成ReadView）。</p>
<h2 id="二级索引和MVCC"><a href="#二级索引和MVCC" class="headerlink" title="二级索引和MVCC"></a>二级索引和MVCC</h2><p>注意只有聚簇索引记录才有 trx_id和roll_pointer。那么如果使用二级索引查询记录如何判断可见性呢？</p>
<ol>
<li>二级索引页面的Page Header部分有一个PAGE_MAX_TRX_ID的属性，它代表着<strong>修改</strong>该二级索引页面的最大事务id。如果此<code>PAGE_MAX_TRX_ID</code>是小于min_trx_id的，说明整个页面对当前事务都是可见的，判断完毕。</li>
<li>否则， 根据二级索引的主键值执行回表操作，得到对应的聚簇索引记录根据前面的方法判断可见性，然后对第一个可见的记录判断是否和利用二级索引查询的索引列的值相匹配，匹配，则此条记录可见；否则继续往下找，<strong>直到聚簇索引记录可见同时二级索引匹配条件满足</strong>。</li>
</ol>
<blockquote>
<p><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-95-51.pdf">A Critique of ANSI SQL Isolation Levels</a></p>
<p><a href="https://blog.csdn.net/hhc9_9/article/details/109394221">Mysql8.0下验证mysql的四种隔离级别</a></p>
<p>《MySQL是怎样运行的》</p>
</blockquote>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL系列 —— 锁机制</title>
    <url>/2021/11/03/MySQL%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94-%E9%94%81%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="两阶段锁协议"><a href="#两阶段锁协议" class="headerlink" title="两阶段锁协议"></a>两阶段锁协议</h3><p>两阶段锁协议（2PL）是一种能够保证事务可串行化的协议，它将事务的获取锁和释放锁划分成了增长（Growing）和缩减（Shrinking）两个不同的阶段。</p>
<p>在增长阶段，一个事务可以获得锁但是不能释放锁；而在缩减阶段事务只可以释放锁，并不能获得新的锁，如果只看 2PL 的定义，那么到这里就已经介绍完了，但是它还有两个变种：</p>
<ol>
<li><strong>严格两阶段锁</strong>（Strict 2PL）：事务持有的<strong>互斥</strong>锁必须在提交后再释放；</li>
<li><strong>强两阶段锁</strong>（Rigorous 2PL）：事务持有的<strong>所有</strong>锁必须在提交后释放；</li>
</ol>
<h1 id="MySQL中锁机制"><a href="#MySQL中锁机制" class="headerlink" title="MySQL中锁机制"></a>MySQL中锁机制</h1><h2 id="按粒度分"><a href="#按粒度分" class="headerlink" title="按粒度分"></a>按粒度分</h2><p>表锁<br>行锁</p>
<p>简单的说，表锁上锁的粒度是table，而行锁可以只对部分行上锁。</p>
<p>后者粒度低得多，这也是为什么InnoDB引擎是默认的引擎，除非你的数据库操作只有读，没有写和加锁读。</p>
<p>否则表锁的代价太大。</p>
<p><img src="/2021/11/03/MySQL%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94-%E9%94%81%E6%9C%BA%E5%88%B6/granularity-hierarchy.png" alt="granularity-hierarchy"></p>
<h2 id="按是否意向锁区分"><a href="#按是否意向锁区分" class="headerlink" title="按是否意向锁区分"></a>按是否意向锁区分</h2><p>意向锁、非意向锁</p>
<p>（见上图）</p>
<p>虽然这种不同粒度的锁能够解决父节点被加锁时，子节点不能被加锁的问题，但是我们没有办法在子节点被加锁时，立刻确定父节点能不能被加锁。</p>
<p>在这时我们就需要引入<strong>意向锁</strong>来解决这个问题了。</p>
<p><strong>当需要给子节点加锁时，先给所有的父节点加对应的意向锁</strong>，<strong>意向锁之间是完全不会互斥的</strong>，只是用来帮助父节点快速判断是否可以对该节点进行加锁。</p>
<p>具体的，InnoDB如果需要对每一行加上行锁，那么需要先给它所在表加上意向锁。</p>
<p>加的是互斥行锁，就给表加上意向互斥锁（IX）；</p>
<p>加的是共享行锁，就给锁加上意向共享锁（IS）。</p>
<p>见下图，各种锁的兼容性矩阵。</p>
<p><img src="/2021/11/03/MySQL%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94-%E9%94%81%E6%9C%BA%E5%88%B6/lock-type-compatibility-matrix.png" alt="lock-type-compatibility-matrix"></p>
<h2 id="按读写性质分"><a href="#按读写性质分" class="headerlink" title="按读写性质分"></a>按读写性质分</h2><p>读锁（共享锁、S锁）<br>写锁（互斥锁、X锁）</p>
<p>这个锁的语义和其他地方（如Java中的<code>ReadWriteLock</code>）锁的意义是一致的。</p>
<p>读锁-读锁共享；读锁-写锁互斥；写锁-写锁互斥。</p>
<p>写操作加的都是写锁，普通读操作是不加锁的（这个读称之为MVCC的一致性非锁定读）。</p>
<p>如果需要读操作也要加锁，可以使用<code>for share</code>、<code>for update</code>）(前者也就是<code>lock in share mode </code>)。（后面会详细介绍）</p>
<blockquote>
<p> 注意MySQL支持多种存储引擎，不同引擎对锁的支持是不一样的。<br>比如，MyISAM、Memory引擎就不支持行锁，自然也无需表级别的意向锁。<br>重点是InnoDB中的锁机制。</p>
</blockquote>
<h1 id="InnoDB存储引擎中的锁"><a href="#InnoDB存储引擎中的锁" class="headerlink" title="InnoDB存储引擎中的锁"></a>InnoDB存储引擎中的锁</h1><h2 id="InnoDB中的表级锁"><a href="#InnoDB中的表级锁" class="headerlink" title="InnoDB中的表级锁"></a>InnoDB中的表级锁</h2><ul>
<li><strong>表级别的S锁、X锁</strong></li>
</ul>
<ol>
<li><p>默认情况在对一个表执行 select、insert、delete、update语句时, InnoDB引擎不会为这个表加上表级别的锁。</p>
</li>
<li><p>在执行一些DDL语句时，会和select、insert、delete、update产生冲突，一个阻塞另一个。</p>
<p>不过，这个不是表锁起的作用，而是位于服务器层的 <strong>元数据锁</strong>（Metadata Lock）来实现的。</p>
<p>（DDL语句执行时，<strong>会隐式提交当前会话中的事务</strong>，这个要注意)</p>
</li>
<li><p>InnoDB存储引擎提供的表锁其实在一般使用场景下，并不会直接使用到，只有在一些特殊场景下（服务崩溃需要对系统运维时使用）。</p>
</li>
</ol>
<p><strong>如何加表锁</strong></p>
<p>在系统变量为 <code>autocommit = 0</code>和<code>innodb_table_locks = 1</code>时，</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">LOCK TABLES t READ; # 表级别读锁</span><br><span class="line">LOCK TABLES T WRITE; # 表级别的写锁</span><br></pre></td></tr></table></figure>



<ul>
<li><p><strong>表级别的IS、IX锁</strong></p>
<p>在需要加行锁的时候，需要先给所在的表加上意向锁。加意向锁的作用和意图在上面已经说过了。</p>
</li>
</ul>
<ul>
<li><strong>表级别的AUTO-INC锁</strong></li>
</ul>
<p>如何实现对具有<strong>AUTO_INCREMENT</strong>属性的列的自增？</p>
<p>这个时候需要使用到表级别的<strong>自增锁</strong>。</p>
<p>注意这个AUTO-INC锁的作用范围只有单个插入语句，在插入语句完成后，这把锁就会被释放。</p>
<p>还有一个更轻量的实现，就是在获取到需要的自增值就立即释放锁，不必等待插入语句完成。</p>
<p>可以使用<code>innodb_autoinc_lock_mode</code>控制使用哪个实现。</p>
<h2 id="InnoDB中的行级锁"><a href="#InnoDB中的行级锁" class="headerlink" title="InnoDB中的行级锁"></a>InnoDB中的行级锁</h2><p>InnoDB中的行级锁有下面几种概念， 共同实现了行锁这个语义。</p>
<ul>
<li><p><strong>Record Lock</strong></p>
<p>记录锁，官方叫它“LOCK_REC_NOT_GAP”，顾名思义，锁住的是真实的数据行。</p>
</li>
<li><p><strong>Gap Lock</strong></p>
<p>间隙锁，”LOCK_GAP”</p>
<p>这个间隙锁，锁住的是数据记录之间的间隙。</p>
<p>为什么要锁住间隙？这个gap lock的提出是为了解决”幻行“现象的发生。</p>
<p>所谓幻读，就是一个事务向另一个事务读范围中插入了一条记录，然后另一个事务就读到了“幻行”（虽然说MVCC的一致性读很大程度上可以避免，但是彻底避免幻读就需要使用gap lock）。 </p>
</li>
</ul>
<img src="gap-lock.png" style="zoom:50%;" />

<p>如上图，再给7上间隙锁的时候，其他事务无法向(5,7)之间插入行记录。这就是<strong>锁住间隙</strong>的作用。</p>
<ul>
<li><strong>Next-key Lock</strong></li>
</ul>
<p>临键锁，官方叫它”LOCK_ORDINARY“,从这个英文名字就可以看出。</p>
<p>这个锁才是正常使用的加的行锁。</p>
<img src="next-key-lock.png" style="zoom:50%;" />

<p>如上，临键锁实际上记录锁和间隙锁的合体。给某个记录加上临键锁，实际上锁住了这条记录和它前面的间隙。</p>
<p>所以说临键锁是”左开右闭“的。</p>
<h1 id="InnoDB锁的内存结构"><a href="#InnoDB锁的内存结构" class="headerlink" title="InnoDB锁的内存结构"></a>InnoDB锁的内存结构</h1><p>上面讲到了表锁和行锁。</p>
<p>表锁的对象的是一个表，可以为这张表生成一个锁结构。</p>
<p>如果是行锁呢？难不成为每一个数据行都要生成一个锁结构吧，这个对内存消耗太大了，也不利于管理。</p>
<p>所以，符合下面这些条件的记录的锁实际上使用一个锁结构就可以做到。</p>
<ul>
<li>同一个事务中</li>
<li>加锁的类型一样</li>
<li>等待状态一样</li>
<li>被加锁的记录在同一个页面中</li>
</ul>
<img src="lock-structure.png" style="zoom:30%;" />



<ul>
<li><p><strong>锁所在的事务信息</strong>：无论表级锁还是行级锁，都是属于一个事务的，这里记载着属于这个事务的信息。</p>
</li>
<li><p><strong>索引信息</strong>：对于行级锁而言，需要记录一下加锁的记录属于哪个索引。</p>
</li>
<li><p>表锁或者行锁信息：</p>
<p>如果是行锁的话：</p>
<ul>
<li>Space ID：记录所在表空间。</li>
<li>Page Number：记录所在的页号</li>
<li>n_bits：对弈行级锁而言，一条记录对应一个比特，实际上就是用一个位图结构去记录那些行记录被加了锁，n_bits则是表示使用了多少比特。</li>
</ul>
</li>
<li><p><strong>type mode</strong></p>
<ul>
<li><p><strong>lock_mode</strong>（锁模式）</p>
<ul>
<li>LOCK_IS（共享意向锁）</li>
<li>LOCK_IX（独占意向锁）</li>
<li>LOCK_S（共享锁）</li>
<li>LOCK_X（独占锁）</li>
<li>LOCK_AUTO_INC（AUTO_INC锁）</li>
</ul>
</li>
<li><p><strong>lock_type</strong>（锁类型）</p>
<ul>
<li>LOCK_TABLE（表级锁）</li>
<li>LOCK_REC （行级锁）</li>
</ul>
</li>
<li><p><strong>rec_lock_type</strong> （行锁的具体类型，只有当lock_type为LOCK_REC时才是有效的）</p>
<ul>
<li>LOCK_ORDINARY（next_key临键锁）</li>
<li>LOCK_GAP（间隙锁）</li>
<li>LOCK_REC_NOT_GAP（记录锁）</li>
<li>LOCK_INSERT_INTENTION（插入意向锁）</li>
</ul>
</li>
<li><p><strong>LOCK_WAITING</strong> </p>
<p>1 表示当前事务尚未得到锁，正处于等待状态，0 表示当前事务已经或得到锁。</p>
</li>
</ul>
</li>
</ul>
<p>其实仅仅看这个一个type mode 的结构皆可以知道MySQL锁的整体结构了。</p>
<p><img src="/2021/11/03/MySQL%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94-%E9%94%81%E6%9C%BA%E5%88%B6/typemode.png"></p>
<ul>
<li>其他信息</li>
</ul>
<p>为了更好地管理系统运行过程中生成的锁结构，有哈希表、链表等等数据结构方便管理</p>
<ul>
<li><p>比特数组</p>
<p>n_bits属性指出这个位图有多大，那么这一堆比特位就是用来隐射这一页中有哪些记录加上了锁的。</p>
</li>
</ul>
<h1 id="查看事务的加锁情况"><a href="#查看事务的加锁情况" class="headerlink" title="查看事务的加锁情况"></a>查看事务的加锁情况</h1><p>也许需要打开一些配置项：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> innodb_status_output<span class="operator">=</span><span class="keyword">ON</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> innodb_status_output_locks<span class="operator">=</span><span class="keyword">ON</span>;</span><br></pre></td></tr></table></figure>

<p>在MySQL Clinet中使用<code>show engine innodb status</code></p>
<p>这里只列出关于事务和锁的信息，其余信息省略：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 当前活动的事务</span> </span><br><span class="line">TRANSACTIONS</span><br><span class="line">------------</span><br><span class="line"><span class="meta">#</span><span class="bash"> 下一个分配的事务ID信息</span></span><br><span class="line">Trx id counter 7203081</span><br><span class="line">Purge done for trx&#x27;s n:o &lt; 7203074 undo n:o &lt; 0 state: running but idle</span><br><span class="line"><span class="meta">#</span><span class="bash"> 每个回滚段中都有一个History链表，链表的长度为 57</span></span><br><span class="line">History list length 57</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下面对于每一个会话列出它的事务信息</span></span><br><span class="line">LIST OF TRANSACTIONS FOR EACH SESSION:</span><br><span class="line"><span class="meta">#</span><span class="bash">  每一个<span class="string">&#x27;---TRANSACTION&#x27;</span> 后面跟着响应的事务的信息</span></span><br><span class="line">---TRANSACTION 422190990756560, not started</span><br><span class="line">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 事务ID7203080, 活跃了 163 秒</span></span><br><span class="line">---TRANSACTION 7203080, ACTIVE 163 sec</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2个锁结构， 7个行锁（实际上只有6条记录）（这里的锁结构指的就是前面的锁的内存结构）</span></span><br><span class="line">2 lock struct(s), heap size 1136, 7 row lock(s)</span><br><span class="line"><span class="meta">#</span><span class="bash"> MySQL内部线程号、操作系统中的线程号等信息</span></span><br><span class="line">MySQL thread id 17, OS thread handle 13048123392, query id 389 localhost 127.0.0.1 root</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 锁结构1. 表级别的意向互斥锁</span></span><br><span class="line">TABLE LOCK table `test_lock`.`test_lock` trx id 7203080 lock mode IX</span><br><span class="line"><span class="meta">#</span><span class="bash"> 锁结构2. 记录锁（</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 详细解释：表空间号是106，页号是4，锁的位图大小为80，索引是PRIMARY聚簇索引，X型实际上是next-key-lock，（aka 临键锁）</span></span><br><span class="line">RECORD LOCKS space id 106 page no 4 n bits 80 index PRIMARY of table `test_lock`.`test_lock` trx id 7203080 lock_mode X</span><br><span class="line"><span class="meta">#</span><span class="bash"> 紧接着就是加锁记录的详细信息</span></span><br><span class="line">Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0</span><br><span class="line"> 0: len 8; hex 73757072656d756d; asc supremum;;</span><br><span class="line"></span><br><span class="line">Record lock, heap no 2 PHYSICAL RECORD: n_fields 6; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 80000000; asc     ;;</span><br><span class="line"> 1: len 6; hex 0000002e0502; asc    .  ;;</span><br><span class="line"> 2: len 7; hex 0100000164102a; asc     d *;;</span><br><span class="line"> 3: len 4; hex 80000000; asc     ;;</span><br><span class="line"> 4: len 4; hex 80000000; asc     ;;</span><br><span class="line"> 5: len 4; hex 80000000; asc     ;;</span><br><span class="line"></span><br><span class="line">Record lock, heap no 3 PHYSICAL RECORD: n_fields 6; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 8000000a; asc     ;;</span><br><span class="line"> 1: len 6; hex 0000002e0502; asc    .  ;;</span><br><span class="line"> 2: len 7; hex 01000001641060; asc     d `;;</span><br><span class="line"> 3: len 4; hex 8000000a; asc     ;;</span><br><span class="line"> 4: len 4; hex 8000000a; asc     ;;</span><br><span class="line"> 5: len 4; hex 8000000a; asc     ;;</span><br><span class="line"></span><br><span class="line">Record lock, heap no 4 PHYSICAL RECORD: n_fields 6; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 80000014; asc     ;;</span><br><span class="line"> 1: len 6; hex 0000002e0551; asc    . Q;;</span><br><span class="line"> 2: len 7; hex 010000012c112d; asc     , -;;</span><br><span class="line"> 3: len 4; hex 80000014; asc     ;;</span><br><span class="line"> 4: len 4; hex 80000014; asc     ;;</span><br><span class="line"> 5: len 4; hex 80000014; asc     ;;</span><br><span class="line"></span><br><span class="line">Record lock, heap no 5 PHYSICAL RECORD: n_fields 6; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 8000001e; asc     ;;</span><br><span class="line"> 1: len 6; hex 0000002e0502; asc    .  ;;</span><br><span class="line"> 2: len 7; hex 01000001641100; asc     d  ;;</span><br><span class="line"> 3: len 4; hex 8000001e; asc     ;;</span><br><span class="line"> 4: len 4; hex 8000001e; asc     ;;</span><br><span class="line"> 5: len 4; hex 8000001e; asc     ;;</span><br><span class="line"></span><br><span class="line">Record lock, heap no 6 PHYSICAL RECORD: n_fields 6; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 80000028; asc    (;;</span><br><span class="line"> 1: len 6; hex 0000002e13cd; asc    .  ;;</span><br><span class="line"> 2: len 7; hex 02000001591605; asc     Y  ;;</span><br><span class="line"> 3: len 4; hex 80000028; asc    (;;</span><br><span class="line"> 4: len 4; hex 80000028; asc    (;;</span><br><span class="line"> 5: len 4; hex 80000028; asc    (;;</span><br><span class="line"></span><br><span class="line">Record lock, heap no 7 PHYSICAL RECORD: n_fields 6; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 80000032; asc    2;;</span><br><span class="line"> 1: len 6; hex 0000002e0990; asc    .  ;;</span><br><span class="line"> 2: len 7; hex 020000013e14d7; asc     &gt;  ;;</span><br><span class="line"> 3: len 4; hex 80000032; asc    2;;</span><br><span class="line"> 4: len 4; hex 80000032; asc    2;;</span><br><span class="line"> 5: len 4; hex 80000032; asc    2;;</span><br><span class="line"></span><br><span class="line">--------</span><br></pre></td></tr></table></figure>



<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁示例sql：</p>
<p>事务1</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction ;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test_lock <span class="keyword">where</span> primary_id <span class="operator">=</span> <span class="number">10</span> <span class="keyword">for</span> update ;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test_lock <span class="keyword">where</span> primary_id <span class="operator">=</span> <span class="number">20</span> <span class="keyword">for</span> update ;</span><br></pre></td></tr></table></figure>

<p>事务2</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction ;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test_lock <span class="keyword">where</span> primary_id <span class="operator">=</span> <span class="number">20</span> <span class="keyword">for</span> update ;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test_lock <span class="keyword">where</span> primary_id <span class="operator">=</span> <span class="number">10</span> <span class="keyword">for</span> update ;</span><br></pre></td></tr></table></figure>



<p><strong>InnoDB的死锁检测机制</strong></p>
<p>当它检测到死锁发生时，会选择一个较小的事务（所谓较小的事务，就是在事务执行过程中插入、更新后删除的记录较少的事务）进行回滚（这个是自动完成的），并向客户端发送一条消息：<code>[40001][1213] Deadlock found when trying to get lock; try restarting transaction</code> .</p>
<blockquote>
<p>那么如何定位到死锁的发生的地方呢？</p>
</blockquote>
<p>仍然是使用<code>show engine innnodb status</code>来查看死锁信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">------------------------</span><br><span class="line"><span class="meta">#</span><span class="bash"> 最近一次捕捉的死锁信息</span></span><br><span class="line">LATEST DETECTED DEADLOCK</span><br><span class="line">------------------------</span><br><span class="line"><span class="meta">#</span><span class="bash"> 死锁发生时间</span></span><br><span class="line">2021-11-27 11:49:06 0x309c3d000</span><br><span class="line"><span class="meta">#</span><span class="bash"> 死锁发生时的第一个事务信息</span></span><br><span class="line">*** (1) TRANSACTION:</span><br><span class="line">TRANSACTION 7203086, ACTIVE 12 sec starting index read</span><br><span class="line"><span class="meta">#</span><span class="bash"> 该事务使用了一个表，为一个表上了锁</span></span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 拥有 3 个锁结构，2个行锁</span></span><br><span class="line">LOCK WAIT 3 lock struct(s), heap size 1136, 2 row lock(s)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 线程信息</span></span><br><span class="line">MySQL thread id 24, OS thread handle 13048426496, query id 978 localhost 127.0.0.1 root statistics</span><br><span class="line"><span class="meta">#</span><span class="bash"> 发生锁时执行的SQL语句</span></span><br><span class="line">/* ApplicationName=DataGrip 2020.3.1 */ select * from test_lock where primary_id = 20 for update</span><br><span class="line"><span class="meta">#</span><span class="bash"> 当前线程正在等待获取的锁</span></span><br><span class="line">*** (1) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 106 page no 4 n bits 80 index PRIMARY of table `test_lock`.`test_lock` trx id 7203086 lock_mode X locks rec but not gap waiting</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这条记录正对应着 select * from test_lock <span class="built_in">where</span> primary_id = 20 <span class="keyword">for</span> update ;</span></span><br><span class="line">Record lock, heap no 4 PHYSICAL RECORD: n_fields 6; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 80000014; asc     ;;</span><br><span class="line"> 1: len 6; hex 0000002e0551; asc    . Q;;</span><br><span class="line"> 2: len 7; hex 010000012c112d; asc     , -;;</span><br><span class="line"> 3: len 4; hex 80000014; asc     ;;</span><br><span class="line"> 4: len 4; hex 80000014; asc     ;;</span><br><span class="line"> 5: len 4; hex 80000014; asc     ;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 死锁发生时的第二个事务信息</span></span><br><span class="line">*** (2) TRANSACTION:</span><br><span class="line">TRANSACTION 7203087, ACTIVE 9 sec starting index read</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">3 lock struct(s), heap size 1136, 2 row lock(s)</span><br><span class="line">MySQL thread id 25, OS thread handle 13048729600, query id 987 localhost 127.0.0.1 root statistics</span><br><span class="line">/* ApplicationName=DataGrip 2020.3.1 */ select * from test_lock where primary_id = 10 for update</span><br><span class="line"><span class="meta">#</span><span class="bash"> 此事务已经或得到的锁</span></span><br><span class="line">*** (2) HOLDS THE LOCK(S):</span><br><span class="line">RECORD LOCKS space id 106 page no 4 n bits 80 index PRIMARY of table `test_lock`.`test_lock` trx id 7203087 lock_mode X locks rec but not gap</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这条记录正对应着 select * from test_lock <span class="built_in">where</span> primary_id = 20 <span class="keyword">for</span> update ;</span></span><br><span class="line">Record lock, heap no 4 PHYSICAL RECORD: n_fields 6; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 80000014; asc     ;;</span><br><span class="line"> 1: len 6; hex 0000002e0551; asc    . Q;;</span><br><span class="line"> 2: len 7; hex 010000012c112d; asc     , -;;</span><br><span class="line"> 3: len 4; hex 80000014; asc     ;;</span><br><span class="line"> 4: len 4; hex 80000014; asc     ;;</span><br><span class="line"> 5: len 4; hex 80000014; asc     ;;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 此事务等待的锁</span></span><br><span class="line">*** (2) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 106 page no 4 n bits 80 index PRIMARY of table `test_lock`.`test_lock` trx id 7203087 lock_mode X locks rec but not gap waiting</span><br><span class="line">Record lock, heap no 3 PHYSICAL RECORD: n_fields 6; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 8000000a; asc     ;;</span><br><span class="line"> 1: len 6; hex 0000002e0502; asc    .  ;;</span><br><span class="line"> 2: len 7; hex 01000001641060; asc     d `;;</span><br><span class="line"> 3: len 4; hex 8000000a; asc     ;;</span><br><span class="line"> 4: len 4; hex 8000000a; asc     ;;</span><br><span class="line"> 5: len 4; hex 8000000a; asc     ;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> InnoDB决定回滚第二个事务</span></span><br><span class="line">*** WE ROLL BACK TRANSACTION (2)</span><br></pre></td></tr></table></figure>



<p>不过注意，默认只记录最近一次死锁信息，可以将全局变量<code>innodb_print_all_deadlocks</code>设置为ON，这样的话</p>
<p>死锁发生的信息就会都记录在MySQL的错误日志中，然后就可以通过查看错误日志来分析更多的日志情况了。</p>
<p>于是，根据死锁发生的死锁日志来逆向定位产生的死锁的语句，然后再优化我们的业务。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote>
<p><a href="https://draveness.me/database-concurrency-control/">浅谈数据库并发控制 - 锁和 MVCC</a></p>
</blockquote>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL系列——InnoDB Buffer Pool</title>
    <url>/2021/10/29/MySQL%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94InnoDB%20Buffer%20Pool/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="InnoDB-Buffer-Pool"><a href="#InnoDB-Buffer-Pool" class="headerlink" title="InnoDB Buffer Pool"></a>InnoDB Buffer Pool</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>磁盘太慢，用内存作为缓冲区很有必要——这是缓存的基本思想，将数据存放在读写速度更快的存储介质中。</p>
<p>不过这里的缓冲区指的不是 Redis、Memchached这些外部的内存性缓冲，还是MySQL自治的一块内存缓冲区。</p>
<p>所谓自治，就是说完全由MySQL自己去管理这块内存区域，自己完成脏数据的刷盘，使用MySQL执行CRUD无需也无法自己做这方面的操作——不过你可以修改其中的配置以调整缓存的具体行为。</p>
<p>InnoDB Buffer Pool 本质上是MySQL在向操作系统申请的一大块内存，默认是128MB（比较小，完全可以开大一点）。</p>
<h2 id="内部组成"><a href="#内部组成" class="headerlink" title="内部组成"></a>内部组成</h2><p>Buffer Pool 对应的一大块内存被划分一个又一个页面，页面大小和InnoDB表空间的页面大小一致，默认是16KB，不妨称它为<strong>缓冲页。</strong></p>
<p>由于这些缓冲业本身较大，如果已过用户的调整可能更大，不便于直接管理。于是为每个缓冲页创建一个控制块，</p>
<p>每个控制块包含该页所属的表空间编号、页号、缓冲页在Buffer Pool 中的地址等关键信息。</p>
<p>每个控制块的所占用的内存大小是一致的，大概只有16KB的5%左右（aka 800个字节）。</p>
<img src="innodb-buffer.png" style="zoom:35%;" />





<h2 id="free-链表"><a href="#free-链表" class="headerlink" title="free 链表"></a>free 链表</h2><p>缓冲页一开始都为空（逻辑上的空），随着从磁盘读取数据会逐渐使用buffer pool中的页。</p>
<p>如何区分这些空闲的页和非空闲的页呢？</p>
<p>MySQL的做法并不特殊，使用一条链表将空闲也组织起来。</p>
<p>具体的数据结构，下面的图说的很清楚了。</p>
<p>红色对应的空闲的控制块，蓝色对应的是相应的缓冲页。</p>
<img src="free.png" style="zoom:40%;" />



<h2 id="flush-链表"><a href="#flush-链表" class="headerlink" title="flush 链表"></a>flush 链表</h2><p>读缓存的逻辑比较简单，就是把磁盘中的页读到内存中（不过还要设计缓冲页的淘汰问题）。</p>
<p>写缓存呢？</p>
<p>和上面，我们需要把buffer pool中的写过的页（也就是和磁盘的上的页不一致的页），也就是脏页管理起来，然后按照某种刷盘逻辑将这些脏页在未来某个时刻写到磁盘上。</p>
<p>具体的组织结构也是链表，和上面的的形式几乎一致。不再赘述。</p>
<h2 id="缓冲页的哈希表"><a href="#缓冲页的哈希表" class="headerlink" title="缓冲页的哈希表"></a>缓冲页的哈希表</h2><p>如何根据快速知道某个是否在缓冲池中，毫无疑问，哈希表可以派上用场。</p>
<p>具体的，可以使用 <strong>表空间号+页号</strong> 作为键来定位一个页，值是页控制块的内存地址。</p>
<h2 id="LRU链表的使用管理"><a href="#LRU链表的使用管理" class="headerlink" title="LRU链表的使用管理"></a>LRU链表的使用管理</h2><p>只要涉及到缓存，就必然涉及到缓存区不够用，需要淘汰部分缓存的情况。对于innodb buffer pool来说也不意外。</p>
<p>不过，这里的LRU算法不是最朴素的实现（比如每使用一次页，就把它对应的控制块移动到LRU链表的头部），<br>这里的LRU链表是变种。</p>
<h3 id="数据冷热分离"><a href="#数据冷热分离" class="headerlink" title="数据冷热分离"></a>数据冷热分离</h3><p>为什么呢？</p>
<p>两个原因：</p>
<ol>
<li>MySQL的预读策略可能将一些原本不会使用的页面误装载进了buffer pool；</li>
<li>执行一些全表扫描的SQL时，会将大量的数据页加载进buffer pool，不过又由于这些全表扫描出的页面的本身的使用频率的非常低（全表的扫描这样的sql一般只有定期做报表的时候用到），这个时候相当于一下子就把缓冲区全用冷数据充满了，也就是说相当于清空了缓冲区。</li>
</ol>
<p>所以，MySQL对这里LRU链表作如下处理，</p>
<p>将数据冷热分离，默认情况下，将LRU链表前约5/8的数据作为热数据（也称为 young ）区域，后3/8的数据作为冷数据（也称为 old）区域。</p>
<p>如何对上面提出的两个问题做出优化，上面的问题的共同点在于使用一个页面之后就再不用了（aka，用完即弃，不是那种在一个时间段里频繁使用到的数据）。</p>
<p>所以，<code>innnodb_old_blocks_time</code>这个系统配置变量其到作用，默认是1000ms。</p>
<p>对于从磁盘加载进来的数据页，先将它加入old区域，记录下第一次加入的时间，之后再访问它的时候，如果间隔的时间小于<code>innnodb_old_blocks_time</code>, 还不会加入young区域，仍然作为冷数据处理。</p>
<p>于是，对于那些原表扫描和预读机制的冷数据页不会影响到真正的需要缓存的热数据。</p>
<h3 id="进一步优化"><a href="#进一步优化" class="headerlink" title="进一步优化"></a>进一步优化</h3><p>是不是对于young区域数据页每访问一次就要把它加入LRU链表的头部呢？因为这些数据可能都很热，每一次每访问一次就把要移动一次控制块节点，没必要。</p>
<p>所以，MySQL只对于那些处于young区域后3/4区域的节点才会在使用的时候加入young的头部。</p>
<h2 id="刷新脏页到磁盘"><a href="#刷新脏页到磁盘" class="headerlink" title="刷新脏页到磁盘"></a>刷新脏页到磁盘</h2><p>后台线程会定期将脏页刷新到磁盘中。</p>
<p>也就是说，这里的缓存使用方式实际上是<strong>Write-hehind（异步缓存写入）</strong>，适合多写的方式。</p>
<p>脏页的刷新主要有3种做法：</p>
<ol>
<li><p>从LRU的尾部（也是从old区域）开始扫描一些页面，扫描页面的数量由<code>innodb_lru_scan_depth</code>（默认是1024）指定，如果扫描中发现是脏页就把它刷新到磁盘。</p>
</li>
<li><p>从flush链表刷新一部分页面到磁盘。刷新的速率取决于当时系统繁忙的程度。</p>
</li>
<li><p>如果用户线程想将一个磁盘页加载进buffer pool，但是此时全都是脏页了，这时就必须挑出一个脏页刷到磁盘上。</p>
</li>
</ol>
<h2 id="查看当前-buffer-pool的状态-配置"><a href="#查看当前-buffer-pool的状态-配置" class="headerlink" title="查看当前 buffer pool的状态/配置"></a>查看当前 buffer pool的状态/配置</h2><p>查看当前状态</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> engine innodb status;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ......</span></span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 137428992 # 向操作系统申请的一大块连续空间 + 全部控制块 + 缓冲页 + 碎片</span><br><span class="line">Dictionary memory allocated 410319</span><br><span class="line">Buffer pool size   8191  # 一共容纳多少缓冲页（页数）</span><br><span class="line">Free buffers       7017  # 空闲的缓冲页个数</span><br><span class="line">Database pages     1170  # LRU链表中的页的数量</span><br><span class="line">Old database pages 451   # OLD区域中的页的数量</span><br><span class="line">Modified db pages  0     # FLUSH链表中页的数量（脏页的数量）</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 0, not young 0</span><br><span class="line">0.00 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 1039, created 131, written 137</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">No buffer pool page gets since the last printout</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 1170, unzip_LRU len: 0</span><br><span class="line">I/O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br></pre></td></tr></table></figure>

<p>具体的参看官方文档。</p>
<p><strong>查看配置变量</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;Innodb_buffer_pool_%&#x27;</span></span><br></pre></td></tr></table></figure>



<p><strong>变量解析</strong></p>
<ul>
<li>Innodb_buffer_pool_pages_total 参数表示缓存页面的总数量;</li>
<li>Innodb_buffer_pool_pages_data 代表有数据的缓存页数;</li>
<li>Innodb_buffer_pool_pages_free 代表没有使用的缓存页数;</li>
<li>Innodb_buffer_pool_pages_misc: innodb buffer pool 缓存池中当前已经被用作管理用途或hash index而不能用作为普通数据页的数目。</li>
<li>Innodb_buffer_pool_read_requests表示read请求的次数，</li>
<li>Innodb_buffer_pool_reads 表示从物理磁盘中读取数据的请求次数，</li>
</ul>
<p>innodb buffer的read命中率 =（Innodb_buffer_pool_read_requests -Innodb_buffer_pool_reads） / Innodb_buffer_pool_read_requests * 100%。<br>如果这个命中率小于95%，建议增大 innodb_buffer_pool_size。</p>
<p>如果Innodb_buffer_pool_pages_free偏大的话，证明有很多缓存没有被利用到，这时可以考虑减小缓存; 相反Innodb_buffer_pool_pages_data过大就考虑增大缓存。</p>
<h2 id="配置-Buffer-Pool"><a href="#配置-Buffer-Pool" class="headerlink" title="配置 Buffer Pool"></a>配置 Buffer Pool</h2><h3 id="配置解析"><a href="#配置解析" class="headerlink" title="配置解析"></a>配置解析</h3><p>由于一个Buffer Pool可能很大，一次性申请、移动、管理它不适合，所以MySQL实际做法是用多个做个chunk组成一个buffer pool。</p>
<ul>
<li>innodb_buffer_pool_size 参数为innodb_buffer_pool的大小设置（默认是128MB）。</li>
<li>innodb_buffer_pool_chunk_size 参数为InnoDB缓冲池块大小（默认是128MB）。</li>
<li>innodb_buffer_pool_instances 参数为缓冲池实例的个数（默认是1）。</li>
</ul>
<p>注意，不同的innodb_buffer_pool 实例的链表管理、哈希管理、锁管理都是独立的，也正因此如果可以配置多个buffer pool实例可以增大并发度。</p>
<p>配置规则：<br>*<em>innodb_buffer_pool_size = innodb_buffer_pool_chunk_size * innodb_buffer_pool_instances <em>N</em></em></p>
<p>其中N指的是一个buffer pool实例中有几个 chunk。</p>
<p>（注意，如果不是整数倍，那么会调整为整数倍；又如果配置的innodb_buffer_pool_size 小于innodb_buffer_pool_chunk_size * innodb_buffer_pool_instances，那么MySQL会缩小innodb_buffer_pool_chunk_size的大小）</p>
<p>系统默认的innodb_buffer_pool_chunk_size （8.x版本）为128M。<br>innodb_buffer_pool_instances参数的默认设置为1 最大设置为64 ，但是<br>将innodb_buffer_pool_size大小设置为1GB或更大时，此选项才生效。<br>（主要是防止有太多小的instance从而导致性能问题。）</p>
<h3 id="配置参考"><a href="#配置参考" class="headerlink" title="配置参考"></a>配置参考</h3><p>建议设置为系统内存的50%-80%，但也不是越大越好，要根据具体项目具体分析<br>（操作系统留1G左右，mysql连接数*4M，宿主程序缓存nM）。</p>
<table>
<thead>
<tr>
<th align="left">实例内存大小（单位：MB）</th>
<th align="left">默认Buffer Pool（单位：MB）</th>
<th align="left">推荐最大Buffer Pool（单位：MB）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1024</td>
<td align="left">256</td>
<td align="left">256</td>
</tr>
<tr>
<td align="left">2048</td>
<td align="left">512</td>
<td align="left">512</td>
</tr>
<tr>
<td align="left">4096</td>
<td align="left">1536</td>
<td align="left">1536</td>
</tr>
<tr>
<td align="left">8192</td>
<td align="left">4608</td>
<td align="left">4608</td>
</tr>
<tr>
<td align="left">16384</td>
<td align="left">12288</td>
<td align="left">12288</td>
</tr>
<tr>
<td align="left">24576</td>
<td align="left">18432</td>
<td align="left">19456</td>
</tr>
<tr>
<td align="left">32768</td>
<td align="left">24576</td>
<td align="left">25600</td>
</tr>
<tr>
<td align="left">49152</td>
<td align="left">36864</td>
<td align="left">38912</td>
</tr>
<tr>
<td align="left">65536</td>
<td align="left">49152</td>
<td align="left">52224</td>
</tr>
<tr>
<td align="left">98304</td>
<td align="left">73728</td>
<td align="left">77824</td>
</tr>
<tr>
<td align="left">131072</td>
<td align="left">98304</td>
<td align="left">104448</td>
</tr>
<tr>
<td align="left">196608</td>
<td align="left">147456</td>
<td align="left">156672</td>
</tr>
<tr>
<td align="left">229376</td>
<td align="left">172032</td>
<td align="left">183296</td>
</tr>
<tr>
<td align="left">262144</td>
<td align="left">196608</td>
<td align="left">208896</td>
</tr>
</tbody></table>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><blockquote>
<p>《MySQL是怎样运行的》</p>
</blockquote>
<p><a href="https://www.cnblogs.com/frankcui/p/15227775.html">https://www.cnblogs.com/frankcui/p/15227775.html</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>InnoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL系列——存储引擎</title>
    <url>/2021/10/27/MySQL%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL系列——索引</title>
    <url>/2021/10/27/MySQL%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h1><h2 id="B树、B-树"><a href="#B树、B-树" class="headerlink" title="B树、B+树"></a>B树、B+树</h2><blockquote>
<p>关于 B树、B+树本身的介绍，不是本文的重点，之后也许会专门写一篇文章详细介绍，</p>
</blockquote>
<p>这里直接就贴出wiki的链接了。</p>
<p><a href="https://zh.wikipedia.org/wiki/B%E6%A0%91">B树</a></p>
<p><a href="https://zh.wikipedia.org/wiki/B%2B%E6%A0%91">B+树</a></p>
<ul>
<li><p>为什么不使用普通的平衡二叉树（如RB树、AVL树）？</p>
<p>MySQL的数据是存储在磁盘文件中的，查询处理数据时，需要先把磁盘中的数据加载到内存中，<strong>磁盘IO 操作非常耗时</strong>，所以我们优化的重点就是尽量减少磁盘 IO 操作。<strong>访问二叉树的每个节点就会发生一次IO，如果想要减少磁盘IO操作，就需要尽量降低树的高度</strong>。那如何降低树的高度呢？</p>
<p>B树的特点就是一个多叉的平衡树，特点就是<strong>矮胖</strong>（相比于普通平衡二叉树的高瘦），在相同数据规模下访问节点的次数更少，换句话说，磁盘IO的开销更少。</p>
</li>
</ul>
<p>如下图，红色的是主键，黄色的其余的数据，蓝色的是指向子节点的指针。</p>
<p><img src="/2021/10/27/MySQL%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%B4%A2%E5%BC%95/btree.png" alt="B树"></p>
<ul>
<li><p>为什么Innodb引擎使用B+树而不是B树？</p>
<ol>
<li><p>B树不支持范围查询的快速查找，你想想这么一个情况如果我们想要查找10和35之间的数据，查找到15之后，需要回到根节点重新遍历查找，需要从根节点进行多次遍历，查询效率有待提高。</p>
</li>
<li><p>如果data存储的是行记录，行的大小随着列数的增多，所占空间会变大。这时，<strong>一个页中可存储的数据量就会变少，树相应就会变高</strong>，磁盘IO次数就会变大。</p>
</li>
</ol>
<p>B+树和B树最主要的区别在于<strong>非叶子节点是否存储数据</strong>的问题</p>
<ul>
<li>B树：非叶子节点和叶子节点都会存储数据。</li>
<li>B+树：<strong>只有叶子节点才会存储数据，非叶子节点至存储键值</strong>。叶子节点之间使用双向指针连接，<strong>最底层的叶子节点形成了一个双向有序链表</strong>。</li>
</ul>
<p>当然，非要讲B+树和B树的缺点，就是每一次查询行数据，都一定要查询到叶子节点，不过这个缺点和它的优势相比可以忽略了。</p>
</li>
</ul>
<p><img src="/2021/10/27/MySQL%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%B4%A2%E5%BC%95/b+tree.png" alt="B+树"></p>
<h2 id="MyISAM引擎中的索引"><a href="#MyISAM引擎中的索引" class="headerlink" title="MyISAM引擎中的索引"></a>MyISAM引擎中的索引</h2><p>MyISAM的数据文件和索引文件是分开存储的。MyISAM使用B+树构建索引树时，<strong>叶子节点中存储的键值为索引列的值，数据为索引所在行的磁盘地址</strong>。</p>
<p><strong>在 MyISAM 中,辅助索引和主键索引的结构是一样的，没有任何区别</strong>。叶子节点的数据存储的都是行记录的磁盘地址。只是主键索引的键值是唯一的，而辅助索引的键值可以重复。</p>
<p><img src="/2021/10/27/MySQL%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%B4%A2%E5%BC%95/myisam.png" alt="MyISAM主键索引"></p>
<p>MyISAM通过key_buffer<strong>把索引先缓存到内存中</strong>，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后<strong>通过索引找到磁盘相应数据</strong>。</p>
<p>这也就是为什么索引不在key buffer命中时，速度慢的原因。</p>
<h2 id="InnoDB引擎中的索引"><a href="#InnoDB引擎中的索引" class="headerlink" title="InnoDB引擎中的索引"></a>InnoDB引擎中的索引</h2><blockquote>
<p>首先需要澄清的一点是，MySQL 跟 B+ 树没有直接的关系，<strong>真正与 B+ 树有关系的是 MySQL 的默认存储引擎 InnoDB</strong>，MySQL 中存储引擎的主要作用是负责数据的存储和提取，除了 InnoDB 之外，MySQL 中也支持 MyISAM 作为表的底层存储引擎。</p>
<p><del>不过本文不介绍xianMyISAM，只介绍 InnoDB，会在介绍MySQL中的存储引擎文章中介绍 MyISAM引擎以及其索引特点。</del></p>
</blockquote>
<h3 id="主键索引（聚簇索引）"><a href="#主键索引（聚簇索引）" class="headerlink" title="主键索引（聚簇索引）"></a>主键索引（聚簇索引）</h3><p>通俗点讲：</p>
<p>聚簇索引的意思就是：将数据存储与索引放到了一块，找到索引也就找到了数据。</p>
<p>每个InnoDB表都有一个聚簇索引 ，<strong>聚簇索引使用B+树构建</strong>，<strong>叶子节点存储的数据是整行记录</strong>。一般情况下，<strong>聚簇索引基本上等同于主键索引</strong>，当一个表没有创建主键索引时，InnoDB会自动创建一个ROWID字段来构建聚簇索引。</p>
<p>InnoDB创建索引的具体规则如下：</p>
<ol>
<li>在表上定义主键PRIMARY KEY，InnoDB将<strong>主键</strong>用作聚簇索引。</li>
<li>如果表没有定义主键，InnoDB会选择<strong>第一个不为NULL的唯一索引列</strong>用作聚簇索引。</li>
<li>如果以上两个都没有，InnoDB 会使用一个6 字节长整型的隐式字段 <strong>ROWID字段</strong>构建聚簇索引。该ROWID字段会在插入新行时自动递增。</li>
</ol>
<p> 在检索时，InnoDB使用此主键值在聚簇索引中搜索行记录。</p>
<p><img src="/2021/10/27/MySQL%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%B4%A2%E5%BC%95/innodb1.png" alt="InnoDB主键索引"></p>
<h3 id="二级索引（辅助索引）"><a href="#二级索引（辅助索引）" class="headerlink" title="二级索引（辅助索引）"></a>二级索引（辅助索引）</h3><p>除聚簇索引之外的所有索引都称为辅助索引。在中InnoDB，<strong>辅助索引中的叶子节点存储的数据是该行的主键值</strong>。</p>
<p><strong>辅助索引也使用B+树构建</strong>。</p>
<p><img src="/2021/10/27/MySQL%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%B4%A2%E5%BC%95/innodb2.png" alt="InnoDB辅助索引"></p>
<p>如何使用二级索引来查询行数据呢？</p>
<p>第一步，在二级索引里根据索引列查询到主键值。</p>
<p>第二步，根据主键值再到聚簇索引里查询数据行。</p>
<p>这个操作就叫做<strong>回表</strong>。</p>
<p><img src="/2021/10/27/MySQL%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E7%B4%A2%E5%BC%95/rolltable.png" alt="回表"></p>
<h2 id="聚簇索引-vs-非聚簇索引"><a href="#聚簇索引-vs-非聚簇索引" class="headerlink" title="聚簇索引 vs 非聚簇索引"></a>聚簇索引 vs 非聚簇索引</h2><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li>由于行数据和叶子节点存储在一起，同一页中会有多条行数据，访问同一数据页不同行记录时，已经把页加载到了Buffer中，再次访问的时候，会在内存中完成访问，不必访问磁盘。</li>
<li>辅助索引使用主键作为”指针”而不是使用地址值作为指针的好处是，<strong>减少了当出现行移动或者数据页分裂时辅助索引的维护工作</strong>。也就是聚簇索引这棵树由于页分裂导致的树的结构的调整，不会牵扯到辅助索引这个树的调整。</li>
<li><strong>可以把相关数据保存在一起</strong>。例如实现电子邮箱时，可以根据用户 ID 来聚集数据，这样只需要从磁盘读取少数的数据页就能获取某个用户的全部邮件。如果没有使用聚簇索引，则每封邮件都可能导致一次磁盘 I/O。</li>
</ul>
<h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><ol>
<li><p><strong>维护索引很昂贵，特别是插入新行或者主键被更新导至要分页(page split)的时候</strong>。建议在大量插入新行后，选在负载较低的时间段，通过OPTIMIZE TABLE优化表，因为必须被移动的行数据可能造成碎片。使用独享表空间可以弱化碎片。</p>
</li>
<li><p>如果主键比较大的话，那辅助索引将会变的更大，因为<strong>辅助索引的叶子存储的是主键值；过长的主键值，会导致非叶子节点占用占用更多的物理空间</strong>。</p>
</li>
</ol>
<h1 id="使用索引的一些注意点"><a href="#使用索引的一些注意点" class="headerlink" title="使用索引的一些注意点"></a>使用索引的一些注意点</h1><h2 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h2><p><strong>组合索引的最左前缀匹配原则：使用组合索引查询时，mysql会一直向右匹配直至遇到范围查询(&gt;、&lt;、between、like)就停止匹配。</strong></p>
<p>最左前缀匹配原则和联合索引的<strong>索引存储结构和检索方式</strong>是有关系的。</p>
<p>说白了，就是B树的节点的键进行比较的时候比较原则。</p>
<p>比方说，创建索引了<code>index_abc(a,b,c)</code>，</p>
<p>在组合索引树中，最底层的叶子节点按照第一列按a字段从左到右递增排列，但是b列和c列是相对无序的——只有在a相同的时候，b才是有序的。同理，c列只能在a，b两列相等的情况下小范围内递增有序。</p>
<h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>覆盖索引并不是说是索引结构，<strong>覆盖索引是一种很常用的优化手段</strong>。</p>
<p>因为在使用辅助索引的时候，我们只可以拿<strong>到主键值和建立的辅助索引列</strong>，相当于获取数据还需要再根据主键查询主键索引再获取到数据。但是试想下这么一种情况，，那是不是意味着我们查询到组合索引的叶子节点就可以直接返回了，而<strong>不需要回表</strong>。这种情况就是覆盖索引。</p>
<p>如何知道是否使用了覆盖索引呢？</p>
<p>explain执行计划，查询Extra列，如果是Using index，表明确实使用了覆盖索引，或者说没有回表操作。</p>
<h2 id="合理建立联合索引"><a href="#合理建立联合索引" class="headerlink" title="合理建立联合索引"></a>合理建立联合索引</h2><p>联合索引，在建立索引的时候，尽量在多个单列索引上判断下是否可以使用联合索引。联合索引的使用<strong>不仅可以节省空间</strong>，还可以更容易的使用到索引覆盖。</p>
<p>比如联合索引（a_b_c），是不是等于有了索引：a，a_b，a_b_c三个索引，这样是不是节省了空间，当然节省的空间并不是三倍于（a，a_b，a_b_c）三个索引。</p>
<p>总之：</p>
<ol>
<li>考虑当前是否已经存在多个可以合并的单列索引，如果有，那么<strong>将当前多个单列索引创建为一个联合索引</strong>。</li>
<li>当前索引<strong>存在频繁使用作为返回字段的列</strong>，这个时候就可以考虑当前列是否可以加入到当前已经存在索引上，使其查询语句可以使用到覆盖索引。</li>
</ol>
<h1 id="索引的创建、删除、使用"><a href="#索引的创建、删除、使用" class="headerlink" title="索引的创建、删除、使用"></a>索引的创建、删除、使用</h1><h2 id="索引的创建"><a href="#索引的创建" class="headerlink" title="索引的创建"></a>索引的创建</h2><ul>
<li><p>建表时创建</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名（</span><br><span class="line">......</span><br><span class="line">[<span class="keyword">UNIQUE</span><span class="operator">|</span>FULLTEXT<span class="operator">|</span>SPATIAL] INDEX<span class="operator">|</span>KEY </span><br><span class="line">[索引名](字段名 [长度] [ASC | DESC]...) [USING &#123;BTREE|HASH&#125;]</span><br><span class="line">）</span><br></pre></td></tr></table></figure>



<ul>
<li>UNIQUE: 可选。表示索引为唯一性索引；FULLTEXT:可选。表示索引为全文索引；SPATIAL:可选。表示索引为空间索引。</li>
<li>INDEX和KEY: 用于指定字段为索引，两者选择其中之一就可以了，作用是一样的。</li>
<li>索引名: 可选。给创建的索引取一个新名称。</li>
<li>字段名: 指定索引对应的字段的名称，该字段必须是前面定义好的字段。</li>
<li>长度: 可选。指索引的长度，必须是字符串类型才可以使用。</li>
<li>ASC: 可选。表示升序排列、DESC:可选。表示降序排列。<br>注：索引方法默认使用B+TREE。</li>
</ul>
</li>
</ul>
<ul>
<li><p>建表后创建</p>
<p>第一种方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD [UNIQUE|FULLTEXT|SPATIAL] INDEX|KEY [索引名] (字段名[(长度)] [ASC|DESC]) [USING 索引方法]；</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> mytable <span class="keyword">ADD</span> INDEX idx_c1c2c3 (mycol1, mycol2, mycol3);</span><br></pre></td></tr></table></figure>



<p>第二种方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX 索引名 ON 表名(字段名) [USING 索引方法]；</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_c1c2c3 <span class="keyword">ON</span> mytable(mycol1, mycol2, mycol3);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="查看与删除索引"><a href="#查看与删除索引" class="headerlink" title="查看与删除索引"></a>查看与删除索引</h2><ul>
<li>查看<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure></li>
<li>删除<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX 索引名 <span class="keyword">ON</span> 表名</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> INDEX 索引名</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="有关索引的补充了解"><a href="#有关索引的补充了解" class="headerlink" title="有关索引的补充了解"></a>有关索引的补充了解</h1><h2 id="自适应哈希索引"><a href="#自适应哈希索引" class="headerlink" title="自适应哈希索引"></a>自适应哈希索引</h2><p><strong>自适应hash索引（Adaptive Hash Index）</strong><br>是InnoDB存储引擎中的内存结构的组成部分。</p>
<p><strong>InnoDB存储引擎会自动根据访问的频率和模式来自动的为某些热点数据建立hash索引</strong>。</p>
<p>InnoDB存储引擎会监控对表上各索引页的查询，如果观察到建立hash索引可以提高查询速度，则自动建立hash索引。这就是自适应哈希索引（Adaptive Hash Index，AHI）<br><strong>AHI是通过缓存池的B+树页构造而来</strong>，因此建立的速度很快，而且不需要对整张表构建hash索引。</p>
<h2 id="索引下推（IPC）"><a href="#索引下推（IPC）" class="headerlink" title="索引下推（IPC）"></a>索引下推（IPC）</h2><p>索引条件下推 (ICP) 是 MySQL 5.6.2 里程碑版本中的新优化器功能之一。</p>
<p><strong>Index Condition Pushdown 的目标是将尽可能多的条件处理（主要是 WHERE 子句）从服务器层转移到存储引擎层</strong>。</p>
<p>举个具体的例子吧，</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> person (</span><br><span class="line">  personid <span class="type">INTEGER</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">  firstname <span class="type">CHAR</span>(<span class="number">20</span>),</span><br><span class="line">  lastname <span class="type">CHAR</span>(<span class="number">20</span>),</span><br><span class="line">  postalcode <span class="type">INTEGER</span>,</span><br><span class="line">  age <span class="type">INTEGER</span>,</span><br><span class="line">  address <span class="type">CHAR</span>(<span class="number">50</span>),</span><br><span class="line">  KEY k1（postalcode，age）</span><br><span class="line"> ）ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure>



<p>如果有下面这条sql语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> lastname, firstname <span class="keyword">FROM</span> person</span><br><span class="line"><span class="keyword">WHERE</span> postalcode <span class="keyword">BETWEEN</span> <span class="number">5000</span> <span class="keyword">AND</span> <span class="number">5500</span> <span class="keyword">AND</span> age <span class="keyword">BETWEEN</span> <span class="number">21</span> <span class="keyword">AND</span> <span class="number">22</span>;</span><br></pre></td></tr></table></figure>

<p>根据最左匹配原则，只能使用到索引k1的postalcode列，age列无法使用（因为postalcode是一个范围查询）</p>
<p>如果，没有IPC, 那么怎么处理这条sql呢？</p>
<p>服务器层将sql推给存储引擎层，引擎层只能使用索引的第一个列查询一部分数据（比如说由10000条），</p>
<p>然后将这10000条数据返回给存储引擎层，然后服务器层再根据第二个条件进行过滤，最终留下1000条数据。</p>
<p>有了IPC之后呢，服务器层可以直接把where条件下推给存储引擎层，然后存储引擎可以直接查出这1000条数据，然后再返回给服务器层。</p>
<blockquote>
<p>参考链接</p>
</blockquote>
<p><a href="http://olavsandstaa.blogspot.com/2011/04/mysql-56-index-condition-pushdown.html">MySQL 5.6：索引条件下推</a></p>
<blockquote>
<p>参考链接</p>
<p><a href="https://blog.csdn.net/qq_35190492/article/details/109257302">一文搞懂MySQL索引所有知识点（建议收藏）</a></p>
<p><a href="https://draveness.me/whys-the-design-mysql-b-plus-tree/">为什么 MySQL 使用 B+ 树</a></p>
<p><a href="https://www.jianshu.com/p/fa8192853184">聚簇索引与非聚簇索引</a></p>
</blockquote>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>Queue的实现类源码分析——ArrayDeque、PriorityQueue</title>
    <url>/2021/07/26/Queue%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94ArrayDeque%E3%80%81PriorityQueue/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Queue的实现"><a href="#Queue的实现" class="headerlink" title="Queue的实现"></a>Queue的实现</h1><h2 id="继承类图"><a href="#继承类图" class="headerlink" title="继承类图"></a>继承类图</h2><p>其中<code>LinkedList</code>的实现已经在这篇<a href="http://47.117.127.179/2021/07/24/List%E5%AE%9E%E7%8E%B0%E7%B1%BB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20%E2%80%94%E2%80%94%20LinkedList%E3%80%81ArrayList/">List实现类</a>里面讲过了。</p>
<p><img src="/2021/07/26/Queue%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94ArrayDeque%E3%80%81PriorityQueue/Queue.png"></p>
<h2 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>使用一个循环数组来实现队列, 应将数组视作首尾相连的。</p>
<p>数组的长度始终是2的整数次幂。为什么呢？</p>
<p>还是和HashMap一样的道理，取模运算可以使用位运算代替，加快速度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">// 存储真实元素的数组，其 length 必为2的整数次幂</span></span><br><span class="line">  <span class="keyword">transient</span> Object[] elements; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 队列头部元素在数组中的索引</span></span><br><span class="line">  <span class="keyword">transient</span> <span class="keyword">int</span>  head;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 队列尾部元素的下一个元素在数组中的索引</span></span><br><span class="line">  <span class="comment">// 也就是下一个元素要放置的位置索引</span></span><br><span class="line">  <span class="keyword">transient</span> <span class="keyword">int</span> tail;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  不变量: x 为 element、o 为 empty cell</span></span><br><span class="line"><span class="comment">  实例1:</span></span><br><span class="line"><span class="comment">      o x x x x x o o	</span></span><br><span class="line"><span class="comment">        h         t</span></span><br><span class="line"><span class="comment">实例2:	 </span></span><br><span class="line"><span class="comment">      x x o o o o x x</span></span><br><span class="line"><span class="comment">          t       h</span></span><br><span class="line"><span class="comment">  实例3: (队列空)</span></span><br><span class="line"><span class="comment">      o o o o o o o o</span></span><br><span class="line"><span class="comment">        h(t)</span></span><br><span class="line"><span class="comment">  实例4: (队列即将满)      </span></span><br><span class="line"><span class="comment">      x x x o x x x x</span></span><br><span class="line"><span class="comment">            t h</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>注意head、tail字段的含义</p>
<ul>
<li>head： 队列第一个元素在数组中的索引；</li>
<li>tail： 队列尾部元素的下一个元素在数组中的索引，也就是下一个元素要放置的位置索引；</li>
</ul>
<p>这样做有一个小缺点，就是数组满的数组的空的时候，head都是等于tail都是空的，所以需要这一点的处理。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>值得一提的是，这里并没有按照 ArrayList的处理方式进行“懒”处理，而是直接接分配数组容量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认构造器的容量是 16</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayDeque</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    elements = <span class="keyword">new</span> Object[<span class="number">16</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定容量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayDeque</span><span class="params">(<span class="keyword">int</span> numElements)</span> </span>&#123;</span><br><span class="line">    allocateElements(numElements);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><p>这里的扩容机制做的很简单。</p>
<p>在每次添加完元素后，检查一下，如果head==tail，表明此时数组已满，需要扩容。</p>
<p>如何扩容呢？</p>
<p>也很简单，开辟一个两倍的大的数组，然后原来的数组元素拷贝过来，更新head与tail。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只在队列满的时候调用，断言此时 head == tail</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doubleCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">assert</span> head == tail;</span><br><span class="line">     <span class="keyword">int</span> p = head;</span><br><span class="line">     <span class="keyword">int</span> n = elements.length;</span><br><span class="line">     <span class="keyword">int</span> r = n - p; <span class="comment">// number of elements to the right of p</span></span><br><span class="line">     <span class="keyword">int</span> newCapacity = n &lt;&lt; <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">if</span> (newCapacity &lt; <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Sorry, deque too big&quot;</span>);</span><br><span class="line">     Object[] a = <span class="keyword">new</span> Object[newCapacity];</span><br><span class="line">     <span class="comment">// 左边的</span></span><br><span class="line">     System.arraycopy(elements, p, a, <span class="number">0</span>, r);</span><br><span class="line">     <span class="comment">// 右边的</span></span><br><span class="line">     System.arraycopy(elements, <span class="number">0</span>, a, r, p);</span><br><span class="line">     elements = a;</span><br><span class="line">     <span class="comment">// 注意 tail 是最后一个元素的下一个位置（循环意义上）</span></span><br><span class="line">     head = <span class="number">0</span>;</span><br><span class="line">     tail = n;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h2 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h2><p>Java中的PriorityQueue的实现也是符合队列的方式，不过又略有不同，区别就在于PriorityQueue<br>的priority上，其是一个支持优先级的队列，当使用了其priority的特性的时候，则并非FIFO。</p>
<h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><p><strong>底层是一个用数组实现的小根堆</strong>。注意c++的priority_queue默认是小根堆。</p>
<blockquote>
<p>堆，是具有下列性质的完全二叉树：每个节点的值都小于等于其左右孩子节点值是小根堆；（大于等于则是大根堆）。 批注：有些参考书将堆直接定义为序列，但是，从逻辑结构上讲，还是将堆定义为完全二叉树更好。 虽然堆的典型实现方法是数组，但从逻辑的角度上讲，堆实际上是一种树结构。</p>
</blockquote>
<p>需要注意的第一个元素从 0 开始。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 本实现中，最小的元素放在下标为 0 的位置，</span></span><br><span class="line"><span class="comment">// 某个下标为 n 的节点的左右孩子的下标为 2*n+1,2*(n+1)</span></span><br><span class="line"><span class="comment">// 注意和起始位置为 1 的构造方法的区别</span></span><br><span class="line"><span class="keyword">transient</span> Object[] queue; <span class="comment">// non-private to simplify nested class access</span></span><br></pre></td></tr></table></figure>



<h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><p>注意，比较器可以为null;</p>
<p>如果为null, 则是自然顺序，但是如果泛型类又没有实现Comparable接口，则会抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化容量、比较器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                     Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Note: This restriction of at least one is not actually needed,</span></span><br><span class="line">    <span class="comment">// but continues for 1.5 compatibility</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">// 这里也没有进行懒处理。</span></span><br><span class="line">    <span class="keyword">this</span>.queue = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="算法逻辑"><a href="#算法逻辑" class="headerlink" title="算法逻辑"></a>算法逻辑</h3><p>这里就jdk中优先队列的实现，复习一下堆的相关操作。</p>
<h4 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h4><p>时间复杂度：O(n)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 建堆操作，</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 原本是 从 size/2 到 1 进行 down(i) 操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (size &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        siftDown(i, (E) queue[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="下移"><a href="#下移" class="headerlink" title="下移"></a>下移</h4><p>时间复杂度：O(log n)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将元素放置在 k 位置上，然后执行 down 操作 </span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">          siftDownUsingComparator(k, x);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          siftDownComparable(k, x);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>这里会区分是根据 comparator 还是 Comparable来进行比较操作。这两个是一样的，任意挑一个看一下源码。</p>
<p>很简单，就是把 k 处元素一直往下移动，直到到达叶子节点或者满足堆的性质。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 采用自然排序</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;)x;</span><br><span class="line">    <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;        <span class="comment">// loop while a non-leaf</span></span><br><span class="line">    <span class="comment">// k &gt;= half 说明已经到叶子了</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// assume left child is least</span></span><br><span class="line">        Object c = queue[child];</span><br><span class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">            ((Comparable&lt;? <span class="keyword">super</span> E&gt;) c).compareTo((E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        <span class="keyword">if</span> (key.compareTo((E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = c;</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="上移"><a href="#上移" class="headerlink" title="上移"></a>上移</h4><p>时间复杂度：O(log n)</p>
<p>也很简单，一直把元素往上移动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;) x;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        Object e = queue[parent];</span><br><span class="line">        <span class="keyword">if</span> (key.compareTo((E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="入队和出队操作的实现"><a href="#入队和出队操作的实现" class="headerlink" title="入队和出队操作的实现"></a>入队和出队操作的实现</h3><ul>
<li><p>入队</p>
<p>将元素放置在最后一个位置，然后<code>siftUp</code>调整。时间复杂度：O(log n)</p>
</li>
<li><p>出队</p>
<p>将第一个元素用最后一个元素替代，最后一个位置置null，然后<code>siftDown</code>调整。时间复杂度：O(log n)</p>
</li>
</ul>
<h3 id="扩容机制-1"><a href="#扩容机制-1" class="headerlink" title="扩容机制"></a>扩容机制</h3><p>如果数组很小，直接双倍size，否则扩容50%。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = queue.length;</span><br><span class="line">    <span class="comment">// Double size if small; else grow by 50%</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((oldCapacity &lt; <span class="number">64</span>) ?</span><br><span class="line">                                     (oldCapacity + <span class="number">2</span>) :</span><br><span class="line">                                     (oldCapacity &gt;&gt; <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    queue = Arrays.copyOf(queue, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="源码阅读笔记"><a href="#源码阅读笔记" class="headerlink" title="源码阅读笔记"></a>源码阅读笔记</h1><h2 id="ArrayDeque-1"><a href="#ArrayDeque-1" class="headerlink" title="ArrayDeque"></a><code>ArrayDeque</code></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现了 Deque 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayDeque</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">                           <span class="keyword">implements</span> <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 存储真实元素的数组，其 length 必为2的整数次幂</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elements; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    不变量: x 为 element、o 为 empty cell</span></span><br><span class="line"><span class="comment">    实例1:</span></span><br><span class="line"><span class="comment">        o x x x x x o o	</span></span><br><span class="line"><span class="comment">          h         t</span></span><br><span class="line"><span class="comment">		实例2:	 </span></span><br><span class="line"><span class="comment">        x x o o o o x x</span></span><br><span class="line"><span class="comment">            t       h</span></span><br><span class="line"><span class="comment">    实例3: (队列空)</span></span><br><span class="line"><span class="comment">        o o o o o o o o</span></span><br><span class="line"><span class="comment">          h(t)</span></span><br><span class="line"><span class="comment">    实例4: (队列满)      </span></span><br><span class="line"><span class="comment">        x x x o x x x x</span></span><br><span class="line"><span class="comment">              t h</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列头部元素在数组中的索引</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span>  head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列尾部元素的下一个元素在数组中的索引</span></span><br><span class="line">    <span class="comment">// 也就是下一个元素要放置的位置索引</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组容量的最小值,必为 2 的整数次幂</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_INITIAL_CAPACITY = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ******  Array allocation and resizing utilities ******</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算能容纳 numElements个元素的最小2的幂次</span></span><br><span class="line">    <span class="comment">// 也就是 arg_min(2^p &gt;= numElements) , 不过这里没有使用循环实现</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateSize</span><span class="params">(<span class="keyword">int</span> numElements)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> initialCapacity = MIN_INITIAL_CAPACITY;</span><br><span class="line">        <span class="comment">// 这里的位运算很巧妙，将形如 10011011的串，转换到 11111111再加1</span></span><br><span class="line">        <span class="keyword">if</span> (numElements &gt;= initialCapacity) &#123;</span><br><span class="line">            initialCapacity = numElements;</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">1</span>);</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">2</span>);</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">4</span>);</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">8</span>);</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">            initialCapacity++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)   <span class="comment">// Too many elements, must back  off</span></span><br><span class="line">                initialCapacity &gt;&gt;&gt;= <span class="number">1</span>;<span class="comment">// Good luck allocating 2 ^ 30 elements</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> initialCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配”空“数组</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">allocateElements</span><span class="params">(<span class="keyword">int</span> numElements)</span> </span>&#123;</span><br><span class="line">        elements = <span class="keyword">new</span> Object[calculateSize(numElements)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只在队列满的时候调用，断言此时 head == tail</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doubleCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> head == tail;</span><br><span class="line">        <span class="keyword">int</span> p = head;</span><br><span class="line">        <span class="keyword">int</span> n = elements.length;</span><br><span class="line">        <span class="keyword">int</span> r = n - p; <span class="comment">// number of elements to the right of p</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = n &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Sorry, deque too big&quot;</span>);</span><br><span class="line">        Object[] a = <span class="keyword">new</span> Object[newCapacity];</span><br><span class="line">        <span class="comment">// 左边的</span></span><br><span class="line">        System.arraycopy(elements, p, a, <span class="number">0</span>, r);</span><br><span class="line">        <span class="comment">// 右边的</span></span><br><span class="line">        System.arraycopy(elements, <span class="number">0</span>, a, r, p);</span><br><span class="line">        elements = a;</span><br><span class="line">        <span class="comment">// 注意 tail 是最后一个元素的下一个位置（循环意义上）</span></span><br><span class="line">        head = <span class="number">0</span>;</span><br><span class="line">        tail = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; T[] copyElements(T[] a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head &lt; tail) &#123;</span><br><span class="line">            System.arraycopy(elements, head, a, <span class="number">0</span>, size());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (head &gt; tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> headPortionLen = elements.length - head;</span><br><span class="line">            System.arraycopy(elements, head, a, <span class="number">0</span>, headPortionLen);</span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, a, headPortionLen, tail);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认构造器的容量是 16, 并没有按照 ArrayList的处理方式进行“懒”处理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayDeque</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        elements = <span class="keyword">new</span> Object[<span class="number">16</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定容量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayDeque</span><span class="params">(<span class="keyword">int</span> numElements)</span> </span>&#123;</span><br><span class="line">        allocateElements(numElements);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayDeque</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        allocateElements(c.size());</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    注意：在数组长度在为2的幂次时，取模运算可以用位运算代替，</span></span><br><span class="line"><span class="comment">    这也正是为什么设计者要把数组容量设置为 2的幂次 的原因了（加快取模操作）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        elements[head = (head - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)] = e;</span><br><span class="line">        <span class="keyword">if</span> (head == tail)</span><br><span class="line">            doubleCapacity();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        elements[tail] = e;</span><br><span class="line">        <span class="keyword">if</span> ( (tail = (tail + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)) == head)</span><br><span class="line">            doubleCapacity();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的返回值是没有意义的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        addFirst(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        addLast(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// removeX 会抛出异常，但 pollX 不会</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        E x = pollFirst();</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        E x = pollLast();</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = head;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        E result = (E) elements[h];</span><br><span class="line">        <span class="comment">// Element is null if deque empty</span></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        elements[h] = <span class="keyword">null</span>;     <span class="comment">// Must null out slot</span></span><br><span class="line">        head = (h + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = (tail - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        E result = (E) elements[t];</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        elements[t] = <span class="keyword">null</span>;</span><br><span class="line">        tail = t;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getX会抛出异常，但 peekX 不会</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        E result = (E) elements[head];</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        E result = (E) elements[(tail - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)];</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// elements[head] is null if deque empty</span></span><br><span class="line">        <span class="keyword">return</span> (E) elements[head];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (E) elements[(tail - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Queue的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        addLast(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> offerLast(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pollFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">element</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> peekFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Stack的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        addFirst(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// *** Collection Methods ***</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一样的道理，本来是取模，现在用位运算，而且做减法的时候无需加上 elements.length</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (tail - head) &amp; (elements.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head == tail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> removeFirstOccurrence(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// head、tail复位、数组的所有cell置空（help GC）</span></span><br><span class="line">    <span class="comment">// 但是注意，此时没有对数组容量作出改变！</span></span><br><span class="line">    <span class="comment">// 此方法的时间复杂度也就是 O(n) 的。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = head;</span><br><span class="line">        <span class="keyword">int</span> t = tail;</span><br><span class="line">        <span class="keyword">if</span> (h != t) &#123; <span class="comment">// clear all cells</span></span><br><span class="line">            head = tail = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> i = h;</span><br><span class="line">            <span class="keyword">int</span> mask = elements.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                elements[i] = <span class="keyword">null</span>;</span><br><span class="line">                i = (i + <span class="number">1</span>) &amp; mask;</span><br><span class="line">            &#125; <span class="keyword">while</span> (i != t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /</span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> copyElements(<span class="keyword">new</span> Object[size()]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = size();</span><br><span class="line">        <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">            <span class="comment">// 注意，泛型数组的创建，需要使用反射的方式</span></span><br><span class="line">            a = (T[])java.lang.reflect.Array.newInstance(</span><br><span class="line">                    a.getClass().getComponentType(), size);</span><br><span class="line">        copyElements(a);</span><br><span class="line">        <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">            a[size] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2340985798034038923L</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="PriorityQueue-1"><a href="#PriorityQueue-1" class="headerlink" title="PriorityQueue"></a><code>PriorityQueue</code></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现了 Queue接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">7720805057305804111L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本实现中，最小的元素放在下标为 0 的位置，</span></span><br><span class="line">    <span class="comment">// 某个下标为 n 的节点的左右孩子的下标为 2*n+1,2*(n+1)</span></span><br><span class="line">    <span class="comment">// 注意和起始位置为 1 的构造方法的区别</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] queue; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元素的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较器，如果为null, 则是自然顺序（如果没有实现Comparable接口，报错）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, comparator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化容量、比较器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Note: This restriction of at least one is not actually needed,</span></span><br><span class="line">        <span class="comment">// but continues for 1.5 compatibility</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 三种构造方式：SortedSet、PriorityQueue、普通Collection</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c <span class="keyword">instanceof</span> SortedSet&lt;?&gt;) &#123;</span><br><span class="line">            SortedSet&lt;? extends E&gt; ss = (SortedSet&lt;? extends E&gt;) c;</span><br><span class="line">            <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) ss.comparator();</span><br><span class="line">            initElementsFromCollection(ss);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c <span class="keyword">instanceof</span> PriorityQueue&lt;?&gt;) &#123;</span><br><span class="line">            PriorityQueue&lt;? extends E&gt; pq = (PriorityQueue&lt;? extends E&gt;) c;</span><br><span class="line">            <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) pq.comparator();</span><br><span class="line">            initFromPriorityQueue(pq);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.comparator = <span class="keyword">null</span>;</span><br><span class="line">            initFromCollection(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(PriorityQueue&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) c.comparator();</span><br><span class="line">        initFromPriorityQueue(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(SortedSet&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) c.comparator();</span><br><span class="line">        <span class="comment">// 已经有序了，所以无需堆化</span></span><br><span class="line">        initElementsFromCollection(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initFromPriorityQueue</span><span class="params">(PriorityQueue&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c.getClass() == PriorityQueue.class) &#123;</span><br><span class="line">            <span class="keyword">this</span>.queue = c.toArray();</span><br><span class="line">            <span class="keyword">this</span>.size = c.size();</span><br><span class="line">        <span class="comment">// 有可能是 PriorityQueue 的子类</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            initFromCollection(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initElementsFromCollection</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="keyword">if</span> (c.getClass() != ArrayList.class)</span><br><span class="line">            a = Arrays.copyOf(a, a.length, Object[].class);</span><br><span class="line">        <span class="keyword">int</span> len = a.length;</span><br><span class="line">        <span class="comment">// 检查为null</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span> || <span class="keyword">this</span>.comparator != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">                <span class="keyword">if</span> (a[i] == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.queue = a;</span><br><span class="line">        <span class="keyword">this</span>.size = a.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initFromCollection</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        initElementsFromCollection(c);</span><br><span class="line">        <span class="comment">// 建堆操作</span></span><br><span class="line">        heapify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心扩容函数</span></span><br><span class="line">    <span class="comment">// size 过小则 double 一下；否则，增长一半</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oldCapacity = queue.length;</span><br><span class="line">        <span class="comment">// Double size if small; else grow by 50%</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + ((oldCapacity &lt; <span class="number">64</span>) ?</span><br><span class="line">                                         (oldCapacity + <span class="number">2</span>) :</span><br><span class="line">                                         (oldCapacity &gt;&gt; <span class="number">1</span>));</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        queue = Arrays.copyOf(queue, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> offer(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用 siftUp函数</span></span><br><span class="line">    <span class="comment">// 也就是插入数组末端，然后向上 up </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">int</span> i = size;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">            grow(i + <span class="number">1</span>);</span><br><span class="line">        size = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">            queue[<span class="number">0</span>] = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftUp(i, e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (size == <span class="number">0</span>) ? <span class="keyword">null</span> : (E) queue[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意，这一步仍然没有减少数组容量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            queue[i] = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用数组的最后一个元素代替第一个元素，然后从位置 0 处进行一次down操作</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> s = --size;</span><br><span class="line">        modCount++;</span><br><span class="line">        E result = (E) queue[<span class="number">0</span>];</span><br><span class="line">        E x = (E) queue[s];</span><br><span class="line">        queue[s] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">            siftDown(<span class="number">0</span>, x);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将元素放置在 k 位置上，然后执行 up 操作</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">            siftUpUsingComparator(k, x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftUpComparable(k, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;) x;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 注意在从 0 开始的情况下，父亲的节点是 (k-1)/2</span></span><br><span class="line">            <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            Object e = queue[parent];</span><br><span class="line">            <span class="keyword">if</span> (key.compareTo((E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            queue[k] = e;</span><br><span class="line">            k = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[k] = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 算法同上</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将元素放置在 k 位置上，然后执行 down 操作 </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">            siftDownUsingComparator(k, x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftDownComparable(k, x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 采用自然排序</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;)x;</span><br><span class="line">        <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;        <span class="comment">// loop while a non-leaf</span></span><br><span class="line">        <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">            <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// assume left child is least</span></span><br><span class="line">            Object c = queue[child];</span><br><span class="line">            <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">                ((Comparable&lt;? <span class="keyword">super</span> E&gt;) c).compareTo((E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">                c = queue[child = right];</span><br><span class="line">            <span class="keyword">if</span> (key.compareTo((E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            queue[k] = c;</span><br><span class="line">            k = child;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[k] = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 算法是相同的，只不过是比较器罢了</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 算法同上</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建堆操作，时间复杂度：O(n)</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 原本是 从 size/2 到 1 进行 down(i) 操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (size &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            siftDown(i, (E) queue[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java集合类</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Java集合类</tag>
        <tag>源码系列</tag>
      </tags>
  </entry>
  <entry>
    <title>Reactor和Proactor</title>
    <url>/2021/11/30/Reactor%E5%92%8CProactor/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
  </entry>
  <entry>
    <title>Raft</title>
    <url>/2021/12/09/Raft/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>参考</p>
<p><a href="https://zinglix.xyz/2020/06/25/raft/">https://zinglix.xyz/2020/06/25/raft/</a></p>
<p><a href="https://mp.weixin.qq.com/s/ZmRS9Gjh9P-4lPLZ9jWk_A">https://mp.weixin.qq.com/s/ZmRS9Gjh9P-4lPLZ9jWk_A</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>Redis-哨兵</title>
    <url>/2021/12/09/Redis-%E5%93%A8%E5%85%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>Redis主从复制的作用有数据热备、负载均衡、故障恢复等；但主从复制存在的一个问题是故障恢复无法自动化。本文将要介绍的哨兵，它基于Redis主从复制，主要作用便是解决主节点故障恢复的自动化问题，进一步提高系统的高可用性。</p>
</blockquote>
<h2 id="部署哨兵节点"><a href="#部署哨兵节点" class="headerlink" title="部署哨兵节点"></a>部署哨兵节点</h2><p><strong>哨兵节点本质上是特殊的Redis节点</strong>，它的两个基本功能是<strong>监控</strong>和<strong>故障转移</strong>。</p>
<p>新建一个配置文件<code>sentinel.conf</code>,内容为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> sentinel monitor mymaster ip port quorum</span></span><br><span class="line">sentinel monitor mymaster 192.168.92.128 6379 2</span><br></pre></td></tr></table></figure>



<p>其中，sentinel monitor mymaster 192.168.92.128 6379 2 配置的含义是：</p>
<p>该哨兵节点监控192.168.92.128:6379这个主节点，该主节点的名称是mymaster，最后的2表示最低通过票数，与主节点的故障判定有关：至少需要2个哨兵节点同意，才能判定主节点故障并进行故障转移。</p>
<p>注意，在配置哨兵监控一个系统的时候，只需要配置其监控主数据库即可，哨兵会自动发现所有复制该主库的从库。</p>
<p>哨兵节点的启动有两种方式，二者作用是完全相同的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-sentinel sentinel-26379.conf</span><br><span class="line">redis-server sentinel-26379.conf --sentinel</span><br></pre></td></tr></table></figure>


<p>哨兵系统的搭建过程，有几点需要注意：</p>
<p>（1）哨兵系统中的主从节点，与普通的主从节点并没有什么区别，故障发现和转移是由哨兵来控制和完成的。</p>
<p>（2）哨兵节点本质上是redis节点。</p>
<p>（3）<strong>每个哨兵节点，只需要配置监控主节点</strong>，便可以自动发现其他的哨兵节点和从节点。</p>
<p>（4）在哨兵节点启动和故障转移阶段，各个节点的配置文件会被重写(config rewrite)。</p>
<h2 id="Jedis使用哨兵"><a href="#Jedis使用哨兵" class="headerlink" title="Jedis使用哨兵"></a>Jedis使用哨兵</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSentinel</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">         String masterName = <span class="string">&quot;mymaster&quot;</span>;</span><br><span class="line">         Set&lt;String&gt; sentinels = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">         sentinels.add(<span class="string">&quot;192.168.92.128:26379&quot;</span>);</span><br><span class="line">         sentinels.add(<span class="string">&quot;192.168.92.128:26380&quot;</span>);</span><br><span class="line">         sentinels.add(<span class="string">&quot;192.168.92.128:26381&quot;</span>);</span><br><span class="line"> </span><br><span class="line">         JedisSentinelPool pool = <span class="keyword">new</span> JedisSentinelPool(masterName, sentinels); <span class="comment">//初始化过程做了很多工作</span></span><br><span class="line">         Jedis jedis = pool.getResource();</span><br><span class="line">         jedis.set(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">         pool.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Jedis客户端对哨兵提供了很好的支持。如上述代码所示，我们只需要向Jedis提供哨兵节点集合和masterName，构造JedisSentinelPool对象；然后便可以像使用普通redis连接池一样来使用了：通过pool.getResource()获取连接，执行具体的命令。</p>
<p>在整个过程中，我们的代码<strong>不需要显式的指定主节点的地址</strong>，就可以连接到主节点；</p>
<p>代码中对故障转移没有任何体现，就可以<strong>在哨兵完成故障转移后自动的切换主节点</strong>。</p>
<p>之所以可以做到这一点，是因为在JedisSentinelPool的构造器中，进行了相关的工作；主要包括以下两点：</p>
<p>（1）<strong>遍历哨兵节点，获取主节点信息：</strong>遍历哨兵节点，通过其中一个哨兵节点+masterName获得主节点的信息；该功能是通过调用哨兵节点的sentinel get-master-addr-by-name命令实现，该命令示例如下：</p>
<p>一旦获得主节点信息，停止遍历（因此一般来说遍历到第一个哨兵节点，循环就停止了）。</p>
<p>（2）<strong>增加对哨兵的监听：</strong>这样当<strong>发生故障转移时，客户端便可以收到哨兵的通知</strong>，从而完成主节点的切换。具体做法是：<strong>利用redis提供的发布订阅功能，为每一个哨兵节点开启一个单独的线程，订阅哨兵节点的+switch-master频道，当收到消息时，重新初始化连接池</strong>。</p>
<p><strong>需要注意的是，哨兵只是配置提供者，而不是代理</strong>。</p>
<h2 id="哨兵的原理"><a href="#哨兵的原理" class="headerlink" title="哨兵的原理"></a>哨兵的原理</h2><p>关于哨兵的原理，关键是了解以下几个概念。</p>
<h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><p>每个哨兵节点维护了3个定时任务。定时任务的功能分别如下：1. 通过向主从节点发送info命令获取最新的主从结构；2. 通过发布订阅功能获取其他哨兵节点的信息；3. 通过向其他节点发送ping命令进行心跳检测，判断是否下线。</p>
<ol>
<li><p><strong>每10秒哨兵会向主数据库和从数据库发送Info命令</strong>。发送Info命令是的哨兵能够获得主节点的相关信息，并能够获得到从节点的信息，从而<strong>实现对新节点的自动发现</strong>。</p>
</li>
<li><p><strong>每2秒哨兵向主数据库和从数据库的__sentinel__:hello频道发送自己的信息</strong> ，用于分享和获取同样监控此数据库的哨兵节点的信息。当其他节点受到信息后，会判断发消息的哨兵节点是否是新发现的节点，如果是则会加入哨兵列表。</p>
</li>
<li><p><strong>每30秒会向主数据库、从数据库和其他哨兵节点发送PING命令</strong>。此命令的作用就是用于<strong>定时监控这些数据库和哨兵节点有没有停止服务</strong>，很关键的一点。</p>
</li>
</ol>
<h3 id="主观下线和客观下线"><a href="#主观下线和客观下线" class="headerlink" title="主观下线和客观下线"></a>主观下线和客观下线</h3><ul>
<li>主观下线：在心跳检测的定时任务中，如果其他节点超过一定时间没有回复，哨兵节点就会将其进行主观下线。顾名思义，<strong>主观下线的意</strong>思是一个哨兵节点“主观地”判断下线，也就是哨兵它自己认为一个节点下线了，但还没有得到其他节点的认同；与主观下线相对应的是客观下线。</li>
</ul>
<ul>
<li>客观下线：哨兵节点在对主节点进行主观下线后，会通过<code>sentinel is-master-down-by-addr</code>命令询问其他哨兵节点该主节点的状态；<strong>如果判断主节点下线的哨兵数量达到一定数值，则对该主节点进行客观下线</strong>。</li>
</ul>
<p>需要特别注意的是，<strong>客观下线是主节点才有的概念</strong>；<strong>如果从节点和哨兵节点发生故障，被哨兵主观下线后，不会再有后续的客观下线和故障转移操作</strong>。</p>
<h3 id="选举领导者哨兵节点"><a href="#选举领导者哨兵节点" class="headerlink" title="选举领导者哨兵节点"></a>选举领导者哨兵节点</h3><p>当主节点被判断客观下线以后，各个哨兵节点会进行协商，选举出一个领导者哨兵节点，并由该领导者节点对其进行故障转移操作。</p>
<p>监视该主节点的所有哨兵都有可能被选为领导者，选举使用的算法是Raft算法。</p>
<p>使用Raft算法选举领头哨兵的过程如下：</p>
<ol>
<li>发现主数据库客观下线的哨兵节点（称为节点A），向每个哨兵节点发送命令，要求对方选自己称为领导者哨兵。</li>
<li>如果目标哨兵节点没有选过其他人，则会同意将A设置成领头节点。</li>
<li>如果A发现有超过半数且超过quorum参数值的哨兵节点同意选自己为领导者节点，则A成功成为领导者节点。</li>
<li>当有多个哨兵节点同时参选领头节点的时候，则会出现任何节点都不能当选的情况，这个时候每个参选节点都等待一个随机时间重新发起参选请求，进行下一轮选举，直到选举成功。</li>
</ol>
<p><strong>注意：每次选举出来的最多只会选出一个领头哨兵。</strong></p>
<h3 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h3><p>选举出的领导者哨兵，开始进行故障恢复操作，该操作大体可以分为3个步骤： </p>
<ol>
<li><strong>在从节点中选择新的主节点</strong>：选择的原则是，<strong>首先过滤掉不健康的从节点；然后选择优先级最高的从节点(由slave-priority指定)；如果优先级无法区分，则选择复制偏移量最大的从节点；如果仍无法区分，则选择runid最小的从节点</strong>。（健康状态–&gt;优先级–&gt;复制偏移量–&gt;runid）</li>
<li><strong>更新主从状态</strong>：<strong>通过slaveof no one命令，让选出来的从节点成为主节点</strong>；并<strong>通过slaveof命令让其他节点成为其从节点</strong>。</li>
<li><strong>将已经下线的主节点(如localhost:6379)设置为新的主节点的从节点</strong>，当localhost:6379重新上线后，它会成为新的主节点的从节点。</li>
</ol>
<p>通过上述几个关键概念，可以基本了解哨兵的工作原理。为了更形象的说明，下图展示了领导者哨兵节点的日志，包括从节点启动到完成故障转移。</p>
<p><img src="/2021/12/09/Redis-%E5%93%A8%E5%85%B5/Redis-%E5%93%A8%E5%85%B51.png"></p>
<h2 id="配置与实践建议"><a href="#配置与实践建议" class="headerlink" title="配置与实践建议"></a>配置与实践建议</h2><h3 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h3><p>下面介绍与哨兵相关的几个配置。</p>
<ol>
<li>sentinel monitor {masterName} {masterIp} {masterPort} {quorum}</li>
</ol>
<p>sentinel monitor是哨兵最核心的配置，在前文讲述部署哨兵节点时已说明，其中：masterName指定了主节点名称，masterIp和masterPort指定了主节点地址<strong>，quorum是判断主节点客观下线的哨兵数量阈值</strong>：当判定主节点下线的哨兵数量达到quorum时，对主节点进行客观下线。<strong>quorum建议取值为N/2 + 1（其中 N 为哨兵节点的数量）</strong>。</p>
<ol start="2">
<li>sentinel down-after-milliseconds {masterName} {time}</li>
</ol>
<p>sentinel down-after-milliseconds与主观下线的判断有关：<strong>哨兵使用ping命令对其他节点进行心跳检测，如果其他节点超过down-after-milliseconds配置的时间没有回复，哨兵就会将其进行主观下线</strong>。该配置对主节点、从节点和哨兵节点的主观下线判定都有效。</p>
<p>down-after-milliseconds的默认值是30000，即30s；可以根据不同的网络环境和应用要求来调整：值越大，对主观下线的判定会越宽松，好处是误判的可能性小，坏处是故障发现和故障转移的时间变长，客户端等待的时间也会变长。例如，如果应用对可用性要求较高，则可以将值适当调小，当故障发生时尽快完成转移；如果网络环境相对较差，可以适当提高该阈值，避免频繁误判。</p>
<ol start="3">
<li>sentinel parallel-syncs {masterName} {number}</li>
</ol>
<p>sentinel parallel-syncs与故障转移之后从节点的复制有关，<strong>规定了每次向新的主节点发起复制操作的从节点个数</strong>。例如，假设主节点切换完成之后，有3个从节点要向新的主节点发起复制；如果parallel-syncs=1，则从节点会一个一个开始复制；如果parallel-syncs=3，则3个从节点会一起开始复制。</p>
<p>parallel-syncs取值越大，从节点完成复制的时间越快，但是对主节点的网络负载、硬盘负载造成的压力也越大；应根据实际情况设置。例如，如果主节点的负载较低，而从节点对服务可用的要求较高，可以适量增加parallel-syncs取值。parallel-syncs的默认值是1。</p>
<ol start="4">
<li>sentinel failover-timeout {masterName} {time}</li>
</ol>
<p>sentinel failover-timeout与故障转移超时的判断有关，但是<strong>该参数不是用来判断整个故障恢复阶段的超时</strong>，而是其几个子阶段的超时，例如如果<strong>从节点晋升为主节点时间超过timeout</strong>，或<strong>从节点向新的主节点发起复制操作的时间</strong>(不包括复制数据的时间)超过timeout，都会导致故障转移超时失败。</p>
<p>failover-timeout的默认值是180000，即180s；如果超时，则下一次该值会变为原来的2倍。</p>
<h3 id="实践建议"><a href="#实践建议" class="headerlink" title="实践建议"></a>实践建议</h3><p>（1）<strong>哨兵节点的数量应不止一个</strong>，一方面增加哨兵节点的冗余，避免哨兵本身成为高可用的瓶颈；另一方面减少对下线的误判。此外，<strong>这些不同的哨兵节点应部署在不同的物理机上</strong>。</p>
<p>（2）<strong>哨兵节点的数量应该是奇数</strong>，便于哨兵通过投票做出“决策”：领导者选举的决策、客观下线的决策等。</p>
<p>（3）<strong>各个哨兵节点的配置应一致</strong>，包括硬件、参数等；此外，所有节点都应该使用ntp或类似服务，保证时间准确、一致。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
        <tag>Redis</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 持久化机制</title>
    <url>/2021/12/01/Redis-%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Redis是一个内存数据库，所有的数据将保存在内存中，这与传统的MySQL、Oracle、SqlServer等关系型数据库直接把数据保存到硬盘相比，Redis的读写效率非常高。但是保存在内存中也有一个很大的缺陷，一旦断电或者宕机，内存数据库中的内容将会全部丢失。为了弥补这一缺陷，Redis提供了把内存数据持久化到硬盘文件，以及通过备份文件来恢复数据的功能，即Redis持久化机制。</p>
<p>Redis支持两种方式的持久化：RDB快照和AOF。</p>
<img src="summary.jpeg" alt="img" style="zoom:60%;" />



<h1 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h1><p>RDB快照用官方的话来说：RDB持久化方案是按照指定时间间隔对你的数据集生成的<strong>时间点快照</strong>（point-to-time snapshot）。</p>
<p>它<strong>以紧缩的二进制文件保存Redis数据库某一时刻所有数据对象的内存快照</strong>，可用于Redis的数据<strong>备份</strong>、<strong>转移</strong>与<strong>恢复</strong>。到目前为止，仍是官方的默认支持方案。</p>
<h2 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h2><p>触发的方式分为手动和自动。手动触发容易理解，是指我们通过Redis客户端人为的对Redis服务端发起持久化备份指令，然后Redis服务端开始执行持久化流程，这里的指令有save和bgsave。自动触发是Redis根据自身运行要求，在满足预设条件时自动触发的持久化流程。</p>
<h3 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h3><ul>
<li>serverCron中<code>save m n</code>配置规则自动触发；</li>
<li>从节点全量复制时，主节点发送rdb文件给从节点完成复制操作，主节点会出发bgsave；</li>
<li>执行<code>debug reload</code>命令重新加载redis时；</li>
<li>默认情况下（未开启AOF）执行shutdown命令时，自动执行bgsave；</li>
</ul>
<p><strong>save规则及检查</strong></p>
<p><code>serverCron</code>是Redis内的一个周期性函数，每隔100毫秒执行一次，它的其中一项工作就是：根据配置文件中save规则来判断当前需要进行自动持久化流程，如果满足条件则尝试开始持久化。</p>
<p><code>save m n</code>的意思是：m秒内有n条写入就触发一次快照，即备份一次。save参数可以配置多组，满足在不同条件的备份要求。如果需要关闭RDB的自动备份策略，可以使用<code>save &quot;&quot;</code>。以下为几种配置的说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 表示900秒（15分钟）内至少有1个key的值发生变化，则执行</span><br><span class="line">save 900 1</span><br><span class="line"># 表示300秒（5分钟）内至少有1个key的值发生变化，则执行</span><br><span class="line">save 300 10</span><br><span class="line"># 表示60秒（1分钟）内至少有10000个key的值发生变化，则执行</span><br><span class="line">save 60 10000</span><br><span class="line"># 该配置将会关闭RDB方式的持久化</span><br><span class="line">save &quot;&quot;</span><br></pre></td></tr></table></figure>






<h3 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h3><ol>
<li><code>save</code></li>
<li><code>bgsave</code></li>
<li><code>flushall</code></li>
</ol>
<p>总结如下图所示：</p>
<p><img src="/2021/12/01/Redis-%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/durable.png"></p>
<h2 id="持久化原理"><a href="#持久化原理" class="headerlink" title="持久化原理"></a>持久化原理</h2><p>在Redis内完成RDB持久化的方法有rdbSave和rdbSaveBackground两个函数方法（源码文件rdb.c中），先简单说下两者差别：</p>
<ul>
<li><code>rdbSave</code>：是同步执行的，方法调用后就会立刻启动持久化流程。由于Redis是单线程模型，持久化过程中会阻塞，Redis无法对外提供服务；</li>
<li><code>rdbSaveBackground</code>：是后台（异步）执行的，该方法会fork出子进程，真正的持久化过程是在子进程中执行的（调用rdbSave），主进程会继续提供服务；</li>
</ul>
<ol>
<li><p>第一种情况不可取，持久化备份会导致短时间内Redis服务不可用，这<strong>对于高可用的系统来讲是无法容忍的</strong>。</p>
</li>
<li><p>第二种方式是RDB持久化的主要实践方式。由于fork子进程后，父进程数据一直在变化，子进程并不与父进程同步，<strong>RDB持久化必然无法保证实时性</strong>；RDB持久化完成后发生断电或宕机，会导致部分数据丢失；<strong>备份频率决定了丢失数据量的大小</strong>，提高备份频率，意味着fork过程消耗较多的CPU资源，也会导致较大的磁盘I/O。</p>
</li>
</ol>
<h3 id="Fork-和-CopyOnWrite"><a href="#Fork-和-CopyOnWrite" class="headerlink" title="Fork 和 CopyOnWrite"></a>Fork 和 CopyOnWrite</h3><p>Redis默认会把快照存储文件存储在当前进程的工作目录中的dump.rdb文件中，可以用配置<code>dir</code>和<code>dbfilename</code>配置存储路径和文件名。</p>
<p><strong>快照的过程</strong></p>
<ol>
<li>Redis使用<code>fork</code>函数创建一个子进程复制一份当前进程的副本——子进程；</li>
<li>父进程继续接受并处理客户端发来的命令，而子进程开始将内存中的数据写入硬盘中临时文件。</li>
<li>当子进程写入完所有数据后会用该临时文件替换旧的RDB备份文件，至此一次备份完成。</li>
</ol>
<blockquote>
<p>注意，这里使用到了 Unix中 CoW，也就是写时复制技术。具体的，这里就不介绍了。</p>
</blockquote>
<p>需要注意的是，如果父进程内存占用过大，fork过程会比较耗时，在这个过程中父进程无法对外提供服务；</p>
<p>另外，需要综合考虑计算机内存使用量，fork子进程后会占用双倍的内存资源，需要确保内存够用。</p>
<p>通过<code>info stats</code>(在redis-cli中查看)命令查看latest_fork_usec选项，可以获取最近一个fork以操作的耗时。</p>
<h3 id="rdbSaveBackground"><a href="#rdbSaveBackground" class="headerlink" title="rdbSaveBackground"></a>rdbSaveBackground</h3><p>rdbSaveBackground是RDB持久化的辅助性方法，主要工作是fork子进程，然后根据调用方（父进程或者子进程）不同，有两种不同的执行逻辑。</p>
<ul>
<li>如果调用方是父进程，则fork出子进程，保存子进程信息后直接返回。</li>
<li>如果调用方是子进程则调用rdbSave执行RDB持久化逻辑，持久化完成后退出子进程。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSaveBackground</span><span class="params">(<span class="keyword">char</span> *filename, rdbSaveInfo *rsi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> childpid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasActiveChildProcess()) <span class="keyword">return</span> C_ERR;</span><br><span class="line"></span><br><span class="line">    server.dirty_before_bgsave = server.dirty;</span><br><span class="line">    server.lastbgsave_try = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fork子进程</span></span><br><span class="line">    <span class="keyword">if</span> ((childpid = redisFork(CHILD_TYPE_RDB)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Child 子进程：修改进程标题 */</span></span><br><span class="line">        redisSetProcTitle(<span class="string">&quot;redis-rdb-bgsave&quot;</span>);</span><br><span class="line">        redisSetCpuAffinity(server.bgsave_cpulist);</span><br><span class="line">        <span class="comment">// 执行rdb持久化</span></span><br><span class="line">        retval = rdbSave(filename,rsi);</span><br><span class="line">        <span class="keyword">if</span> (retval == C_OK) &#123;</span><br><span class="line">            sendChildCOWInfo(CHILD_TYPE_RDB, <span class="number">1</span>, <span class="string">&quot;RDB&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 持久化完成后，退出子进程</span></span><br><span class="line">        exitFromChild((retval == C_OK) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Parent 父进程：记录fork子进程的时间等信息*/</span></span><br><span class="line">        <span class="keyword">if</span> (childpid == <span class="number">-1</span>) &#123;</span><br><span class="line">            server.lastbgsave_status = C_ERR;</span><br><span class="line">            serverLog(LL_WARNING,<span class="string">&quot;Can&#x27;t save in background: fork: %s&quot;</span>,</span><br><span class="line">                strerror(errno));</span><br><span class="line">            <span class="keyword">return</span> C_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">&quot;Background saving started by pid %ld&quot;</span>,(<span class="keyword">long</span>) childpid);</span><br><span class="line">        <span class="comment">// 记录子进程开始的时间、类型等。</span></span><br><span class="line">        server.rdb_save_time_start = time(<span class="literal">NULL</span>);</span><br><span class="line">        server.rdb_child_type = RDB_CHILD_TYPE_DISK;</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C_OK; <span class="comment">/* unreached */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="rdbSave"><a href="#rdbSave" class="headerlink" title="rdbSave"></a>rdbSave</h3><p><code>rdbSave</code>是真正执行持久化的方法，它在执行时存在大量的I/O、计算操作，耗时、CPU占用较大，<strong>在Redis的单线程模型中持久化过程会持续占用线程资源</strong>，<strong>进而导致Redis无法提供其他服务</strong>。</p>
<p>为了解决这一问题Redis在rdbSaveBackground中fork出子进程，由子进程完成持久化工作，避免了占用父进程过多的资源。</p>
<p>整体流程可以总结为：创建并打开临时文件、Redis内存数据写入临时文件、临时文件写入磁盘、临时文件重命名为正式RDB文件、更新持久化状态信息（dirty、lastsave）。其中“Redis内存数据写入临时文件”最为核心和复杂，写入过程直接体现了RDB文件的文件格式，本着一图胜千言的理念，我按照源码流程绘制了下图。</p>
<img src="rdbsave.png" style="zoom:30%;" />







<h1 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h1><p>RDB是一种时间点（point-to-time）快照，适合数据备份及灾难恢复，由于工作原理的“先天性缺陷”无法保证实时性持久化，这对于缓存丢失零容忍的系统来说是个硬伤，于是就有了AOF。</p>
<h2 id="AOF原理"><a href="#AOF原理" class="headerlink" title="AOF原理"></a>AOF原理</h2><p>AOF是Append Only File的缩写，它是Redis的完全持久化策略，从1.1版本开始支持；这里的file存储的是引起Redis数据修改的命令集合（比如：set/hset/del等）。</p>
<p>这些集合按照Redis Server的处理顺序追加到文件中。当重启Redis时，Redis就可以从头读取AOF中的指令并重放，进而恢复关闭前的数据状态。</p>
<p>AOF持久化默认是关闭的，修改redis.conf以下信息并重启，即可开启AOF持久化功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># no-关闭，yes-开启，默认no</span><br><span class="line">appendonly yes</span><br><span class="line">appendfilename appendonly.aof</span><br></pre></td></tr></table></figure>

<p>AOF本质是为了持久化，持久化对象是Redis内每一个key的状态，持久化的目的是为了在Reids发生故障重启后能够恢复至重启前或故障前的状态。相比于RDB，AOF采取的策略是按照执行顺序持久化每一条能够引起Redis中对象状态变更的命令，命令是有序的、有选择的。把aof文件转移至任何一台Redis Server，从头到尾按序重放这些命令即可恢复如初。</p>
<p>最本质的原理用<strong>命令重放</strong>四个字就可以概括。</p>
<p>但是，考虑实际生产环境的复杂性及操作系统等方面的限制，Redis所要考虑的工作要比这个例子复杂的多。</p>
<h2 id="持久化流程"><a href="#持久化流程" class="headerlink" title="持久化流程"></a>持久化流程</h2><p>从流程上来看，AOF的工作原理可以概括为几个步骤：</p>
<p>命令追加（append）、文件写入与同步（fsync）、文件重写（rewrite）、重启加载（load）。</p>
<p><img src="/2021/12/01/Redis-%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/aof.png"></p>
<h3 id="命令追加"><a href="#命令追加" class="headerlink" title="命令追加"></a>命令追加</h3><p>当 AOF 持久化功能处于打开状态时，Redis 在执行完一个写命令之后，会以协议格式(也就是RESP，即 Redis 客户端和服务器交互的通信协议 )把被执行的写命令追加到 Redis 服务端维护的 AOF 缓冲区末尾。对AOF文件只有单线程的追加操作，没有seek等复杂的操作，即使断电或宕机也不存在文件损坏风险。</p>
<h3 id="文件写入与同步"><a href="#文件写入与同步" class="headerlink" title="文件写入与同步"></a>文件写入与同步</h3><p>AOF文件的写入与同步离不开操作系统的支持，开始介绍之前，我们需要补充一下Linux I/O缓冲区相关知识。硬盘I/O性能较差，文件读写速度远远比不上CPU的处理速度，如果每次文件写入都等待数据写入硬盘，会整体拉低操作系统的性能。为了解决这个问题，操作系统提供了延迟写（delayed write）机制来提高硬盘的I/O性能。</p>
<blockquote>
<p>传统的UNIX实现在内核中设有缓冲区高速缓存或页面高速缓存，大多数磁盘I/O都通过缓冲进行。 当将数据写入文件时，内核通常先将该数据复制到其中一个缓冲区中，如果该缓冲区尚未写满，则并不将其排入输出队列，而是等待其写满或者当内核需要重用该缓冲区以便存放其他磁盘块数据时， 再将该缓冲排入到输出队列，然后待其到达队首时，才进行实际的I/O操作。这种输出方式就被称为延迟写。</p>
<p>为了保证磁盘上实际文件系统与缓冲区高速缓存中内容的一致性，UNIX系统提供了<code>sync</code>、<code>fsync</code>和<code>fdatasync</code>三个函数为强制写入硬盘提供支持。</p>
</blockquote>
<p>延迟写减少了磁盘读写次数，但是却降低了文件内容的更新速度，使得欲写到文件中的数据在一段时间内并没有写到磁盘上。当系统发生故障时，这种延迟可能造成文件更新内容的丢失。</p>
<p>Redis每次事件轮训结束前（<code>beforeSleep</code>）都会调用函数<code>flushAppendOnlyFile</code>。</p>
<p><code>flushAppendOnlyFile</code>会把AOF缓冲区（<code>aof_buf</code>）中的数据写入内核缓冲区，</p>
<p>并且根据<code>appendfsync</code>配置来决定采用何种策略把内核缓冲区中的数据写入磁盘，即调用<code>fsync()</code>。该配置有三个可选项<code>always</code>、<code>no</code>、<code>everysec</code>，具体说明如下：</p>
<ul>
<li>always：每次都调用<code>fsync()</code>，是安全性最高、性能最差的一种策略。</li>
<li>no：不会调用<code>fsync()</code>。性能最好，安全性最差。</li>
<li>everysec：仅在满足同步条件时调用<code>fsync()</code>。<strong>这是官方建议的同步策略</strong>，也是默认配置，做到兼顾性能和数据安全性，理论上只有在系统突然宕机的情况下丢失1秒的数据。</li>
</ul>
<p>注意：上面介绍的策略受配置项<code>no-appendfsync-on-rewrite</code>的影响，它的作用是告知Redis：AOF文件重写期间是否禁止调用fsync()，默认是no，即允许允许调用<code>fsync</code>。</p>
<h3 id="文件重写"><a href="#文件重写" class="headerlink" title="文件重写"></a>文件重写</h3><p>如前面提到的，Redis长时间运行，命令不断写入AOF，文件会越来越大，不加控制可能影响宿主机的安全。</p>
<p>为了解决AOF文件体积问题，Redis引入了<strong>AOF文件重写</strong>功能，它会根据Redis内数据对象的最新状态生成新的AOF文件，<strong>新旧文件对应的数据状态一致，但是新文件会具有较小的体积</strong>。重写既减少了AOF文件对磁盘空间的占用，又可以提高Redis重启时数据恢复的速度。</p>
<p><strong>AOF文件太大时会触发AOF文件重写，那到底是多大呢？有哪些情况会触发重写操作呢？</strong></p>
<p>与RDB方式一样，AOF文件重写既可以手动触发，也会自动触发。手动触发直接调用<code>bgrewriteaof</code>命令，如果当时无子进程执行会立刻执行，否则安排在子进程结束后执行。自动触发由Redis的周期性方法<code>serverCron</code>检查在满足一定条件时触发。先了解两个配置项：</p>
<ul>
<li>auto-aof-rewrite-percentage：代表当前AOF文件大小（aof_current_size）和上一次重写后AOF文件大小（aof_base_size）相比，增长的比例。</li>
<li>auto-aof-rewrite-min-size：表示运行<code>BGREWRITEAOF</code>时AOF文件占用空间最小值，默认为64MB；</li>
</ul>
<p>Redis启动时把<code>aof_base_size</code>初始化为当时aof文件的大小，Redis运行过程中，当AOF文件重写操作完成时，会对其进行更新；<code>aof_current_size</code>为<code>serverCron</code>执行时AOF文件的实时大小。当满足以下两个条件时，AOF文件重写就会触发：</p>
<ol>
<li><p>增长比例：(aof_current_size - aof_base_size) / aof_base_size &gt; auto-aof-rewrite-percentage</p>
</li>
<li><p>文件大小：aof_current_size &gt; auto-aof-rewrite-min-size</p>
</li>
</ol>
<h3 id="混合持久化方案"><a href="#混合持久化方案" class="headerlink" title="混合持久化方案"></a>混合持久化方案</h3><p>除了纯AOF的方式，还有RDB+AOF方式。</p>
<p>这一策略由配置参数<code>aof-use-rdb-preamble</code>（使用RDB作为AOF文件的前半段）控制，设置为yes可开启。所以，在AOF重写过程中文件的写入会有两种不同的方式。</p>
<ul>
<li>no：按照AOF格式写入命令，与4.0前版本无差别；</li>
<li>yes：先按照RDB格式写入数据状态，然后把重写期间AOF缓冲区的内容以AOF格式写入，文件前半部分为RDB格式，后半部分为AOF格式。</li>
</ul>
<h3 id="重启加载"><a href="#重启加载" class="headerlink" title="重启加载"></a>重启加载</h3><p>Redis启动后通过<code>loadDataFromDisk</code>函数执行数据加载工作。这里需要注意，虽然持久化方式可以选择AOF、RDB或者两者兼用，但是<strong>数据加载时必须做出选择</strong>，两种方式各自加载一遍就乱套了。</p>
<p>理论上，AOF持久化比RDB具有更好的实时性，当<strong>开启了AOF持久化方式，Redis在数据加载时优先考虑AOF方式</strong>。而且，Redis 4.0版本后AOF支持了混合持久化，加载AOF文件需要考虑版本兼容性。Redis数据加载流程如下图所示：</p>
<p><img src="/2021/12/01/Redis-%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/aof-info.png"></p>
<p>在AOF方式下，开启混合持久化机制生成的文件是<strong>RDB头+AOF尾</strong>，未开启时生成的文件全部为AOF格式。</p>
<p>考虑两种文件格式的兼容性，如果Redis发现AOF文件为RDB头，会使用RDB数据加载的方法读取并恢复前半部分；然后再使用AOF方式读取并恢复后半部分。由于AOF格式存储的数据为RESP协议命令，Redis采用伪客户端执行命令的方式来恢复数据。</p>
<p>如果在AOF命令追加过程中发生宕机，由于延迟写的技术特点，AOF的RESP命令可能不完整（被截断）。</p>
<p>遇到这种情况时，Redis会按照配置项<code>aof-load-truncated</code>执行不同的处理策略。这个配置是告诉Redis启动时读取aof文件，如果发现文件被截断（不完整）时该如何处理：</p>
<ul>
<li>yes：则尽可能多的加载数据，并以日志的方式通知用户；</li>
<li>no：则以系统错误的方式崩溃，并禁止启动，需要用户修复文件后再重启。</li>
</ul>
<p><img src="/2021/12/01/Redis-%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/aof+rdb.png"></p>
<h1 id="RDB-vs-AOF"><a href="#RDB-vs-AOF" class="headerlink" title="RDB vs AOF"></a>RDB vs AOF</h1><p>Redis提供了两种持久化的选择：</p>
<ol>
<li>RDB支持以特定的实践间隔为数据集生成时间点快照；</li>
<li>AOF把Redis Server收到的每条写指令持久化到日志中，待Redis重启时通过重放命令恢复数据。日志格式为RESP协议，对日志文件只做append操作，无损坏风险。并且当AOF文件过大时可以自动重写压缩文件。</li>
</ol>
<p>当然，如果你不需要对数据进行持久化，也可以禁用Redis的持久化功能，但是大多数情况并非如此。实际上，我们时有可能<strong>同时使用RDB和AOF两种方式</strong>的，最重要的就是我们要理解两者的区别，以便合理使用。</p>
<h4 id="RDB优点"><a href="#RDB优点" class="headerlink" title="RDB优点"></a>RDB优点</h4><ul>
<li>RDB是一个<strong>格式紧凑压缩</strong>的二进制文件，代表Redis在某一个时间点上的数据快照，非常<strong>适合用于备份、全量复制</strong>等场景。</li>
<li>RDB<strong>对灾难恢复、数据迁移非常友好</strong>，RDB文件可以转移至任何需要的地方并重新加载。</li>
<li>RDB是Redis数据的内存快照，<strong>数据恢复速度较快</strong>，相比于AOF的命令重放有着更高的性能。</li>
</ul>
<h4 id="RDB缺点"><a href="#RDB缺点" class="headerlink" title="RDB缺点"></a>RDB缺点</h4><ul>
<li>RDB方式<strong>无法做到实时或秒级持久化</strong>。因为持久化过程是通过fork子进程后由子进程完成的，子进程的内存只是在fork操作那一时刻父进程的数据快照，而fork操作后父进程持续对外服务，内部数据时刻变更，子进程的数据不再更新，两者始终存在差异，所以无法做到实时性。</li>
<li>RDB持久化过程中的fork操作，会导致<strong>内存占用加倍（可能）</strong>，而且父进程数据越多，fork过程越长。</li>
<li>Redis请求<strong>高并发可能会频繁命中save规则</strong>，导致fork操作及持久化备份的频率不可控；</li>
<li>RDB文件有文件格式要求，不同版本的Redis会对文件格式进行调整，存在老版本无法兼容新版本的问题。</li>
</ul>
<h4 id="AOF优点"><a href="#AOF优点" class="headerlink" title="AOF优点"></a>AOF优点</h4><ul>
<li>AOF持久化具有<strong>更好的实时性</strong>，我们可以选择三种不同的方式（<code>appendfsync</code>）：no、every second、always，<strong>every second作为默认的策略</strong>具有最好的性能，极端情况下可能会丢失一秒的数据。</li>
<li>AOF文件只有append操作，无复杂的seek等文件操作，没有损坏风险。即使最后写入数据被截断，也很容易使用<code>redis-check-aof</code>工具修复；</li>
<li>AOF文件以已于理解与解析的方式包含了对Redis中数据的所有操作命令。即使不小心错误的清除了所有数据，只要没有对AOF文件重写，我们就可以通过移除最后一条命令找回所有数据。</li>
<li><strong>AOF已经支持混合持久化</strong>，<strong>文件大小可以有效控制</strong>，并<strong>提高了数据加载时的效率</strong>。</li>
</ul>
<h4 id="AOF缺点"><a href="#AOF缺点" class="headerlink" title="AOF缺点"></a>AOF缺点</h4><ul>
<li>对于相同的数据集合，<strong>AOF文件通常会比RDB文件大</strong>；</li>
<li>在特定的fsync策略下，<strong>AOF会比RDB略慢</strong>。一般来讲，fsync_every_second的性能仍然很高，fsync_no的性能与RDB相当。但是在巨大的写压力下，RDB更能提供最大的低延时保障。</li>
<li>在AOF上，Redis曾经遇到一些几乎不可能在RDB上遇到的罕见bug。一些特殊的指令（如BRPOPLPUSH）导致重新加载的数据与持久化之前不一致，Redis官方曾经在相同的条件下进行测试，但是无法复现问题。</li>
</ul>
<h2 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h2><p>对RDB和AOF两种持久化方式的工作原理、执行流程及优缺点了解后，我们来思考下，实际场景中应该怎么权衡利弊，合理的使用两种持久化方式。如果仅仅是使用Redis作为缓存工具，所有数据可以根据持久化数据库进行重建，则可关闭持久化功能，做好预热、缓存穿透、击穿、雪崩之类的防护工作即可。</p>
<p>一般情况下，Redis会承担更多的工作，如分布式锁、排行榜、注册中心等，持久化功能在灾难恢复、数据迁移方面将发挥较大的作用。建议遵循几个原则：</p>
<ul>
<li><strong>不要把Redis作为数据库</strong>，所有数据尽可能可由应用服务自动重建。</li>
<li>使用4.0以上版本Redis，使用AOF+RDB混合持久化功能。</li>
<li><strong>合理规划Redis最大占用内存</strong>，防止AOF重写或save过程中资源不足。</li>
<li>避免单机部署多实例。</li>
<li><strong>生产环境多为集群化部署</strong>，可在slave开启持久化能力，让master更好的对外提供写服务。</li>
<li><strong>备份文件应自动上传至异地机房或云存储</strong>，做好灾难备份。</li>
</ul>
<blockquote>
<p><a href="https://www.cnblogs.com/kismetv/p/9137897.html">深入学习Redis（2）：持久化 </a></p>
</blockquote>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis在Java 语言的使用 —— 使用 Jedis 测试 redis操纵几种常见数据类型的命令</title>
    <url>/2021/09/16/Redis%E5%9C%A8Java%20%E8%AF%AD%E8%A8%80%E7%9A%84%E4%BD%BF%E7%94%A8%20%E2%80%94%E2%80%94%20%E4%BD%BF%E7%94%A8%20Jedis%20%E6%B5%8B%E8%AF%95%20redis%E6%93%8D%E7%BA%B5%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h1><h2 id="Jedis介绍"><a href="#Jedis介绍" class="headerlink" title="Jedis介绍"></a>Jedis介绍</h2><p>Jedis 是 Redis 官方首选的 Java 客户端开发包。</p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>三样东西必不可少：</p>
<ol>
<li>jdk</li>
<li>redis-server</li>
<li>java的redis驱动</li>
</ol>
<p>我没有直接使用jar包导入，而是采用maven。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在终端打开 redis-server之后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PingJedis</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//连接本地的 Redis 服务</span></span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果 Redis 服务设置来密码，需要下面这行，没有就不需要</span></span><br><span class="line">        <span class="comment">// jedis.auth(&quot;123456&quot;);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务正在运行: &quot;</span>+jedis.ping());</span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(&quot;终止Redis服务:&quot;+jedis.shutdown());</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>如果正常返回 <code>pong</code>，说明我们已经可以在java里使用redis了；</p>
<h2 id="测试string"><a href="#测试string" class="headerlink" title="测试string"></a>测试string</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringInJedis</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务正在运行: &quot;</span>+jedis.ping());</span><br><span class="line">        System.out.println(<span class="string">&quot;——————————————————————————————————————————&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        先清空一下</span></span><br><span class="line">        jedis.flushAll();</span><br><span class="line"></span><br><span class="line"><span class="comment">//       测试 set、get</span></span><br><span class="line">        jedis.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;Ji&quot;</span>);</span><br><span class="line">        System.out.println(jedis.get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        <span class="comment">// 测试 get 不存在的键</span></span><br><span class="line">        System.out.println(jedis.get(<span class="string">&quot;non-exist&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//       测试增量 incr incrBy</span></span><br><span class="line">        jedis.incr(<span class="string">&quot;num&quot;</span>);</span><br><span class="line">        System.out.println(jedis.get(<span class="string">&quot;num&quot;</span>));</span><br><span class="line">        jedis.incrBy(<span class="string">&quot;num&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        System.out.println(jedis.get(<span class="string">&quot;num&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//        测试增量 incr incrBy</span></span><br><span class="line">        jedis.decr(<span class="string">&quot;num&quot;</span>);</span><br><span class="line">        System.out.println(jedis.get(<span class="string">&quot;num&quot;</span>));</span><br><span class="line">        jedis.decrBy(<span class="string">&quot;num&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        System.out.println(jedis.get(<span class="string">&quot;num&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//        测试浮点数的增量</span></span><br><span class="line">        jedis.incrByFloat(<span class="string">&quot;num&quot;</span>,<span class="number">9.9</span>);</span><br><span class="line">        System.out.println(jedis.get(<span class="string">&quot;num&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//        测试追加功能</span></span><br><span class="line">        jedis.append(<span class="string">&quot;name&quot;</span>,<span class="string">&quot; Songyang&quot;</span>);</span><br><span class="line">        System.out.println(jedis.get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        获取字符串长度</span></span><br><span class="line">        System.out.println(jedis.strlen(<span class="string">&quot;name&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//        一次性获取多个值</span></span><br><span class="line">        List&lt;String&gt; values = jedis.mget(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;num&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(String val:values) System.out.println(val);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">连接成功</span><br><span class="line">服务正在运行: PONG</span><br><span class="line">——————————————————————————————————————————</span><br><span class="line">Ji</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">9.90000000000000036</span></span><br><span class="line">Ji Songyang</span><br><span class="line"><span class="number">11</span></span><br><span class="line">Ji Songyang</span><br><span class="line"><span class="number">9.90000000000000036</span></span><br></pre></td></tr></table></figure>

<h2 id="测试hash"><a href="#测试hash" class="headerlink" title="测试hash"></a>测试hash</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashInJedis</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务正在运行: &quot;</span>+jedis.ping());</span><br><span class="line">        System.out.println(<span class="string">&quot;——————————————————————————————————————————&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        先清空一下</span></span><br><span class="line">        jedis.flushAll();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        测试 hset、hget</span></span><br><span class="line">        jedis.hset(<span class="string">&quot;car&quot;</span>,<span class="string">&quot;color&quot;</span>,<span class="string">&quot;white&quot;</span>);</span><br><span class="line">        jedis.hset(<span class="string">&quot;car&quot;</span>,<span class="string">&quot;price&quot;</span>,<span class="string">&quot;999998&quot;</span>);</span><br><span class="line">        System.out.println(jedis.hget(<span class="string">&quot;car&quot;</span>,<span class="string">&quot;color&quot;</span>));</span><br><span class="line">        System.out.println(jedis.hget(<span class="string">&quot;car&quot;</span>,<span class="string">&quot;price&quot;</span>));</span><br><span class="line"></span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;kind&quot;</span>,<span class="string">&quot;bmw&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;owner&quot;</span>,<span class="string">&quot;jsy&quot;</span>);</span><br><span class="line">        jedis.hset(<span class="string">&quot;car&quot;</span>,map);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//       批量获取 键、值、键值对</span></span><br><span class="line">        System.out.println(jedis.hlen(<span class="string">&quot;car&quot;</span>));</span><br><span class="line">        System.out.println(jedis.hgetAll(<span class="string">&quot;car&quot;</span>));</span><br><span class="line">        Set&lt;String&gt; keySet = jedis.hkeys(<span class="string">&quot;car&quot;</span>);</span><br><span class="line">        System.out.println(keySet);</span><br><span class="line">        List&lt;String&gt; values = jedis.hvals(<span class="string">&quot;car&quot;</span>);</span><br><span class="line">        System.out.println(values);</span><br><span class="line"></span><br><span class="line"><span class="comment">//       测试字段是否存在</span></span><br><span class="line">        System.out.println(jedis.hexists(<span class="string">&quot;car&quot;</span>,<span class="string">&quot;price&quot;</span>));</span><br><span class="line">        System.out.println(jedis.hexists(<span class="string">&quot;car&quot;</span>,<span class="string">&quot;manufacturer&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//        测试 hsetnx</span></span><br><span class="line">        jedis.hsetnx(<span class="string">&quot;car&quot;</span>,<span class="string">&quot;country&quot;</span>,<span class="string">&quot;US&quot;</span>);</span><br><span class="line">        System.out.println(jedis.hgetAll(<span class="string">&quot;car&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//        测试给某一个字段自增</span></span><br><span class="line">        jedis.hincrBy(<span class="string">&quot;car&quot;</span>,<span class="string">&quot;price&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        jedis.hincrByFloat(<span class="string">&quot;car&quot;</span>,<span class="string">&quot;price&quot;</span>,<span class="number">0.99</span>);</span><br><span class="line">        System.out.println(jedis.hget(<span class="string">&quot;car&quot;</span>,<span class="string">&quot;price&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//        测试 删除字段</span></span><br><span class="line">        System.out.println(jedis.hdel(<span class="string">&quot;car&quot;</span>, <span class="string">&quot;price&quot;</span>, <span class="string">&quot;non-exist-field&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">连接成功</span><br><span class="line">服务正在运行: PONG</span><br><span class="line">——————————————————————————————————————————</span><br><span class="line">white</span><br><span class="line"><span class="number">999998</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">&#123;color=white, owner=jsy, price=<span class="number">999998</span>, kind=bmw&#125;</span><br><span class="line">[color, owner, price, kind]</span><br><span class="line">[white, <span class="number">999998</span>, bmw, jsy]</span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line">&#123;owner=jsy, country=US, color=white, price=<span class="number">999998</span>, kind=bmw&#125;</span><br><span class="line"><span class="number">999999.98999999999068677</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="测试list"><a href="#测试list" class="headerlink" title="测试list"></a>测试list</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListInJedis</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务正在运行: &quot;</span>+jedis.ping());</span><br><span class="line">        System.out.println(<span class="string">&quot;——————————————————————————————————————————&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        先清空一下</span></span><br><span class="line">        jedis.flushAll();</span><br><span class="line"></span><br><span class="line"><span class="comment">//      测试 lpush、rpush</span></span><br><span class="line">        jedis.lpush(<span class="string">&quot;list&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        jedis.rpush(<span class="string">&quot;list&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        System.out.println(jedis.lrange(<span class="string">&quot;list&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        测试删除</span></span><br><span class="line">        jedis.lpop(<span class="string">&quot;list&quot;</span>);</span><br><span class="line">        jedis.rpop(<span class="string">&quot;list&quot;</span>);</span><br><span class="line">        System.out.println(jedis.llen(<span class="string">&quot;list&quot;</span>));</span><br><span class="line">        System.out.println(jedis.lrange(<span class="string">&quot;list&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        jedis.lpop(<span class="string">&quot;list&quot;</span>);</span><br><span class="line">        jedis.lpop(<span class="string">&quot;list&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时 list为空</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) jedis.rpush(<span class="string">&quot;list&quot;</span>,<span class="string">&quot;&quot;</span>+i);</span><br><span class="line">        System.out.println(jedis.lrange(<span class="string">&quot;list&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//        测试 lrange(key,start,end);</span></span><br><span class="line">        System.out.println(jedis.lrange(<span class="string">&quot;list&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>));</span><br><span class="line">        System.out.println(jedis.lrange(<span class="string">&quot;list&quot;</span>,<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">        System.out.println(jedis.lrange(<span class="string">&quot;list&quot;</span>,<span class="number">3</span>,-<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//       测试线性表的get、set方法</span></span><br><span class="line">        System.out.println(jedis.lindex(<span class="string">&quot;list&quot;</span>,<span class="number">3</span>));</span><br><span class="line">        System.out.println(jedis.lindex(<span class="string">&quot;list&quot;</span>,-<span class="number">2</span>));</span><br><span class="line">        jedis.lset(<span class="string">&quot;list&quot;</span>,<span class="number">0</span>,<span class="string">&quot;10&quot;</span>);</span><br><span class="line">        System.out.println(jedis.lrange(<span class="string">&quot;list&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//        测试 list 的删除元素的功能</span></span><br><span class="line">        <span class="comment">// 按索引 保留 [start,end]</span></span><br><span class="line">        jedis.ltrim(<span class="string">&quot;list&quot;</span>,<span class="number">3</span>,<span class="number">8</span>);</span><br><span class="line">        <span class="comment">// 按元素去删</span></span><br><span class="line">        jedis.lrem(<span class="string">&quot;list&quot;</span>,<span class="number">1</span>,<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        System.out.println(jedis.lrange(<span class="string">&quot;list&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">连接成功</span><br><span class="line">服务正在运行: PONG</span><br><span class="line">——————————————————————————————————————————</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="number">2</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line">[<span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure>

<h2 id="操纵set"><a href="#操纵set" class="headerlink" title="操纵set"></a>操纵set</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetInJedis</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务正在运行: &quot;</span>+jedis.ping());</span><br><span class="line">        System.out.println(<span class="string">&quot;——————————————————————————————————————————&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        先清空一下</span></span><br><span class="line">        jedis.flushAll();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        测试 sadd、srem</span></span><br><span class="line">        jedis.sadd(<span class="string">&quot;set&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        System.out.println(jedis.smembers(<span class="string">&quot;set&quot;</span>));</span><br><span class="line">        jedis.srem(<span class="string">&quot;set&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        System.out.println(jedis.smembers(<span class="string">&quot;set&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//        元素是否在集合中</span></span><br><span class="line">        System.out.println(jedis.sismember(<span class="string">&quot;set&quot;</span>,<span class="string">&quot;2&quot;</span>));</span><br><span class="line">        System.out.println(jedis.sismember(<span class="string">&quot;set&quot;</span>,<span class="string">&quot;1&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//        获取集合元素的个数</span></span><br><span class="line">        System.out.println(jedis.scard(<span class="string">&quot;set&quot;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        测试集合的交集、并集、差集</span></span><br><span class="line">        <span class="comment">// 几个用于测试集合</span></span><br><span class="line">        jedis.sadd(<span class="string">&quot;set1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        jedis.sadd(<span class="string">&quot;set2&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        jedis.sadd(<span class="string">&quot;set3&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;6&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 并集</span></span><br><span class="line">        Set&lt;String&gt; res1 = jedis.sunion(<span class="string">&quot;set1&quot;</span>,<span class="string">&quot;set2&quot;</span>,<span class="string">&quot;set3&quot;</span>);</span><br><span class="line">        System.out.println(res1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交集</span></span><br><span class="line">        Set&lt;String&gt; res2 = jedis.sinter(<span class="string">&quot;set1&quot;</span>,<span class="string">&quot;set2&quot;</span>,<span class="string">&quot;set3&quot;</span>);</span><br><span class="line">        System.out.println(res2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 差集</span></span><br><span class="line">        Set&lt;String&gt; res3 = jedis.sdiff(<span class="string">&quot;set1&quot;</span>,<span class="string">&quot;set2&quot;</span>,<span class="string">&quot;set3&quot;</span>);</span><br><span class="line">        System.out.println(res3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 集合中间的元算，还可以存储到Redis中。</span></span><br><span class="line">        jedis.sunionstore(<span class="string">&quot;st1&quot;</span>,<span class="string">&quot;set1&quot;</span>,<span class="string">&quot;set2&quot;</span>,<span class="string">&quot;set3&quot;</span>);</span><br><span class="line">        jedis.sinterstore(<span class="string">&quot;st2&quot;</span>,<span class="string">&quot;set1&quot;</span>,<span class="string">&quot;set2&quot;</span>,<span class="string">&quot;set3&quot;</span>);</span><br><span class="line">        jedis.sdiffstore(<span class="string">&quot;st3&quot;</span>,<span class="string">&quot;set1&quot;</span>,<span class="string">&quot;set2&quot;</span>,<span class="string">&quot;set3&quot;</span>);</span><br><span class="line">        System.out.println(jedis.smembers(<span class="string">&quot;st1&quot;</span>));</span><br><span class="line">        System.out.println(jedis.smembers(<span class="string">&quot;st2&quot;</span>));</span><br><span class="line">        System.out.println(jedis.smembers(<span class="string">&quot;st3&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">连接成功</span><br><span class="line">服务正在运行: PONG</span><br><span class="line">——————————————————————————————————————————</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line">[<span class="number">2</span>]</span><br><span class="line">[]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line">[<span class="number">2</span>]</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>

<h2 id="操纵zset"><a href="#操纵zset" class="headerlink" title="操纵zset"></a>操纵zset</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Tuple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZSetInJedis</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务正在运行: &quot;</span>+jedis.ping());</span><br><span class="line">        System.out.println(<span class="string">&quot;——————————————————————————————————————————&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        先清空一下</span></span><br><span class="line">        jedis.flushAll();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        测试有序集合的增加功能</span></span><br><span class="line">        jedis.zadd(<span class="string">&quot;student_score&quot;</span>,<span class="number">100</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        Map&lt;String,Double&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;李四&quot;</span>,<span class="number">80.0</span>);</span><br><span class="line">        map.put(<span class="string">&quot;王五&quot;</span>,<span class="number">90.0</span>);</span><br><span class="line">        map.put(<span class="string">&quot;陈二&quot;</span>,<span class="number">60.0</span>);</span><br><span class="line">        jedis.zadd(<span class="string">&quot;student_score&quot;</span>,map);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        获取有序集合某个元素的分数、排名</span></span><br><span class="line">        System.out.println(jedis.zscore(<span class="string">&quot;student_score&quot;</span>,<span class="string">&quot;李四&quot;</span>));</span><br><span class="line">        System.out.println(jedis.zrank(<span class="string">&quot;student_score&quot;</span>,<span class="string">&quot;李四&quot;</span>));</span><br><span class="line">        System.out.println(jedis.zscore(<span class="string">&quot;student_score&quot;</span>,<span class="string">&quot;张三&quot;</span>));</span><br><span class="line">        System.out.println(jedis.zrank(<span class="string">&quot;student_score&quot;</span>,<span class="string">&quot;张三&quot;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        按名次顺序检索元素（及其分数）</span></span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;按名次顺序检索元素（及其分数） ——————————————————————\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 返回 索引 [0,2]的元素</span></span><br><span class="line">        System.out.println(jedis.zrange(<span class="string">&quot;student_score&quot;</span>,<span class="number">0</span>,<span class="number">2</span>));</span><br><span class="line">        <span class="comment">// 返回 索引 [1,3]的元素及分数</span></span><br><span class="line">        Set&lt;Tuple&gt; s = jedis.zrangeWithScores(<span class="string">&quot;student_score&quot;</span>,<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span>(Tuple tuple:s)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;元素： &quot;</span>+tuple.getElement()+<span class="string">&quot;      分数：&quot;</span>+tuple.getScore());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 降序返回</span></span><br><span class="line">        System.out.println(jedis.zrevrange(<span class="string">&quot;student_score&quot;</span>, <span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line">        System.out.println(jedis.zrevrangeWithScores(<span class="string">&quot;student_score&quot;</span>, <span class="number">1</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//        按分数范围检索元素</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;按分数范围检索元素 ————————————————————  \n&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取分数在 [80,100]的元素</span></span><br><span class="line">        System.out.println(jedis.zrangeByScore(<span class="string">&quot;student_score&quot;</span>,<span class="number">80</span>,<span class="number">100</span>));</span><br><span class="line">        <span class="comment">// 降序返回</span></span><br><span class="line">        System.out.println(jedis.zrevrangeByScore(<span class="string">&quot;student_score&quot;</span>, <span class="number">100</span>, <span class="number">80</span>));</span><br><span class="line">        <span class="comment">// 获取分数在 [80,100]的元素（包括分数）</span></span><br><span class="line">        System.out.println(jedis.zrangeByScoreWithScores(<span class="string">&quot;student_score&quot;</span>,<span class="number">80</span>,<span class="number">100</span>));</span><br><span class="line">        <span class="comment">// 降序返回</span></span><br><span class="line">        System.out.println(jedis.zrevrangeByScoreWithScores(<span class="string">&quot;student_score&quot;</span>,<span class="number">100</span>,<span class="number">80</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回分数大于等于70的，从第2个元素开始，且不超过2个元素，</span></span><br><span class="line">        System.out.println(jedis.zrangeByScoreWithScores(<span class="string">&quot;student_score&quot;</span>,<span class="number">70</span>,Integer.MAX_VALUE,<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//        返回有序集合的基数</span></span><br><span class="line">        System.out.println(jedis.zcard(<span class="string">&quot;student_score&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//        统计分数在 [min,max]的元素的个数</span></span><br><span class="line">        System.out.println(jedis.zcount(<span class="string">&quot;student_score&quot;</span>, <span class="number">75</span>, <span class="number">95</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        测试 删除元素的功能</span></span><br><span class="line">        System.out.println(<span class="string">&quot;直接删除、按排名范围删除、按分数范围删除&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;当前有元素：  &quot;</span>+jedis.zrangeWithScores(<span class="string">&quot;student_score&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 直接删除</span></span><br><span class="line">        jedis.zrem(<span class="string">&quot;student_score&quot;</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        System.out.println(jedis.zrangeWithScores(<span class="string">&quot;student_score&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照排名范围删除</span></span><br><span class="line">        jedis.zremrangeByRank(<span class="string">&quot;student_score&quot;</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        System.out.println(jedis.zrangeWithScores(<span class="string">&quot;student_score&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按分数范围删除</span></span><br><span class="line">        jedis.zremrangeByScore(<span class="string">&quot;student_score&quot;</span>,<span class="number">70</span>,<span class="number">95</span>);</span><br><span class="line">        System.out.println(jedis.zrangeWithScores(<span class="string">&quot;student_score&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有序集合的集合之间的操作 （ 并、交、差 ） 类似 集合之间的操作,这里略去</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">连接成功</span><br><span class="line">服务正在运行: PONG</span><br><span class="line">——————————————————————————————————————————</span><br><span class="line"><span class="number">80.0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">100.0</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line">按名次顺序检索元素（及其分数） ——————————————————————</span><br><span class="line"></span><br><span class="line">[陈二, 李四, 王五]</span><br><span class="line">元素： 李四      分数：<span class="number">80.0</span></span><br><span class="line">元素： 王五      分数：<span class="number">90.0</span></span><br><span class="line">元素： 张三      分数：<span class="number">100.0</span></span><br><span class="line">[张三, 王五, 李四]</span><br><span class="line">[[王五,<span class="number">90.0</span>], [李四,<span class="number">80.0</span>], [陈二,<span class="number">60.0</span>]]</span><br><span class="line"></span><br><span class="line">按分数范围检索元素 ————————————————————  </span><br><span class="line"></span><br><span class="line">[李四, 王五, 张三]</span><br><span class="line">[张三, 王五, 李四]</span><br><span class="line">[[李四,<span class="number">80.0</span>], [王五,<span class="number">90.0</span>], [张三,<span class="number">100.0</span>]]</span><br><span class="line">[[张三,<span class="number">100.0</span>], [王五,<span class="number">90.0</span>], [李四,<span class="number">80.0</span>]]</span><br><span class="line">[[王五,<span class="number">90.0</span>], [张三,<span class="number">100.0</span>]]</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">直接删除、按排名范围删除、按分数范围删除</span><br><span class="line">当前有元素：  [[陈二,<span class="number">60.0</span>], [李四,<span class="number">80.0</span>], [王五,<span class="number">90.0</span>], [张三,<span class="number">100.0</span>]]</span><br><span class="line">[[陈二,<span class="number">60.0</span>], [李四,<span class="number">80.0</span>], [王五,<span class="number">90.0</span>]]</span><br><span class="line">[[陈二,<span class="number">60.0</span>], [王五,<span class="number">90.0</span>]]</span><br><span class="line">[[陈二,<span class="number">60.0</span>]]</span><br></pre></td></tr></table></figure>


<h2 id="测试HyperLogLog"><a href="#测试HyperLogLog" class="headerlink" title="测试HyperLogLog"></a>测试HyperLogLog</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HyperLogLog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务正在运行: &quot;</span>+jedis.ping());</span><br><span class="line">        System.out.println(<span class="string">&quot;——————————————————————————————————————————&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        先清空一下</span></span><br><span class="line">        jedis.flushAll();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 随机插入 1E8 个数字，看一下 HyperLogLog 的准确率</span></span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> N = (<span class="keyword">int</span>)<span class="number">1e6</span>;</span><br><span class="line">        <span class="keyword">int</span> gap = (<span class="keyword">int</span>)<span class="number">1e5</span> , n = (<span class="keyword">int</span>)<span class="number">1e5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(n&lt;=N)&#123;</span><br><span class="line">            Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            jedis.del(<span class="string">&quot;hp&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = random.nextInt();</span><br><span class="line">                set.add(x);</span><br><span class="line">                jedis.pfadd(<span class="string">&quot;hp&quot;</span>,Integer.toString(x));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;真实数据是 &quot;</span>+set.size()+<span class="string">&quot;个不同的数&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;HyperLogLog 统计数据为 &quot;</span>+jedis.pfcount(<span class="string">&quot;hp&quot;</span>)+<span class="string">&quot;个不同的数&quot;</span>);</span><br><span class="line">            <span class="keyword">double</span> rate = <span class="number">1.0</span>*Math.abs(jedis.pfcount(<span class="string">&quot;hp&quot;</span>)-set.size())/set.size();</span><br><span class="line">            System.out.println(<span class="string">&quot;误差率为：&quot;</span>+rate);</span><br><span class="line">            System.out.println();</span><br><span class="line">            n += gap;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">连接成功</span><br><span class="line">服务正在运行: PONG</span><br><span class="line">——————————————————————————————————————————</span><br><span class="line">真实数据是 <span class="number">99999</span>个不同的数</span><br><span class="line">HyperLogLog 统计数据为 <span class="number">100268</span>个不同的数</span><br><span class="line">误差率为：<span class="number">0.002690026900269003</span></span><br><span class="line"></span><br><span class="line">真实数据是 <span class="number">199997</span>个不同的数</span><br><span class="line">HyperLogLog 统计数据为 <span class="number">200718</span>个不同的数</span><br><span class="line">误差率为：<span class="number">0.003605054075811137</span></span><br><span class="line"></span><br><span class="line">真实数据是 <span class="number">299989</span>个不同的数</span><br><span class="line">HyperLogLog 统计数据为 <span class="number">297310</span>个不同的数</span><br><span class="line">误差率为：<span class="number">0.008930327445339663</span></span><br><span class="line"></span><br><span class="line">真实数据是 <span class="number">399981</span>个不同的数</span><br><span class="line">HyperLogLog 统计数据为 <span class="number">394993</span>个不同的数</span><br><span class="line">误差率为：<span class="number">0.012470592353136774</span></span><br><span class="line"></span><br><span class="line">真实数据是 <span class="number">499974</span>个不同的数</span><br><span class="line">HyperLogLog 统计数据为 <span class="number">497927</span>个不同的数</span><br><span class="line">误差率为：<span class="number">0.004094212899070752</span></span><br><span class="line"></span><br><span class="line">真实数据是 <span class="number">599960</span>个不同的数</span><br><span class="line">HyperLogLog 统计数据为 <span class="number">592881</span>个不同的数</span><br><span class="line">误差率为：<span class="number">0.011799119941329423</span></span><br><span class="line"></span><br><span class="line">真实数据是 <span class="number">699948</span>个不同的数</span><br><span class="line">HyperLogLog 统计数据为 <span class="number">697609</span>个不同的数</span><br><span class="line">误差率为：<span class="number">0.003341676810277335</span></span><br><span class="line"></span><br><span class="line">真实数据是 <span class="number">799939</span>个不同的数</span><br><span class="line">HyperLogLog 统计数据为 <span class="number">797154</span>个不同的数</span><br><span class="line">误差率为：<span class="number">0.0034815154655542485</span></span><br><span class="line"></span><br><span class="line">真实数据是 <span class="number">899907</span>个不同的数</span><br><span class="line">HyperLogLog 统计数据为 <span class="number">912082</span>个不同的数</span><br><span class="line">误差率为：<span class="number">0.01352917579260968</span></span><br><span class="line"></span><br><span class="line">真实数据是 <span class="number">999889</span>个不同的数</span><br><span class="line">HyperLogLog 统计数据为 <span class="number">998794</span>个不同的数</span><br><span class="line">误差率为：<span class="number">0.0010951215584929926</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure>



<h2 id="测试-Bitmap"><a href="#测试-Bitmap" class="headerlink" title="测试 Bitmap"></a>测试 Bitmap</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitMapInJedis</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务正在运行: &quot;</span> + jedis.ping());</span><br><span class="line">        System.out.println(<span class="string">&quot;——————————————————————————————————————————&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        先清空一下</span></span><br><span class="line">        jedis.flushAll();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String key = <span class="string">&quot;key_bitmap&quot;</span>;</span><br><span class="line"></span><br><span class="line">        jedis.setbit(key,<span class="number">0</span>,<span class="keyword">true</span>);</span><br><span class="line">        jedis.setbit(<span class="string">&quot;key_bitmap&quot;</span>,<span class="number">1</span>,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(key+<span class="number">1</span>+<span class="string">&quot; :&quot;</span>+jedis.getbit(key, <span class="number">1</span>));</span><br><span class="line">        System.out.println(key+<span class="number">2</span>+<span class="string">&quot; : &quot;</span>+jedis.getbit(key, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只允许 0、1</span></span><br><span class="line">        jedis.setbit(key,<span class="number">131</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        jedis.setbit(key,<span class="number">132</span>,<span class="string">&quot;0&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis实现分布式锁</title>
    <url>/2021/11/29/Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="分布式锁简介"><a href="#分布式锁简介" class="headerlink" title="分布式锁简介"></a>分布式锁简介</h1><blockquote>
<p>分布式锁，是一种思想，它的实现方式有很多。比如，我们将沙滩当做分布式锁的组件，那么它看起来应该是这样的：</p>
<ul>
<li><strong>加锁</strong><br>在沙滩上踩一脚，留下自己的脚印，就对应了加锁操作。其他进程或者线程，看到沙滩上已经有脚印，证明锁已被别人持有，则等待。</li>
<li><strong>解锁</strong><br>把脚印从沙滩上抹去，就是解锁的过程。</li>
<li><strong>锁超时</strong><br>为了避免死锁，我们可以设置一阵风，在单位时间后刮起，将脚印自动抹去。</li>
</ul>
</blockquote>
<p>分布式锁的实现有很多，比如基于数据库、memcached、Redis、系统文件、zookeeper等。它们的核心的理念跟上面的过程大致相同。</p>
<p>在许多环境中不同进程必须以互斥方式使用共享资源进行操作时，分布式锁是一个非常有用的原语。此试图提供一种更规范的算法来实现Redis的分布式锁。我们提出了一种称为<code>Redlock</code>的算法，它实现了<code>DLM</code>（猜测是<code>Distributed Lock Manager</code>的缩写，分布式锁管理器），我们认为它比普通的单实例方法更安全。</p>
<h2 id="锁的安全和活性保证"><a href="#锁的安全和活性保证" class="headerlink" title="锁的安全和活性保证"></a>锁的安全和活性保证</h2><p>算法的三个核心特征（三大最低保证）：</p>
<ul>
<li><strong>Safety property</strong>（安全性）：互斥。确保在任何给定时刻下，只有一个客户端可以持有锁；</li>
<li><strong>Liveness property A</strong>（活性A）：无死锁。即使存在曾经锁定资源的客户端崩溃或者出现网络分区异常，确保锁总是能够成功获取；</li>
<li><strong>Liveness property B</strong>（活性B）：容错性。只要大多数Redis节点处于正常运行状态，客户端就可以获取和释放锁。</li>
</ul>
<h2 id="主从结构故障转移时的并发问题"><a href="#主从结构故障转移时的并发问题" class="headerlink" title="主从结构故障转移时的并发问题"></a>主从结构故障转移时的并发问题</h2><p>文档中还指出了目前算法对于故障转移的实现还存在明显的竞态条件问题（描述的应该是<code>Redis</code>主从架构下的问题）：</p>
<ul>
<li>客户端A获取Redis主节点中的锁（假设锁定的资源为X）</li>
<li>在Redis主节点把KEY同步到Redis从节点之前，Redis主节点崩溃</li>
<li>Redis从节点因为故障晋升为主节点</li>
<li>此时，客户端B获取资源X的锁成功，问题是资源X的锁在前面已经被客户端A获取过，这样就出现了并发问题。</li>
</ul>
<h1 id="单机下Redis实现锁"><a href="#单机下Redis实现锁" class="headerlink" title="单机下Redis实现锁"></a>单机下Redis实现锁</h1><p>单个实例是我们将用于此处描述的分布式算法的基础。</p>
<h2 id="锁的获取"><a href="#锁的获取" class="headerlink" title="锁的获取"></a>锁的获取</h2><p>下面的redis命令是获取锁的核心思想 —— 如果键不存在，则设置一个id值（此时相当于拿到了锁），并且为了保证上面所说的活性要求，还设置了键的过期时间。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SET resource_name my_random_value NX PX 30000</span><br></pre></td></tr></table></figure>

<p>这实际上是<code>setnx</code>和<code>setex</code>的结合体，不过它是原子的。</p>
<p>如果较低版本的客户端中不支持这个命令，那就要使用lua脚本。</p>
<h2 id="锁的释放"><a href="#锁的释放" class="headerlink" title="锁的释放"></a>锁的释放</h2><p>下面的lua脚本的含义是：</p>
<p>当键存在，并且键值正是当前线程的独属id时（也就是防止释放别的线程加的锁，这就是这个独属于加到锁的线程的id的作用）。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>




<h2 id="使用Jedis实现”丐版“Redis锁"><a href="#使用Jedis实现”丐版“Redis锁" class="headerlink" title="使用Jedis实现”丐版“Redis锁"></a>使用Jedis实现”丐版“Redis锁</h2><p><del>注意下面的代码只能算是对redis加锁的原理予以初步的实践，远远达不到高性能、高可靠。</del></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRedisLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> JedisPool jedisPool = <span class="keyword">new</span> JedisPool(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> EXPIRE_TIME_OUT = <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">// SET命令已经提供了可选的复合操作符</span></span><br><span class="line">    <span class="comment">// EX：设置超时时间，单位是秒</span></span><br><span class="line">    <span class="comment">// PX：设置超时时间，单位是毫秒</span></span><br><span class="line">    <span class="comment">// NX：IF NOT EXIST的缩写，只有KEY不存在的前提下才会设置K-V，设置成功返回1，否则返回0</span></span><br><span class="line">    <span class="comment">// XX：IF EXIST的缩写，只有在KEY存在的前提下才会设置K-V，设置成功返回1，否则返回0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SetParams params = SetParams.setParams().nx().px(EXPIRE_TIME_OUT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; lockedId = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String lockName;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyRedisLock</span><span class="params">(String lockName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lockName = lockName;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyRedisLock <span class="title">getLock</span><span class="params">(String lockName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyRedisLock(lockName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String id = UUID.randomUUID().toString();</span><br><span class="line">        lockedId.set(id);</span><br><span class="line">        <span class="keyword">try</span> (Jedis jedis = jedisPool.getResource()) &#123;</span><br><span class="line">            <span class="comment">// 加锁失败就重试</span></span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                String statusCode = jedis.set(lockName, id, params);</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;OK&quot;</span>.equals(statusCode)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>); <span class="comment">// 可以设计成 wait-notify 范式，不过这里就简陋一点了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Jedis jedis = jedisPool.getResource()) &#123;</span><br><span class="line">            <span class="comment">// 为做到原子性，使用 Lua 脚本</span></span><br><span class="line">            String script =</span><br><span class="line">                    <span class="string">&quot;if redis.call(&#x27;get&#x27;,KEYS[1]) == ARGV[1] then&quot;</span> +</span><br><span class="line">                            <span class="string">&quot;   return redis.call(&#x27;del&#x27;,KEYS[1]) &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;else&quot;</span> +</span><br><span class="line">                            <span class="string">&quot;   return 0 &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;end&quot;</span>;</span><br><span class="line">            String id = lockedId.get();</span><br><span class="line">            jedis.eval(script, Collections.singletonList(lockName), Collections.singletonList(id)).toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 测试代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyRedisLock lock = MyRedisLock.getLock(<span class="string">&quot;lock1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        MyInteger.testLock(lock);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> l = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">10000</span>;</span><br><span class="line">        MyInteger integer = <span class="keyword">new</span> MyInteger(N);</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(N);</span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            pool.submit(() -&gt; &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    integer.decr();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            countDownLatch.await(); <span class="comment">// just wait all tasks to finish</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;end : &quot;</span> + integer.getX());</span><br><span class="line">        <span class="keyword">long</span> r = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时 &quot;</span> + (r - l) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>上述算法的主要缺点：</p>
<ol>
<li>忙等（busy-waiting）的问题，消耗CPU资源；</li>
<li>只适用于单机；</li>
<li>不可重入</li>
<li>没有限制等待获取的锁的超时时间</li>
<li>不能做到在等待锁的时候响应中断</li>
</ol>
<h1 id="Redisson实现分布式锁"><a href="#Redisson实现分布式锁" class="headerlink" title="Redisson实现分布式锁"></a>Redisson实现分布式锁</h1><p><a href="https://redisson.org/">Redisson</a>是架设在<a href="http://redis.cn/">Redis</a>基础上的一个Java驻内存数据网格（In-Memory Data Grid）。</p>
<p>相对于Jedis而言，Redisson是一个更高级的客户端。</p>
<p>它里面实现了各种分布式锁（本文只介绍和使用简单的）。</p>
<h2 id="使用Redisson中的锁"><a href="#使用Redisson中的锁" class="headerlink" title="使用Redisson中的锁"></a>使用Redisson中的锁</h2><p><strong>maven依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.16.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p><strong>简单使用 lock</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 配置类</span></span><br><span class="line">  Config config = <span class="keyword">new</span> Config();</span><br><span class="line">  config.useSingleServer().setAddress(<span class="string">&quot;redis://127.0.0.1:6379&quot;</span>);</span><br><span class="line">  config.useSingleServer().setPassword(<span class="string">&quot;redis1234&quot;</span>);</span><br><span class="line">  <span class="comment">// 初始化客户端</span></span><br><span class="line">  <span class="keyword">final</span> RedissonClient client = Redisson.create(config);  </span><br><span class="line">  RLock lock = client.getLock(<span class="string">&quot;lock1&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 加锁</span></span><br><span class="line">lock.lock();</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="comment">// do something ...  </span></span><br><span class="line">  &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">      <span class="comment">// 释放锁</span></span><br><span class="line">      lock.unlock();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h2 id="Redisson中RLock的实现特点"><a href="#Redisson中RLock的实现特点" class="headerlink" title="Redisson中RLock的实现特点"></a>Redisson中RLock的实现特点</h2><p><code>Redisson</code>中<code>RLock</code>的实现是基本参照了<code>Redis</code>的<code>red lock</code>算法进行实现，不过在原始的<code>red lock</code>算法下进行了改良，主要包括下面的特性：</p>
<ul>
<li>互斥</li>
<li>无死锁</li>
<li>可重入，类似于<code>ReentrantLock</code>，同一个线程可以重复获取同一个资源的锁（一般使用计数器实现），锁的重入特性一般情况下有利于提高资源的利用率</li>
<li><strong>续期</strong>，这个是一个比较前卫解决思路，也就是如果一个客户端对资源<code>X</code>永久锁定，那么并不是直接对<code>KEY</code>生存周期设置为<code>-1</code>，而是通<strong>过一个守护线程每隔固定周期延长<code>KEY</code>的过期时间</strong>，这样就能实现<strong>在守护线程不被杀掉的前提下，避免客户端崩溃导致锁无法释放长期占用资源的问题</strong></li>
<li><strong>锁状态变更订阅</strong>，依赖于<code>org.redisson.pubsub.LockPubSub</code>，用于订阅和通知锁释放事件</li>
<li>数据类型选用了<code>HASH</code>，配合<code>Lua</code>脚本完成多个命令的原子性</li>
</ul>
<p><code>RLock</code>的类图</p>
<p><img src="/2021/11/29/Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/rlock.jpeg"></p>
<p>RedissonLock<code>就是</code>RLock<code>的直接实现，也是分布式锁实现的核心类，从源码中看到</code>Redisson.getLock()<code>就是直接实例化</code>RedissonLock。</p>
<p><code>RedissonLock</code>的类继承图</p>
<p><img src="/2021/11/29/Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/redission-lock.jpeg"></p>
<h2 id="加锁整体流程"><a href="#加锁整体流程" class="headerlink" title="加锁整体流程"></a>加锁整体流程</h2><blockquote>
<p>下面的代码是版本3.16.4中的，其他版本有点差别：</p>
</blockquote>
<h3 id="构造锁"><a href="#构造锁" class="headerlink" title="构造锁"></a>构造锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RedissonLock</span><span class="params">(CommandAsyncExecutor commandExecutor, String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(commandExecutor, name);</span><br><span class="line">    <span class="comment">//命令执行器</span></span><br><span class="line">    <span class="keyword">this</span>.commandExecutor = commandExecutor;</span><br><span class="line">    <span class="comment">//UUID字符串</span></span><br><span class="line">    <span class="keyword">this</span>.id = commandExecutor.getConnectionManager().getId();</span><br><span class="line">    <span class="comment">//内部锁过期时间(默认是 30*1000 , 也就是 30 秒)</span></span><br><span class="line">    <span class="keyword">this</span>.internalLockLeaseTime = commandExecutor.</span><br><span class="line">                getConnectionManager().getCfg().getLockWatchdogTimeout();</span><br><span class="line">    <span class="keyword">this</span>.entryName = id + <span class="string">&quot;:&quot;</span> + name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>lockWatchdogTimeout</code>参数只有在没有使用<code>leaseTimeout</code>参数定义的成功获取到锁的场景（简单来说就是不设置时限的加锁）下生效，<br>如果看门狗在下一个<code>lockWatchdogTimeout</code>周期内不进行续期，那么锁就会过期释放<br>（从源码上看，每三分之一<code>lockWatchdogTimeout</code>就会执行一次续期任务，每次通过<code>pexpire</code>把<code>KEY</code>的存活周期延长<code>lockWatchdogTimeout</code>），<code>lockWatchdogTimeout</code>的默认值为<code>30000</code>，也就是<code>30</code>秒。</p>
<p>这里先列举一下<code>RedissonLock</code>中获取名称的方法，以便后面分析这些名称作为<code>K-V</code>结构的<code>KEY</code>时候使用：</p>
<ul>
<li><code>id</code>：由配置实例化时候实例化的<code>UUID</code>实例生成，从源码上分析每个连接方式的<code>Redisson</code>实例有唯一的<code>UUID</code>，<code>ConnectionManager</code>初始化的时候会调用<code>UUID id = UUID.randomUUID()</code>，笔者认为可以理解为<code>Redisson</code>实例在某个应用程序进程中的唯一标识，毕竟一般情况下，一个应用程序应该只会应用一种<code>Redisson</code>的连接方式</li>
<li><code>getEntryName()</code>：返回的是<code>UUID + : + $KEY</code>，例如<code>559cc9df-bad8-4f6c-86a4-ffa51b7f1c36:resource:x</code></li>
<li><code>getName()</code>：返回的是<code>$KEY</code>，例如<code>resource:x</code></li>
<li><code>getChannelName()</code>：返回的是<code>redisson_lock__channel:&#123;$KEY&#125;</code>，例如<code>redisson_lock__channel:&#123;resource:x&#125;</code></li>
<li><code>getLockName(long threadId)</code>：返回的是<code>UUID + : + $threadId</code>，例如<code>559cc9df-bad8-4f6c-86a4-ffa51b7f1c36:1</code></li>
</ul>
<h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> RLock <span class="title">getLock</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RedissonLock(commandExecutor, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">   	 * LeaseTime - 获取后持有锁的最长时间，如果它尚未通过调用unlock 。 如果leaseTime 为-1，则保持锁定直到显式解锁。</span></span><br><span class="line"><span class="comment">   	 */</span></span><br><span class="line">		 <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">boolean</span> interruptibly)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      	<span class="comment">// 当前线程ID</span></span><br><span class="line">        <span class="keyword">long</span> threadId = Thread.currentThread().getId();</span><br><span class="line">      	<span class="comment">// 尝试获取锁</span></span><br><span class="line">        Long ttl = tryAcquire(-<span class="number">1</span>, leaseTime, unit, threadId);</span><br><span class="line">        <span class="comment">// lock acquired</span></span><br><span class="line">        <span class="comment">// 如果ttl为 null，则证明获取锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (ttl == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      	<span class="comment">// 如果获取锁失败，则订阅到对应这个锁的channel</span></span><br><span class="line">        RFuture&lt;RedissonLockEntry&gt; future = subscribe(threadId);</span><br><span class="line">        <span class="keyword">if</span> (interruptibly) &#123;</span><br><span class="line">            commandExecutor.syncSubscriptionInterrupted(future);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            commandExecutor.syncSubscription(future);</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 不断尝试</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 再次尝试获取锁</span></span><br><span class="line">                ttl = tryAcquire(-<span class="number">1</span>, leaseTime, unit, threadId);</span><br><span class="line">                <span class="comment">// lock acquired</span></span><br><span class="line">                <span class="keyword">if</span> (ttl == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// waiting for message</span></span><br><span class="line">                <span class="comment">// ttl大于0 则等待ttl时间后继续尝试获取</span></span><br><span class="line">                <span class="keyword">if</span> (ttl &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        future.getNow().getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (interruptibly) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        future.getNow().getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (interruptibly) &#123;</span><br><span class="line">                        future.getNow().getLatch().acquire();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        future.getNow().getLatch().acquireUninterruptibly();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 取消对channel的订阅</span></span><br><span class="line">            unsubscribe(future, threadId);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        get(lockAsync(leaseTime, unit));</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>如上代码，就是加锁的全过程。先调用<code>tryAcquire</code>来获取锁，如果返回值ttl为空，则证明加锁成功，返回；如果不为空，则证明加锁失败。这时候，它会订阅这个锁的Channel，等待锁释放的消息，然后重新尝试获取锁。流程如下：</p>
<img src="lock1.webp" style="zoom:60%;" />











<p>获取锁的过程是怎样的呢？接下来就要看<code>tryAcquire</code>方法。在这里，它有两种处理方式，一种是带有过期时间的锁，一种是不带过期时间的锁。</p>
<h3 id="获取互斥状态"><a href="#获取互斥状态" class="headerlink" title="获取互斥状态"></a>获取互斥状态</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">// 同步方法依赖异步方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Long <span class="title">tryAcquire</span><span class="params">(<span class="keyword">long</span> waitTime, <span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(tryAcquireAsync(waitTime, leaseTime, unit, threadId));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过传入锁持有的最大时间和线程ID异步获取锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">RFuture&lt;Long&gt; <span class="title">tryAcquireAsync</span><span class="params">(<span class="keyword">long</span> waitTime, <span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">        RFuture&lt;Long&gt; ttlRemainingFuture;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;   <span class="comment">// 锁持有最大时间不为-1，也就是明确锁的持有时间，不是永久持有的场景</span></span><br><span class="line">            ttlRemainingFuture = tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 先按照30秒的过期时间来执行获取锁的方法</span></span><br><span class="line">            ttlRemainingFuture = tryLockInnerAsync(waitTime, internalLockLeaseTime,</span><br><span class="line">                    TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果还持有这个锁，则开启定时任务不断刷新该锁的过期时间</span></span><br><span class="line">        ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">            <span class="comment">// // 执行异常场景直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// lock acquired（当前已经获取到锁）</span></span><br><span class="line">            <span class="keyword">if</span> (ttlRemaining == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span><br><span class="line">                    internalLockLeaseTime = unit.toMillis(leaseTime);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果是永久持有，定时调度进行 续期操作</span></span><br><span class="line">                    scheduleExpirationRenewal(threadId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> ttlRemainingFuture;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h4 id="底层加锁逻辑"><a href="#底层加锁逻辑" class="headerlink" title="底层加锁逻辑"></a>底层加锁逻辑</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">RFuture&lt;T&gt; <span class="title">tryLockInnerAsync</span><span class="params">(<span class="keyword">long</span> waitTime, <span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> evalWriteAsync(getRawName(), LongCodec.INSTANCE, command,</span><br><span class="line">             <span class="comment">//如果锁不存在，则通过hincrby设置持有数为 1 ，并设置过期时间</span></span><br><span class="line">             <span class="comment">// KEYS[1] ：hash类型的键，代表哪个锁</span></span><br><span class="line">             <span class="comment">// ARGV[2] ：hash类型的字段，代表目前获取到锁的线程名</span></span><br><span class="line">             <span class="comment">// ARGV[1] ：传入的锁的过期时间                       </span></span><br><span class="line">            <span class="string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                    <span class="comment">// 如果锁已存在，并且锁的是当前线程，则通过hincrby给数值递增1</span></span><br><span class="line">                    <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span>, <span class="comment">// //如果锁已存在，但并非本线程，则返回过期时间ttl</span></span><br><span class="line">            Collections.singletonList(getRawName()), unit.toMillis(leaseTime), getLockName(threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这段LUA代码看起来并不复杂，有三个判断：</p>
<ul>
<li><strong>通过exists判断，如果锁不存在，则设置值和过期时间，加锁成功</strong></li>
<li><strong>通过hexists判断，如果锁已存在，并且锁的是当前线程，则证明是重入锁，加锁成功</strong></li>
<li><strong>如果锁已存在，但锁的不是当前线程，则证明有其他线程持有锁。返回当前锁的过期时间，加锁失败</strong></li>
</ul>
<img src="lock2.webp" style="zoom:60%;" />





<p>最后再概括一下<code>Redisson</code>中实现<code>red lock</code>算法使用的<code>HASH</code>数据类型：</p>
<ul>
<li><code>KEY</code>代表的就是资源或者锁，<strong>创建、存在性判断，延长生存周期和删除操作总是针对<code>KEY</code>进行的</strong></li>
<li><code>FIELD</code>代表的是锁名称<code>lockName()</code>，但是其实它由<code>Redisson</code>连接管理器实例的初始化<code>UUID</code>拼接客户端线程<code>ID</code>组成，严格来说应该是获取锁的客户端线程唯一标识；</li>
<li><code>VALUE</code>代表的是客户端线程对于锁的持有量。</li>
</ul>
<h2 id="解锁整体流程"><a href="#解锁整体流程" class="headerlink" title="解锁整体流程"></a>解锁整体流程</h2><h3 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RFuture&lt;Void&gt; <span class="title">unlockAsync</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">    RPromise&lt;Void&gt; result = <span class="keyword">new</span> RedissonPromise&lt;&gt;();</span><br><span class="line">    <span class="comment">// // 返回的RFuture如果持有的结果为true，说明解锁成功，返回NULL说明线程ID异常，加锁和解锁的客户端线程不是同一个线程</span></span><br><span class="line">    RFuture&lt;Boolean&gt; future = unlockInnerAsync(threadId);</span><br><span class="line">    future.onComplete((opStatus, e) -&gt; &#123;</span><br><span class="line">      	<span class="comment">// 需要取消看门狗的续期任务</span></span><br><span class="line">        cancelExpirationRenewal(threadId);</span><br><span class="line">		<span class="comment">// 这是内部的异常，说明解锁异常</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            result.tryFailure(e);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 这种情况说明线程ID异常，加锁和解锁的客户端线程不是同一个线程，抛出IllegalMonitorStateException异常</span></span><br><span class="line">        <span class="keyword">if</span> (opStatus == <span class="keyword">null</span>) &#123;</span><br><span class="line">            IllegalMonitorStateException cause = <span class="keyword">new</span> IllegalMonitorStateException(<span class="string">&quot;attempt to unlock lock, not locked by current thread by node id: &quot;</span></span><br><span class="line">                    + id + <span class="string">&quot; thread-id: &quot;</span> + threadId);</span><br><span class="line">            result.tryFailure(cause);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 走到这里说明正常解锁</span></span><br><span class="line">        result.trySuccess(<span class="keyword">null</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="解锁的底层逻辑"><a href="#解锁的底层逻辑" class="headerlink" title="解锁的底层逻辑"></a>解锁的底层逻辑</h3><p>核心还是lua脚本实现的原子性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title">unlockInnerAsync</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">            <span class="comment">// KEYS[1] 锁名</span></span><br><span class="line">            <span class="comment">// ARGV[3] 线程id</span></span><br><span class="line">            <span class="comment">// 如果释放锁的线程和已存在锁的线程不是同一个线程，返回null         </span></span><br><span class="line">            <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[3]) == 0) then &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return nil;&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                    <span class="comment">// 通过hincrby递减1的方式，释放一次锁</span></span><br><span class="line">                    <span class="string">&quot;local counter = redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[3], -1); &quot;</span> +</span><br><span class="line">                    <span class="comment">// 若剩余次数大于0 ，则刷新过期时间</span></span><br><span class="line">                    <span class="string">&quot;if (counter &gt; 0) then &quot;</span> +</span><br><span class="line">                    <span class="comment">// ARGV[2] 过期时间</span></span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2]); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return 0; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;else &quot;</span> +</span><br><span class="line">                    <span class="comment">// 否则证明锁已经释放，删除key并发布锁释放的消息</span></span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;del&#x27;, KEYS[1]); &quot;</span> +</span><br><span class="line">                    <span class="comment">// KEYS[2] ： 指的是 publish 的频道名</span></span><br><span class="line">                    <span class="comment">// ARGV[1] ：解锁的消息</span></span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;publish&#x27;, KEYS[2], ARGV[1]); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return 1; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return nil;&quot;</span>,</span><br><span class="line">            Arrays.asList(getRawName(), getChannelName()), LockPubSub.UNLOCK_MESSAGE, internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol>
<li><p><strong>如果解锁的线程和当前锁的线程不是同一个，解锁失败，抛出异常</strong>‘’</p>
</li>
<li><p><strong>通过hincrby递减1，先释放一次锁。</strong></p>
</li>
<li><p><strong>若剩余次数还大于0，则证明当前锁是重入锁，刷新过期时间；</strong></p>
</li>
<li><p><strong>若剩余次数小于0，删除key并发布锁释放的消息，解锁成功</strong></p>
</li>
</ol>
<img src="unlock.webp" style="zoom:60%;" />






<h2 id="Redisson的锁总结"><a href="#Redisson的锁总结" class="headerlink" title="Redisson的锁总结"></a>Redisson的锁总结</h2><p><code>Redisson</code>中的<code>red lock</code>实现，应用到下面的核心技术：</p>
<ul>
<li>合理应用<code>Redis</code>的基本数据类型<code>HASH</code></li>
<li><code>Redis</code>的订阅发布</li>
<li><code>Lua</code>脚本的原子性</li>
<li><code>Netty</code>中的<code>Promise</code>实现</li>
<li><code>Netty</code>中的时间轮<code>HashedWheelTimer</code>和对应的定时任务<code>(HashedWheel)Timeout</code></li>
<li><code>Semaphore</code>进行带期限、永久或者可中断的阻塞以及唤醒，替代<code>CountDownLatch</code>中的无等待期限阻塞</li>
</ul>
<p>上面的核心技术相对合理地应用，才能实现一个高效而且容错能力相对比较高的分布式锁方案，但是从目前来看，<code>Redisson</code>仍未解决<code>red lock</code>算法中的故障转移缺陷，笔者认为这个有可能是<code>Redis</code>实现分布式锁方案的一个底层缺陷，<strong>此方案在<code>Redis</code>单实例中是相对完善</strong>，一旦应用在<code>Redis</code>集群（普通主从、哨兵或者<code>Cluster</code>），有几率会出现前文提到的节点角色切换导致多个不同客户端获取到同一个资源对应的锁的问题。暂时无解。</p>
<blockquote>
<p>但值得注意的是，上面的两种实现方式都是针对单机Redis实例而进行的。如果我们有多个Redis实例，请参阅<strong>Redlock算法</strong>。该算法的具体内容，请参考<a href="http://redis.cn/topics/distlock.html">http://redis.cn/topics/distlock.html</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.cnblogs.com/throwable/p/14264804.html">冷饭新炒：理解Redisson中分布式锁的实现 </a></p>
<p><a href="https://redis.io/topics/distlock">Distributed locks with Redis</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
        <tag>Redis</tag>
        <tag>分布式锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis官方文档笔记 —— 事务（Transactions）</title>
    <url>/2021/09/16/Redis%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0%20%E2%80%94%E2%80%94%20%E4%BA%8B%E5%8A%A1%EF%BC%88Transactions%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>相关命令</strong></p>
<blockquote>
<p>MULTI<br>EXEC<br>DISCARD<br>WATCH<br>UNWATCH</p>
</blockquote>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务是一组命令的集合。3</p>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ul>
<li>事务中的<strong>所有命令都被序列化并顺序执行</strong>。在Redis事务的执行过程中（指定的是 <code>exec</code>后的真正的执行过程，而不是用<code>multi</code>后的入队过程），永远不会执行另一个客户端发出的请求（**命令不会加塞）。</li>
<li>所有命令都将被执行，或者所有命令都不执行，因此<strong>Redis事务也是原子的</strong>（这句话有可能会引起争议）。</li>
</ul>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>使用<code>MULTI</code>命令输入Redis事务。该命令始终以答复OK。<br>此时，用户可以发出多个命令。<strong>Redis不会执行这些命令，而是将它们排队。</strong><br><strong>一旦调用EXEC，将执行所有命令。</strong>，并且<strong>EXEC返回了一个答复数组</strong>，其中每个元素都是事务中单个命令的答复，其发出顺序与命令相同。<br>如：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SET k1 v1</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SET k2 v2</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; GET k1</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; EXEC</span><br><span class="line"><span class="number">1</span>) OK</span><br><span class="line"><span class="number">2</span>) OK</span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;v1&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; </span><br></pre></td></tr></table></figure>
<p>需要强调的是，<code>MULTI</code>之后的命令并不会执行，它们只是入队而已，知道<code>EXEC</code>命令发出，所有命令才会一起执行。</p>
<h2 id="事务中的错误"><a href="#事务中的错误" class="headerlink" title="事务中的错误"></a>事务中的错误</h2><h3 id="命令排队入队错误"><a href="#命令排队入队错误" class="headerlink" title="命令排队入队错误"></a>命令排队入队错误</h3><p>这种常见的错误有 ① 命令不存在 ② 命令参数的个数不对。<br>这种错误一旦发生，<strong>这个事务就会失败，也就是说事务中的命令全都不会执行</strong>。<br>如：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; multi</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set a <span class="number">1</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get b <span class="number">1</span></span><br><span class="line">(<span class="built_in">error</span>) ERR wrong number of arguments <span class="keyword">for</span> <span class="string">&#x27;get&#x27;</span> command</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set c <span class="number">3</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; exec</span><br><span class="line">(<span class="built_in">error</span>) EXECABORT Transaction discarded because of previous errors.</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get a</span><br><span class="line">(<span class="literal">nil</span>)</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get c</span><br><span class="line">(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>

<p>可见即使是正确的命令也没有执行成功。</p>
<blockquote>
<p>从Redis 2.6.5开始，服务器会记住命令累积期间发生错误，并且将拒绝执行事务，并且在EXEC期间还会返回错误并自动丢弃该事务。</p>
</blockquote>
<h3 id="命令执行错误"><a href="#命令执行错误" class="headerlink" title="命令执行错误"></a>命令执行错误</h3><p>常见的有，命令与键的类型冲突，给一个字符串类型的键自增但是键值不是数字，等等。</p>
<p>EXEC之后发生的错误不会以特殊方式处理:<strong>即使在事务期间某些命令失败，也会执行所有其他命令</strong>。<br>也正是因为一点，让Redis事务的原子性受到质疑。</p>
<p>如：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SET a hello</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; INCR a</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SET b <span class="number">2</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; EXEC</span><br><span class="line"><span class="number">1</span>) (<span class="built_in">error</span>) ERR value is <span class="keyword">not</span> an integer <span class="keyword">or</span> out of range</span><br><span class="line"><span class="number">2</span>) OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; GET b</span><br><span class="line"><span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; </span><br></pre></td></tr></table></figure>
<p>即使在<code>INCR</code>命令执行错误之后，可以看到之后的合法的命令仍然执行成功了。</p>
<h2 id="为什么Redis不支持回滚"><a href="#为什么Redis不支持回滚" class="headerlink" title="为什么Redis不支持回滚"></a>为什么Redis不支持回滚</h2><p>大致有三点原因：</p>
<ol>
<li>程序员自身犯的错误是无法避免的。</li>
<li>不支持回滚可以使得Redis事务的实现更加高效。</li>
<li>发生错误一般发生在开发过程中，不太可能进入到生产环境中。</li>
</ol>
<h2 id="DISCARD命令队列"><a href="#DISCARD命令队列" class="headerlink" title="DISCARD命令队列"></a>DISCARD命令队列</h2><p>之前说，一旦客户端给Redis服务器发送一个<code>MULTI</code>此时，Redis受到的命令不会立即执行，而是存储在队列里。<br>也就是此时客户端和服务器的连接状态进入一种<strong>事务状态</strong>。<br><strong>而<code>DISCARD</code>命令相反，它用来结束这种状态的，当然之前队列里的命令组也会被清空。</strong>    </p>
<p>注意，此命令只在客户端和服务器之间有<code>MULTI</code>执行之后，才会返回<strong>OK</strong>,否则返回<br><strong>(error) ERR DISCARD without MULTI</strong>。</p>
<h2 id="WATCH实现乐观锁"><a href="#WATCH实现乐观锁" class="headerlink" title="WATCH实现乐观锁"></a>WATCH实现乐观锁</h2><blockquote>
<p><code>WATCH</code>用于为Redis事务提供检查设置（CAS check-ans-set）行为。</p>
</blockquote>
<p>被WATCH的键，如果在事务执行（exec）前发生了变化，那么之后事务就不会执行，返回（null）。</p>
<p>下面的实现自增<code>INCR</code>命令组在多个客户端并发访问服务器的时候，就会产生竞争条件。<br>比如，一开始键的值的是10，向后两个客户端执行了自增命令，最终值应该是12。<br>但是，两个客户端可能先后拿到10，然后分别自增，最后分别赋值11。<br>就出现错误。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">val = GET mykey</span><br><span class="line">val = val + <span class="number">1</span></span><br><span class="line">SET mykey $val</span><br></pre></td></tr></table></figure>

<p>可能初学者，有这样的想法，将这组命令当成一个事务执行，不就解决问题了吗。<br>不过，事务执行的结果是在<code>exec</code>之后才能拿到的，无法中途拿到（其次你也要知道的是 multi 之后也是不加任何锁的）</p>
<p>这个时候就需要<code>WATCH</code>命令了。<br>不妨换思路，</p>
<ol>
<li>监控我们需要自增的键。</li>
<li>然后获取键值，并让值加1。</li>
<li>最后用<code>set</code>命令赋值。如果，在赋值的时候，发现值已经被另一个客户端修改了，这个时候如果还去set就会出现上面的情况，所以此次事务就放弃执行。</li>
</ol>
<p><strong>基于这个思路，我们采取先check后set的方式，执行事务，如果事务失败，再执行一次，并期望这次没有产生冲突，直到这个事务执行成功。</strong><br>这种锁的形式成为<strong>乐观锁</strong>。</p>
<p>最终借助<code>WATCH</code>和事务实现了自增命令如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">WATCH mykey</span><br><span class="line">val = GET mykey</span><br><span class="line">val = val + <span class="number">1</span></span><br><span class="line">MULTI</span><br><span class="line">SET mykey $val</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure>

<p>关于<code>watch</code>命令还有如下补充：</p>
<ul>
<li><code>watch</code> 可以在<code>multi</code>之前多次调用，并且可以一次watch多个键，只要有一个键被改变，事务就不会执行。</li>
<li>当<code>exec</code>被调用时，所有键都会恢复 <strong>UNWATCHED</strong> 的状态，不管事务是否中止与否。<br>同样，当客户端连接关闭时，所有键都会被<strong>UNWATCHED</strong>。</li>
<li>也可以使用<code>unwatch</code>命令（不带参数）来刷新所有监视的键。</li>
<li>注意，很重要的一点是，<strong>键是否被监控都是相对于每个客户端而言的，也就是说它不是对于服务器的一个全局状态</strong>。以后会在Redis的实现里具体探讨。</li>
</ul>
<p>一个例子：有序集合zset是没有弹出第一个元素的原子性命令的，我们可以使用watch和事务实现它。<br><strong>使用WATCH实现ZPOP</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">WATCH zset</span><br><span class="line">element = ZRANGE zset <span class="number">0</span> <span class="number">0</span></span><br><span class="line">MULTI</span><br><span class="line">ZREM zset element</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure>

<p>如果EXEC失败（即返回Null答复），我们将重复该操作。</p>
<h2 id="Redis脚本和事务"><a href="#Redis脚本和事务" class="headerlink" title="Redis脚本和事务"></a>Redis脚本和事务</h2><blockquote>
<p>一个Redis的脚本是定义事务性的，所以一切都可以用Redis的事务做的，你也可以用一个脚本做的，平时脚本会更简单，更快速。<br>这种重复是由于以下事实：脚本是在Redis 2.6中引入的，而事务早已存在。但是，我们不太可能在短期内取消对事务的支持，因为在语义上似乎是适当的，即使不诉诸Redis脚本，仍然有可能避免竞争状况，尤其是因为Redis事务的实现复杂性极低。<br>但是，在不久的将来，我们会看到整个用户群只是在使用脚本，这并非不可能。如果发生这种情况，我们可能会弃用并最终删除事务。</p>
</blockquote>
<h1 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h1><p>与关系型数据库ACID的对比。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis系列笔记之 —— 简介、安装、入门、配置</title>
    <url>/2021/09/14/Redis%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%E4%B9%8B%20%E2%80%94%E2%80%94%20%E7%AE%80%E4%BB%8B%E3%80%81%E5%AE%89%E8%A3%85%E3%80%81%E5%85%A5%E9%97%A8%E3%80%81%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="Redis是什么"><a href="#Redis是什么" class="headerlink" title="Redis是什么"></a>Redis是什么</h2><blockquote>
<p>Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API,是一个由Salvatore Sanfilippo写的key-value存储系统。</p>
</blockquote>
<ul>
<li><strong>Redis</strong> 即 <strong>Remote Dictionary Server</strong> （远程字典服务器），是一个以<strong>字典结构</strong>（<strong>key-value</strong>形式）存储数据的存储系统。</li>
<li>Redis 由 <strong>C语言</strong>编写而成，<strong>开源</strong>，简单稳定，代码量只有几万行，<strong>单线程</strong>模式工作，但性能强劲。</li>
</ul>
<h2 id="特性与优势"><a href="#特性与优势" class="headerlink" title="特性与优势"></a>特性与优势</h2><ul>
<li>Redis的数据都存储在内存中，<strong>读写速度快</strong>（相对于关系型数据库而言）。</li>
<li>Redis支持<strong>数据的持久化</strong>，可以将内存中的数据保存在磁盘中(<strong>异步写入</strong>)，重启的时候可以再次加载进行使用。</li>
<li>Redis 支持<strong>高级数据结构</strong>，如<strong>list，set，zset，hash</strong>（列表、集合、有序集合、散列）等数据结构的存储。</li>
<li>Redis支持<strong>数据的备份</strong>，即master-slave模式的数据备份。</li>
<li>Redis的所有操作都是<strong>原子性</strong>的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持<strong>事务</strong>，即原子性，通过MULTI和EXEC指令包起来。</li>
</ul>
<h2 id="功能角色"><a href="#功能角色" class="headerlink" title="功能角色"></a>功能角色</h2><ul>
<li><strong>数据库</strong>,这也是它最开始的用途。</li>
<li><strong>缓存</strong>，Redis可以为每个键设置生存时间（Time To Live）TTL，这一功能可以让Redis扮演缓存系统的功能。</li>
<li><strong>高性能的优先队列</strong>，Redis的列表类型键可以用来实现队列，并且支持阻塞式读取。</li>
</ul>
<h1 id="安装与入门操作"><a href="#安装与入门操作" class="headerlink" title="安装与入门操作"></a>安装与入门操作</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>MacOS中安装Redis很简单，使用包管理工具如HomeBrew即可，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install redis</span><br></pre></td></tr></table></figure>

<p>在<code>/usr/local/bin</code>下,我们可以看到这么几个可执行文件：</p>
<ul>
<li>redis-server <strong>Redis服务器</strong></li>
<li>redis-cli       <strong>Redis命令行客户端</strong></li>
<li>redis-benchmark    <strong>Redis性能测试工具</strong></li>
<li>redis-check-aof    <strong>AOF文件修复文件</strong></li>
<li>redis-check-rdb    <strong>RDB文件检查文件</strong></li>
<li>redis-sentinel       <strong>Sentinel服务器</strong></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210118202017633.png" alt="在这里插入图片描述"></p>
<p>最常用的是 redis-server 和 redis-cli<br>其中</p>
<ul>
<li>redis-server是Redis的服务器，启动Redis也就是启动redis-server;</li>
<li>redis-cli是Redis<strong>自带的命令行客户端</strong>。</li>
</ul>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure>
<p>默认是 6379端口。<br>会出现如下提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">51490:C 18 Jan 2021 20:25:26.344 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">51490:C 18 Jan 2021 20:25:26.345 # Redis version&#x3D;6.0.9, bits&#x3D;64, commit&#x3D;00000000, modified&#x3D;0, pid&#x3D;51490, just started</span><br><span class="line">51490:C 18 Jan 2021 20:25:26.345 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server &#x2F;path&#x2F;to&#x2F;redis.conf</span><br><span class="line">51490:M 18 Jan 2021 20:25:26.346 * Increased maximum number of open files to 10032 (it was originally set to 256).</span><br><span class="line">                _._                                                  </span><br><span class="line">           _.-&#96;&#96;__ &#39;&#39;-._                                             </span><br><span class="line">      _.-&#96;&#96;    &#96;.  &#96;_.  &#39;&#39;-._           Redis 6.0.9 (00000000&#x2F;0) 64 bit</span><br><span class="line">  .-&#96;&#96; .-&#96;&#96;&#96;.  &#96;&#96;&#96;\&#x2F;    _.,_ &#39;&#39;-._                                   </span><br><span class="line"> (    &#39;      ,       .-&#96;  | &#96;,    )     Running in standalone mode</span><br><span class="line"> |&#96;-._&#96;-...-&#96; __...-.&#96;&#96;-._|&#39;&#96; _.-&#39;|     Port: 6379</span><br><span class="line"> |    &#96;-._   &#96;._    &#x2F;     _.-&#39;    |     PID: 51490</span><br><span class="line">  &#96;-._    &#96;-._  &#96;-.&#x2F;  _.-&#39;    _.-&#39;                                   </span><br><span class="line"> |&#96;-._&#96;-._    &#96;-.__.-&#39;    _.-&#39;_.-&#39;|                                  </span><br><span class="line"> |    &#96;-._&#96;-._        _.-&#39;_.-&#39;    |           http:&#x2F;&#x2F;redis.io        </span><br><span class="line">  &#96;-._    &#96;-._&#96;-.__.-&#39;_.-&#39;    _.-&#39;                                   </span><br><span class="line"> |&#96;-._&#96;-._    &#96;-.__.-&#39;    _.-&#39;_.-&#39;|                                  </span><br><span class="line"> |    &#96;-._&#96;-._        _.-&#39;_.-&#39;    |                                  </span><br><span class="line">  &#96;-._    &#96;-._&#96;-.__.-&#39;_.-&#39;    _.-&#39;                                   </span><br><span class="line">      &#96;-._    &#96;-.__.-&#39;    _.-&#39;                                       </span><br><span class="line">          &#96;-._        _.-&#39;                                           </span><br><span class="line">              &#96;-.__.-&#39;                                               </span><br><span class="line"></span><br><span class="line">51490:M 18 Jan 2021 20:25:26.351 # Server initialized</span><br><span class="line">51490:M 18 Jan 2021 20:25:26.353 * Loading RDB produced by version 6.0.9</span><br><span class="line">51490:M 18 Jan 2021 20:25:26.353 * RDB age 623843 seconds</span><br><span class="line">51490:M 18 Jan 2021 20:25:26.353 * RDB memory usage when created 1.02 Mb</span><br><span class="line">51490:M 18 Jan 2021 20:25:26.353 * DB loaded from disk: 0.002 seconds</span><br><span class="line">51490:M 18 Jan 2021 20:25:26.353 * Ready to accept connections</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-server- --port 8888</span><br></pre></td></tr></table></figure>
<p>通过–port自定义端口号。</p>
<h2 id="关闭Redis"><a href="#关闭Redis" class="headerlink" title="关闭Redis"></a>关闭Redis</h2><ol>
<li><p>关闭服务器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli SHUTDOWN</span><br></pre></td></tr></table></figure>
<p>因为Redis此时可能正在将内存中的数据同步到硬盘，所以强行终止Redis进程可能导致数据丢失，所以应该让客户端请求关闭Redis。<br>当Redis收到 <code>SHUTDOWN</code>(小写的也是可以的)之后，</p>
</li>
<li><p>先<strong>断开所有客户端连接</strong>。</p>
</li>
<li><p>根据配置执行<strong>持久化</strong>。</p>
</li>
<li><p>完成<strong>退出</strong>。</p>
</li>
</ol>
<p>在会看到如下提示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">51578:M 18 Jan 2021 20:32:13.180 # User requested shutdown...</span><br><span class="line">51578:M 18 Jan 2021 20:32:13.180 * Saving the final RDB snapshot before exiting.</span><br><span class="line">51578:M 18 Jan 2021 20:32:13.182 * DB saved on disk</span><br><span class="line">51578:M 18 Jan 2021 20:32:13.182 # Redis is now ready to exit, bye bye...</span><br></pre></td></tr></table></figure>


<ol start="2">
<li>退出客户端<br>使用<code>quit</code>即可</li>
</ol>
<h2 id="客户端的启动"><a href="#客户端的启动" class="headerlink" title="客户端的启动"></a>客户端的启动</h2><p>通过redis-cli向Redis发送命令有两种方式</p>
<ol>
<li><p>将命令作为<code>redis-cli</code>的参数，比如上面的将SHUTDOWN作为参数。</p>
</li>
<li><p>不带参数的启动<code>redis-cli</code>，进入交互模式，自由输入命令，在输入多条命令时方便。</p>
</li>
</ol>
<p>-h、-p自定义地址和端口号。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6379</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>在远程服务上执行命令</strong><br>用密码password连接主机名为host，端口号为port的<strong>Redis</strong>服务<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli -h host -p port -a password</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="PING检测"><a href="#PING检测" class="headerlink" title="PING检测"></a>PING检测</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PING</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure>
<p>PING 命令，该命令用于检测 redis 服务是否启动。</p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>Redis 的配置文件位于 Redis 安装目录下，文件名为 redis.conf。<br><img src="https://img-blog.csdnimg.cn/20210119134549587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0ODQ2MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="获取配置"><a href="#获取配置" class="headerlink" title="获取配置"></a>获取配置</h2><ul>
<li><strong>获取所有配置</strong><br>在进入redis客户端的交互模式后，输入:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CONFIG GET *</span><br></pre></td></tr></table></figure>
即可获取所有配置。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1) &quot;rdbchecksum&quot;</span><br><span class="line">2) &quot;yes&quot;</span><br><span class="line">3) &quot;daemonize&quot;</span><br><span class="line">4) &quot;no&quot;</span><br><span class="line">5) &quot;io-threads-do-reads&quot;</span><br><span class="line">6) &quot;no&quot;</span><br><span class="line">7) &quot;lua-replicate-commands&quot;</span><br><span class="line">8) &quot;yes&quot;</span><br><span class="line">9) &quot;always-show-logo&quot;</span><br><span class="line">10) &quot;no&quot;</span><br><span class="line">11) &quot;protected-mode&quot;</span><br><span class="line">………………</span><br><span class="line">291) &quot;slaveof&quot;</span><br><span class="line">292) &quot;&quot;</span><br><span class="line">293) &quot;notify-keyspace-events&quot;</span><br><span class="line">294) &quot;&quot;</span><br><span class="line">295) &quot;bind&quot;</span><br><span class="line">296) &quot;&quot;</span><br><span class="line">297) &quot;requirepass&quot;</span><br><span class="line">298) &quot;&quot;</span><br><span class="line">299) &quot;oom-score-adj-values&quot;</span><br><span class="line">300) &quot;0 200 800&quot;</span><br></pre></td></tr></table></figure>


<ul>
<li><strong>获取单个配置信息：</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get loglevel</span><br><span class="line">1) &quot;loglevel&quot;</span><br><span class="line">2) &quot;notice&quot;</span><br></pre></td></tr></table></figure>
第一行是选项名，第二行是选项值。</li>
</ul>
<h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CONFIG SET config_setting_name new_config_value</span><br></pre></td></tr></table></figure>

<p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config set loglevel warning</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; config get loglevel</span><br><span class="line">1) &quot;loglevel&quot;</span><br><span class="line">2) &quot;warning&quot;</span><br></pre></td></tr></table></figure>


<h2 id="带配置启动"><a href="#带配置启动" class="headerlink" title="带配置启动"></a>带配置启动</h2><p>如果我们要修改的参数过多，可以直接修改配置文件（备份一开始的），然后带着配置文件启动。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis系列笔记之 —— 缓存与数据库一致性</title>
    <url>/2021/10/30/Redis%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%E4%B9%8B%20%E2%80%94%E2%80%94%20%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="使用缓存的两种模式"><a href="#使用缓存的两种模式" class="headerlink" title="使用缓存的两种模式"></a>使用缓存的两种模式</h2><h3 id="Cache-Aside-Pattern（旁路缓存模式）"><a href="#Cache-Aside-Pattern（旁路缓存模式）" class="headerlink" title="Cache-Aside Pattern（旁路缓存模式）"></a>Cache-Aside Pattern（旁路缓存模式）</h3><ol>
<li>失效：程序先从缓存中读取数据，如果没有命中，则从数据库中读取，成功之后将数据放到缓存中；</li>
<li>命中：程序先从缓存中读取数据，如果命中，则直接返回；</li>
<li>更新：程序<strong>先更新数据库，再删除缓存</strong>。（这个操作顺序之后在细讲）。</li>
</ol>
<h3 id="Write-behind（异步缓存写入）"><a href="#Write-behind（异步缓存写入）" class="headerlink" title="Write-behind（异步缓存写入）"></a>Write-behind（异步缓存写入）</h3><p>这种使用模式的读缓存机制和上是一样的。但是更新缓存的策略为：</p>
<p><strong>更新时只更新缓存，不直接更新数据库</strong>，通过<strong>批量异步</strong> 的方式来更新数据库。</p>
<p>这个设计的好处就是让数据的I/O操作飞快无比（因为直接操作内存嘛 ），因为异步，write backg还可以合并对同一个数据的多次操作，所以性能的提高是相当可观的。</p>
<p>但是，其带来的问题是，数据不是强一致性的，而且可能会丢失（我们知道Unix/Linux非正常关机会导致数据丢失，就是因为这个事）。</p>
<p>另外，Write Back实现逻辑比较复杂，因为他需要track有哪数据是被更新了的，需要刷到持久层上。操作系统的write back会在仅当这个cache需要失效的时候，才会被真正持久起来，比如，内存不够了，或是进程退出了等情况，这又叫lazy write。</p>
<p>这种方式下，缓存和数据库的一致性不强，<strong>对一致性要求高的系统要谨慎使用</strong> 。但是它适合频繁写的场景，MySQL的<strong>InnoDB Buffer Pool机制</strong> 就使用到这种模式。</p>
<blockquote>
<p>不过本篇文章只对第一种模式进行拓展解析。</p>
</blockquote>
<h2 id="具体的更新缓存策略"><a href="#具体的更新缓存策略" class="headerlink" title="具体的更新缓存策略"></a>具体的更新缓存策略</h2><ol>
<li>操作缓存的时候，到底是<strong>删除缓存</strong>呢，还是<strong>更新缓存</strong>？</li>
<li>双写的情况下，<strong>先操作数据库</strong>还是<strong>先操作缓存</strong>？</li>
</ol>
<p>组合起来就有四种情况：</p>
<ol>
<li>先更新缓存，再更新数据库</li>
<li>先更新数据库，再更新缓存</li>
<li>先删除缓存，再更新数据库</li>
<li>先更新数据库，再删除缓存</li>
</ol>
<h3 id="先更新缓存，再更新数据库"><a href="#先更新缓存，再更新数据库" class="headerlink" title="先更新缓存，再更新数据库"></a>先更新缓存，再更新数据库</h3><p>这种方式可轻易排除，因为如果先更新缓存成功，但是数据库更新失败，则肯定会造成数据不一致。</p>
<p>绝对不要使用。</p>
<h3 id="先更新数据库，再更新缓存"><a href="#先更新数据库，再更新缓存" class="headerlink" title="先更新数据库，再更新缓存"></a>先更新数据库，再更新缓存</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">updateDB();</span><br><span class="line">updateRedis();</span><br></pre></td></tr></table></figure>

<p>这种缓存更新策略俗称双写。</p>
<p><strong>存在问题是：并发更新数据库场景下，会将脏数据刷到缓存。</strong></p>
<p>注意上面的代码并非是原子的，在并发环境下，很明显很有可能出现数据不一致的情况。</p>
<p>比如下面的竞态条件：</p>
<p><img src="/2021/10/30/Redis%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%E4%B9%8B%20%E2%80%94%E2%80%94%20%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7/%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E5%86%8D%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98.png" alt="先更新数据库，再更新缓存"></p>
<h3 id="先删除缓存，再更新数据库"><a href="#先删除缓存，再更新数据库" class="headerlink" title="先删除缓存，再更新数据库"></a>先删除缓存，再更新数据库</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">deleteRedis();</span><br><span class="line">updateDB();</span><br></pre></td></tr></table></figure>

<p><strong>存在问题：更新数据库之前，若有查询请求，会将脏数据刷到缓存。</strong></p>
<p><img src="/2021/10/30/Redis%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%E4%B9%8B%20%E2%80%94%E2%80%94%20%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7/%E5%85%88%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%EF%BC%8C%E5%86%8D%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93.png" alt="先删除缓存，再更新数据库"></p>
<h3 id="先更新数据库，再删除缓存"><a href="#先更新数据库，再删除缓存" class="headerlink" title="先更新数据库，再删除缓存"></a>先更新数据库，再删除缓存</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">updateDB();</span><br><span class="line">deleteRedis();</span><br></pre></td></tr></table></figure>



<p><strong>存在问题：在更新数据库之前有查询请求，并且缓存失效了，会查询数据库，然后更新缓存。如果在查询数据库和更新缓存之间进行了数据库更新的操作，那么就会把脏数据刷到缓存。</strong></p>
<p><img src="/2021/10/30/Redis%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%E4%B9%8B%20%E2%80%94%E2%80%94%20%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7/%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E5%86%8D%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98.png" alt="先更新数据库，再删除缓存"></p>
<p>如果发生上述情况，确实是会发生脏数据。但是发生上述情况有一个先天性条件，就是写数据库操作比读数据库操作耗时更短。</p>
<p><strong>不过数据库的读操作的速度远快于写操作的</strong></p>
<p>因此这一情形导致数据不一致性的概率比上面3种可能性都要小。</p>
<h2 id="对上面四种方式的总结"><a href="#对上面四种方式的总结" class="headerlink" title="对上面四种方式的总结"></a>对上面四种方式的总结</h2><p>为什么无论按照哪种做法都有可能导致数据不一致？</p>
<p>上面的四种策略其实到最后<strong>有两步操作</strong>，而<strong>这两步操作并不是原子性的</strong>，在并发场景下总会导致缓存和数据库的不一致。 </p>
<h3 id="更新缓存还是删除缓存？"><a href="#更新缓存还是删除缓存？" class="headerlink" title="更新缓存还是删除缓存？"></a>更新缓存还是删除缓存？</h3><p>对于一个不能保证事务性的操作，一定涉及“哪个任务先做，哪个任务后做”的问题，解决这个问题的方向是：如果出现不一致，谁先做对业务的影响较小，就谁先执行。</p>
<p>更新缓存：</p>
<p>缺点：</p>
<ul>
<li><strong>更新缓存需要有一定的维护成本</strong>；</li>
<li>存在<strong>并发更新</strong>的问题；</li>
<li>写多读少的情况下，读请求还没有来，<strong>缓存会被无用地更新很多次</strong>，没有起到缓存的作用；</li>
</ul>
<p>删除缓存</p>
<ul>
<li>优点：简单、成本低，容易开发；</li>
<li>缺点：会造成一次cache miss；</li>
</ul>
<p>如果更新缓存开销较小并且读多写少，基本不会有高写并发的时候可以才用更新缓存，否则<strong>通用做法还是删除缓存</strong>。</p>
<h2 id="推荐的做法"><a href="#推荐的做法" class="headerlink" title="推荐的做法"></a>推荐的做法</h2><h3 id="设置一个合理的redis过期时间"><a href="#设置一个合理的redis过期时间" class="headerlink" title="设置一个合理的redis过期时间"></a>设置一个合理的redis过期时间</h3><p><strong>缓存必须要有过期时间</strong>。</p>
<p>为什么必须要有过期时间？</p>
<p>首先，对于缓存来说，当它的命中率越高的时候，我们的系统性能也就越好。如果某个缓存项没有过期时间，而它命中的概率又很低，这就是在浪费缓存的空间。</p>
<p>其次，设置过期时间还有一个最大好处，就是当数据库跟缓存出现数据不一致的情况时，这个可以<strong>作为一个最后的兜底手段</strong>。也就是说，当数据确实出现不一致的情况时，过期时间可以保证只有在出现不一致的时间点到缓存过期这段时间之内，数据库跟缓存的数据是不一致的，因此也<strong>保证了数据的最终一致性</strong>。</p>
<p>所以，如果可以设置一个比较小的过期时间，那么<strong>数据不一致终归是暂时的，最终一致性可以保证</strong>。</p>
<h3 id="延迟双删"><a href="#延迟双删" class="headerlink" title="延迟双删"></a>延迟双删</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String key,Object data)</span></span>&#123;</span><br><span class="line">     redis.del(key);  <span class="comment">// 第一次删除缓存</span></span><br><span class="line">     db.update(data); <span class="comment">// 操作数据库</span></span><br><span class="line">     Thread.sleep(<span class="number">1000</span>);  <span class="comment">// 延时一段时间，在这段时间内有可能读操作设置的redis脏数据</span></span><br><span class="line">     redis.del(key); <span class="comment">// 第二次删除缓存</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<p>大家应该评估自己的项目的读数据业务逻辑的耗时，然后写数据的休眠时间，则在读数据业务逻辑的耗时基础上即可加几百 ms 即可。</p>
<p>这么做的目的，就是<strong>尽可能确保读请求结束，写请求可以删除读请求造成的缓存脏数据。</strong>（也就是说为了避免产生第四种策略的问题）</p>
<p>当然，完全可能在第二次删除缓存之后，还有读操作设置了旧的缓存数据。</p>
<p>是的，所以<strong>延迟双删这种方案说到底也只是降低了数据不一致的概率，不是强一致性</strong>。</p>
<h3 id="延时的具体实现"><a href="#延时的具体实现" class="headerlink" title="延时的具体实现"></a>延时的具体实现</h3><p>上面的阻塞只是语义上的延时，实际不会这样做，否则这个用户线程就阻塞在这了。</p>
<p>实际处理时，可以如下方法：</p>
<ol>
<li>线程池提交任务，任务中睡眠</li>
<li>Quartz定时任务</li>
<li>Rabbitmq的延时队列</li>
<li>Java中的DelayedQueue</li>
</ol>
<h3 id="删除缓存失败的重试机制"><a href="#删除缓存失败的重试机制" class="headerlink" title="删除缓存失败的重试机制"></a>删除缓存失败的重试机制</h3><p>采取<strong>先更新数据库，再删除缓存</strong>这种方案，我们没有考虑操作数据库或者操作缓存可能失败的情况，而这种情况也是客观存在的。那么在这里我们简单讨论下，首先是如果更新数据库失败了，其实没有太大关系，因为此时数据库和缓存中都还是老数据，不存在不一致的问题。</p>
<p>假设删除缓存失败了呢？此时确实会存在数据不一致的情况。除了设置缓存过期时间这种兜底方案之外，如果我们希望尽可能保证缓存可以被及时删除，那么我们必须<strong>要考虑对删除操作进行重试</strong>。</p>
<p>最简单方式，就是在代码中进行重试删除，但是这样的代码侵入比较严重。</p>
<p>另外考虑到，分布式环境下一台需要删除redis缓存的机器可能会宕机，导致需要删除的缓存没有得到正确删除，此时需要删除的key的信息就会丢失。</p>
<p>这个时候可以引入 <strong>消息中间件</strong>, 将需要删除的key发往消息中间件，然后消费端负责根据拉下来的key删除缓存，删除失败就把这条消息重新入队，直到成功。</p>
<p><img src="/2021/10/30/Redis%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%E4%B9%8B%20%E2%80%94%E2%80%94%20%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7/del-key.png" alt="图片"></p>
<p>上面的做法的确点就是对业务代码有入侵，可以采用一种订阅数据库binlog的方式，用非业务代码完成对缓存的删除。</p>
<p><img src="/2021/10/30/Redis%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%E4%B9%8B%20%E2%80%94%E2%80%94%20%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7/binlog-mq.png" alt="img"></p>
<p>启动一个订阅程序去订阅数据库的 binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作。</p>
<h2 id="怎么做到强一致性？"><a href="#怎么做到强一致性？" class="headerlink" title="怎么做到强一致性？"></a>怎么做到强一致性？</h2><p>上面讲述的所有的方案都是最终一致性的， 如果我们就要实现强一致性呢？</p>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>假设我们仍然使用<code> Cache-Aside Pattern</code>, 所谓导致数据不一致的情况</p>
<p>实际上根本原因是<strong>写操作的两个方法</strong>（更新数据库-删除缓存）与<strong>读操作两个方法</strong>（查询数据库-更新缓存）不是串行化的执行。</p>
<p>所以，为了做到这样的强一致性，我们可以引入<strong>读写锁</strong>，去完成这样<strong>写读-读写-读读-写写</strong>操作之间的串行化操作。</p>
<p>使用读写锁之后：</p>
<p>回到”先更新数据库，再删除缓存”这个方案本身上来，从字面上来看，这里有两步操作，因此在数据库更新之前，到缓存被删除这段时间之内，读请求读取到的都是脏数据。</p>
<p>如果要实现这两者的强一致性，只能是在更新完数据库之前，所有的读请求都必须要被阻塞直到缓存最终被删除为止，读请求和读请求之间并不没有冲突，而这个同步语义正由<strong>读写锁</strong>提供。</p>
<p>需要注意是，</p>
<ol>
<li>要使用分布式读写锁；</li>
<li>锁的粒度要尽可能小。</li>
</ol>
<h3 id="分布式一致性算法"><a href="#分布式一致性算法" class="headerlink" title="分布式一致性算法"></a>分布式一致性算法</h3><p>虽然这里谈论的是Redis缓存和数据库的数据一致性，但是逻辑模型上这里和CAP定理中的C是一回事。</p>
<p>因而在分布式系统中为了达到多副本单操作的一致性的各种一致性算法都可以派上用场，来达到这里的缓存与数据库一致性的目的。</p>
<p>比如2PC、3PC、Paxos和Raft 等。</p>
<p>说到这里，你可以看到为了做到 <strong>缓存-数据库一致性</strong>的强一致性并不是一件很容易的事，实际上分布式环境下的一致性问题一直都是一个痛点，如果你使用了redis缓存来加快数据库多读少写场景下的业务，同时又想确保<strong>缓存-数据库一致性</strong>，是不现实的，或者说实现成本太高，即使实现效果也不好。</p>
<p>这个时候，你需要考虑，如果真的就需要保证强一致性，还不如将读写串行化，甚至去掉缓存。</p>
<h2 id="分布式架构、读写分离环境下的一致性保证"><a href="#分布式架构、读写分离环境下的一致性保证" class="headerlink" title="分布式架构、读写分离环境下的一致性保证"></a>分布式架构、读写分离环境下的一致性保证</h2><p>上面的谈论的缓存-数据库一致性的架构仍然是单数据库-单应用程序的架构，如果是数据库读写分离环境下的呢？</p>
<p>我们知道数据库（以Mysql为例）主从之间的数据同步是通过binlog同步来实现的，因此这里可以考虑订阅binlog（可以使用canal之类的中间件实现，提取出要删除的缓存项，然后作为消息写入消息队列，然后再由消费端进行慢慢的消费去删除redis缓存和重试。</p>
<p><img src="/2021/10/30/Redis%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%E4%B9%8B%20%E2%80%94%E2%80%94%20%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7/redis-mysql.png"></p>
<blockquote>
<p><a href="https://juejin.cn/post/6844903941646319623#heading-10">聊聊数据库与缓存数据一致性问题</a></p>
<p>[缓存更新的套路](Redis系列笔记之 —— 缓存与数据库一致性/17416.html)</p>
<p><a href="https://xie.infoq.cn/article/47241d099404a1565e168fad4">缓存与数据库一致性问题深度剖析</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis系列笔记之 —— 缓存三大问题及其解决方案</title>
    <url>/2021/10/31/Redis%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%E4%B9%8B-%E2%80%94%E2%80%94-%E7%BC%93%E5%AD%98%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>老八股文了，redis必问问题。</p>
</blockquote>
<h1 id="缓存的利与弊"><a href="#缓存的利与弊" class="headerlink" title="缓存的利与弊"></a>缓存的利与弊</h1><h2 id="引入缓存的优点"><a href="#引入缓存的优点" class="headerlink" title="引入缓存的优点"></a>引入缓存的优点</h2><ul>
<li>能够缩短服务的响应时间，给用户带来更好的体验。</li>
<li>能够增大系统的吞吐量，依然能够提升用户体验。</li>
<li>减轻数据库的压力，防止高峰期数据库被压垮，导致整个线上服务 BOOM！</li>
</ul>
<h2 id="引入缓存的缺点"><a href="#引入缓存的缺点" class="headerlink" title="引入缓存的缺点"></a>引入缓存的缺点</h2><ul>
<li>缓存有多种选型，是内存缓存，memcached 还是 redis，你是否都熟悉，如果不熟悉，无疑增加了维护的难度（本来是个纯洁的数据库系统）。</li>
<li>缓存系统也要考虑分布式，比如 redis 的分布式缓存还会有很多坑，无疑增加了系统的复杂性。</li>
<li>在特殊场景下，如果对缓存的准确性有非常高的要求，就必须考虑缓存和数据库的一致性问题。</li>
</ul>
<p>适合缓存的数据：读多写少、不常变化的数据，比如详情，评论等。</p>
<p>不适合缓存的数据：对于那些经常变化的数据，其实并不适合缓存，一方面会增加系统的复杂性（缓存的更新，缓存脏数据），另一方面也给系统带来一定的不稳定性（缓存系统的维护）。</p>
<p>但一些极端情况下，你需要将一些会变动的数据进行缓存，比如想要页面显示准实时的库存数，或者其他一些特殊业务场景。这时候你需要保证缓存不能（一直）有脏数据，这就需要再深入讨论一下，也就是<strong>缓存-数据库一致性的问题</strong>。</p>
<h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>缓存穿透是指<strong>缓存和数据库中都没有的数据</strong>，而用户不断发起请求，如发起id为-1的数据或者特别大的不存在的数据。有可能是黑客利用漏洞攻击从而去压垮应用的数据库。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>对于缓存穿透问题，常见的解决方案有以下三种：</p>
<ol>
<li><strong>验证拦截</strong>：接口层进行校验，如鉴定用户权限，对ID之类的字段做基础的校验，如<code>id&lt;=0</code>的字段直接拦截；</li>
<li><strong>缓存空数据</strong>：当数据库查询到的数据为空时，也将这条数据进行缓存，但缓存的有效性设置得要较短，以免影响正常数据的缓存（因为有可能一开始没有这个key，但后来有了，当然你可以主动删除缓存）；</li>
<li>使用布隆过滤器：布隆过滤器是一种比较独特数据结构，有一定的误差。当它指定一个数据存在时，它可能存在也可能不存在，但是当它指定一个数据不存在时，那么它一定是不存在的。（<del>具体使用方法参考文章模链接</del>）</li>
</ol>
<h1 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h1><h2 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h2><p>缓存击穿是指当前热点数据存储到期时，<strong>多个线程同时并发访问热点数据</strong>。因为缓存刚过期，<strong>所有并发请求都会到数据库中查询数据</strong>。</p>
<h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><ul>
<li><p>将热点数据设置为永不过期；</p>
</li>
<li><p>加互斥锁：互斥锁可以控制查询数据库的线程访问，只让一个请求通过，只有一个请求去数据库拉取数据，取完数据，不管如何都需要释放锁。</p>
</li>
<li><p>添加超时标记：在缓存的对象上增加一个属性来标识超时时间，当获取到数据后，校验数据内部的标记时间，判定是否快超时了，如果是，异步发起一个线程（控制好并发）去主动更新该缓存。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(Object key, <span class="keyword">int</span> retryCount)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 重试次数太多直接 return null</span></span><br><span class="line">    <span class="keyword">if</span>(retryCount &gt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String value = redis.get(key);</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123; <span class="comment">// 代表缓存值过期</span></span><br><span class="line">        <span class="comment">// 设置1 min的超时，防止del操作失败的时候，下次缓存过期一直不能load db</span></span><br><span class="line">        <span class="keyword">if</span> (redis.setnx(key_mutex, <span class="number">1</span>, <span class="number">60</span>) == <span class="number">1</span>) &#123;  <span class="comment">// 代表设置成功</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                value = db.get(key);</span><br><span class="line">                redis.set(key, value, expire_secs);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 确保最后删除，释放锁</span></span><br><span class="line">                redis.del(key_mutex); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可</span></span><br><span class="line">            sleep(<span class="number">200</span>);</span><br><span class="line">            get(key, retryCount + <span class="number">1</span>);  <span class="comment">// 重试</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><h2 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h2><p>缓存雪崩是指缓存中有大量的数据，在同一个时间点，或者较短的时间段内，全部过期了，这个时候请求过来，缓存没有数据，都会请求数据库，则数据库的压力就会突增，扛不住就会宕机。</p>
<p>造成缓存雪崩的关键在于在同一时间大规模的key失效。为什么会出现这个问题呢，有几种可能，</p>
<p>第一种可能是Redis宕机，</p>
<p>第二种可能是采用了相同的过期时间。</p>
<h2 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h2><ol>
<li>如果是热点数据，那么可以考虑<strong>设置永远不过期</strong>。</li>
<li>缓存的过期时间除非比较严格，要不考虑<strong>设置一个波动随机值</strong>，比如理论十分钟，那这类key的缓存时间都加上一个1-3分钟，过期时间在7-13分钟内波动，<strong>有效防止都在同一个时间点上大量过期</strong>。</li>
<li>如果所有的热点数据在一台redis服务器上，也是极其危险的，如果网络有问题，或者redis服务器挂了，那么所有的热点数据也会雪崩（查询不到），因此<strong>将热点数据打散分不到不同的机器上</strong>，也可以有效减少这种情况。</li>
<li>对于redis服务挂掉的问题,可以实现redis的高可用主从架构, 并且做redis的持久化, 在redis挂掉的同时时读取本地缓存数据, 同时恢复redis服务加载持久化的数据。</li>
</ol>
<ul>
<li>【事前】<strong>高可用缓存</strong>：高可用缓存是防止出现整个缓存故障。即使个别节点，机器甚至机房都关闭，系统仍然可以提供服务，Redis 哨兵(Sentinel) 和 Redis 集群(Cluster) 都可以做到高可用；</li>
<li>【事中】<strong>缓存降级</strong>（临时支持）：当访问次数急剧增加导致服务出现问题时，我们如何确保服务仍然可用。在国内使用比较多的是 Hystrix，它通过熔断、降级、限流三个手段来降低雪崩发生后的损失。只要确保数据库不死，系统总可以响应请求，每年的春节 12306 我们不都是这么过来的吗？只要还可以响应起码还有抢到票的机会；</li>
<li>【事后】<strong>备份和快速预热</strong>：Redis数据备份和恢复、快速缓存预热。</li>
</ul>
<blockquote>
<p>参考链接：</p>
<p><a href="https://blog.csdn.net/Revivedsun/article/details/94992323">Guava布隆过滤器(boomfilter)使用简介</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis系列笔记之 —— 键、字符串、散列、列表、集合、有序集合、HyperLogLog的性质及操作命令</title>
    <url>/2021/09/15/Redis%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%E4%B9%8B%20%E2%80%94%E2%80%94%20%E9%94%AE%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E6%95%A3%E5%88%97%E3%80%81%E5%88%97%E8%A1%A8%E3%80%81%E9%9B%86%E5%90%88%E3%80%81%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E3%80%81HyperLogLog%E7%9A%84%E6%80%A7%E8%B4%A8%E5%8F%8A%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="键"><a href="#键" class="headerlink" title="键"></a>键</h1><blockquote>
<p>命令不区分大小写，尽量使用大写，表明是Redis的关键字。</p>
</blockquote>
<h2 id="获得符合规则的键名列表"><a href="#获得符合规则的键名列表" class="headerlink" title="获得符合规则的键名列表"></a>获得符合规则的键名列表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">KEYS your_pattern</span><br></pre></td></tr></table></figure>

<p>pattern支持glob风格。</p>
<ol>
<li><code>？</code> 匹配单个字符；</li>
<li><code>*</code> 匹配任意个（包括0个）字符；</li>
<li><code>[]</code> 匹配 [] 括号间的任一字符，可以使用<code>-</code>表示范围，如a[b-d],表示匹配ab、ac、ad；</li>
<li><code>\x</code> 用于转义，匹配字符 x 本身。</li>
</ol>
<p>那么<code>KEYS *</code>实际上就会返回Redis中所有的键。</p>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><ol>
<li><p><strong>删除</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DEL key</span><br></pre></td></tr></table></figure>
<p>存在并删除成功返回1，失败返回0；</p>
</li>
<li><p> <strong>判断是否存在</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXISTS key</span><br></pre></td></tr></table></figure></li>
<li><p><strong>获取类型</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TYPE key</span><br></pre></td></tr></table></figure>
<p>返回类型可能是（string字符串、hash散列、list列表、set集合、zset有序集合）</p>
</li>
</ol>
<ol start="4">
<li>序列化给定 key<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DUMP key</span><br></pre></td></tr></table></figure>
返回被序列化的值</li>
</ol>
<h2 id="生存时间相关"><a href="#生存时间相关" class="headerlink" title="生存时间相关"></a>生存时间相关</h2><ol>
<li><p>为给定 key 设置过期时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPIRE key seconds</span><br></pre></td></tr></table></figure>
<p>单位秒。</p>
</li>
<li><p>设置 key 的过期时间以毫秒计</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PEXPIRE key milliseconds</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>和 EXPIRE 类似</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPIREAT key timestamp</span><br></pre></td></tr></table></figure>
<p>EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。</p>
</li>
<li><p>和 EXPIRE 类似</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PEXPIREAT key milliseconds-timestamp</span><br></pre></td></tr></table></figure>
<p>设置 key 过期时间的时间戳(unix timestamp) 以毫秒计</p>
</li>
<li><p>移除过期时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PERSIST key</span><br></pre></td></tr></table></figure>
<p>移除 key 的过期时间，key 将持久保持。</p>
</li>
</ol>
<p>注意，使用<code>SET</code>、<code>GETSET</code>命令为键赋值，也会同时清除键的过期时间。<br>但是只对键值操作的命令，如（RPUSH、INCR、HSET、ZREM）</p>
<ol start="6">
<li><p>返回剩余的生存时间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TTL key</span><br></pre></td></tr></table></figure>
<p>以<strong>秒为单位</strong>，返回给定 key 的剩余生存时间(TTL, time to live)。</p>
</li>
<li><p>和TTL类似</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PTTL key</span><br></pre></td></tr></table></figure>
<p>以<strong>毫秒为单位</strong>返回 key 的剩余的过期时间。</p>
</li>
</ol>
<h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><ol>
<li><p>修改 key 的名称</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RENAME key newkey</span><br></pre></td></tr></table></figure></li>
<li><p>仅当 newkey 不存在时，将 key 改名为 newkey 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RENAMENX key newkey</span><br></pre></td></tr></table></figure></li>
<li><p>从当前数据库中随机返回一个 key </p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RANDOMKEY</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>将当前数据库的 key 移动到给定的数据库 db 当中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MOVE key db</span><br></pre></td></tr></table></figure></li>
<li><p>清除某个数据库的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FLUSHDB</span><br></pre></td></tr></table></figure></li>
<li><p>清除Redis所有数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FLUSHALL</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="字符串-string"><a href="#字符串-string" class="headerlink" title="字符串(string)"></a>字符串(string)</h2><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul>
<li><p>string 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。</p>
</li>
<li><p>string 类型是二进制安全的。意思是 <strong>redis 的 string 可以包含任何数据</strong>。比如jpg图片或者<strong>序列化的对象</strong>。</p>
</li>
<li><p>string 类型是 Redis 最基本的数据类型，<strong>string</strong> 类型的值最大能存储 <strong>512M</strong>B。</p>
</li>
</ul>
<h3 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h3><ul>
<li><strong>取值赋值</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET key value</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET key</span><br></pre></td></tr></table></figure>


<p>在指定的 key 不存在时，为 key 设置指定的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SETNX KEY_NAME VALUE</span><br></pre></td></tr></table></figure>


<ul>
<li><strong>递增递减数字</strong><br>当存储的字符串是<strong>整数形式</strong>时，可以使用<code>INCR</code>命令自增1，并返回自增后的值。<br>（当键不存在时，默认从0开始自增，所以第一次返回值为 1 ）。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">INCR num </span><br><span class="line">返回：<span class="number">1</span></span><br><span class="line">INCR num </span><br><span class="line">返回：<span class="number">2</span></span><br></pre></td></tr></table></figure>
如果给非整数类型的值，如浮点值、字符串，使用INCR命令，会报错。<br>如：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; GET s</span><br><span class="line">&quot;helloworld&quot;</span><br><span class="line">127.0.0.1:6379[1]&gt; INCR s</span><br><span class="line">(error) ERR value is not an integer or out of range</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>指定增量</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INCRBY key increment</span><br></pre></td></tr></table></figure>


<p>同样的，也有<strong>减少命令</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DECR key</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DECR key decrement</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>浮点数的增加</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INCRBYFLOAT key increment</span><br></pre></td></tr></table></figure>
但没有对应的减少命令。</li>
</ul>
<ul>
<li><p><strong>向尾部追加值</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">APPEND key value</span><br></pre></td></tr></table></figure></li>
<li><p><strong>获取字符串长度</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">STRLEN key</span><br></pre></td></tr></table></figure></li>
<li><p><strong>同时获得/得到多个键值</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MGET key [key ...]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MSET key value [key1 value1 ...]</span><br></pre></td></tr></table></figure></li>
<li><p>位操作<br>暂略。</p>
</li>
</ul>
<blockquote>
<p>以下的数据类型都不能支持嵌套。</p>
</blockquote>
<h2 id="散列-hash"><a href="#散列-hash" class="headerlink" title="散列(hash)"></a>散列(hash)</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>Redis hash 是一个<strong>键值(key=&gt;value)对集合</strong>。</li>
<li>键值的类型只能是<strong>字符串</strong>，也就是说不能去嵌套其他类型。</li>
<li>hash 特别适合用于<strong>存储对象</strong>。 </li>
<li>一个散列类型的键最多只能包含$2^{32}-1$（<strong>40亿</strong>多）个字段。</li>
</ul>
<h3 id="操作命令-1"><a href="#操作命令-1" class="headerlink" title="操作命令"></a>操作命令</h3><ul>
<li><strong>赋值、取值</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HSET key field value</span><br><span class="line">HGET key field</span><br></pre></td></tr></table></figure>
<p>注：HSET命令不区分插入还是更新操作，插入操返回1，更新返回0；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HMSET key field1 value1 field2 value2 [filed3 value3]</span><br><span class="line">HMGET key field1 field2 [field3]</span><br></pre></td></tr></table></figure>

<p>如果不知道散列类型的键对应的值有哪些字段，可以使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HGETALL</span><br></pre></td></tr></table></figure>

<ul>
<li>只获取<strong>字段名</strong>或<strong>字段值</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HKEYS key</span><br><span class="line">HVALS key</span><br></pre></td></tr></table></figure></li>
<li>只获取<strong>字段数量</strong><br>返回字段的数量。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HLEN key</span><br></pre></td></tr></table></figure></li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HSET car price 50000</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; HMSET car kind bmw color white</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; HGET car price</span><br><span class="line">&quot;50000&quot;</span><br><span class="line">127.0.0.1:6379&gt; HMGET car kind color</span><br><span class="line">1) &quot;bmw&quot;</span><br><span class="line">2) &quot;white&quot;</span><br><span class="line">127.0.0.1:6379&gt; HGETALL car</span><br><span class="line">1) &quot;price&quot;</span><br><span class="line">2) &quot;50000&quot;</span><br><span class="line">3) &quot;kind&quot;</span><br><span class="line">4) &quot;bmw&quot;</span><br><span class="line">5) &quot;color&quot;</span><br><span class="line">6) &quot;white&quot;</span><br></pre></td></tr></table></figure>


<ul>
<li><p><strong>判断字段是否存在</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HEXISTS key field</span><br></pre></td></tr></table></figure></li>
<li><p><strong>当字段不存在时赋值</strong><br>（NX表示not exists）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HSETNX key field value</span><br></pre></td></tr></table></figure>
<p>值得一提的是，这个命令也是一个原子操作，不需要担心静态条件。</p>
</li>
<li><p><strong>增加数字</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HINCRBY key filed increment</span><br></pre></td></tr></table></figure>
<p>（散列类型没有HINCR命令）</p>
</li>
<li><p><strong>删除字段</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HDEL key field [field1 ……]</span><br></pre></td></tr></table></figure>
<p>返回成功的删除字段的个数。</p>
</li>
</ul>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。<br>列表类型的内部使用双向链表，所以在链表两端添加元素的时间复杂度为O(1)。<br>自然，在链表两端查询元素都是很快的。</p>
<h3 id="操作命令-2"><a href="#操作命令-2" class="headerlink" title="操作命令"></a>操作命令</h3><ul>
<li><strong>向列表两端添加元素</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 从左边添加（头部）</span><br><span class="line">LPUSH key val [val1 ……]</span><br><span class="line">&#x2F;&#x2F; 从右边添加（尾部）</span><br><span class="line">RPUSH key val [val1 ……]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>向列表两端弹出元素</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LPOP key</span><br><span class="line">RPOP key</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>获取列表中元素的个数</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LLEN</span><br></pre></td></tr></table></figure>
<p>当键不存在时，返回0；</p>
<ul>
<li><strong>获得列表片段</strong><br>两个注意点，① 索引<strong>从0开始</strong>， ② <strong>左右都是闭区间</strong>。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LRANGE key start end</span><br></pre></td></tr></table></figure>
并且支持负索引，表示从右边开始计数。<br>如-1表示右边第一个，-2表示右边第二个。</li>
</ul>
<p> <strong>两个情况</strong><br>① start的位置在stop的后面，返回空列表<br>② stop的位置大于实际的索引范围，则返回到列表最右边的元素。</p>
<ul>
<li><strong>删除列表中指定的值</strong><br>REM为remove的缩写<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LREM key count value</span><br></pre></td></tr></table></figure>
删除前count个值value的元素。</li>
</ul>
<p><strong>注意</strong>：<br>① count为0时，删除所有<br>②count为负，仍然删除前|count|个。</p>
<p><strong>返回的是实际删除的元素的个数</strong>。</p>
<ul>
<li><p><strong>获得/修改制定索引的元素值</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LINDEX key index</span><br><span class="line">LSET KEY index value</span><br></pre></td></tr></table></figure>
<p>注意：索引从0开始</p>
</li>
<li><p><strong>只保留指定阶段</strong></p>
</li>
</ul>
<p><strong>只保留[start,end]的元素</strong>，其余的元素删除。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LTRIM key start end</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>将元素从一个列表转到另一个列表</strong><br>将第一个列表的元素从右边弹出，从左边添加进第二的列表。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RPOPLPUSH source destination</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><p><strong>Redis 的 Set 是 String 类型的无序集合</strong>。集合成员是<strong>唯一的</strong>，这就意味着集合中不能出现重复的数据。</p>
<p>Redis 中集合是通过<strong>哈希表 hash table</strong>实现的，所以添加，删除，查找的复杂度<strong>基本上是</strong> O(1)的。</p>
<p>集合中最大的成员数为 $2^{32}- 1$ (4294967295, 每个集合可存储40多亿个成员)。</p>
<h3 id="操作命令-3"><a href="#操作命令-3" class="headerlink" title="操作命令"></a>操作命令</h3><ul>
<li><p><strong>增加/删除元素</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SADD key member [member ...]</span><br><span class="line">SREM key member [member ...]</span><br></pre></td></tr></table></figure>
<p>返回是成功添加、删除的元素的个数。</p>
</li>
<li><p><strong>获得集合的所有元素</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SMEMBERS</span><br></pre></td></tr></table></figure></li>
<li><p><strong>判断元素是否在集合中</strong></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SISMEMBER key member</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(1)。当值存在时返回1，否则返回0。</p>
<ol>
<li><p><strong>集合的交</strong><br>intersection： 交集</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SINTER setA setB setC</span><br></pre></td></tr></table></figure></li>
<li><p><strong>集合的并</strong><br>union：并集</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SUNION setA setB setC</span><br></pre></td></tr></table></figure></li>
<li><p><strong>集合的差</strong><br>首先差集$A-B$的含义是，${x| x\in A \ \ and \ \ x\notin B }$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SDIFF key [key ....]</span><br></pre></td></tr></table></figure></li>
</ol>
<p>比如: A - B - C，依次计算即可：<br>多个集合做差集是将前两个集合差集的结果再次作为操作数。</p>
<ul>
<li><strong>获取集合中元素的个数</strong> </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SCARD  key</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>进行集合运算并将结果存储</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SINTERSTORE destination key [key ...]</span><br><span class="line">SDIFFSTORE destination key [key ...]</span><br><span class="line">SUNIONSTORE destination key [key ...]</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h2><h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><ul>
<li>Redis的zset 和 set 一样也是<strong>string类型元素的集合</strong>,且<strong>不允许重复</strong>的成员。</li>
<li>不同的是<strong>每个元素都会关联一个double类型的分数</strong>。redis正是通过分数来为集合中的成员进行<strong>从小到大的排序</strong>。</li>
<li>zset的<strong>成员是唯一的</strong>,但分数(score)却可以重复。</li>
</ul>
<h3 id="操作命令-4"><a href="#操作命令-4" class="headerlink" title="操作命令"></a>操作命令</h3><ul>
<li><strong>增加元素</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZADD key score member [score member ...]</span><br></pre></td></tr></table></figure></li>
</ul>
<p>如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZADD student_score 100 zhangsan 90 xiaoming 60 xiaohua</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>获得元素的分数</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZSCORE  key number</span><br></pre></td></tr></table></figure></li>
<li><p>获得<strong>排名在某个范围</strong>的元素列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZRANGE key start stop [WITHSCORES]</span><br><span class="line">ZREVRANGE key start stop [WITHSCORES]</span><br></pre></td></tr></table></figure>
<p>ZRANGE命令会按照<strong>元素分数的从小到大的顺序</strong>返回<strong>索引从start到stop之间的所有元素</strong></p>
</li>
<li><p>ZARNGE和 LRANGE类似，包括 star, stop；</p>
</li>
<li><p>如果<strong>需要同时获得元素的分数</strong>，加上参数<code>WITHSCORES</code>,</p>
</li>
<li><p>如果<strong>需要从大到小排序</strong>，用ZREVRANGE<br>如：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZRANGE student_score 0 -1 WITHSCORES</span><br><span class="line">1) &quot;xiaohua&quot;</span><br><span class="line">2) &quot;60&quot;</span><br><span class="line">3) &quot;xiaoming&quot;</span><br><span class="line">4) &quot;90&quot;</span><br><span class="line">5) &quot;zhangsan&quot;</span><br><span class="line">6) &quot;100&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGE student_score 0 -1 WITHSCORES</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;100&quot;</span><br><span class="line">3) &quot;xiaoming&quot;</span><br><span class="line">4) &quot;90&quot;</span><br><span class="line">5) &quot;xiaohua&quot;</span><br><span class="line">6) &quot;60&quot;</span><br></pre></td></tr></table></figure>


<ul>
<li>获得<strong>指定分数范围的元素</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offser count]</span><br></pre></td></tr></table></figure></li>
</ul>
<p>该命令按照<strong>元素分数从小到大</strong>的顺序返回分数在min到max之间（包含min、max）的元素。</p>
<ul>
<li> 如果需要是开区间，在min、max前面加上<code>(</code></li>
<li>min、max也可以使用<strong>无穷大</strong>，<code>+inf、-inf</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LIMIT offset count</span><br></pre></td></tr></table></figure>
<p>和SQL中语法类似，offset是偏移量，count是最大允许的个数。</p>
<p>表示获取分数<strong>大于</strong>80分的从第<strong>2</strong>个人开始的3个人（不足3个就拉倒）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZRANGEBYSCORE student_score (80 +inf WITHSCORES LIMIT  1 3</span><br></pre></td></tr></table></figure>


<ul>
<li><p><strong>增加某个元素的分数</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZINCRBY key increment member</span><br></pre></td></tr></table></figure></li>
<li><p><strong>获得集合中元素的数量</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZCARD key</span><br></pre></td></tr></table></figure></li>
<li><p>获得指定<strong>分数范围内的元素个数</strong></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZCOUNT key min max</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>删除元素</strong><br>返回成功删除的元素个数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZREM member [member...]</span><br></pre></td></tr></table></figure></li>
<li><p>按照<strong>排名范围删除元素</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZREMRANGEBYRANK key start stop</span><br></pre></td></tr></table></figure></li>
<li><p>按照<strong>分数范围删除元素</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZREMRANGEBYSCORE key min max</span><br></pre></td></tr></table></figure></li>
<li><p>按<strong>元素的排名</strong><br>从0开始，从小到大获取元素的排名，最小元素的排名为0；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZRANK key member</span><br></pre></td></tr></table></figure></li>
<li><p><strong>有序集合的交集</strong><br>暂略。</p>
</li>
</ul>
<h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><blockquote>
<p>基数：一个数据集中不同元素的个数。<br>基数估计：估计一个数据集中不同元素的个数，但是允许有误差。</p>
</blockquote>
<h2 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h2><ul>
<li><p>HyperLogLog 是用来做<strong>基数统计</strong>的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。</p>
</li>
<li><p>在 Redis 里面，<strong>每个 HyperLogLog 键只需要花费 12 KB 内存</strong>，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p>
</li>
<li><p>但是，因为 HyperLogLog 只会<strong>根据输入元素来计算基数</strong>，而<strong>不会储存输入元素本身</strong>，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p>
</li>
</ul>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><ul>
<li>将多个元素添加进<strong>HyperLogLog</strong>,但是只是统计个数，不会保存数据本身。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PFADD key element [element ...]</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>返回数据集的基数<br>如果有多个key，会统计这些数据集的基数之和，但是注意<strong>不是简单的求和</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PFCOUNT key [key ...]</span><br></pre></td></tr></table></figure></li>
<li><p>将多个 HyperLogLog 合并为一个 HyperLogLog</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PFMERGE destkey sourcekey [sourcekey ...]</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Sandbox的安全机制</title>
    <url>/2021/12/10/Sandbox%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Sandbox的安全机制如何设计？"><a href="#Sandbox的安全机制如何设计？" class="headerlink" title="Sandbox的安全机制如何设计？"></a>Sandbox的安全机制如何设计？</h1><p>对于Linux而言，它的风格是一贯的。沙盒是进程而不是线程，这点非常明确。</p>
<h2 id="用户权限相关"><a href="#用户权限相关" class="headerlink" title="用户权限相关"></a>用户权限相关</h2><h3 id="Nobody-用户"><a href="#Nobody-用户" class="headerlink" title="Nobody 用户"></a>Nobody 用户</h3><p>在许多Unix系统与类Unix系统（如Linux）中，nobody是一个没有任何权限的用户。<br>该用户不拥有任何文件，也没有任何特殊权限。某些系统还会定义类似的用户组“nogroup”。<br>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @Author: 吉松阳</span></span><br><span class="line"><span class="comment"> * @Date: 2021/9/23</span></span><br><span class="line"><span class="comment"> * @Description: </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pwd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> *<span class="title">pw</span>;</span></span><br><span class="line">    <span class="keyword">char</span> *username = <span class="string">&quot;nobody&quot;</span>;</span><br><span class="line">    pw = getpwnam(username);</span><br><span class="line">    <span class="keyword">if</span> (!pw) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s is not exist\n&quot;</span>, username);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pw-&gt;pw_name = %s\n&quot;</span>, pw-&gt;pw_name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pw-&gt;pw_passwd = %s\n&quot;</span>, pw-&gt;pw_passwd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pw-&gt;pw_uid = %d\n&quot;</span>, pw-&gt;pw_uid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pw-&gt;pw_gid = %d\n&quot;</span>, pw-&gt;pw_gid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pw-&gt;pw_gecos = %s\n&quot;</span>, pw-&gt;pw_gecos);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pw-&gt;pw_dir = %s\n&quot;</span>, pw-&gt;pw_dir);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pw-&gt;pw_shell = %s\n&quot;</span>, pw-&gt;pw_shell);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是 MacOS Big Sur 上的 nobody 用户相关信息。<br>其中<code>/var/empty</code>表明它不拥有任何文件，<code>/usr/bin/false</code>表明它不能登录使用shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pw-&gt;pw_name &#x3D; nobody</span><br><span class="line">pw-&gt;pw_passwd &#x3D; *</span><br><span class="line">pw-&gt;pw_uid &#x3D; -2</span><br><span class="line">pw-&gt;pw_gid &#x3D; -2</span><br><span class="line">pw-&gt;pw_gecos &#x3D; Unprivileged User</span><br><span class="line">pw-&gt;pw_dir &#x3D; &#x2F;var&#x2F;empty</span><br><span class="line">pw-&gt;pw_shell &#x3D; &#x2F;usr&#x2F;bin&#x2F;false</span><br></pre></td></tr></table></figure>

<p>在运行oj用户的代码的时候，是以nobody的身份运行的，意味着它的权限非常有限，不能去执行那些危险的代码。</p>
<h3 id="root-用户"><a href="#root-用户" class="headerlink" title="root 用户"></a>root 用户</h3><p>root用户，即系统的管理员。<br>sandbox程序本身需要 root权限。<br>如何区分呢？<br>将上面的代码中的用户名替换成 root, 输出为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">pw-&gt;</span><span class="bash">pw_name = root</span></span><br><span class="line"><span class="meta">pw-&gt;</span><span class="bash">pw_passwd = *</span></span><br><span class="line"><span class="meta">pw-&gt;</span><span class="bash">pw_uid = 0</span></span><br><span class="line"><span class="meta">pw-&gt;</span><span class="bash">pw_gid = 0</span></span><br><span class="line"><span class="meta">pw-&gt;</span><span class="bash">pw_gecos = System Administrator</span></span><br><span class="line"><span class="meta">pw-&gt;</span><span class="bash">pw_dir = /var/root</span></span><br><span class="line"><span class="meta">pw-&gt;</span><span class="bash">pw_shell = /bin/sh</span></span><br></pre></td></tr></table></figure>
<p>发现uid、gid 均为 0。<br>于是在运行沙箱之前判定一下程序的执行者的uid、gid是不是 root 用户即可。</p>
<h2 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h2><h3 id="setuid-setgid"><a href="#setuid-setgid" class="headerlink" title="setuid/setgid"></a>setuid/setgid</h3><ul>
<li><p>background infomation<br>内核为每个进程维护的三个UID值。<br>这三个UID分别是实际用户ID(real uid)、有效用户ID(effective uid)、保存的设置用户ID(saved set-user ID)。<br>其中 real uid 指的是运行某程序的实际用户ID（登录shell的那个用户的uid）；<br>effective uid 指的是指当前进程是以哪个用户ID来运行的；<br>保存的设置用户ID就是有效用户ID的一个副本，与SUID权限有关。<br>一般情况下 real uid 和 effective uid 相同，但是使用<code>setuid</code>、<code>chmod +s</code>之后，二者就不一定相同了。</p>
</li>
<li><p><code>setuid</code>函数定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>函数说明：<br>+（1） 如果进程具有超级用户权限，那么 <code>setuid(uid_t uid)</code>会将三种 uid 全部设置成参数uid；<br> (启动sandbox其实就是要求以root身份启动的)</p>
<ul>
<li>(2) 如果 uid 等于 real uid 或者 saved set-user ID, 那么只把 effective uid 修改成 uid；</li>
<li>(3) 两种情况都不满组足，返回 -1 , errno被设置为 EPERM。</li>
</ul>
</li>
<li><p>返回值<br>执行成功则返回0； 失败则返回-1, 错误代码存于errno.</p>
</li>
<li><p>使用场景</p>
<ul>
<li>降低权限，比如在sandbox中通过让程序以 nobody 的身份来运行。</li>
<li>提高权限，但是最好注意在使用完 root 权限后建议马上执行setuid(getuid())，来抛弃root 权限，避免不必要的风险。</li>
</ul>
</li>
</ul>
<h3 id="setrlimit-getrlimit"><a href="#setrlimit-getrlimit" class="headerlink" title="setrlimit/getrlimit"></a>setrlimit/getrlimit</h3><ul>
<li>头文件:<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>函数说明:<br>获取或设定资源使用限制。<br>每种资源都有相关的软硬限制:<strong>软限制</strong>是内核强加给相应资源的限制值，<strong>硬限制</strong>是软限制的最大值。<br>非授权调用进程只可以将其软限制指定为0~硬限制范围中的某个值，同时能不可逆转地降低其硬限制。<br>授权进程可以任意改变其软硬限制。<br>RLIM_INFINITY的值表示不对资源限制。</li>
</ul>
<ul>
<li>函数定义<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getrlimit</span><span class="params">(<span class="keyword">int</span> resource, struct rlimit *rlim)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setrlimit</span><span class="params">(<span class="keyword">int</span> resource, <span class="keyword">const</span> struct rlimit *rlim)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>resource：可能的选择有</p>
<ul>
<li>RLIMIT_AS // 进程的最大虚内存空间，字节为单位。</li>
<li>RLIMIT_CORE // 内核转存文件的最大长度。</li>
<li>RLIMIT_CPU // 最大允许的CPU使用时间，秒为单位。当进程达到软限制，内核将给其发送<strong>SIGXCPU</strong>信号，这一信号的默认行为是终止进程的执行。<br>然而，可以捕捉信号，处理句柄可将控制返回给主程序。<br>如果进程继续耗费CPU时间，核心会以每秒一次的频率给其发送SIGXCPU信号。<br>如果达到硬限制，那时将给进程发送 SIGKILL信号终止其执行。</li>
<li>RLIMIT_DATA // 进程数据段的最大值。</li>
<li>RLIMIT_FSIZE // 进程可建立的文件的最大长度。如果进程试图超出这一限制时，核心会给其发送<strong>SIGXFSZ</strong>信号，默认情况下将终止进程的执行。</li>
<li>RLIMIT_LOCKS // 进程可建立的锁和租赁的最大值。</li>
<li>RLIMIT_MEMLOCK // 进程可锁定在内存中的最大数据量，字节为单位。</li>
<li>RLIMIT_MSGQUEUE // 进程可为POSIX消息队列分配的最大字节数。</li>
<li>RLIMIT_NICE // 进程可通过setpriority() 或 nice()调用设置的最大完美值。</li>
<li>RLIMIT_NOFILE // 指定比进程可打开的最大文件描述词大一的值，超出此值，将会产生EMFILE错误。</li>
<li>RLIMIT_NPROC // 用户可拥有的最大进程数。</li>
<li>RLIMIT_RTPRIO // 进程可通过sched_setscheduler 和 sched_setparam设置的最大实时优先级。</li>
<li>RLIMIT_SIGPENDING // 用户可拥有的最大挂起信号数。</li>
<li>RLIMIT_STACK // 最大的进程栈，以字节为单位。</li>
</ul>
<p>rlimit：描述资源软硬限制的结构体，原型如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> &#123;</span></span><br><span class="line">	<span class="keyword">rlim_t</span>  rlim_cur;               <span class="comment">/* current (soft) limit 软限制 */</span></span><br><span class="line">	<span class="keyword">rlim_t</span>  rlim_max;               <span class="comment">/* maximum value for rlim_cur 硬限制 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<ul>
<li>返回值<br><strong>成功执行时，返回 0 。失败返回 -1</strong> 。<br>errno被设为以下的某个值：<ul>
<li>EFAULT：rlim指针指向的空间不可访问</li>
<li>EINVAL：参数无效</li>
<li>EPERM：增加资源限制值时，权能不允许</li>
</ul>
</li>
</ul>
<ul>
<li>参考链接：<br><a href="https://man7.org/linux/man-pages/man2/getrlimit.2.html">getrlimit(2) — Linux manual page</a></li>
</ul>
<h1 id="seccomp"><a href="#seccomp" class="headerlink" title="seccomp"></a>seccomp</h1><h2 id="什么是seccomp"><a href="#什么是seccomp" class="headerlink" title="什么是seccomp"></a>什么是seccomp</h2><p>seccomp（全称 <strong>secure computing mode</strong>）是linux kernel从2.6.23版本开始所支持的一种安全机制。<br>seccomp是一种<strong>内核中的安全机制</strong>,正常情况下,程序可以使用所有的syscall,这是不安全的。<br>比如劫持程序流后通过execve的syscall来<code>getshell</code>。<br>通过seccomp我们可以在程序中禁用掉某些syscall,这样就算劫持了程序流也只能调用部分的syscall了.</p>
<p><strong>通过seccomp，我们限制程序使用某些系统调用，这样可以减少系统的暴露面，同时是程序进入一种“安全”的状态。</strong><br>详细介绍可参考seccomp内核文档(见参考链接)。</p>
<h2 id="如何使用seccomp"><a href="#如何使用seccomp" class="headerlink" title="如何使用seccomp"></a>如何使用seccomp</h2><p>seccomp可以通过系统调用ptrctl(2)或者通过系统调用seccomp(2)开启，前提是内核配置中开启了CONFIG_SECCOMP和CONFIG_SECCOMP_FILTER。</p>
<p>seccomp支持两种模式：<strong>SECCOMP_MODE_STRICT</strong> 和 <strong>SECCOMP_MODE_FILTER</strong>。</p>
<ul>
<li>在SECCOMP_MODE_STRICT模式下，进程不能使用<code>read(2)</code>、<code>write(2)</code>、<code>_exit(2)</code>和<code>sigreturn(2)</code>以外的其他系统调用。</li>
<li>在SECCOMP_MODE_FILTER模式下，可以利用BerkeleyPacket Filter配置哪些系统调用及它们的参数可以被进程使用。</li>
</ul>
<h2 id="如何查看是否使用了seccomp"><a href="#如何查看是否使用了seccomp" class="headerlink" title="如何查看是否使用了seccomp"></a>如何查看是否使用了seccomp</h2><p>通常有两种方法：<br>利用<code>prctl(2)</code>的PR_GET_SECCOMP的参数获取当前进程的seccomp状态。</p>
<ul>
<li>返回值0表示没有使用seccomp;</li>
<li>返回值2表示使用了seccomp并处于SECCOMP_MODE_FILTER模式； </li>
<li>其他情况进程会被SIGKILL信号杀死。</li>
</ul>
<p>从Linux3.8开始，可以利用/proc/$pid/status中的Seccomp字段查看。如果没有seccomp字段，说明内核不支持seccomp。</p>
<ul>
<li><p>举例:<br>查看mysql服务的seccomp的状态，发现并没有进入安全限制模式。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /proc/`pidof mysqld`/status</span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出</span></span><br><span class="line">Name:	mysqld</span><br><span class="line">......</span><br><span class="line">Seccomp:	0</span><br><span class="line">Seccomp_filters:	0</span><br></pre></td></tr></table></figure>
<p>在sandbox环境下执行 python3 脚本，<br>查看次进程的seccomp的状态，发现进程处于SECCOMP_MODE_FILTER模式 。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Name:	python3</span><br><span class="line">......</span><br><span class="line">Seccomp:	2</span><br><span class="line">Seccomp_filters:	1</span><br></pre></td></tr></table></figure></li>
<li><p>代码示例<br>使用 <code>syscall</code> 调用 execve，如果没有安全限制的话，会正常进入 shell</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;seccomp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    scmp_filter_ctx ctx; <span class="comment">// scmp 过滤上下文</span></span><br><span class="line">    ctx = seccomp_init(SCMP_ACT_ALLOW); <span class="comment">// 初始化过滤状态为允许所有系统调用</span></span><br><span class="line">    seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), <span class="number">0</span>); <span class="comment">// 添加需要限制的系统调用</span></span><br><span class="line">    seccomp_load(ctx); <span class="comment">// 装载上下文</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *filename = <span class="string">&quot;/bin/sh&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> *argv[] = &#123;<span class="string">&quot;/bin/sh&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> *envp[] = &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line">    syscall(SYS_execve, filename, argv, envp); <span class="comment">// execve</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -o ban ban.c -l seccomp</span><br><span class="line"><span class="meta">#</span><span class="bash"> 须先实现安装</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> sudo apt install libseccomp-dev libseccomp2 seccomp</span></span><br></pre></td></tr></table></figure>
<p>运行程序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">songyangji@SongyangJi-Ubuntu-DeskStop:~/桌面$ ./ban</span><br><span class="line">错误的系统调用 (核心已转储) # Bad system call (core dumped)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="api-rule"><a href="#api-rule" class="headerlink" title="api rule"></a>api rule</h2><h3 id="SCMP-SYS"><a href="#SCMP-SYS" class="headerlink" title="SCMP_SYS"></a>SCMP_SYS</h3><p>根据系统调用名获取系统调用号，虽然你可以直接使用 <code>__NR_syscall</code> 直接指定，但是为了跨平台最好使用它获取。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SCMP_SYS</span><span class="params">(syscall_name)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="scmp-filter-ctx"><a href="#scmp-filter-ctx" class="headerlink" title="scmp_filter_ctx"></a>scmp_filter_ctx</h3><p>结构体定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> * scmp_filter_ctx;</span><br></pre></td></tr></table></figure>
<p>seccmp的过滤器上下文，保存、传递了我们传入的系统调用过滤条件。</p>
<h3 id="seccomp-init"><a href="#seccomp-init" class="headerlink" title="seccomp_init"></a>seccomp_init</h3><ul>
<li><p>函数说明:<br>seccomp_init的作用就是初始化 scmp_filter_ctx结构。<br>需要注意的是，任何其他libseccomp中的函数调用，必须在seccomp_init之后。</p>
</li>
<li><p>函数定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">scmp_filter_ctx <span class="title">seccomp_init</span><span class="params">(<span class="keyword">uint32_t</span> def_action)</span></span>; </span><br></pre></td></tr></table></figure></li>
<li><p>返回值<br>成功返回scmp_filter_ctx（过滤器上下文） ctx；<br>失败返回NULL</p>
</li>
<li><p>参数说明<br>def_action用于指定默认行为，有效动作值如下：（当线程调用了<code>seccomp</code>过滤规则中没有相关配置规则的系统调用时触发）</p>
<ul>
<li>SCMP_ACT_KILL<br>线程将会被内核以SIGSYS信号终止；</li>
<li>SCMP_ACT_KILL_PROCESS<br>整个进程被终止；</li>
<li>SCMP_ACT_TRAP<br>线程将会抛出一个SIGSYS信号；</li>
<li>SCMP_ACT_ERRNO(uint16_t errno)<br>线程调用与筛选规则匹配的系统调用时，它将收到一个errno的返回值；</li>
<li>SCMP_ACT_TRACE(uint16_t msg_num)<br>略</li>
<li>SCMP_ACT_LOG<br>不会对调用系统调用的线程产生任何影响，但系统调用会被记录到日志。</li>
<li>SCMP_ACT_ALLOW<br>不会对调用系统调用的线程产生任何影响。</li>
</ul>
</li>
</ul>
<h3 id="seccomp-rule-addXXX"><a href="#seccomp-rule-addXXX" class="headerlink" title="seccomp_rule_addXXX"></a>seccomp_rule_addXXX</h3><h4 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明:"></a>函数说明:</h4><p>  这个函数组都会向当前seccomp过滤器添加新的过滤规则。</p>
<blockquote>
<p>调用应用程序提供的所有过滤器规则被组合成一个联合，并带有额外的逻辑来消除冗余的系统调用过滤器。<br>例如，如果添加了一条规则，该规则允许给定的系统调用具有一组特定的参数值，<br>然后又添加了一条规则，该规则允许相同的系统调用而不管参数值如何，<br>那么第一个更具体的规则将有效地从过滤器中删除第二个更通用的规则。</p>
</blockquote>
<h4 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seccomp_rule_add</span><span class="params">(scmp_filter_ctx ctx, <span class="keyword">uint32_t</span> action,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> syscall, <span class="keyword">unsigned</span> <span class="keyword">int</span> arg_cnt, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seccomp_rule_add_exact</span><span class="params">(scmp_filter_ctx ctx, <span class="keyword">uint32_t</span> action,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int</span> syscall, <span class="keyword">unsigned</span> <span class="keyword">int</span> arg_cnt, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seccomp_rule_add_array</span><span class="params">(scmp_filter_ctx ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">uint32_t</span> action, <span class="keyword">int</span> syscall,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">unsigned</span> <span class="keyword">int</span> arg_cnt,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">const</span> struct scmp_arg_cmp *arg_array)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seccomp_rule_add_exact_array</span><span class="params">(scmp_filter_ctx ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">uint32_t</span> action, <span class="keyword">int</span> syscall,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">unsigned</span> <span class="keyword">int</span> arg_cnt,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">const</span> struct scmp_arg_cmp *arg_array)</span></span>;</span><br></pre></td></tr></table></figure>


<h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><ul>
<li><ol>
<li>action有效动作值如下：（当线程调用了<code>seccomp</code>过滤规则中有相关配置规则的系统调用时触发）</li>
</ol>
<ul>
<li>SCMP_ACT_KILL<br>线程将会被内核终止；</li>
<li>SCMP_ACT_KILL_PROCESS<br>整个进程被终止；</li>
<li>SCMP_ACT_TRAP<br>线程将会抛出一个SIGSYS信号；</li>
<li>SCMP_ACT_ERRNO(uint16_t errno)<br>线程调用与筛选规则匹配的系统调用时，它将收到一个errno的返回值；</li>
<li>SCMP_ACT_TRACE(uint16_t msg_num)<br>略</li>
<li>SCMP_ACT_LOG<br>会对调用系统调用的线程产生任何影响，但系统调用会被记录到日志。</li>
<li>SCMP_ACT_ALLOW<br>不会对调用系统调用的线程产生任何影响（也就是允许调用这个system call）。</li>
<li>SCMP_ACT_NOTIFY<br>略</li>
</ul>
</li>
<li><ol start="2">
<li>arg_cnt 指定规则配置的系统调用的参数的匹配情况的个数（因为后面是一个变长数组）</li>
</ol>
</li>
<li><ol start="3">
<li>边长数组的元素是 <code>scmp_arg_cmp</code> 结构体，定义如下。</li>
</ol>
</li>
</ul>
<p>系统调用的参数比较规则相关定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Comparison operators</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">scmp_compare</span> &#123;</span></span><br><span class="line">	_SCMP_CMP_MIN = <span class="number">0</span>,</span><br><span class="line">	SCMP_CMP_NE = <span class="number">1</span>,		<span class="comment">/**&lt; not equal */</span></span><br><span class="line">	SCMP_CMP_LT = <span class="number">2</span>,		<span class="comment">/**&lt; less than */</span></span><br><span class="line">	SCMP_CMP_LE = <span class="number">3</span>,		<span class="comment">/**&lt; less than or equal */</span></span><br><span class="line">	SCMP_CMP_EQ = <span class="number">4</span>,		<span class="comment">/**&lt; equal */</span></span><br><span class="line">	SCMP_CMP_GE = <span class="number">5</span>,		<span class="comment">/**&lt; greater than or equal */</span></span><br><span class="line">	SCMP_CMP_GT = <span class="number">6</span>,		<span class="comment">/**&lt; greater than */</span></span><br><span class="line">	SCMP_CMP_MASKED_EQ = <span class="number">7</span>,		<span class="comment">/**&lt; masked equality */</span></span><br><span class="line">	_SCMP_CMP_MAX,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Argument datum</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint64_t</span> <span class="keyword">scmp_datum_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Argument / Value comparison definition</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scmp_arg_cmp</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> arg;	<span class="comment">/**&lt; argument number, starting at 0 */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">scmp_compare</span> <span class="title">op</span>;</span>	<span class="comment">/**&lt; the comparison op, e.g. SCMP_CMP_* */</span></span><br><span class="line">	<span class="keyword">scmp_datum_t</span> datum_a;</span><br><span class="line">	<span class="keyword">scmp_datum_t</span> datum_b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有效比较操作值（ op ）如下：</p>
<ul>
<li><p>SCMP_CMP_NE<br>参数值不等于基准值时匹配，例如：<br>SCMP_CMP( arg , SCMP_CMP_NE , datum )</p>
</li>
<li><p>SCMP_CMP_LT<br>参数值小于基准值时匹配，例如：<br>SCMP_CMP( arg , SCMP_CMP_LT , datum )</p>
</li>
<li><p>SCMP_CMP_LE<br>参数值小于或等于基准值时匹配，例如：<br>SCMP_CMP( arg , SCMP_CMP_LE , datum )</p>
</li>
<li><p>SCMP_CMP_EQ<br>参数值等于基准值时匹配，例如：<br>SCMP_CMP( arg , SCMP_CMP_EQ , datum )</p>
</li>
<li><p>SCMP_CMP_GE<br>参数值大于或等于基准值时匹配，例如：<br>SCMP_CMP( arg , SCMP_CMP_GE , datum )</p>
</li>
<li><p>SCMP_CMP_GT<br>参数值大于基准值时匹配，例如：<br>SCMP_CMP( arg , SCMP_CMP_GT , datum )</p>
</li>
<li><p>SCMP_CMP_MASKED_EQ<br>当掩码参数值等于掩码基准值时匹配，例如：<br>SCMP_CMP( arg , SCMP_CMP_MASKED_EQ , mask , datum )</p>
</li>
</ul>
<p>注意，scmp_arg_cmp 此结构不能直接生成，需要调用它提供的宏生成，有如下宏：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct scmp_arg_cmp <span class="title">SCMP_CMP</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> arg,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">enum</span> scmp_compare op, ...)</span></span>;</span><br><span class="line">       <span class="function">struct scmp_arg_cmp <span class="title">SCMP_A0</span><span class="params">(<span class="keyword">enum</span> scmp_compare op, ...)</span></span>;</span><br><span class="line">       <span class="function">struct scmp_arg_cmp <span class="title">SCMP_A1</span><span class="params">(<span class="keyword">enum</span> scmp_compare op, ...)</span></span>;</span><br><span class="line">       <span class="function">struct scmp_arg_cmp <span class="title">SCMP_A2</span><span class="params">(<span class="keyword">enum</span> scmp_compare op, ...)</span></span>;</span><br><span class="line">       <span class="function">struct scmp_arg_cmp <span class="title">SCMP_A3</span><span class="params">(<span class="keyword">enum</span> scmp_compare op, ...)</span></span>;</span><br><span class="line">       <span class="function">struct scmp_arg_cmp <span class="title">SCMP_A4</span><span class="params">(<span class="keyword">enum</span> scmp_compare op, ...)</span></span>;</span><br><span class="line">       <span class="function">struct scmp_arg_cmp <span class="title">SCMP_A5</span><span class="params">(<span class="keyword">enum</span> scmp_compare op, ...)</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="function">struct scmp_arg_cmp <span class="title">SCMP_CMP64</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> arg,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">enum</span> scmp_compare op, ...)</span></span>;</span><br><span class="line">       <span class="function">struct scmp_arg_cmp <span class="title">SCMP_A0_64</span><span class="params">(<span class="keyword">enum</span> scmp_compare op, ...)</span></span>;</span><br><span class="line">       <span class="function">struct scmp_arg_cmp <span class="title">SCMP_A1_64</span><span class="params">(<span class="keyword">enum</span> scmp_compare op, ...)</span></span>;</span><br><span class="line">       <span class="function">struct scmp_arg_cmp <span class="title">SCMP_A2_64</span><span class="params">(<span class="keyword">enum</span> scmp_compare op, ...)</span></span>;</span><br><span class="line">       <span class="function">struct scmp_arg_cmp <span class="title">SCMP_A3_64</span><span class="params">(<span class="keyword">enum</span> scmp_compare op, ...)</span></span>;</span><br><span class="line">       <span class="function">struct scmp_arg_cmp <span class="title">SCMP_A4_64</span><span class="params">(<span class="keyword">enum</span> scmp_compare op, ...)</span></span>;</span><br><span class="line">       <span class="function">struct scmp_arg_cmp <span class="title">SCMP_A5_64</span><span class="params">(<span class="keyword">enum</span> scmp_compare op, ...)</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="function">struct scmp_arg_cmp <span class="title">SCMP_CMP32</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> arg,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">enum</span> scmp_compare op, ...)</span></span>;</span><br><span class="line">       <span class="function">struct scmp_arg_cmp <span class="title">SCMP_A0_32</span><span class="params">(<span class="keyword">enum</span> scmp_compare op, ...)</span></span>;</span><br><span class="line">       <span class="function">struct scmp_arg_cmp <span class="title">SCMP_A1_32</span><span class="params">(<span class="keyword">enum</span> scmp_compare op, ...)</span></span>;</span><br><span class="line">       <span class="function">struct scmp_arg_cmp <span class="title">SCMP_A2_32</span><span class="params">(<span class="keyword">enum</span> scmp_compare op, ...)</span></span>;</span><br><span class="line">       <span class="function">struct scmp_arg_cmp <span class="title">SCMP_A3_32</span><span class="params">(<span class="keyword">enum</span> scmp_compare op, ...)</span></span>;</span><br><span class="line">       <span class="function">struct scmp_arg_cmp <span class="title">SCMP_A4_32</span><span class="params">(<span class="keyword">enum</span> scmp_compare op, ...)</span></span>;</span><br><span class="line">       <span class="function">struct scmp_arg_cmp <span class="title">SCMP_A5_32</span><span class="params">(<span class="keyword">enum</span> scmp_compare op, ...)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>解释一下上面的这么多宏的功能分类依据，A{0-5}中的0、1、2、3、4、5用于指定系统调用的那个参数，<br>32还是64自然是指定32位机器还是64位机器，<br>SCMP_CMP的第一个参数<code>unsigned int arg</code>的功能就是<code>A&#123;$arg_num&#125;</code>中的<code>$arg_num</code>，<br>所有宏的第一个参数<code>op</code>就是用于指定比较的规则，如上已经介绍过。</p>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>函数成功时返回零；<br>失败时返回负的errno值。</p>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><ol>
<li><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(open), <span class="number">1</span>, SCMP_CMP(<span class="number">1</span>, SCMP_CMP_MASKED_EQ, O_WRONLY | O_RDWR, <span class="number">0</span>))</span><br></pre></td></tr></table></figure>
指定<code>open(const *path, int oflags)</code>系统调用的<code>oflags</code>参数如果既没有O_WRONLY，也没有O_RDWR（二进制对应位），就是允许的，<br>换言之这条规则禁用掉了 open的 w、rw。</li>
</ol>
<h3 id="seccomp-load"><a href="#seccomp-load" class="headerlink" title="seccomp_load"></a>seccomp_load</h3><ul>
<li>函数说明:<br>将ctx提供的seccomp过滤器加载到内核中；<br>如果函数成功，新的 seccomp 过滤器将在函数返回时处于活动状态</li>
</ul>
<ul>
<li><p>函数定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seccomp_load</span><span class="params">(scmp_filter_ctx ctx)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>返回值<br>成功时返回0，失败时返回以下错误码：<br>-ECANCELED<br>  There was a system failure beyond the control of the<br>library.<br>-EFAULT<br>  Internal libseccomp failure.<br>-EINVAL<br>  Invalid input, either the context or architecture token is invalid.<br>-ENOMEM<br>  The library was unable to allocate enough memory.<br>-ESRCH<br>  Unable to load the filter due to thread issues.</p>
</li>
</ul>
<h3 id="seccomp-release-3"><a href="#seccomp-release-3" class="headerlink" title="seccomp_release(3)"></a>seccomp_release(3)</h3><ul>
<li><p>函数说明:<br>释放ctx 中的 seccomp 过滤器结构的内存，该过滤器首先由seccomp_init(3)或seccomp_reset(3)初始化，<br>并释放与给定 seccomp 过滤器上下文关联的任何内存。<br>加载到内核中的任何 seccomp过滤器不受影响。</p>
</li>
<li><p>函数定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">seccomp_release</span><span class="params">(scmp_filter_ctx ctx)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p>  <a href="https://www.kernel.org/doc/Documentation/prctl/seccomp_filter.txt">Secure Computing with filters</a><br>  <a href="https://man7.org/linux/man-pages/man3/seccomp_init.3.html">seccomp_init(3)</a><br>  <a href="https://man7.org/linux/man-pages/man3/seccomp_rule_add.3.html">seccomp_rule_add(3)</a><br>  <a href="https://man7.org/linux/man-pages/man3/seccomp_load.3.html">seccomp_load(3)</a><br>  <a href="https://man7.org/linux/man-pages/man3/seccomp_release.3.html">seccomp_release(3)</a></p>
]]></content>
      <categories>
        <category>sandbox</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>安全</tag>
        <tag>sandbox</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis高可用</title>
    <url>/2021/12/09/Redis%E9%AB%98%E5%8F%AF%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在介绍哨兵之前，首先从宏观角度回顾一下Redis实现高可用相关的技术。它们包括：持久化、复制、哨兵和集群，其主要作用和解决的问题是：</p>
<ul>
<li>持久化：持久化是最简单的高可用方法(有时甚至不被归为高可用的手段)，主要作用是数据备份，即将数据存储在硬盘，保证数据不会因进程退出而丢失。</li>
<li>复制：复制是高可用Redis的基础，哨兵和集群都是在复制基础上实现高可用的。复制主要实现了数据的多机备份，以及对于读操作的负载均衡和简单的故障恢复。缺陷：故障恢复无法自动化；写操作无法负载均衡；存储能力受到单机的限制。</li>
<li>哨兵：在复制的基础上，哨兵实现了自动化的故障恢复。缺陷：写操作无法负载均衡；存储能力受到单机的限制。</li>
<li>集群：通过集群，Redis解决了写操作无法负载均衡，以及存储能力受到单机限制的问题，实现了较为完善的高可用方案。</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
        <tag>Redis</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 学习笔记1  ——  IOC容器 I （IOC容器、DI依赖注入）</title>
    <url>/2021/07/01/Spring%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%20%20%E2%80%94%E2%80%94%20%20IOC%E5%AE%B9%E5%99%A8%20I%20%EF%BC%88IOC%E5%AE%B9%E5%99%A8%E3%80%81DI%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>这里我做的这份笔记的意义仅仅是记录下自己学习Spring的历程，既不是对官方API的深入解释，也不一定是对新手友好的、知识点详尽的一份学习清单。</p>
</blockquote>
<h1 id="1-Spring-IoC容器和Bean简介"><a href="#1-Spring-IoC容器和Bean简介" class="headerlink" title="1 Spring IoC容器和Bean简介"></a>1 Spring IoC容器和Bean简介</h1><h2 id="1-1-了解IOC"><a href="#1-1-了解IOC" class="headerlink" title="1.1 了解IOC"></a>1.1 了解IOC</h2><h3 id="1-1-1-Bean"><a href="#1-1-1-Bean" class="headerlink" title="1.1.1 Bean"></a>1.1.1 Bean</h3><p>什么是<strong>Bean</strong>?</p>
<blockquote>
<p>在Spring中，构成应用程序主干并由Spring IoC容器管理的对象称为bean。Bean是由Spring<br>IoC容器<strong>实例化</strong>，<strong>组装</strong>和<strong>管理</strong>的对象。</p>
</blockquote>
<p>显然这里的Bean并不只是那些<strong>实体类</strong>，即<strong>POJO</strong>。这里的Bean包含了所有的由Spring托管的Java类的实例！</p>
<blockquote>
<p>Bean及其之间的<strong>依赖关系</strong>反映在容器使用的<strong>配置元数据</strong>（Configuration Metadata）中。</p>
</blockquote>
<p>这里的配置元数据往往用<code>.xml</code>文件或者Java<strong>注解</strong> (<code>annotation</code>)实现。我们马上就能看到具体的例子。</p>
<h3 id="1-1-2-IOC容器"><a href="#1-1-2-IOC容器" class="headerlink" title="1.1.2 IOC容器"></a>1.1.2 IOC容器</h3><p>帮助我们管理Java对象的容器就称为Spring IOC 容器。</p>
<blockquote>
<p>在<code>org.springframework.beans</code>和<code>org.springframework.context</code>包是Spring框架的IoC容器的基础</p>
</blockquote>
<ul>
<li>它们的maven依赖为<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="1-2-容器概述"><a href="#1-2-容器概述" class="headerlink" title="1.2 容器概述"></a>1.2 容器概述</h2><blockquote>
<p><code>org.springframework.context.ApplicationContext</code>接口代表Spring IoC容器，并负责实例化，配置和组装Bean。<br>容器通过读取配置元数据获取有关要实例化，配置和组装哪些对象的指令。配置元数据以XML，Java批注或Java代码表示。</p>
</blockquote>
<p>注意<code>ApplicationContext</code>是一个<strong>接口</strong>，通常创建<code>ClassPathXmlApplicationContext</code> 或的实例 <code>FileSystemXmlApplicationContext</code>（顾名思义，一个通过类路径，一个通过系统文件名）。</p>
<h3 id="1-2-1-配置元数据"><a href="#1-2-1-配置元数据" class="headerlink" title="1.2.1 配置元数据"></a>1.2.1 配置元数据</h3><blockquote>
<p>Spring IoC容器使用一种形式的配置元数据。此配置元数据表示您作为应用程序开发人员如何告诉Spring容器在应用程序中实例化，配置和组装对象。</p>
</blockquote>
<p>这里<strong>元数据Meta data</strong>实际上就是表明对象如何创建，如何组装，如何管理。（否则Spring怎么按照我们的意愿创建出我们想要的对象？）。</p>
<ul>
<li><p>配置的形式</p>
<ul>
<li><p><strong>XML</strong></p>
<p>  这也是最传统的方式，也就是所谓的XML配Bean的方式</p>
</li>
<li><p><strong>注解</strong>（annotation）<br>基于注释的配置：Spring 2.5引入了对基于注释的配置元数据的支持。</p>
</li>
<li><p><strong>基于Java的配置</strong><br>  (这个从Spring3.0开始支持)</p>
</li>
</ul>
</li>
</ul>
<p>基于注解和Java的配置算是Spring后期发展的产物，这里我们就以最传统的XML为例。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- more bean definitions go here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中<code>id</code>是定义单个Bean的唯一唯一表示，<code>class</code>要使用<strong>全限定名</strong>（除非用到后面的<strong>别名</strong>）。</p>
<h3 id="1-2-2-实例化容器"><a href="#1-2-2-实例化容器" class="headerlink" title="1.2.2 实例化容器"></a>1.2.2 实例化容器</h3><p>为了学习笔记的精简化，完整的代码不在这里提供，具体代码可参见 <a href="https://song-yang-ji.blog.csdn.net/article/details/109662902">这篇博客</a>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;beans.xml&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="1-2-3-使用容器"><a href="#1-2-3-使用容器" class="headerlink" title="1.2.3  使用容器"></a>1.2.3  使用容器</h3><p>我们可以使用<code>ApplicationContext</code>来访问有IOC容器托管的对象。</p>
<ul>
<li><p>方式1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">T <span class="title">getBean</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">User user </span>= (User)applicationContext.getBean(<span class="string">&quot;user&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>方式2</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span></span></span><br><span class="line"><span class="function">User user </span>= applicationContext.getBean(<span class="string">&quot;user&quot;</span>,User.class);</span><br></pre></td></tr></table></figure>

<p>总结，方式一使用<strong>类型强制转换</strong>，方式二使用类型做参数，错误可以在编译时期发现，更好。</p>
<h2 id="1-3-Bean"><a href="#1-3-Bean" class="headerlink" title="1.3 Bean"></a>1.3 Bean</h2><h3 id="1-3-1-Bean-的命名"><a href="#1-3-1-Bean-的命名" class="headerlink" title="1.3.1 Bean 的命名"></a>1.3.1 Bean 的命名</h3><ul>
<li><p><strong>命名约定</strong><br>使用<strong>驼峰式命名</strong>，如<code>accountManager， accountService，userDao，loginController</code>。</p>
</li>
<li><p>Bean 的标识</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user2,user3,user4&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.jsy.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;JSY&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用<code>id</code>来唯一标识bean，<code>name</code>是别名,可以有多个。<code>@Bean</code><br>注解也可以提供别名。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user2,user3,user4&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.jsy.pojo.User&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>不提供名称</strong><br>为什么允许这样做，可以猜想就类似于匿名内部类一样，无需提供名称。<br>这和后面的<strong>自动装配</strong>有关。</li>
</ul>
<h3 id="1-3-2-Bean-的实例化"><a href="#1-3-2-Bean-的实例化" class="headerlink" title="1.3.2 Bean 的实例化"></a>1.3.2 Bean 的实例化</h3><p><del>这部分和类的初始化相关，暂且不谈</del> </p>
<h2 id="1-4-依赖（Dependencies）"><a href="#1-4-依赖（Dependencies）" class="headerlink" title="1.4 依赖（Dependencies）"></a>1.4 依赖（Dependencies）</h2><blockquote>
<p>典型的企业应用程序不包含单个对象（或Spring术语中的bean）。即使是最简单的应用程序，也有一些对象可以协同工作，以呈现最终用户视为一致的应用程序。</p>
</blockquote>
<p>简单的说，就是对象的构成很多时候是依赖其他多个对象的。比如， <code>Zoo</code>实例依赖<code>Tiger</code>，<code>Lion</code>实例;<code>UserService</code>实例依赖<code>UserDao</code>或者<code>UserMapper</code>实例。</p>
<blockquote>
<p>使用DI原理，代码更加简洁，当为对象提供依赖项时，去耦会更有效。该对象不查找其依赖项，并且不知道依赖项的位置或类。</p>
</blockquote>
<p>也就是，程序员不在负责对象的创建和组装，而仅仅负责对象的提供，创建及组装（DI)由Spring 完成。</p>
<p>综上， <strong>DI</strong>实际上是实现<strong>IOC</strong>的一种措施。</p>
<h3 id="1-4-1-依赖注入"><a href="#1-4-1-依赖注入" class="headerlink" title="1.4.1 依赖注入"></a>1.4.1 依赖注入</h3><h4 id="1-4-1-1-Constructor-注入"><a href="#1-4-1-1-Constructor-注入" class="headerlink" title="1.4.1.1 Constructor 注入"></a>1.4.1.1 Constructor 注入</h4><p>实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jsy.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zoo</span> </span>&#123;</span><br><span class="line">    Tiger tiger;</span><br><span class="line">    Lion lion;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Zoo</span><span class="params">(Tiger tiger, Lion lion)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tiger = tiger;</span><br><span class="line">        <span class="keyword">this</span>.lion = lion;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;zoo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.jsy.pojo.Zoo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;lion&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;tiger&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;lion&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.jsy.pojo.Lion&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;tiger&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.jsy.pojo.Tiger&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>构造函数参数解析匹配通过使用<strong>参数的类型</strong>进行</li>
</ul>
<p>上述的例子中<code>Lion</code> 、<code>Tiger</code>类不是通过继承关联的，则不存在潜在的歧义，配置生效，</p>
<p>（<del>以下的例子来自官方</del>）</p>
<ul>
<li><strong>type</strong> 属性</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;int&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7500000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;42&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>index</strong> 属性</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;int&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7500000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;42&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>name</strong> 属性</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;years&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7500000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;ultimateAnswer&quot;</span> <span class="attr">value</span>=<span class="string">&quot;42&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h4 id="1-4-1-2-Setter-注入"><a href="#1-4-1-2-Setter-注入" class="headerlink" title="1.4.1.2 Setter 注入"></a>1.4.1.2 Setter 注入</h4><blockquote>
<p>基于设置器的DI是通过在调用无参数构造函数或无参数static工厂方法以实例化您的bean之后，在您的bean上调用setter方法来完成的。</p>
</blockquote>
<ul>
<li>必须具有无参构造器</li>
<li>必须有set函数，函数名为 set+属性名（首字母大写）</li>
</ul>
<h4 id="1-4-1-3-Factory方法注入"><a href="#1-4-1-3-Factory方法注入" class="headerlink" title="1.4.1.3 Factory方法注入"></a>1.4.1.3 Factory方法注入</h4><p>这种方法与上述两种原理是一致的，区别不大。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a private constructor</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ExampleBean</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a static factory method; the arguments to this method can be</span></span><br><span class="line">    <span class="comment">// considered the dependencies of the bean that is returned,</span></span><br><span class="line">    <span class="comment">// regardless of how those arguments are actually used.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExampleBean <span class="title">createInstance</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExampleBean eb = <span class="keyword">new</span> ExampleBean (...);</span><br><span class="line">        <span class="comment">// some other operations...</span></span><br><span class="line">        <span class="keyword">return</span> eb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;createInstance&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;anotherExampleBean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;yetAnotherBean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;anotherExampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.AnotherBean&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;yetAnotherBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.YetAnotherBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>实例（非静态）工厂方法可以以基本上相同的方式使用（除了使用factory-bean属性代替使用class属性外）</p>
</blockquote>
<h4 id="1-4-1-4-循环依赖问题"><a href="#1-4-1-4-循环依赖问题" class="headerlink" title="1.4.1.4 循环依赖问题"></a>1.4.1.4 循环依赖问题</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jsy.pojo;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    B b;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setB</span><span class="params">(B b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.jsy.pojo;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用构造函数注入，则可能会创建无法解决的循环依赖方案<br>一种可能的解决方案是编辑某些类的源代码，这些类的源代码由设置者而不是构造函数来配置。或者，避免构造函数注入，而仅使用setter注入。换句话说，尽管不建议这样做，但是您可以使用setter注入配置循环依赖关系。</p>
</blockquote>
<p>简单的说，如果出现<strong>循环依赖</strong>，必须使用<strong>setter</strong>注入。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;a&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.jsy.pojo.A&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;b&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;b&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;b&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.jsy.pojo.B&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;a&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;a&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="1-4-2-依赖注入的细节"><a href="#1-4-2-依赖注入的细节" class="headerlink" title="1.4.2 依赖注入的细节"></a>1.4.2 依赖注入的细节</h3><p><strong>setter</strong>注入使用<code>&lt;property/&gt;</code><br><strong>constructor</strong> 注入使用<code>&lt;constructor-arg/&gt;元素</code> </p>
<p>下面主要是<strong>setter</strong>注入解释。</p>
<h4 id="1-4-2-1-真值注入"><a href="#1-4-2-1-真值注入" class="headerlink" title="1.4.2.1 真值注入"></a>1.4.2.1 真值注入</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.jsy.pojo.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Mike&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="1-4-2-2-Bean注入"><a href="#1-4-2-2-Bean注入" class="headerlink" title="1.4.2.2 Bean注入"></a>1.4.2.2 Bean注入</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;zoo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.jsy.pojo.Zoo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;lion&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;lion&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;tiger&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;tiger&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="1-4-2-3-空串和NULL"><a href="#1-4-2-3-空串和NULL" class="headerlink" title="1.4.2.3 空串和NULL"></a>1.4.2.3 空串和NULL</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">null</span>/&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>下面的例子来自Kuangshen.</p>
</blockquote>
<h4 id="1-4-2-4-数组注入"><a href="#1-4-2-4-数组注入" class="headerlink" title="1.4.2.4 数组注入"></a>1.4.2.4 数组注入</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;小明&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;addr&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;books&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>西游记<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>红楼梦<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>水浒传<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="1-4-2-5-List注入"><a href="#1-4-2-5-List注入" class="headerlink" title="1.4.2.5 List注入"></a>1.4.2.5 List注入</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hobbys&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">value</span>&gt;</span>听歌<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">value</span>&gt;</span>看电影<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">value</span>&gt;</span>爬山<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h4 id="1-4-2-6-Map注入"><a href="#1-4-2-6-Map注入" class="headerlink" title="1.4.2.6 Map注入"></a>1.4.2.6 Map注入</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;card&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;中国邮政&quot;</span> <span class="attr">value</span>=<span class="string">&quot;456456456465456&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;建设&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1456682255511&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="1-4-2-7-Set注入"><a href="#1-4-2-7-Set注入" class="headerlink" title="1.4.2.7 Set注入"></a>1.4.2.7 Set注入</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;games&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">value</span>&gt;</span>LOL<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">value</span>&gt;</span>BOB<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">value</span>&gt;</span>COC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h4 id="1-4-2-8-Properties注入"><a href="#1-4-2-8-Properties注入" class="headerlink" title="1.4.2.8 Properties注入"></a>1.4.2.8 Properties注入</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;学号&quot;</span>&gt;</span>20190604<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;性别&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;姓名&quot;</span>&gt;</span>小明<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="1-4-2-9-p-命名空间与c-命名空间"><a href="#1-4-2-9-p-命名空间与c-命名空间" class="headerlink" title="1.4.2.9 p-命名空间与c-命名空间"></a>1.4.2.9 p-命名空间与c-命名空间</h4><ul>
<li>p-空间<br>依赖于<code>setter</code>方法的依赖注入<br>在头文件中导入约束xml名称空间 : xmlns:p=<a href="http://www.springframework.org/schema/p">传送门</a><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--P(属性: properties)命名空间 , 属性依然要设置set方法, 无参构造器仍然要有--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.jsy.pojo.User&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;jsy&quot;</span> <span class="attr">p:spouse-ref</span>=<span class="string">&quot;address&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>注意对于bean的注入必须在字段名后面加上<code>-ref</code>，否则bean初始化出错。</p>
<ul>
<li>c-空间<br>依赖于<strong>构造函数</strong>;<br>须导入名称空间：xmlns:c=[传送门](<a href="http://www.springframework.org/schema/c%EF%BC%89">http://www.springframework.org/schema/c）</a><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--C(构造: Constructor)命名空间&gt;</span></span><br><span class="line"><span class="comment">&lt;bean id=&quot;user&quot; class=&quot;com.jsy.pojo.User&quot; c:name=&quot;jsy&quot; c:age=&quot;18&quot;/&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="1-4-2-10-复合属性名称"><a href="#1-4-2-10-复合属性名称" class="headerlink" title="1.4.2.10 复合属性名称"></a>1.4.2.10 复合属性名称</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;something&quot;</span> <span class="attr">class</span>=<span class="string">&quot;things.ThingOne&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;fred.bob.sammy&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>相当于一直递归地设置属性。</p>
<h3 id="1-4-3-depends-on"><a href="#1-4-3-depends-on" class="headerlink" title="1.4.3 depends-on"></a>1.4.3 depends-on</h3><p><strong>bean</strong>的依赖关系除了使用 <code>&lt;ref&gt;</code>元素表示之外，<br>可以显示的使用<code>depends-on</code>属性：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beanOne&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ExampleBean&quot;</span> <span class="attr">depends-on</span>=<span class="string">&quot;manager,accountDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;manager&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;manager&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;manager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ManagerBean&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.jdbc.JdbcAccountDao&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>有时bean之间的依赖关系不太直接。<br>也就是说，一个bean没有直接使用另一个bean，这个时候如果好像配置这种依赖关系，就要使用depends-on了。<br>使用它，可以强制指定bean的初始化顺序以及销毁顺序。</p>
<h3 id="1-4-4-Bean的懒加载"><a href="#1-4-4-Bean的懒加载" class="headerlink" title="1.4.4 Bean的懒加载"></a>1.4.4 Bean的懒加载</h3><blockquote>
<p>默认情况下，ApplicationContext实现会在初始化过程中创建和配置所有 单例（singleton）bean。</p>
</blockquote>
<p>如果不希望使用此行为，则可以通过将bean定义标记为延迟初始化来防止单例bean的预实例化。延迟初始化的bean告诉IoC容器<strong>在首次请求时而不是在启动时</strong>创建一个bean实例。</p>
<p>使用<code>lazy-init</code>属性。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 默认的 情况 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;not.lazy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.something.AnotherBean&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 懒加载 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;lazy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.something.ExpensiveToCreateBean&quot;</span> <span class="attr">lazy-init</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 可以直接在 容器级别上进行所有 bean的懒初始化 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">default-lazy-init</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- no beans will be pre-instantiated... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="1-4-5-自动装配"><a href="#1-4-5-自动装配" class="headerlink" title="1.4.5 自动装配"></a>1.4.5 自动装配</h3><p>这里并不打算讲在spring中基于xml的自动装配，后面会基于<strong>注解</strong>来实现自动装配，故这里略去不谈。</p>
<h3 id="1-4-6-方法注入"><a href="#1-4-6-方法注入" class="headerlink" title="1.4.6 方法注入"></a>1.4.6 方法注入</h3><blockquote>
<p>方法注入是Spring IoC容器的一项高级功能，这里只讲解决办法。</p>
</blockquote>
<p>这里只讲一下为什么需要方法注入。</p>
<p>简单来说，由于bean的声明周期不同，导致的问题。比如一个单例的bean依赖一个原型的bean，但是单例的bean的属性注入只有一次机会，这个时候就产生了问题。</p>
<p>使用 <code>@Lookup</code> 注解。</p>
<ol>
<li><p>声明一个原型bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPrototype</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在单例bean写一个返回 null 的 getXXX方法，</p>
</li>
</ol>
<p><strong>这里的方法名实际上就是xml的 bean的id</strong>。<br>再用<code>@Lookup</code>标记方法。</p>
<p>（这里也可以直接写成抽象方法，但不管怎样到最后，<strong>Spring框架都要通过使用CGLIB库中的字节码生成来动态生成覆盖该方法的子类，从而实现此方法注入</strong>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Lookup</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyPrototype <span class="title">getMyPrototype</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>获取 原型bean，然后使用。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 这里返回的可不是 null，放心使用它</span></span><br><span class="line">        MyPrototype myPrototype = getMyPrototype();</span><br><span class="line">        System.out.println(myPrototype.hashCode());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>参考资料</p>
<p><a href="https://docs.spring.io/spring-framework/docs/current-SNAPSHOT/reference/html/core.html#spring-core">Spring官方文档</a></p>
<p><a href="https://docs.spring.io/spring-framework/docs/">doc index</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring核心</tag>
        <tag>JavaEE</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 学习笔记2  ——  IOC容器 2 （Bean的作用域、生命周期回调接口）</title>
    <url>/2021/07/05/Spring%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%20%20%E2%80%94%E2%80%94%20%20IOC%E5%AE%B9%E5%99%A8%202%20%EF%BC%88Bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%9E%E8%B0%83%E6%8E%A5%E5%8F%A3%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<blockquote>
<p>这里我做的这份笔记的意义仅仅是记录下自己学习Spring的历程，既不是对官方API的深入解释，也不一定是对新手友好的、知识点详尽的一份学习清单。</p>
</blockquote>
</blockquote>
<h1 id="1-Spring-IoC容器和Bean简介"><a href="#1-Spring-IoC容器和Bean简介" class="headerlink" title="1 Spring IoC容器和Bean简介"></a>1 Spring IoC容器和Bean简介</h1><h2 id="1-5-Bean的作用域"><a href="#1-5-Bean的作用域" class="headerlink" title="1.5 Bean的作用域"></a>1.5 Bean的作用域</h2><h3 id="1-5-1-介绍"><a href="#1-5-1-介绍" class="headerlink" title="1.5.1 介绍"></a>1.5.1 介绍</h3><p>Spring框架支持六个作用域，但是后面四个只在web环境下才支持。<br>重点讲<strong>单例</strong>和<strong>原型</strong>。</p>
<ul>
<li>singleton<br>单例。IOC容器中只有一个实例。</li>
<li>prototype<br>原型。在每次请求该特定Bean时创建一个新的Bean实例。</li>
<li>request</li>
<li>session</li>
<li>application</li>
<li>websocket</li>
</ul>
<p>XML配置Bean举例。<br><strong>单例</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.something.DefaultAccountService&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- the following is equivalent, though redundant (singleton scope is the default) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.something.DefaultAccountService&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>原型</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.something.DefaultAccountService&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-5-2-单例与原型的区别"><a href="#1-5-2-单例与原型的区别" class="headerlink" title="1.5.2 单例与原型的区别"></a>1.5.2 单例与原型的区别</h3><p>原型作用域用于有状态的Bean。<br>将单例作用域用于无状态的Bean。</p>
<p>单例Bean好处是无需维护会话状态，可重复复用，开销低。<br>原型作用域用于有状态的Bean，某种程度上可以当成是 new 的替代。</p>
<p>关于原型bean的生命周期管理</p>
<blockquote>
<p>与其他作用域相比，<strong>Spring不能管理原型Bean的完整生命周期</strong>。容器将实例化，配置或组装原型对象，然后将其交给客户端，而无需对该原型实例的进一步记录。因此，尽管在不考虑范围的情况下在所有对象上都调用了初始化生命周期回调方法，但<strong>在原型的情况下，不会调用已配置的销毁生命周期回调</strong>。客户端代码必须清除原型作用域内的对象并释放原型Bean拥有的昂贵资源。为了使Spring容器释放原型作用下的bean所拥有的资源，请尝试使用 bean post-processor ，其中包含对需要清理的bean的引用。</p>
</blockquote>
<h3 id="1-5-3-单例与原型的四种依赖关系"><a href="#1-5-3-单例与原型的四种依赖关系" class="headerlink" title="1.5.3 单例与原型的四种依赖关系"></a>1.5.3 单例与原型的四种依赖关系</h3><ol>
<li><p>单例依赖单例<br>这也是默认的依赖关系。没什么好说的。</p>
</li>
<li><p>原型依赖原型</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPrototype</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    AnotherPrototype anotherPrototype;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    MySingleton mySingleton;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnotherPrototype</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上面，这样做也没有什么问题。两个bean每次拿都是<strong>全新的</strong>。</p>
<ol start="3">
<li><p>原型依赖单例<br>由于单例，所以原型bean里的单例bean仍然是惟一的。</p>
</li>
<li><p>单例依赖原型</p>
</li>
</ol>
<p>如果希望单例作用域的bean在运行时重复获取原型作用域的bean的新实例，不能将原型作用域的bean依赖项注入到您的单例bean中，因为当Spring容器实例化单例bean并解析并注入其依赖项时，<strong>该注入仅发生一次</strong>。如果在运行时不止一次需要原型bean的新实例，请参见<strong>方法注入</strong>。</p>
<p><a href="https://song-yang-ji.blog.csdn.net/article/details/109661012">文章末尾就是方法注入的使用</a></p>
<h3 id="1-5-4-使用自定义范围"><a href="#1-5-4-使用自定义范围" class="headerlink" title="1.5.4. 使用自定义范围"></a>1.5.4. 使用自定义范围</h3><p>暂略。。。</p>
<h2 id="1-6-自定义Bean的性质"><a href="#1-6-自定义Bean的性质" class="headerlink" title="1.6 自定义Bean的性质"></a>1.6 自定义Bean的性质</h2><p>Spring框架提供了许多接口，您可以使用这些接口来自定义Bean的性质。本节将它们分为以下几类：</p>
<ol>
<li><p>生命周期回调</p>
</li>
<li><p>ApplicationContextAware 和 BeanNameAware</p>
</li>
<li><p>其他 Aware接口</p>
</li>
</ol>
<h3 id="1-6-1-生命周期回调"><a href="#1-6-1-生命周期回调" class="headerlink" title="1.6.1 生命周期回调"></a>1.6.1 生命周期回调</h3><p>从Spring 2.5开始，您可以至少使用三个方法来控制Bean生命周期行为。</p>
<ol>
<li><p>实现<code>InitializingBean</code>和<code>DisposableBean</code>回调接口</p>
</li>
<li><p>xml里使用<code>init-method</code>和<code>destroy-methodbean</code>定义元数据, 指定回调方法</p>
</li>
<li><p>使用<code>@PostConstruct</code>和<code>@PreDestroy</code>注解</p>
</li>
</ol>
<p>第一种方法，虽然也能达成目的，但是将代码强耦合到Spring，并不被推荐。</p>
<p>第二种方法，使用Spring的xml配置bean的方式完成。</p>
<p>第三种方法，在全注解开发Spring项目的现在，无疑是最佳选择（官方也是这么说的）。</p>
<p><strong>初始化后回调</strong>和<strong>销毁之前回调</strong>的处理是差不多，这里仅仅以初始化回调为例，另一个是一样的。</p>
<h4 id="1-6-1-1-初始化回调"><a href="#1-6-1-1-初始化回调" class="headerlink" title="1.6.1.1 初始化回调"></a>1.6.1.1 初始化回调</h4><ul>
<li>实现 <code>InitializingBean</code>接口<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleInitBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.AnotherExampleBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnotherExampleBean</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do some initialization work</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 bean 的 <code>init-method</code>属性<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleInitBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do some initialization work</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>使用 @PostConstruct 注解<br>值得一提的是，这个注解并不是Spring里的，而是javax里的。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</span><br><span class="line">	<span class="meta">@PostConstruct</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do some initialization work</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="1-6-1-2-销毁回调"><a href="#1-6-1-2-销毁回调" class="headerlink" title="1.6.1.2 销毁回调"></a>1.6.1.2 销毁回调</h4><p>与上面几乎一样，略。</p>
<h4 id="1-6-1-3-默认初始化和销毁​​方法"><a href="#1-6-1-3-默认初始化和销毁​​方法" class="headerlink" title="1.6.1.3 默认初始化和销毁​​方法"></a>1.6.1.3 默认初始化和销毁​​方法</h4><p>当你需要为很多个，甚至所有的bean去设置初始化或销毁方法的时候，你可以直接为他们设置一个默认的公共的回调方法。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">default-init-method</span>=<span class="string">&quot;init&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;blogService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.something.DefaultBlogService&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.something.DefaultUserService&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 可以覆盖掉默认的 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;authorService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.something.DefaultAuthorService&quot;</span>  <span class="attr">init-method</span>=<span class="string">&quot;initMethod&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>&lt;beans&gt;</code>的default-init-method 为一系列bean设置回调方法。</p>
<p>你还可以覆盖掉默认的。</p>
<h4 id="1-6-1-4-配置多个回调方法的调用顺序"><a href="#1-6-1-4-配置多个回调方法的调用顺序" class="headerlink" title="1.6.1.4 配置多个回调方法的调用顺序"></a>1.6.1.4 配置多个回调方法的调用顺序</h4><ul>
<li>为同一个bean配置的具有不同初始化方法的调用顺序。</li>
</ul>
<ol>
<li><p>用注解的方法 @PostConstruct</p>
</li>
<li><p>由InitializingBean回调接口定义的afterPropertiesSet()</p>
</li>
<li><p>定制配置的init()方法</p>
</li>
</ol>
<p>销毁方法的调用顺序相同：</p>
<ol>
<li><p>用注释的方法 @PreDestroy</p>
</li>
<li><p>由DisposableBean回调接口定义的destroy()</p>
</li>
<li><p>定制配置的destroy()方法</p>
</li>
</ol>
<h4 id="1-6-1-5-Lifecycle接口"><a href="#1-6-1-5-Lifecycle接口" class="headerlink" title="1.6.1.5 Lifecycle接口"></a>1.6.1.5 Lifecycle接口</h4><p>暂略。</p>
<h3 id="1-6-2-ApplicationContextAware-接口"><a href="#1-6-2-ApplicationContextAware-接口" class="headerlink" title="1.6.2 ApplicationContextAware 接口"></a>1.6.2 ApplicationContextAware 接口</h3><p>以前，我们都是用 <code>ApplicationContext</code>去获取Bean（按类型、按bean的名字也罢）。<br>但是bean怎么拿到上下文，进而拿到其他的bean呢？<br>这个接口的出现终于解释了这个问题。</p>
<p>当 <code>ApplicationContext</code> 创建一个实现<code>ApplicationContextAware</code>接口的对象实例时，该实例将获得对<code>ApplicationContext</code>上下文的引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanImplApplicationContextAware</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个方法会由 Spring 自动调用，并传入上下文，</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        context = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ExampleBean exampleBean = context.getBean(<span class="string">&quot;exampleBean&quot;</span>,ExampleBean.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;在BeanImplApplicationContextAware里获得了&quot;</span>+exampleBean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boot</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(<span class="string">&quot;life_cycle&quot;</span>);</span><br><span class="line">        applicationContext.getBean(BeanImplApplicationContextAware.class).showBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-6-3-其他-Aware-接口"><a href="#1-6-3-其他-Aware-接口" class="headerlink" title="1.6.3 其他 Aware 接口"></a>1.6.3 其他 Aware 接口</h3><p><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-aware">官方文档的1.6.3</a></p>
<p><strong>必须要指明的一点的是，使用这些接口会将你的代码与Spring API绑定在一起，并且不遵循“控制反转”风格</strong>。</p>
<p>因此，只有在你确实需要编写一些基础bean，而他们确实需要访问 <strong>上下文容器时</strong>，才推荐使用这些接口。（总之，一般不用就拿ApplicationContextAware接口为例，我们完全可以使用自动装配AutoWire来代替它。）</p>
<blockquote>
<p>参考资料</p>
<p><a href="https://docs.spring.io/spring-framework/docs/current-SNAPSHOT/reference/html/core.html#spring-core">Spring官方文档</a></p>
<p><a href="https://docs.spring.io/spring-framework/docs/">doc index</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring核心</tag>
        <tag>JavaEE</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 学习笔记3 —— IOC容器 3 (使用注解配置IOC容器)</title>
    <url>/2021/07/10/Spring%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%20%E2%80%94%E2%80%94%20IOC%E5%AE%B9%E5%99%A8%203%20(%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AEIOC%E5%AE%B9%E5%99%A8)/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>这里我做的这份笔记的意义仅仅是记录下自己初涉Spring的历程，既不是对官方API的深入解释，也不一定是对新手友好的、知识点详尽的一份学习清单。</p>
</blockquote>
<h1 id="1-Spring-IoC容器和Bean简介"><a href="#1-Spring-IoC容器和Bean简介" class="headerlink" title="1 Spring IoC容器和Bean简介"></a>1 Spring IoC容器和Bean简介</h1><h2 id="1-9-基于注解的容器配置"><a href="#1-9-基于注解的容器配置" class="headerlink" title="1.9 基于注解的容器配置"></a>1.9 基于注解的容器配置</h2><blockquote>
<p><strong>注解</strong>在配置Spring上比<strong>XML</strong>更好吗？ 两种方式并无绝对的更好。不过目前的趋势是使用注解，尤其是对于不是特别大的项目。</p>
</blockquote>
<h3 id="1-9-1-Autowire"><a href="#1-9-1-Autowire" class="headerlink" title="1.9.1 @Autowire"></a>1.9.1 @Autowire</h3><p><strong>@Autowire</strong> 用于自动装配，按照 <strong>类型</strong> 装配。</p>
<ol>
<li>注解字段</li>
<li>注解构造器</li>
<li>注解方法</li>
</ol>
<p>其中，不建议使用 @Autowire 注入，这强依赖于 Spring 上下文的，无法在脱离ioc容器创建对象，比如在进行单元测试的时候。<br>使用构造器注入，表达强依赖关系。<br>使用方法（不一定是setter），表达依赖的可选择关系。</p>
<h3 id="1-9-2-Primary"><a href="#1-9-2-Primary" class="headerlink" title="1.9.2 @Primary"></a>1.9.2 @Primary</h3><p>由于@Autowire是按类型自动装配的，如果有过个bean的话Spring不知道找那个，<br>可以使用 <strong>@Primary</strong> 指定 bean 的优先级。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> ...</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以及</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MovieCatalog <span class="title">firstMovieCatalog</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MovieCatalog <span class="title">secondMovieCatalog</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-9-3-Qualifier"><a href="#1-9-3-Qualifier" class="headerlink" title="1.9.3 @Qualifier"></a>1.9.3 @Qualifier</h3><p>配合 @Autowire 使用，可以根据 bean 的名字进行精确匹配。<br>此注解可以使用在 方法、字段、类型、参数，相当于在需要根据name进行标识的时候，就使用它。</p>
<p>注：<br>可能有人想用 <strong>@Resource</strong> 去彻底代替 @Autowire + @Qualifier。<br>在一定场景下是可以的。<br>但是 <strong>@Resource 只能用于字段，和单个参数的setter</strong>，对于注解构造函数和多个参数的方法，它无能为力。不过， @Autowire + @Qualifier 没有这个限制。</p>
<p>官方文档这里还讲了 自定义的 @Qualifier ，这里就不细讲了。</p>
<h3 id="1-9-4-Resource"><a href="#1-9-4-Resource" class="headerlink" title="1.9.4 @Resource"></a>1.9.4 @Resource</h3><p> <code>@Resource</code>有两个属性<code>name</code>、<code>type</code><br>匹配规则：</p>
<ul>
<li>后面没有任何内容，<strong>默认通过name属性</strong>去匹配bean，找不到再按type去匹配；</li>
<li> 指定了name或者type则根据指定的类型去匹配bean；</li>
<li>指定了name和type则根据指定的name和type去匹配bean，任何一个不匹配都将报错。</li>
</ul>
<h3 id="1-9-5-将泛型用作自动装配限定符"><a href="#1-9-5-将泛型用作自动装配限定符" class="headerlink" title="1.9.5 将泛型用作自动装配限定符"></a>1.9.5 将泛型用作自动装配限定符</h3><p>暂略。</p>
<h3 id="1-9-4-Value"><a href="#1-9-4-Value" class="headerlink" title="1.9.4 @Value"></a>1.9.4 @Value</h3><p>@Value 通常用于注入外部属性。<br>这里还用到了 Spring表达式，不过这里仅仅使用读取即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String catalog;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MovieRecommender</span><span class="params">(<span class="meta">@Value(&quot;$&#123;catalog.name&#125;&quot;)</span> String catalog)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.catalog = catalog;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 application.properties</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">catalog.name&#x3D;MovieCatalog</span><br></pre></td></tr></table></figure>


<p>还可以使用SpEL进行读取值后动态计算生成值。</p>
<h2 id="1-10-类路径扫描与托管组件"><a href="#1-10-类路径扫描与托管组件" class="headerlink" title="1.10 类路径扫描与托管组件"></a>1.10 类路径扫描与托管组件</h2><h3 id="1-10-1-ComponentScan"><a href="#1-10-1-ComponentScan" class="headerlink" title="1.10.1 @ComponentScan"></a>1.10.1 @ComponentScan</h3><p>要<strong>自动检测这些类并注册相应的bean</strong>，就可以使用 <strong>@ComponentScan</strong>。</p>
<p>它的作用，找到这些bean,并把它注册到 ioc 容器里， 就像我们手动在 xml 配置一样。</p>
<p>对于SpringBoot应用这个注解可能不会直接被我们使用，<br>原因是 @SpringBootApplication已经使用了 这个注解，而这个注解会扫描 com.xxx.xxx包及其子包下所有的@Component 及其派生注解，所以一般情况下我们用不着。</p>
<p>但是如果有类写在启动类所在包的外面，而你又想使用它，就得用上这个注解了。</p>
<p>使用方法：<br>指定扫描的包（子包会自动扫描），指定过滤器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;org.example&quot;,</span></span><br><span class="line"><span class="meta">        includeFilters = @Filter(type = FilterType.REGEX, pattern = &quot;.*Stub.*Repository&quot;),</span></span><br><span class="line"><span class="meta">        excludeFilters = @Filter(Repository.class))</span></span><br></pre></td></tr></table></figure>

<h3 id="1-10-2-Bean"><a href="#1-10-2-Bean" class="headerlink" title="1.10.2 @Bean"></a>1.10.2 @Bean</h3><p>@Bean注释的作用与<bean/>元素相同。</p>
<p>@Bean可以结合其他注解使用<br>这些注解基本上是补全了XML的功能</p>
<ul>
<li>如<br>@Primary :优先级，当有两个相同类型的Spring Bean，如果有一个被声明了是@Primary，那么@Autowired会注入这个带有@Primary的。<br>@Scope :作用域，默认有singleton/prototype，单例和每次注入重新初始化，<br>@Profile :见@Configuration<br>@Lazy :见@Configuration</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@Component</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanHolder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExampleBean <span class="title">exampleBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ExampleBean();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在类内调用，同样也会经过代理</span></span><br><span class="line">    <span class="comment">// （ 很好理解，cglib生成的子类override上面的getExampleBean方法后，调用f()时，</span></span><br><span class="line">    <span class="comment">// 根据类的多态，此时调用的getExampleBean方法是被增强过的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(exampleBean());</span><br><span class="line">        System.out.println(exampleBean());</span><br><span class="line">        System.out.println(exampleBean());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它和如下的xml配置等效</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xxx.BeanHolder&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果把这里的 <strong>@Configuration</strong>换成 <strong>@Component</strong>会怎样？<br>注意，@Configuration类下被 @Bean 注解的方法，调用的时候会得到CGLIB代理的增强，<br>而@Component下的@Bean方法不经过代理，是标准的java调用。</p>
</li>
<li><p>如果@Bean修饰的方法被 static呢？<br>注意CGLIB生成的子类只会override非静态方法，所以static的@Bean方法不会被容器拦截。<br>技术上来说，CGLIB会动态生成BeanHolder的子类，然后override那个@Bean代理的方法。</p>
</li>
</ul>
<p>注意，看到下面的图，你通过Spring容器拿到的类，其实已经不是你自己写的类了，而是经过cglib加强过的类。<br><img src="https://img-blog.csdnimg.cn/20210526013456644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0ODQ2MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="1-10-3-命名自动检测的组件"><a href="#1-10-3-命名自动检测的组件" class="headerlink" title="1.10.3 命名自动检测的组件"></a>1.10.3 命名自动检测的组件</h3><p>Spring自己生成的bean的名字是有规则的，就是类名答第一个字母变成小写，而你可以自定义名称生成规则（不过似乎很鸡肋，没什么用）。</p>
<h3 id="1-10-4-Scope"><a href="#1-10-4-Scope" class="headerlink" title="1.10.4 @Scope"></a>1.10.4 @Scope</h3><p>这个注解可以用在Bean class 和@Bean 方法上，用来指定作用域。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> ...</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MyBean <span class="title">myBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<blockquote>
<p>参考资料</p>
<p><a href="https://docs.spring.io/spring-framework/docs/current-SNAPSHOT/reference/html/core.html#spring-core">Spring官方文档</a></p>
<p><a href="https://docs.spring.io/spring-framework/docs/">doc index</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring核心</tag>
        <tag>JavaEE</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 学习笔记4  ——  AOP（面向切面编程）</title>
    <url>/2021/08/01/Spring%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04%20%20%E2%80%94%E2%80%94%20%20AOP%EF%BC%88%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>这里我做的这份笔记的意义仅仅是记录下自己学习Spring的历程，既不是对官方API的深入解释，也不一定是对新手友好的、知识点详尽的一份学习清单。</p>
</blockquote>
<h1 id="5-Spring-面向方面编程"><a href="#5-Spring-面向方面编程" class="headerlink" title="5. Spring 面向方面编程"></a>5. Spring 面向方面编程</h1><h2 id="5-1-AOP概念"><a href="#5-1-AOP概念" class="headerlink" title="5.1 AOP概念"></a>5.1 AOP概念</h2><p>下面是一些核心 AOP 概念和术语。这些术语不是特定于 Spring 的。</p>
<ul>
<li><p>切面（Aspect）：跨越多个类的关注点的模块化—— <strong>AOP中的基本单位</strong>，正如OOP中的类一样。在 Spring AOP 中，方面是通过使用<strong>基于XML配置常规Bean</strong>或<strong>使用注解@Aspect注解的常规类 （@AspectJ 风格）实现的</strong>。</p>
<p>注意：<code>@Aspect</code>是注解，@AspectJ是AspectJ project在Spring AOP中实现的风格。</p>
</li>
<li><p>连接点（Join point）：<strong>程序执行过程中的一个点，例如方法的执行或异常的处理</strong>。</p>
<p>在 Spring AOP 中，一个连接点总是代表一个<strong>方法</strong>的执行，目前不能对<strong>字段</strong>进行拦截。</p>
</li>
<li><p>通知（Advice）：<strong>方面在特定连接点采取的行动</strong>。通知类型将在后面讨论。</p>
</li>
<li><p>切点（Pointcut）：<strong>匹配连接点的谓词。</strong>由切入点表达式匹配的连接点的概念是 AOP 的核心，Spring 默认使用 AspectJ 风格的切入点表达式语言。</p>
<p>通俗的说，Spring会根据切点定义的规则去匹配连接点。</p>
</li>
<li><p>引入（Introduction） ：代表类型声明额外的方法或字段。Spring AOP 允许您向任何目标对象引入新的接口（和相应的实现）。</p>
<p>这个算是AOP里比较难理解的概念，最好通过实例来解释。</p>
</li>
<li><p>目标对象（Target object）：被一个或多个方面建议的对象。也称为“建议对象”。由于 Spring AOP 是使用运行时代理实现的，所以这个对象始终是一个<strong>被代理的对象</strong> （即原对象）。</p>
</li>
<li><p>AOP 代理：由 AOP 框架创建的对象，用于实现方面契约（建议方法执行等）。在 Spring Framework 中，AOP 代理由 JDK 动态代理或 CGLIB 代理。</p>
</li>
<li><p>编织：将切面与其他应用程序类型或对象联系起来以创建 Advised 对象。</p>
</li>
</ul>
<p>切入点匹配的连接点概念是 AOP 的关键，它区别于仅提供拦截器的技术。</p>
<p>Spring AOP 包括以下类型的通知</p>
<ul>
<li>前置（Before）通知：在连接点之前运行的通知，<strong>但不能阻止执行流继续到连接点</strong>（除非它抛出异常）。</li>
<li>返回后（After returning）通知：在连接点正常完成后运行的通知（例如，如果方法返回而没有抛出异常）。</li>
<li>抛出异常后（After throwing）通知：如果方法通过抛出异常退出，则运行通知。</li>
<li>后置（After or finally）通知：不管连接点退出的方式（正常或异常返回）都将运行的通知。</li>
<li>环绕（Around）通知：环绕连接点的通知。这是最有力的通知。<strong>环绕通知可以在方法调用之前和之后执行自定义行为</strong>。它还<strong>负责选择是继续连接点还是通过返回自己的返回值或抛出异常来缩短被代理的方法执行</strong>。</li>
</ul>
<h2 id="5-2-使用-AspectJ风格的AOP"><a href="#5-2-使用-AspectJ风格的AOP" class="headerlink" title="5.2 使用@AspectJ风格的AOP"></a>5.2 使用@AspectJ风格的AOP</h2><p>AOP在Spring中的使用，既可以使用注解驱动，也可以使用XML配置。</p>
<p>这里仍然只介绍注解驱动的AOP。</p>
<h3 id="5-2-1-启用-AspectJ支持"><a href="#5-2-1-启用-AspectJ支持" class="headerlink" title="5.2.1 启用@AspectJ支持"></a>5.2.1 启用@AspectJ支持</h3><p>对于SpringBoot项目而言，引入依赖即可。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- aop --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>下面介绍AOP中的一系列概念在@AspectJ中的具体落地实现。</p>
<h3 id="5-2-2-声明一个切面"><a href="#5-2-2-声明一个切面" class="headerlink" title="5.2.2 声明一个切面"></a>5.2.2 声明一个切面</h3><p>使用注解 <code>@Aspect</code>标记类即可。</p>
<p>但请注意， <code>@Aspect</code>注释不足以在类路径中进行自动检测从而被Spring容器管理，所以@Component是有必要的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotVeryUsefulAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而且，在 Spring AOP 中，切面本身不能成为其他切面通知的目标。</p>
<h3 id="5-2-3-声明一个切入点"><a href="#5-2-3-声明一个切入点" class="headerlink" title="5.2.3 声明一个切入点"></a>5.2.3 声明一个切入点</h3><p>如下，<strong>切点是一个用<code>@Pointcut</code>标记的方法（返回值必须是void）</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(* transfer(..))&quot;)</span> <span class="comment">// the pointcut expression</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">anyOldTransfer</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// the pointcut signature</span></span><br></pre></td></tr></table></figure>

<p>构成<code>@Pointcut</code>注解值的切入点表达式是一个正则 AspectJ 切入点表达式，这是切点的关键。</p>
<p>具体可以参考附录中的AspectJ编程指南。</p>
<blockquote>
<p>参考资料</p>
<p><a href="https://docs.spring.io/spring-framework/docs/current-SNAPSHOT/reference/html/core.html#spring-core">Spring官方文档</a></p>
<p><a href="https://docs.spring.io/spring-framework/docs/">doc index</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1532547#:~:text=Spring%20AOP%20%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8JDK,%E5%8F%AF%E4%BB%A5%E5%BC%BA%E5%88%B6%E4%BD%BF%E7%94%A8CGLIB%20%E4%BB%A3%E7%90%86%E3%80%82">Spring 5 AOP 默认改用 CGLIB 了？</a></p>
<p><a href="https://www.eclipse.org/aspectj/doc/released/progguide/index.html">AspectJ编程指南</a></p>
<p><a href="https://www.eclipse.org/aspectj/">AspectJ网站</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring核心</tag>
        <tag>JavaEE</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot整合Kafka</title>
    <url>/2021/10/25/SpringBoot%E6%95%B4%E5%90%88Kafka/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Maven依赖"><a href="#Maven依赖" class="headerlink" title="Maven依赖"></a>Maven依赖</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- kafka 流处理相关 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka-streams<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 本地嵌入式kafka，测试用，可无需依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-kafka-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h1 id="note"><a href="#note" class="headerlink" title="note"></a>note</h1><h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><p>使用SpringBoot,  一个默认配置的 KafkaAdmin 会被注入，可以直接使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> KafkaAdmin <span class="title">admin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; configs = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// configs.put(AdminClientConfig.BOOTSTRAPx_SERVERS_CONFIG, ...); </span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> KafkaAdmin(configs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>使用<code>TopicBuilder</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NewTopic <span class="title">topic1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> TopicBuilder.name(<span class="string">&quot;topic1&quot;</span>)  <span class="comment">// 主题名</span></span><br><span class="line">            .partitions(<span class="number">10</span>) <span class="comment">// 分区数</span></span><br><span class="line">            .replicas(<span class="number">3</span>)    <span class="comment">// 备份数</span></span><br><span class="line">            .compact()</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><h3 id="使用KafkaTemplate"><a href="#使用KafkaTemplate" class="headerlink" title="使用KafkaTemplate"></a>使用KafkaTemplate</h3><p>使用<code>KafkaTemplate</code>来发送消息, API</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 需要设置默认的主题： public void setDefaultTopic(String defaultTopic)</span></span><br><span class="line">ListenableFuture&lt;SendResult&lt;K, V&gt;&gt; sendDefault(V data);</span><br><span class="line"></span><br><span class="line">ListenableFuture&lt;SendResult&lt;K, V&gt;&gt; sendDefault(K key, V data);</span><br><span class="line"></span><br><span class="line">ListenableFuture&lt;SendResult&lt;K, V&gt;&gt; sendDefault(Integer partition, K key, V data);</span><br><span class="line"></span><br><span class="line">ListenableFuture&lt;SendResult&lt;K, V&gt;&gt; sendDefault(Integer partition, Long timestamp, K key, V data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.必须指定主题、值（数据）</span></span><br><span class="line"><span class="comment">// 可以指定分区、键、时间戳</span></span><br><span class="line">ListenableFuture&lt;SendResult&lt;K, V&gt;&gt; send(String topic, V data);</span><br><span class="line"></span><br><span class="line">ListenableFuture&lt;SendResult&lt;K, V&gt;&gt; send(String topic, K key, V data);</span><br><span class="line"></span><br><span class="line">ListenableFuture&lt;SendResult&lt;K, V&gt;&gt; send(String topic, Integer partition, K key, V data);</span><br><span class="line"></span><br><span class="line">ListenableFuture&lt;SendResult&lt;K, V&gt;&gt; send(String topic, Integer partition, Long timestamp, K key, V data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.使用 kafka-clients 提供的 ProducerRecord </span></span><br><span class="line">ListenableFuture&lt;SendResult&lt;K, V&gt;&gt; send(ProducerRecord&lt;K, V&gt; record);</span><br><span class="line"><span class="comment">// 4.使用 spring 封装提供的 message</span></span><br><span class="line">ListenableFuture&lt;SendResult&lt;K, V&gt;&gt; send(Message&lt;?&gt; message);</span><br></pre></td></tr></table></figure>

<p>返回值值得注意,<code>ListenableFuture</code>是spring提供的拓展了juc下<code>Future</code>接口的增加了添加了回调功能增强版Future。</p>
<h3 id="发送模式"><a href="#发送模式" class="headerlink" title="发送模式"></a>发送模式</h3><h3 id="fire-and-forget（发完即忘）"><a href="#fire-and-forget（发完即忘）" class="headerlink" title="fire-and-forget（发完即忘）"></a>fire-and-forget（发完即忘）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">kafkaTemplate.send(...)</span><br></pre></td></tr></table></figure>

<p>也就是发完之后完全不做任何处理，发送失败也无所谓，比如传送一些日志的时候。</p>
<h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><p>因为返回的是 <code>ListenableFuture</code>，所以可以阻塞式的等待结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一直阻塞</span></span><br><span class="line">kafkaTemplate.send().get();</span><br><span class="line"><span class="comment">// 等待固定时间</span></span><br><span class="line">kafkaTemplate.send().get(<span class="number">10</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendToKafka</span><span class="params">(<span class="keyword">final</span> MyOutputData data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ProducerRecord&lt;String, String&gt; record = createRecord(data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        template.send(record).get(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        handleSuccess(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        handleFailure(data, record, e.getCause());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (TimeoutException | InterruptedException e) &#123;</span><br><span class="line">        handleFailure(data, record, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendToKafka</span><span class="params">(<span class="keyword">final</span> MyOutputData data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ProducerRecord&lt;String, String&gt; record = createRecord(data);</span><br><span class="line"></span><br><span class="line">    ListenableFuture&lt;SendResult&lt;Integer, String&gt;&gt; future = template.send(record);</span><br><span class="line">    <span class="comment">// 添加处理回调</span></span><br><span class="line">    future.addCallback(<span class="keyword">new</span> KafkaSendCallback&lt;SendResult&lt;Integer, String&gt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(SendResult&lt;Integer, String&gt; result)</span> </span>&#123;</span><br><span class="line">            handleSuccess(data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(KafkaProducerException ex)</span> </span>&#123;</span><br><span class="line">            handleFailure(data, record, ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>当然，还有种粗粒度的添加回调，在kafkaTemplate上添加回调：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LoggingProducerListener，它会记录错误并且在发送成功时不执行任何操作。</span></span><br><span class="line">kafkaTemplate.setProducerListener(<span class="keyword">new</span> LoggingProducerListener&lt;&gt;());</span><br><span class="line">kafkaTemplate.setProducerListener(<span class="keyword">new</span> ProducerListener&lt;String, String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(ProducerRecord&lt;String, String&gt; producerRecord, RecordMetadata recordMetadata)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(ProducerRecord&lt;String, String&gt; producerRecord, RecordMetadata recordMetadata, Exception exception)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h3 id="使用ReplyingKafkaTemplate"><a href="#使用ReplyingKafkaTemplate" class="headerlink" title="使用ReplyingKafkaTemplate"></a>使用ReplyingKafkaTemplate</h3><p>不过需要注意，这个<code>ReplyingKafkaTemplate</code>SpringBoot并没有注入，需要自行构造。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ReplyingKafkaTemplate&lt;String, String, String&gt; <span class="title">replyingTemplate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ProducerFactory&lt;String, String&gt; pf,</span></span></span><br><span class="line"><span class="function"><span class="params">        ConcurrentMessageListenerContainer&lt;String, String&gt; repliesContainer)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReplyingKafkaTemplate&lt;&gt;(pf, repliesContainer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConcurrentMessageListenerContainer&lt;String, String&gt; <span class="title">repliesContainer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; containerFactory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ConcurrentMessageListenerContainer&lt;String, String&gt; repliesContainer =</span><br><span class="line">            containerFactory.createContainer(<span class="string">&quot;replies&quot;</span>);</span><br><span class="line">    repliesContainer.getContainerProperties().setGroupId(<span class="string">&quot;repliesGroup&quot;</span>);</span><br><span class="line">    repliesContainer.setAutoStartup(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> repliesContainer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>API</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">RequestReplyFuture&lt;K, V, R&gt; <span class="title">sendAndReceive</span><span class="params">(ProducerRecord&lt;K, V&gt; record)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// replyTimeout为等待回复的超时时间</span></span><br><span class="line"><span class="function">RequestReplyFuture&lt;K, V, R&gt; <span class="title">sendAndReceive</span><span class="params">(ProducerRecord&lt;K, V&gt; record,</span></span></span><br><span class="line"><span class="function"><span class="params">    Duration replyTimeout)</span></span>;</span><br></pre></td></tr></table></figure>



<p>如何使用这个返回值<code>RequestReplyFuture</code>呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RequestReplyFuture&lt;String, String, String&gt; replyFuture = template.sendAndReceive(record);</span><br><span class="line"><span class="comment">// 发送结果</span></span><br><span class="line">SendResult&lt;String, String&gt; sendResult = replyFuture.getSendFuture().get();</span><br><span class="line">System.out.println(<span class="string">&quot;Sent ok: &quot;</span> + sendResult.getRecordMetadata());</span><br><span class="line"><span class="comment">// 返回的结果</span></span><br><span class="line">ConsumerRecord&lt;String, String&gt; consumerRecord = replyFuture.get();</span><br><span class="line">System.out.println(<span class="string">&quot;Return value: &quot;</span> + consumerRecord.value()); <span class="comment">// 返回值</span></span><br></pre></td></tr></table></figure>



<h2 id="接受消息"><a href="#接受消息" class="headerlink" title="接受消息"></a>接受消息</h2><p>大的方向有两种接受消息的方式,一个low-level一点，一个high-level一点。</p>
<ol>
<li>配置<code>MessageListenerContainer</code>并提供<code>MessageListener</code>。</li>
<li>使用<code>@KafkaListener</code>。</li>
</ol>
<p>其中第二种方法类似于其他MQ的监听器，如<code>@RabbitListener</code>,使用简单方便。</p>
<p>第一种方法相当于SpringBoot提供了一个消息监听器的容器，这个容器负责<code>kafkaConsumer.poll</code>调用，</p>
<p>以及MessageListener的方法调用，主要的动能就是让用户无需关注多线程并发代码的编写，着力于消息的消费与处理。</p>
<p>值得注意的是，即使你没有直接使用第一种方法，<code>@KafkaListener</code>所注解的类也被封装成<code>MessagingMessageListenerAdapter</code>然后由<code>MessageListenerContainer</code>调度。</p>
<p>下面主要介绍@KafkaListener的使用。</p>
<blockquote>
<p>只列出最常用的属性</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> KafkaListener &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 订阅的主题</span></span><br><span class="line">	String[] topics() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于匹配主题的pattern</span></span><br><span class="line">	<span class="function">String <span class="title">topicPattern</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 主题分区</span></span><br><span class="line">	TopicPartition[] topicPartitions() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function">String <span class="title">errorHandler</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 消费组id</span></span><br><span class="line">	<span class="function">String <span class="title">groupId</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 线程数</span></span><br><span class="line">	<span class="function">String <span class="title">concurrency</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  String[] properties() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TopicPartition &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function">String <span class="title">topic</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	String[] partitions() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	PartitionOffset[] partitionOffsets() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> PartitionOffset &#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">String <span class="title">partition</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function">String <span class="title">initialOffset</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function">String <span class="title">relativeToCurrent</span><span class="params">()</span> <span class="keyword">default</span> &quot;<span class="keyword">false</span>&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>















]]></content>
      <categories>
        <category>消息中间件</category>
      </categories>
      <tags>
        <tag>Message Queue</tag>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot集成Redis ———— 序列化配置、常见工具类、基本的CRUD</title>
    <url>/2021/09/28/SpringBoot%E9%9B%86%E6%88%90Redis-%E2%80%94%E2%80%94%E2%80%94%E2%80%94-%E5%BA%8F%E5%88%97%E5%8C%96%E9%85%8D%E7%BD%AE%E3%80%81%E5%B8%B8%E8%A7%81%E5%B7%A5%E5%85%B7%E7%B1%BB%E3%80%81%E5%9F%BA%E6%9C%AC%E7%9A%84CRUD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Maven依赖"><a href="#Maven依赖" class="headerlink" title="Maven依赖"></a>Maven依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- lettuce连接池需要依赖下面的jar包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>序列化依赖，如果使用 spring-boot-starter-web, 就不需要了。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-json<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="Java-连接-redis-的客户端"><a href="#Java-连接-redis-的客户端" class="headerlink" title="Java 连接 redis 的客户端"></a>Java 连接 redis 的客户端</h2><blockquote>
<p>操作redis的客户端有jedis跟Lettuce。在springboot1.x系列中，其中使用的是jedis,但是到了springboot2.x其中使用的是Lettuce。 因为我们的版本是springboot2.x系列，所以今天使用的是Lettuce。<br>关于jedis跟lettuce的区别：</p>
<ul>
<li> Lettuce 和 Jedis 的定位都是Redis的client，所以他们当然可以直接连接redis server  </li>
<li>Jedis在实现上是直接连接的redis server，如果在多线程环境下是非线程安全的，这个时候只有使用连接池，为每个Jedis实例增加物理连接;</li>
<li>Lettuce的连接是基于Netty的，连接实例（StatefulRedisConnection）可以在多个线程间并发访问，应为StatefulRedisConnection是线程安全的，所以一个连接实例（StatefulRedisConnection）就可以满足多线程环境下的并发访问，当然这个也是可伸缩的设计，一个连接实例不够的情况也可以按需增加连接实例。</li>
</ul>
</blockquote>
<h2 id="序列化配置"><a href="#序列化配置" class="headerlink" title="序列化配置"></a>序列化配置</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate redisTemplate = <span class="keyword">new</span> RedisTemplate();</span><br><span class="line">        <span class="comment">// 设置template获得 redis-connection 的工厂</span></span><br><span class="line">        redisTemplate.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">// 设置序列化器</span></span><br><span class="line">        redisTemplate.setKeySerializer(StringRedisSerializer.UTF_8);</span><br><span class="line">        redisTemplate.setValueSerializer(RedisSerializer.json()); <span class="comment">// value 序列化器使用 Json</span></span><br><span class="line">        redisTemplate.setHashKeySerializer(StringRedisSerializer.UTF_8);</span><br><span class="line">        redisTemplate.setHashValueSerializer(StringRedisSerializer.UTF_8);</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="yml基本配置"><a href="#yml基本配置" class="headerlink" title="yml基本配置"></a>yml基本配置</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span> <span class="comment">#使用第几个数据库</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span> <span class="comment">#redis服务器地址</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span> <span class="comment">#端口号</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">~</span> <span class="comment">#redis服务器连接密码</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">10000</span>  <span class="comment"># 连接超时时间（单位：毫秒）</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="comment">## 下面的值其实是lettuce连接池的默认配置，有兴趣的可以点进源码看一下</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span> <span class="comment">#连接池最大连接数（使用负值表示没有限制）</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">-1</span>  <span class="comment">#连接池最大阻塞等待时间（单位：使用负值表示没有限制）</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span> <span class="comment">#连接池中的最大空闲连接</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span> <span class="comment">#连接池中的最小空闲连接</span></span><br></pre></td></tr></table></figure>



<h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><h3 id="Json工具类"><a href="#Json工具类" class="headerlink" title="Json工具类"></a>Json工具类</h3><p>主要是将检查型异常改为运行时异常抛出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Json工具类, 功能为对象和字符串互相转换</span></span><br><span class="line"><span class="comment"> * 注意，jackson的属性注入是 无参构造器+getter+setter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Serialize any Java value as a String.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">stringfy</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mapper.writeValueAsString(object);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;JsonUtil stringfy error: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Deserialize JSON content from given JSON content String.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">parse</span><span class="params">(String content, Class&lt;T&gt; valueType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mapper.readValue(content, valueType);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;JsonUtil parse error: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="简单Bean类与Map之间的转换"><a href="#简单Bean类与Map之间的转换" class="headerlink" title="简单Bean类与Map之间的转换"></a>简单Bean类与Map之间的转换</h3><p>这个工具类的转换，主要是在使用 redis 的 hash 结构去存储实体类的时候使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: SongyangJi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 提供简单bean类与map之间的转化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2021/9/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanAndMapConvertUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title">beanToMap</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Field field : object.getClass().getDeclaredFields()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">boolean</span> flag = field.isAccessible();</span><br><span class="line">                field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                Object obj = field.get(object);</span><br><span class="line">                map.put(field.getName(), obj != <span class="keyword">null</span> ? obj.toString() : <span class="string">&quot;&quot;</span>);</span><br><span class="line">                field.setAccessible(flag);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">mapToBean</span><span class="params">(Map&lt;String, Object&gt; map, Class&lt;T&gt; beanClass)</span> </span>&#123;</span><br><span class="line">        T t;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t = beanClass.newInstance();</span><br><span class="line">            <span class="keyword">for</span> (Field field : beanClass.getDeclaredFields()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(field.getName())) &#123;</span><br><span class="line">                    <span class="keyword">boolean</span> flag = field.isAccessible();</span><br><span class="line">                    field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    Object obj = map.get(field.getName());</span><br><span class="line">                    <span class="keyword">if</span> (obj != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (field.getType().isAssignableFrom(obj.getClass())) &#123;</span><br><span class="line">                            field.set(t, obj);</span><br><span class="line">                        &#125;</span><br><span class="line">                        field.setAccessible(flag);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h2><h3 id="简单的Entity"><a href="#简单的Entity" class="headerlink" title="简单的Entity"></a>简单的Entity</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> userId;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    LocalDate lastSignDay;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="测试-String"><a href="#测试-String" class="headerlink" title="测试 String"></a>测试 String</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      redisTemplate.opsForValue().set(<span class="string">&quot;str_key&quot;</span>, <span class="string">&quot;hello_world&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>





<h3 id="测试-Hash"><a href="#测试-Hash" class="headerlink" title="测试 Hash"></a>测试 Hash</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testBeanAndHash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      User songyangJi = <span class="keyword">new</span> User(<span class="number">12345L</span>, <span class="string">&quot;SongyangJi&quot;</span>, <span class="number">18</span>, <span class="number">73.5</span>, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">      <span class="keyword">final</span> String user_hash_key = <span class="string">&quot;user_hash&quot;</span>;</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;------ 使用 Hash 存储对象 ------&quot;</span>);</span><br><span class="line">      <span class="comment">// 使用Hash结构，map传入</span></span><br><span class="line">      redisTemplate.opsForHash().putAll(user_hash_key + <span class="string">&quot;:&quot;</span> + songyangJi.getUserId(), BeanAndMapConvertUtil.beanToMap(songyangJi));</span><br><span class="line"></span><br><span class="line">      BoundHashOperations hashOs = redisTemplate.boundHashOps(user_hash_key + <span class="string">&quot;:&quot;</span> + songyangJi.getUserId());</span><br><span class="line">      System.out.println(hashOs.get(<span class="string">&quot;userId&quot;</span>));</span><br><span class="line">      System.out.println(hashOs.get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">      hashOs.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;gong chen bo&quot;</span>);</span><br><span class="line">      hashOs.increment(<span class="string">&quot;age&quot;</span>, <span class="number">1</span>);</span><br><span class="line">      System.out.println(hashOs.keys());</span><br><span class="line">      System.out.println(hashOs.values());</span><br><span class="line">      System.out.println(hashOs.entries());</span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure>



<h3 id="测试-Json序列化"><a href="#测试-Json序列化" class="headerlink" title="测试 Json序列化"></a>测试 Json序列化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testBeanAndHash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     User songyangJi = <span class="keyword">new</span> User(<span class="number">12345L</span>, <span class="string">&quot;SongyangJi&quot;</span>, <span class="number">18</span>, <span class="number">73.5</span>, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">     <span class="keyword">final</span> String user_json_key = <span class="string">&quot;user_json&quot;</span>;</span><br><span class="line"></span><br><span class="line">     System.out.println(<span class="string">&quot;------- 使用 Json 存储对象 -------&quot;</span>);</span><br><span class="line">     redisTemplate.opsForValue().set(user_json_key + <span class="string">&quot;:&quot;</span> + songyangJi.getUserId(), JsonUtil.stringfy(songyangJi));</span><br><span class="line">     User u = JsonUtil.parse((String) redisTemplate.opsForValue().get(user_json_key + <span class="string">&quot;:&quot;</span> + songyangJi.getUserId()), User.class);</span><br><span class="line">     System.out.println(u);</span><br><span class="line">     u.setName(<span class="string">&quot;gong chen bo&quot;</span>);</span><br><span class="line">     BoundValueOperations valueOps = redisTemplate.boundValueOps(user_json_key + <span class="string">&quot;:&quot;</span> + songyangJi.getUserId());</span><br><span class="line">     valueOps.set(JsonUtil.stringfy(u));</span><br><span class="line">     System.out.println(redisTemplate.opsForValue().get(user_json_key + <span class="string">&quot;:&quot;</span> + songyangJi.getUserId()));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h3 id="测试-HyperLogLog"><a href="#测试-HyperLogLog" class="headerlink" title="测试 HyperLogLog"></a>测试 HyperLogLog</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testHyperLogLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用HyperLogLog统计每天登录的用户量</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> userId = <span class="keyword">new</span> Random().nextLong();</span><br><span class="line"><span class="comment">//        final long userId = 1L;</span></span><br><span class="line">        HyperLogLogOperations hyperLogLog = redisTemplate.opsForHyperLogLog();</span><br><span class="line">        String key = <span class="string">&quot;user:login:number:&quot;</span> + LocalDate.now();</span><br><span class="line">        hyperLogLog.add(key, userId);</span><br><span class="line">        System.out.println(hyperLogLog.size(key));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="测试-BitMap"><a href="#测试-BitMap" class="headerlink" title="测试 BitMap"></a>测试 BitMap</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testBitMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">     <span class="comment">// 示例：使用BitMap记录用户本周是否有签到</span></span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">long</span> userId = <span class="keyword">new</span> Random().nextLong();</span><br><span class="line">     <span class="comment">// final long userId = 1L;</span></span><br><span class="line">     <span class="comment">// userId高48位用于将用户划分到不同的key，低16位作为位图偏移参数offset;</span></span><br><span class="line">     String keySign = <span class="string">&quot;user:sign:&quot;</span> + LocalDate.now().getDayOfWeek() + <span class="string">&quot;:&quot;</span> + (userId &gt;&gt; <span class="number">16</span>);</span><br><span class="line">     <span class="comment">// offset参数必须大于或等于0，小于2^32(bit 映射被限制在 512 MB 之内)</span></span><br><span class="line">     redisTemplate.opsForValue().setBit(keySign, userId &amp; <span class="number">0xffff</span>, <span class="keyword">true</span>);</span><br><span class="line">     System.out.println(<span class="string">&quot;是否签到：&quot;</span> + redisTemplate.opsForValue().getBit(keySign, userId &amp; <span class="number">0xffff</span>));</span><br><span class="line">     System.out.println(<span class="string">&quot;是否签到：&quot;</span> + redisTemplate.opsForValue().getBit(keySign, (userId + <span class="number">1</span>) &amp; <span class="number">0xffff</span>));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h3 id="测试-Lua"><a href="#测试-Lua" class="headerlink" title="测试 Lua"></a>测试 Lua</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testLua</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User songyangJi = <span class="keyword">new</span> User(<span class="number">12345L</span>, <span class="string">&quot;SongyangJi&quot;</span>, <span class="number">18</span>, <span class="number">73.5</span>, <span class="number">0</span>, LocalDate.now().minusDays(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">final</span> String user_hash_key = <span class="string">&quot;user&quot;</span>;</span><br><span class="line">    <span class="comment">// 使用Hash结构，map传入</span></span><br><span class="line">    redisTemplate.opsForHash().putAll(user_hash_key + <span class="string">&quot;:&quot;</span> + songyangJi.getUserId(), BeanAndMapConvertUtil.beanToMap(songyangJi));</span><br><span class="line">    System.out.println(redisTemplate.opsForHash().entries(user_hash_key + <span class="string">&quot;:&quot;</span> + songyangJi.getUserId()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造 lua脚本</span></span><br><span class="line">    DefaultRedisScript&lt;String&gt; script = <span class="keyword">new</span> DefaultRedisScript&lt;&gt;();</span><br><span class="line">    script.setLocation(<span class="keyword">new</span> ClassPathResource(<span class="string">&quot;lua-script/user-sign.lua&quot;</span>)); <span class="comment">// 设置脚本所在位置，也可以直接把脚本内容放在字符串里</span></span><br><span class="line">    script.setResultType(String.class); <span class="comment">// 必须设置返回值类型（否则 execute 返回值为 null ）</span></span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; keys = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    keys.add(String.valueOf(songyangJi.getUserId()));</span><br><span class="line">    keys.add(LocalDate.now().toString());</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;签到成功与否：&quot;</span>+redisTemplate.execute(script, keys));</span><br><span class="line">    System.out.println(<span class="string">&quot;签到成功与否：&quot;</span>+redisTemplate.execute(script, keys));</span><br><span class="line">    System.out.println(redisTemplate.opsForHash().entries(user_hash_key + <span class="string">&quot;:&quot;</span> + songyangJi.getUserId()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>resources/lua-script/user-sign.lua</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> score = redis.call(<span class="string">&#x27;hget&#x27;</span>, <span class="string">&#x27;user:&#x27;</span> .. KEYS[<span class="number">1</span>], <span class="string">&#x27;score&#x27;</span>)</span><br><span class="line"><span class="keyword">local</span> day = redis.call(<span class="string">&#x27;hget&#x27;</span>, <span class="string">&#x27;user:&#x27;</span> .. KEYS[<span class="number">1</span>], <span class="string">&#x27;lastSignDay&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> (day == KEYS[<span class="number">2</span>]) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    redis.call(<span class="string">&#x27;hset&#x27;</span>, <span class="string">&#x27;user:&#x27;</span> .. KEYS[<span class="number">1</span>], <span class="string">&#x27;score&#x27;</span>, score + <span class="number">1</span>, <span class="string">&#x27;lastSignDay&#x27;</span>, KEYS[<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 在 lua 中数组的索引从 1 开始</span></span><br></pre></td></tr></table></figure>







<blockquote>
<p> 附录</p>
</blockquote>
<p>Code:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LearnRedisSpringbootApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flushDB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(redisTemplate.getConnectionFactory()).getConnection().flushAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        flushDB();</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;str_key&quot;</span>, <span class="string">&quot;hello_world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testBeanAndHash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        flushDB();</span><br><span class="line"></span><br><span class="line">        User songyangJi = <span class="keyword">new</span> User(<span class="number">12345L</span>, <span class="string">&quot;SongyangJi&quot;</span>, <span class="number">18</span>, <span class="number">73.5</span>, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">final</span> String user_hash_key = <span class="string">&quot;user_hash&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> String user_json_key = <span class="string">&quot;user_json&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------ 使用 Hash 存储对象 ------&quot;</span>);</span><br><span class="line">        <span class="comment">// 使用Hash结构，map传入</span></span><br><span class="line">        redisTemplate.opsForHash().putAll(user_hash_key + <span class="string">&quot;:&quot;</span> + songyangJi.getUserId(), BeanAndMapConvertUtil.beanToMap(songyangJi));</span><br><span class="line"></span><br><span class="line">        BoundHashOperations hashOs = redisTemplate.boundHashOps(user_hash_key + <span class="string">&quot;:&quot;</span> + songyangJi.getUserId());</span><br><span class="line">        System.out.println(hashOs.get(<span class="string">&quot;userId&quot;</span>));</span><br><span class="line">        System.out.println(hashOs.get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        hashOs.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;gong chen bo&quot;</span>);</span><br><span class="line">        hashOs.increment(<span class="string">&quot;age&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(hashOs.keys());</span><br><span class="line">        System.out.println(hashOs.values());</span><br><span class="line">        System.out.println(hashOs.entries());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------- 使用 Json 存储对象 -------&quot;</span>);</span><br><span class="line">        redisTemplate.opsForValue().set(user_json_key + <span class="string">&quot;:&quot;</span> + songyangJi.getUserId(), JsonUtil.stringfy(songyangJi));</span><br><span class="line">        User u = JsonUtil.parse((String) redisTemplate.opsForValue().get(user_json_key + <span class="string">&quot;:&quot;</span> + songyangJi.getUserId()), User.class);</span><br><span class="line">        System.out.println(u);</span><br><span class="line">        u.setName(<span class="string">&quot;gong chen bo&quot;</span>);</span><br><span class="line">        BoundValueOperations valueOps = redisTemplate.boundValueOps(user_json_key + <span class="string">&quot;:&quot;</span> + songyangJi.getUserId());</span><br><span class="line">        valueOps.set(JsonUtil.stringfy(u));</span><br><span class="line">        System.out.println(redisTemplate.opsForValue().get(user_json_key + <span class="string">&quot;:&quot;</span> + songyangJi.getUserId()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testBitMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        flushDB();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 示例：使用BitMap记录用户本周是否有签到</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> userId = <span class="keyword">new</span> Random().nextLong();</span><br><span class="line">        <span class="comment">// final long userId = 1L;</span></span><br><span class="line">        <span class="comment">// userId高48位用于将用户划分到不同的key，低16位作为位图偏移参数offset;</span></span><br><span class="line">        String keySign = <span class="string">&quot;user:sign:&quot;</span> + LocalDate.now().getDayOfWeek() + <span class="string">&quot;:&quot;</span> + (userId &gt;&gt; <span class="number">16</span>);</span><br><span class="line">        <span class="comment">// offset参数必须大于或等于0，小于2^32(bit 映射被限制在 512 MB 之内)</span></span><br><span class="line">        redisTemplate.opsForValue().setBit(keySign, userId &amp; <span class="number">0xffff</span>, <span class="keyword">true</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否签到：&quot;</span> + redisTemplate.opsForValue().getBit(keySign, userId &amp; <span class="number">0xffff</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;是否签到：&quot;</span> + redisTemplate.opsForValue().getBit(keySign, (userId + <span class="number">1</span>) &amp; <span class="number">0xffff</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testHyperLogLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        flushDB();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用HyperLogLog统计每天登录的用户量</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> userId = <span class="keyword">new</span> Random().nextLong();</span><br><span class="line"><span class="comment">//        final long userId = 1L;</span></span><br><span class="line">        HyperLogLogOperations hyperLogLog = redisTemplate.opsForHyperLogLog();</span><br><span class="line">        String key = <span class="string">&quot;user:login:number:&quot;</span> + LocalDate.now();</span><br><span class="line">        hyperLogLog.add(key, userId);</span><br><span class="line">        System.out.println(hyperLogLog.size(key));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testLua</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        flushDB();</span><br><span class="line"></span><br><span class="line">        User songyangJi = <span class="keyword">new</span> User(<span class="number">12345L</span>, <span class="string">&quot;SongyangJi&quot;</span>, <span class="number">18</span>, <span class="number">73.5</span>, <span class="number">0</span>, LocalDate.now().minusDays(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">final</span> String user_hash_key = <span class="string">&quot;user&quot;</span>;</span><br><span class="line">        <span class="comment">// 使用Hash结构，map传入</span></span><br><span class="line">        redisTemplate.opsForHash().putAll(user_hash_key + <span class="string">&quot;:&quot;</span> + songyangJi.getUserId(), BeanAndMapConvertUtil.beanToMap(songyangJi));</span><br><span class="line">        System.out.println(redisTemplate.opsForHash().entries(user_hash_key + <span class="string">&quot;:&quot;</span> + songyangJi.getUserId()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造 lua脚本</span></span><br><span class="line">        DefaultRedisScript&lt;String&gt; script = <span class="keyword">new</span> DefaultRedisScript&lt;&gt;();</span><br><span class="line">        script.setLocation(<span class="keyword">new</span> ClassPathResource(<span class="string">&quot;lua-script/user-sign.lua&quot;</span>)); <span class="comment">// 设置脚本所在位置，也可以直接把脚本内容放在字符串里</span></span><br><span class="line">        script.setResultType(String.class); <span class="comment">// 必须设置返回值类型（否则 execute 返回值为 null ）</span></span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; keys = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        keys.add(String.valueOf(songyangJi.getUserId()));</span><br><span class="line">        keys.add(LocalDate.now().toString());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;签到成功与否：&quot;</span>+redisTemplate.execute(script, keys));</span><br><span class="line">        System.out.println(<span class="string">&quot;签到成功与否：&quot;</span>+redisTemplate.execute(script, keys));</span><br><span class="line">        System.out.println(redisTemplate.opsForHash().entries(user_hash_key + <span class="string">&quot;:&quot;</span> + songyangJi.getUserId()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
        <tag>Redis</tag>
        <tag>SpringBoot 集成一切</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC 常用注解</title>
    <url>/2021/04/02/SpringMVC%20%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a>@Controller</h1><p><code>@Controller</code> 用于标记在一个类上，使用它标记的类就是一个SpringMVC Controller 对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了@RequestMapping 注解。<br><strong>@Controller 只是定义了一个控制器类，而使用@RequestMapping 注解的方法才是真正处理请求的处理器。</strong></p>
<h2 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h2><p>一般我们直接把这个注解加上控制类上，既声明这是一个控制类，也将对象转成json格式传给前端。</p>
<p><code>@RestController</code>  = <code>@Controller</code> + <code>@ResponseBody</code></p>
<h1 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h1><h2 id="URL匹配"><a href="#URL匹配" class="headerlink" title="URL匹配"></a>URL匹配</h2><p>@RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。</p>
<p>通过类路径和方法路径结合访问controller方法</p>
<blockquote>
<p>当@RequestMapping 标记在Controller 类上的时候，里面使用@RequestMapping<br>标记的方法的请求地址都是相对于类上的@RequestMapping 而言的；当Controller<br>类上没有标记@RequestMapping 注解时，方法上的@RequestMapping<br>都是绝对路径。这种绝对路径和相对路径所组合成的最终路径都是相对于根路径“/ ”而言的。</p>
</blockquote>
<p>总之，这个注解的作用是完成了 <strong>url到控制器方法</strong>的映射。</p>
<ul>
<li>常规使用：类路径+方法路径<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="comment">// 这个注解在返回非视图的对象时使用</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/name&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;jsy&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/age&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">age</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">18</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
启动服务器后，访问 <a href="http://localhost:8080/user/name">http://localhost:8080/user/name</a> 。</li>
</ul>
<ul>
<li><p><strong>URL模板</strong><br>为了取出URL模板中的 参数，需要使用<code>@PathVariable</code>注解，下面会细讲。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="comment">// 这个注解在返回非视图的对象时使用</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/name/&#123;p1&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">(<span class="meta">@PathVariable</span> String p1)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我叫&quot;</span>+p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>正则匹配</strong><br>举一个最简单的例子：通配符<code>*</code><br>如<code>@RequestMapping(&quot;*/user/&quot;)</code>会匹配到<code>/test/user/</code>等等。</p>
</li>
</ul>
<h2 id="value和method属性"><a href="#value和method属性" class="headerlink" title="value和method属性"></a>value和method属性</h2><ul>
<li><strong>value</strong><br>  指定请求的实际地址，指定的地址可以是URI Template 模式</li>
<li><strong>method</strong><br>  指定请求的method类型， GET、POST、PUT、DELETE等。也就是<strong>窄化了请求范围</strong> </li>
</ul>
<h2 id="GetMapping、-PostMapping"><a href="#GetMapping、-PostMapping" class="headerlink" title="@GetMapping、@PostMapping"></a>@GetMapping、@PostMapping</h2><p>根据上面的<code>method</code>属性，可以直接使用<code>@RequestMapping</code>的衍生注解：</p>
<ul>
<li>@GetMapping 等同于 @RequestMapping(method = RequestMethod.GET)</li>
<li>@PostMapping 等同于 @RequestMapping(method = RequestMethod.POST)</li>
<li>@PutMapping 等同于 @RequestMapping(method = RequestMethod.PUT)</li>
<li>@DeleteMapping 等同于 @RequestMapping(method = RequestMethod.DELETE)</li>
<li>@PatchMapping 等同于 @RequestMapping(method = RequestMethod.PATCH)<br>等等。</li>
</ul>
<h1 id="获取参数"><a href="#获取参数" class="headerlink" title="获取参数"></a>获取参数</h1><h2 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h2><p><strong>用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="comment">// 这个注解在返回非视图的对象时使用</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/name/&#123;p1&#125;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">(<span class="meta">@PathVariable(&quot;p1&quot;)</span> String p,<span class="meta">@PathVariable</span> <span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我叫&quot;</span>+p+<span class="string">&quot;,学号是&quot;</span>+id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意点，如果所需要使用的变量名跟参数名不相同的时候，就要明确指出使用的是URI 模板中的哪个变量!</p>
<h2 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h2><p>默认会将post请求中body中的json串反序列话为实体类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/student&quot;)</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(<span class="meta">@RequestBody</span> Student student)</span> </span>&#123;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h2 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h2><p>这就是 GET请求的 query-string的格式，形如： <strong>?name1=value1&amp;name2=value2</strong>。</p>
<p>@RequestParam就是用来提取中其中的值的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/student&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Student <span class="title">get</span><span class="params">(<span class="meta">@RequestParam</span> String name, <span class="meta">@RequestParam</span> <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码解析1</title>
    <url>/2021/10/15/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%901/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>为了减少篇幅，以及尽可能介绍核心，在贴出代码的时候只节选部分。完整代码请参阅官方文档。</p>
</blockquote>
<h1 id="顶层设计"><a href="#顶层设计" class="headerlink" title="顶层设计"></a>顶层设计</h1><ol>
<li>如何表示对象与对象之间的关系</li>
<li>描述对象的文件存放在哪里</li>
<li>如何统一一个关于对象的定义</li>
<li>如何对不同的配置文件进行解析</li>
</ol>
<p>IOC的实现方式：</p>
<p>依赖注入（DI）、依赖查找（不再使用）</p>
<h1 id="源码类图"><a href="#源码类图" class="headerlink" title="源码类图"></a>源码类图</h1><h2 id="BeanFactory（存放Bean的容器）"><a href="#BeanFactory（存放Bean的容器）" class="headerlink" title="BeanFactory（存放Bean的容器）"></a>BeanFactory（存放Bean的容器）</h2><blockquote>
<p><strong>访问 Spring bean 容器的根接口</strong>。<br>该接口的实现类包含一个bean的注册表，每个bean定义由一个字符串名称唯一标识。 根<br>据 bean 定义，工厂将返回包含对象的独立实例（原型设计模式），或单个共享实例（单例设计模式的高级替代方案，其中实例是范围内的单例）工厂）。 返回哪种类型的实例取决于 bean factory 配置：API 是相同的。<br>这种方法的重点是 BeanFactory 是应用程序组件的中央注册表，并且集中了应用程序组件的配置（例如，单个对象不再需要读取属性文件）。<br><strong>Spring 的依赖注入功能是使用这个 BeanFactory 接口及其子接口实现的</strong>。<br>通常 BeanFactory 将加载存储在配置源（例如 XML ）中的 bean 定义，并使用org.springframework.beans包来配置 bean。 但是，实现可以简单地直接在 Java 代码中返回它根据需要创建的 Java 对象。 定义的存储方式没有限制：LDAP、RDBMS、XML、属性文件等。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 根据 bean 名称获取 bean</span></span><br><span class="line">   <span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">   &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">   &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">   &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">   <span class="comment">// 判断bean是否存在</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(String name)</span></span>;</span><br><span class="line">   <span class="comment">// bean的作用域</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>源码类图</p>
<p><img src="/BeanFactory.png"></p>
<ul>
<li>ListableBeanFactory</li>
</ul>
<p>将所有bean列表化提供。（换言之，可以一下子获取所有bean）。</p>
<ul>
<li>HierarchicalBeanFactory</li>
</ul>
<p>描述有继承关系的bean。</p>
<ul>
<li>AutowireCapableBeanFactory</li>
</ul>
<p>定义bean的自动装配规则。这个类比较重要，看看它的源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AutowireCapableBeanFactory</span> <span class="keyword">extends</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 自动配置的方式</span></span><br><span class="line">   <span class="keyword">int</span> AUTOWIRE_NO = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> AUTOWIRE_BY_NAME = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">int</span> AUTOWIRE_BY_TYPE = <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">int</span> AUTOWIRE_CONSTRUCTOR = <span class="number">3</span>;</span><br><span class="line">   <span class="meta">@Deprecated</span></span><br><span class="line">   <span class="keyword">int</span> AUTOWIRE_AUTODETECT = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 创建一个新的bean  </span></span><br><span class="line">   &lt;T&gt; <span class="function">T <span class="title">createBean</span><span class="params">(Class&lt;T&gt; beanClass)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 自动装配benan</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">autowireBean</span><span class="params">(Object existingBean)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">   <span class="function">Object <span class="title">configureBean</span><span class="params">(Object existingBean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">   <span class="function">Object <span class="title">initializeBean</span><span class="params">(Object existingBean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// ....</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="BeanDefinition（Bean的统一定义）"><a href="#BeanDefinition（Bean的统一定义）" class="headerlink" title="BeanDefinition（Bean的统一定义）"></a>BeanDefinition（Bean的统一定义）</h2><ul>
<li>AttributeAccessor</li>
</ul>
<p>基于反射的方式，对一个bean根据属性名，对属性值的CRUD操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AttributeAccessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(String name, <span class="meta">@Nullable</span> Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function">Object <span class="title">getAttribute</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function">Object <span class="title">removeAttribute</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">hasAttribute</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">   String[] attributeNames();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>BeanDefinition 描述了一个 bean 实例，而那个bean具有属性值、构造函数参数值以及由具体实现提供的更多信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinition</span> <span class="keyword">extends</span> <span class="title">AttributeAccessor</span>, <span class="title">BeanMetadataElement</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 作用域</span></span><br><span class="line">   String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;</span><br><span class="line">   String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   <span class="comment">// get/set bean的类名</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setBeanClassName</span><span class="params">(<span class="meta">@Nullable</span> String beanClassName)</span></span>;</span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function">String <span class="title">getBeanClassName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// @Scope(&quot;singleton&quot;) / @Scope(&quot;prototype&quot;) 可以指定</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setScope</span><span class="params">(<span class="meta">@Nullable</span> String scope)</span></span>;</span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function">String <span class="title">getScope</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">   <span class="comment">// @Lazy 指定是否延迟初始化</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setLazyInit</span><span class="params">(<span class="keyword">boolean</span> lazyInit)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isLazyInit</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">   <span class="comment">//  bean 所依赖的 bean 名称</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setDependsOn</span><span class="params">(<span class="meta">@Nullable</span> String... dependsOn)</span></span>;</span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   String[] getDependsOn();</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// @Primary 指定</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setPrimary</span><span class="params">(<span class="keyword">boolean</span> primary)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isPrimary</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// @PostConstruct指定初始化方法</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setInitMethodName</span><span class="params">(<span class="meta">@Nullable</span> String initMethodName)</span></span>;</span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function">String <span class="title">getInitMethodName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// @PreDestroy指定销毁方法</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setDestroyMethodName</span><span class="params">(<span class="meta">@Nullable</span> String destroyMethodName)</span></span>;</span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function">String <span class="title">getDestroyMethodName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 单例 or 原型</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring核心</tag>
        <tag>JavaEE</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/12/03/TCP-2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>title: TCP —— 重传机制、流量控制、拥塞控制<br>date: 2021-12-03 08:15:09<br>categories: 计算机网络<br>tags:</p>
<ul>
<li>TCP</li>
</ul>
<h2 id="TCP-是如何保证可靠性的"><a href="#TCP-是如何保证可靠性的" class="headerlink" title="TCP 是如何保证可靠性的"></a>TCP 是如何保证可靠性的</h2><ul>
<li>数据分块：应用数据被分割成 TCP 认为最适合发送的数据块。</li>
<li>序列号和确认应答：TCP 给发送的每一个包进行编号，在传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答，即发送 ACK 报文，这个 ACK 报文当中带有对应的确认序列号，告诉发送方成功接收了哪些数据以及下一次的数据从哪里开始发。除此之外，接收方可以根据序列号对数据包进行排序，把有序数据传送给应用层，并丢弃重复的数据。</li>
<li>校验和： TCP 将保持它首部和数据部分的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到报文段的检验和有差错，TCP 将丢弃这个报文段并且不确认收到此报文段。</li>
<li>流量控制： TCP 连接的双方都有一个固定大小的缓冲空间，发送方发送的数据量不能超过接收端缓冲区的大小。当接收方来不及处理发送方的数据，会提示发送方降低发送的速率，防止产生丢包。TCP 通过滑动窗口协议来支持流量控制机制。</li>
<li>拥塞控制： 当网络某个节点发生拥塞时，减少数据的发送。</li>
<li>ARQ协议： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>
<li>超时重传： 当 TCP 发出一个报文段后，它启动一个定时器，等待目的端确认收到这个报文段。如果超过某个时间还没有收到确认，将重发这个报文段。</li>
</ul>
<h2 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h2><p>TCP 实现可靠传输的⽅式之⼀，是通过序列号与确认应答。</p>
<p>在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回⼀个确认应答消息，表示已收到消息</p>
<p>所以 TCP 针对数据包丢失的情况，会⽤重传机制解决。</p>
<p>接下来说说常⻅的重传机制：</p>
<ul>
<li><p>超时重传</p>
</li>
<li><p>快速重传</p>
</li>
<li><p>SACK</p>
</li>
<li><p>D-SACK</p>
</li>
</ul>
<h3 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h3><p>重传机制的其中⼀个⽅式，就是在发送数据时，设定⼀个定时器，当超过指定的时间后，没有收到对⽅的 ACK</p>
<p>确认应答报⽂，就会重发该数据，也就是我们常说的超时重传。</p>
<p>TCP 会在以下两种情况发⽣超时重传：</p>
<ol>
<li><p>数据包丢失</p>
</li>
<li><p>确认应答丢失</p>
</li>
</ol>
<img src="rtt.png" style="zoom:60%;" />





<p>RTT （Round-Trip Time 往返时延）</p>
<p>RTT 就是数据从⽹络⼀端传送到另⼀端所需的时间，也就是包的往返时间。</p>
<p>超时重传时间是以 RTO （Retransmission Timeout 超时重传时间）表示。</p>
<p>当超时时间 <strong>RTO</strong> 较⼤时，重发就慢，丢了⽼半天才重发，没有效率，性能差；</p>
<p>当超时时间 <strong>RTO</strong> 较⼩时，会导致可能并没有丢就重发，于是重发的就快，会增加⽹络拥塞，导致更多的超</p>
<p>时，更多的超时导致更多的重发。</p>
<p>所以<strong>精确的测量超时时间 RTO 的值是⾮常重要的</strong>，这可让我们的重传机制更⾼效。</p>
<p>根据上述的两种情况，我们可以得知，<strong>超时重传时间RTO的值应该略⼤于报⽂往返RTT的值</strong>。</p>
<p>实际上「报⽂往返 RTT 的值」是经常变化的，因为我们的⽹络也是时常变化的。也就因为「报⽂往返 RTT 的值」</p>
<p>是经常波动变化的，所以「超时重传时间 RTO 的值」应该是⼀个动态变化的值。</p>
<p>我们来看看 Linux 是如何计算 RTO 的呢？</p>
<p>估计往返时间，通常需要采样以下两个：</p>
<ul>
<li>需要 TCP 通过<strong>采样 RTT 的时间，然后进⾏加权平均，算出⼀个平滑 RTT 的值</strong>，⽽且这个值还是要不断变化</li>
</ul>
<p>的，因为⽹络状况不断地变化。</p>
<ul>
<li>除了采样 RTT，还要采样 <strong>RTT 的波动范围</strong>，这样就避免如果 RTT 有⼀个⼤的波动的话，很难被发现的情况。</li>
</ul>
<p>RFC6289 建议使⽤以下的公式计算 RTO：</p>
<img src="rto.png" style="zoom:50%;" />



<p>如果超时重发的数据，<strong>再次超时的时候，⼜需要重传的时候，TCP 的策略是超时间隔加倍</strong>。</p>
<p>也就是每当遇到⼀次超时重传的时候，都会将下⼀次超时时间间隔设为先前值的两倍。两次超时，就说明⽹络环境差，不宜频繁反复发送。</p>
<h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><p>TCP 还有另外⼀种快速重传（<strong>Fast Retransmit</strong>）机制，它<strong>不以时间为驱动，⽽是以数据驱动重传</strong>。</p>
<img src="fast-retransmission.png" style="zoom:80%;" />



<blockquote>
<p>在上图，发送⽅发出了 1，2，3，4，5 份数据：</p>
<ol>
<li>第⼀份 Seq1 先送到了，于是就 Ack 回 2；</li>
<li>结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；</li>
<li>后⾯的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；</li>
<li>发送端收到了三个 <strong>Ack = 2</strong> 的确认，知道了 <strong>Seq2</strong> 还没有收到，就会在定时器过期之前，重传丢失的 <strong>Seq2</strong>。</li>
<li>最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。</li>
</ol>
</blockquote>
<p>快速重传的⼯作⽅式是<strong>当收到三个相同的 ACK 报⽂时，会在定时器过期之前，重传丢失的报⽂段</strong>。</p>
<h3 id="SACK"><a href="#SACK" class="headerlink" title="SACK"></a>SACK</h3><p>为了解决不知道该重传哪些 TCP 报⽂，于是就有 SACK ⽅法。 <strong>SACK （ Selective Acknowledgment 选择性确认）</strong>。</p>
<p>这种⽅式需要在 TCP 头部「选项」字段⾥加⼀个 SACK 的字段，它可以<strong>将缓存的区间发送给发送⽅，这样发送</strong></p>
<p><strong>⽅就可以知道哪些数据收到了，哪些数据没收到</strong>，知道了这些信息，就可以只重传丢失的数据。</p>
<p><img src="/2021/12/03/TCP-2/sack.png"></p>
<p>如上图，发送⽅收到了三次同样的 ACK 确认报⽂，于是就会触发快速重发机制，通过 SACK 信息发现只有</p>
<p>200~299 这段数据丢失，则重发时，就只选择了这个 TCP 段进⾏重复。</p>
<h3 id="Duplicate-SACK"><a href="#Duplicate-SACK" class="headerlink" title="Duplicate SACK"></a>Duplicate SACK</h3><p>使⽤了 SACK 来告诉「发送⽅」有哪些数据被重复接收了。</p>
<p>具体的，就是当 ACK大于sack选项的区间时，表明收到了重复的包。</p>
<p>可⻅， D-SACK 有这么⼏个好处：</p>
<ol>
<li><p>可以让「发送⽅」知道，是发出去的包丢了，还是接收⽅回应的 ACK 包丢了;</p>
</li>
<li><p>可以知道是不是「发送⽅」的数据包被⽹络延迟了;</p>
</li>
<li><p>可以知道⽹络中是不是把「发送⽅」的数据包给复制了; </p>
</li>
</ol>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>停等式发送与接收的方式的缺点是：数据包的往返时间越⻓，通信的效率就越低。</p>
<p>为解决这个问题，TCP 引⼊了窗⼝这个概念。即使在往返时间较⻓的情况下，它也不会降低⽹络通信的效率。</p>
<p>那么有了窗⼝，就可以指定<strong>窗⼝⼤⼩</strong>，窗⼝⼤⼩就是指<strong>⽆需等待确认应答，⽽可以继续发送数据的最⼤值</strong>。</p>
<blockquote>
<p><strong>UDP 为什么是不可靠的？</strong><br>UDP 只有一个 socket 接收缓冲区，没有 socket 发送缓冲区，即只要有数据就发，不管对方是否可以正确接收。而在<strong>对方的 socket 接收缓冲区满了之后，新来的数据报无法进入到 socket 接受缓冲区，此数据报就会被丢弃</strong>，因此 UDP 不能保证数据能够到达目的地，此外，<strong>UDP 也没有流量控制和重传机制</strong>，故UDP的数据传输是不可靠的。</p>
</blockquote>
<h3 id="操作系统缓冲区与滑动窗⼝的关系"><a href="#操作系统缓冲区与滑动窗⼝的关系" class="headerlink" title="操作系统缓冲区与滑动窗⼝的关系"></a>操作系统缓冲区与滑动窗⼝的关系</h3><p><strong>窗⼝的实现实际上是操作系统开辟的⼀个缓存空间</strong>，<strong>发送⽅主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据</strong>。<strong>如果按期收到确认应答，此时数据就可以从缓存区清除</strong>。</p>
<p>前面我们假定了发送窗⼝和接收窗⼝是不变的，但是实际上，发送窗⼝和接收窗⼝中所存放的字节数，都是放在操作系统内存缓冲区中的，⽽<strong>操作系统的缓冲区，会被操作系统调整</strong>。</p>
<p><strong>当应⽤进程没办法及时读取缓冲区的内容时，也会对我们的缓冲区造成影响</strong>。</p>
<img src="sum-ack.png" style="zoom:80%;" />



<p>图中的 ACK 600 确认应答报⽂丢失，也没关系，因为可以通过下⼀个确认应答进⾏确认，只要发送⽅收到了 ACK</p>
<p>700 确认应答，就意味着 700 之前的所有数据「接收⽅」都收到了。这个模式就叫<strong>累计确认</strong>或者<strong>累计应答</strong>。</p>
<h3 id="窗口大小的协商"><a href="#窗口大小的协商" class="headerlink" title="窗口大小的协商"></a>窗口大小的协商</h3><p>TCP 头⾥有⼀个字段叫 Window ，也就是窗⼝⼤⼩。</p>
<p>这个字段是<strong>接收端告诉发送端⾃⼰还有多少缓冲区可以接收数据</strong>。于是发送端就可以根据这个接收端的处理能⼒来</p>
<p>发送数据，⽽不会导致接收端处理不过来。</p>
<p>所以，<strong>通常窗⼝的⼤⼩是由接收⽅的窗⼝⼤⼩来决定的</strong>。<strong>发送⽅发送的数据⼤⼩不能超过接收⽅的窗⼝⼤⼩，否则接收⽅就⽆法正常接收到数据。</strong>（虽然超过对端的窗口大小导致没有收到ACK，最终也会触发超时重传的，但是会导致网络的拥塞）。</p>
<p><strong>接收窗⼝和发送窗⼝的⼤⼩是相等的吗？</strong></p>
<p>并不是完全相等，接收窗⼝的⼤⼩是约等于发送窗⼝的⼤⼩的。</p>
<p>因为滑动窗⼝并不是⼀成不变的。⽐如，当接收⽅的应⽤进程读取数据的速度⾮常快的话，这样的话接收窗⼝可以</p>
<p>很快的就空缺出来。那么新的接收窗⼝⼤⼩，是通过 TCP 报⽂中的 Windows 字段来告诉发送⽅。那么这个传输过程是存在时延的，所以接收窗⼝和发送窗⼝是约等于的关系。</p>
<h3 id="发送⽅的滑动窗⼝"><a href="#发送⽅的滑动窗⼝" class="headerlink" title="发送⽅的滑动窗⼝"></a>发送⽅的滑动窗⼝</h3><p>我们先来看看发送⽅的窗⼝，下图就是发送⽅缓存的数据，根据处理的情况分成四个部分，其中深蓝⾊⽅框是发送</p>
<p>窗⼝，紫⾊⽅框是可⽤窗⼝：</p>
<p><img src="/2021/12/03/TCP-2/window1.png"></p>
<ul>
<li>#1 是<strong>已发送并收到 ACK确认</strong>的数据：1~31 字节</li>
<li>#2 是<strong>已发送但未收到 ACK确认</strong>的数据：32~45 字节</li>
<li>#3 是<strong>未发送但总⼤⼩在接收⽅处理范围内</strong>（接收⽅还有空间）：46~51字节</li>
<li>#4 是<strong>未发送但总⼤⼩超过接收⽅处理范围</strong>（接收⽅没有空间）：52字节以后</li>
</ul>
<h3 id="接收⽅的滑动窗⼝"><a href="#接收⽅的滑动窗⼝" class="headerlink" title="接收⽅的滑动窗⼝"></a>接收⽅的滑动窗⼝</h3><p>接下来我们看看接收⽅的窗⼝，接收窗⼝相对简单⼀些，根据处理的情况划分成三个部分：</p>
<p><img src="/2021/12/03/TCP-2/window2.png"></p>
<ul>
<li>#1 + #2 是<strong>已成功接收并确认的数据</strong>（等待应⽤进程读取）；</li>
<li>#3 是<strong>未收到数据但可以接收的数据；</strong></li>
<li>#4 是<strong>未收到数据并不可以接收的数据</strong>；</li>
</ul>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>发送⽅不能没有限制地发数据给接收⽅，要考虑接收⽅处理能⼒。</p>
<p>如果⼀直⽆脑的发数据给对⽅，但对⽅处理不过来，那么就会导致触发重发机制，从⽽导致⽹络流量的⽆端的浪费。</p>
<p>为了解决这种现象发⽣，<strong>TCP</strong> 提供⼀种机制可以<strong>让「发送⽅」根据「接收⽅」的实际接收能⼒控制发送的数据量</strong>，这就是所谓的<strong>流量控制</strong>。</p>
<p>使用滑动窗口来做到流量控制，这部内容在上面已经得到很好的描述了。</p>
<h3 id="窗⼝关闭"><a href="#窗⼝关闭" class="headerlink" title="窗⼝关闭"></a>窗⼝关闭</h3><p>在前⾯我们都看到了，TCP 通过让接收⽅指明希望从发送⽅接收的数据⼤⼩（窗⼝⼤⼩）来进⾏流量控制。<br>如果窗⼝⼤⼩为 0 时，就会阻⽌发送⽅给接收⽅传递数据，直到窗⼝变为⾮ 0 为⽌，这就是窗⼝关闭。</p>
<p><strong>窗⼝关闭潜在的危险</strong></p>
<p><strong>接收⽅向发送⽅通告窗⼝⼤⼩时，是通过 ACK 报⽂来通告的</strong>。</p>
<p>那么，当发⽣窗⼝关闭时，接收⽅处理完数据后，会向发送⽅通告⼀个窗⼝⾮ 0 的 ACK 报⽂，如果这个通告窗⼝的 ACK 报⽂在⽹络中丢失了，那麻烦就⼤了。</p>
<img src="window-closed.png" style="zoom:67%;" />



<p>这会导致<strong>发送⽅⼀直等待接收⽅的⾮ 0 窗⼝通知</strong>，接收⽅也⼀直等待发送⽅的数据，如不采取措施，这种相互等待的过程，会造成了死锁的现象。</p>
<p>为了解决这个问题，TCP 为每个连接设有⼀个持续定时器，只要 <strong>TCP</strong> 连接⼀⽅收到对⽅的零窗⼝通知，就启动持续计时器。</p>
<p>如果持续计时器超时，就会发送窗⼝探测 <strong>( Window probe )</strong> 报⽂，⽽对⽅在确认这个探测报⽂时，给出⾃⼰现在的接收窗⼝⼤⼩。</p>
<p><img src="/2021/12/03/TCP-2/window-probe.png"></p>
<p>窗⼝探测的次数⼀般为 3 次，每次⼤约 30-60 秒（不同的实现可能会不⼀样）。如果 3 次过后接收窗⼝还是 0 的话，<strong>有的 TCP 实现就会发 RST 报⽂来中断连接</strong>。</p>
<h3 id="低能窗口综合征"><a href="#低能窗口综合征" class="headerlink" title="低能窗口综合征"></a>低能窗口综合征</h3><p>如果接收⽅太忙了，来不及取⾛接收窗⼝⾥的数据，那么就会导致发送⽅的发送窗⼝越来越⼩。</p>
<p>到最后，<strong>如果接收⽅腾出⼏个字节并告诉发送⽅现在有⼏个字节的窗⼝，⽽发送⽅会义⽆反顾地发送这⼏个字节</strong>，</p>
<p>这就是低能窗⼝综合症。</p>
<p>要知道，我们的 TCP + IP 头有 40 个字节，为了传输那⼏个字节的数据，要达上这么⼤的开销，这太不经济</p>
<p>了。</p>
<p>所以，低能窗⼝综合症的现象是可以发⽣在发送⽅和接收⽅：</p>
<ol>
<li><p>接收⽅可以通告⼀个⼩的窗⼝；</p>
</li>
<li><p>发送⽅可以发送⼩数据。</p>
</li>
</ol>
<p>当然解决问题的思路也从这两方面入手：</p>
<ol>
<li><strong>接收⽅不通告⼩窗⼝</strong></li>
<li><strong>发送⽅避免发送⼩数据</strong></li>
</ol>
<p><strong>接收⽅通常的策略如下</strong>:</p>
<p>当「窗⼝⼤⼩」⼩于 min( MSS，缓存空间/2 ) ，也就是<strong>当窗口大小⼩于 MSS 与 1/2 缓存⼤⼩中的最⼩值时，就会向发送⽅通告窗⼝为 0</strong> ，也就阻⽌了发送⽅再发数据过来。</p>
<h4 id="Nagle算法"><a href="#Nagle算法" class="headerlink" title="Nagle算法"></a>Nagle算法</h4><p><strong>发送⽅通常的策略</strong></p>
<p>使⽤ Nagle 算法，该算法的思路是<strong>延时处理</strong>，它满⾜以下两个条件中的⼀条才可以发送数据：</p>
<ul>
<li><p><strong>要等到窗⼝⼤⼩ &gt;= MSS 或是数据⼤⼩ &gt;= MSS</strong> ;</p>
</li>
<li><p><strong>收到之前发送数据的 ack 回包</strong> ;</p>
</li>
</ul>
<p>只要没满⾜上⾯条件中的⼀条，发送⽅⼀直在囤积数据，直到满⾜上⾯的发送条件。</p>
<p>另外，<strong>Nagle 算法默认是打开的</strong>，如果对于⼀些需要⼩数据包交互的场景的程序，⽐如，telnet 或 ssh 这样的交互性⽐较强的程序，则需要关闭 Nagle 算法。</p>
<p>可以在 Socket 设置 <code>TCP_NODELAY</code> 选项来关闭这个算法（关闭 Nagle 算法没有全局参数，需要根据每个应⽤</p>
<p>⾃⼰的特点来关闭）</p>
<p>另外，<strong>Nagle 算法默认是打开的</strong>，如果对于⼀些需要⼩数据包交互的场景的程序，⽐如，telnet 或 ssh 这样的交互性⽐较强的程序，则需要关闭 Nagle 算法。</p>
<p>可以在 Socket 设置 <code>TCP_NODELAY</code> 选项来关闭这个算法（关闭 Nagle 算法没有全局参数，需要根据每个应⽤⾃⼰的特点来关闭）</p>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><blockquote>
<p>拥塞控制是解决网络带宽资源有限的问题，流量控制则是解决主机缓冲区有限的问题。</p>
</blockquote>
<p>在⽹络出现拥堵时，如果继续发送⼤量数据包，可能会导致数据包时延、丢失等，这时 <strong>TCP</strong> 就会重传数据，但是</p>
<p>⼀重传就会导致⽹络的负担更重，于是会导致更⼤的延迟以及更多的丢包，这个情况就会进⼊恶性循环被不断地放</p>
<p>⼤。</p>
<p>所以，TCP 不能忽略⽹络上发⽣的事，它被设计成⼀个⽆私的协议，当⽹络发送拥塞时，TCP 会⾃我牺牲，降低</p>
<p>发送的数据量。</p>
<p>于是，就有了拥塞控制，控制的⽬的就是避免「发送⽅」的数据填满整个⽹络。</p>
<h3 id="拥塞窗口"><a href="#拥塞窗口" class="headerlink" title="拥塞窗口"></a>拥塞窗口</h3><p><strong>拥塞窗⼝ <code>cwnd</code>是发送⽅维护的⼀个的状态变量</strong>，它<strong>会根据⽹络的拥塞程度动态变化</strong>的。</p>
<p>我们在前⾯提到过发送窗⼝ swnd 和接收窗⼝ rwnd 是约等于的关系，那么由于加⼊了拥塞窗⼝的概念后，此时发送窗⼝的值是**swnd = min(cwnd, rwnd)**，也就是拥塞窗⼝和接收窗⼝中的最⼩值。<br>拥塞窗⼝ cwnd 变化的规则：</p>
<ul>
<li>只要⽹络中没有出现拥塞， cwnd 就会增⼤；</li>
<li>但⽹络中出现了拥塞， cwnd 就减少；</li>
</ul>
<p><strong>那么怎么知道当前⽹络是否出现了拥塞呢？</strong></p>
<p><strong>只要「发送⽅」没有在规定时间内接收到 ACK 应答报⽂，也就是发⽣了超时重传</strong>，就会认为⽹络出现了⽤拥</p>
<p>塞。这是拥塞发生的一条很重要的前提。</p>
<h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h3><p>当发送方开始发送数据时，由于一开始不知道网络负荷情况，如果立即将大量的数据字节传输到网络中，那么就有可能引起网络拥塞。一个较好的方法是在一开始发送少量的数据先探测一下网络状况，即由小到大的增大发送窗口（拥塞窗口 cwnd）。慢开始的慢指的是初始时令 cwnd为 1，即一开始发送一个报文段。如果收到确认，则 cwnd = 2，之后每收到一个确认报文，就令 cwnd = cwnd* 2。</p>
<p>但是，为了防止拥塞窗口增长过大而引起网络拥塞，另外设置了一个<strong>慢开始门限</strong> ssthresh。⼀般来说 ssthresh 的⼤⼩是 65535 字节。</p>
<p>① <strong>当 cwnd &lt; ssthresh 时，使用上述的慢开始算法</strong>；</p>
<p>② <strong>当 cwnd &gt; ssthresh 时，停止使用慢开始，转而使用拥塞避免算法</strong>；</p>
<p>③ 当 cwnd == ssthresh 时，两者均可。</p>
<p><strong>慢启动算法</strong>，发包的个数是<strong>指数性的增⻓</strong>。</p>
<h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><p><strong>拥塞控制是为了让拥塞窗口 cwnd 缓慢地增大</strong>，即每经过一个往返时间 RTT （往返时间定义为发送方发送数据到收到确认报文所经历的时间）就把发送方的 cwnd 值加 1，<strong>通过让 cwnd 线性增长，防止很快就遇到网络拥塞状态</strong>。</p>
<p><strong>当网络拥塞发生时</strong>，<strong>让新的慢开始门限值变为发生拥塞时候的值的一半, 并将拥塞窗口置为 1</strong> , 然后再次重复两种算法（慢开始和拥塞避免）,这时一瞬间会将网络中的数据量大量降低。</p>
<h3 id="拥塞发生"><a href="#拥塞发生" class="headerlink" title="拥塞发生"></a>拥塞发生</h3><p>当⽹络出现拥塞，也就是会发⽣数据包重传，重传机制主要有两种：</p>
<ol>
<li><p>超时重传</p>
</li>
<li><p>快速重传</p>
</li>
</ol>
<h4 id="超时重传-1"><a href="#超时重传-1" class="headerlink" title="超时重传"></a>超时重传</h4><p>一旦发生超时重传，可以说是一夜回到解放前，这个时候，</p>
<ul>
<li>cwnd = 1</li>
<li>ssthresh = ssthresh / 2 ;</li>
</ul>
<p>重新开始上述过程。</p>
<h4 id="快速重传-1"><a href="#快速重传-1" class="headerlink" title="快速重传"></a>快速重传</h4><p><strong>快重传算法要求接收方每收到一个失序的报文就立即发送重复确认</strong>，<strong>不必等待超时再重传</strong>。</p>
<p>TCP 认为这种情况不严重，因为⼤部分没丢，只丢了⼀⼩部分，则 ssthresh 和 cwnd 变化如下：</p>
<ul>
<li><p>cwnd = cwnd/2 ，也就是设置为原来的⼀半;</p>
</li>
<li><p>ssthresh = cwnd ;</p>
</li>
<li><p>进⼊快速恢复算法</p>
</li>
</ul>
<h3 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h3><p><strong>快恢复算法是和快重传算法配合使用</strong>的，该算法主要有以下两个要点：</p>
<p>① <strong>当发送方连续收到三个重复确认</strong>，执行乘法减小，慢开始门限 ssthresh 值减半；</p>
<p>② 由于发送方可能认为网络现在没有拥塞，因此与慢开始不同，<strong>把 cwnd 值设置为 ssthresh 减半之后的值，然后执行拥塞避免算法，线性增大 cwnd</strong>。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2021/12/03/TCP-2/%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D.png"></p>
]]></content>
  </entry>
  <entry>
    <title>UDP-用户数据报协议</title>
    <url>/2021/11/18/UDP/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="TCP-和-UDP-区别"><a href="#TCP-和-UDP-区别" class="headerlink" title="TCP 和 UDP 区别"></a>TCP 和 UDP 区别</h1><ol>
<li>连接</li>
</ol>
<p>TCP 是⾯向连接的传输层协议，传输数据前先要建⽴连接。</p>
<p>UDP 是不需要连接，即刻传输数据。</p>
<ol start="2">
<li><p>服务对象<br>TCP 是⼀对⼀的两点服务，即⼀条连接只有两个端点。<br>UDP ⽀持⼀对⼀、⼀对多、多对多的交互通信</p>
</li>
<li><p>可靠性<br>TCP 是可靠交付数据的，数据可以⽆差错、不丢失、不重复、按需到达。<br>UDP 是尽最⼤努⼒交付，不保证可靠交付数据。</p>
</li>
<li><p>拥塞控制、流量控制</p>
<p>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。UDP 则没有，即使⽹络⾮常拥堵了，也不会影响 UDP 的发送速率。</p>
</li>
<li><p>⾸部开销</p>
<p>TCP ⾸部⻓度较⻓，会有⼀定的开销，⾸部在没有使⽤「选项」字段时是 20 个字节，如果使⽤了「选项」</p>
</li>
</ol>
<p>字段则会变⻓的。</p>
<p>UDP ⾸部只有 8 个字节，并且是固定不变的，开销较⼩。</p>
<ol start="6">
<li><p>传输⽅式</p>
<p>TCP 是流式传输，没有边界，但保证顺序和可靠。</p>
<p>UDP 是⼀个包⼀个包的发送，是有边界的，但可能会丢包和乱序。</p>
</li>
<li><p>分⽚不同</p>
<p><strong>TCP 的数据⼤⼩如果⼤于 MSS ⼤⼩，则会在传输层进⾏分⽚</strong>，<strong>⽬标主机收到后，也同样在传输层组装 TCP数据包</strong>，如果中途丢失了⼀个分⽚，只需要传输丢失的这个分⽚。</p>
<p><strong>UDP 的数据⼤⼩如果⼤于 MTU ⼤⼩，则会在 IP 层进⾏分⽚</strong>，<strong>⽬标主机收到后，在 IP 层组装完数据，接着</strong></p>
<p><strong>再传给传输层</strong>，但是如果中途丢了⼀个分⽚，在实现可靠传输的 UDP 时则就需要重传所有的数据包，这样</p>
<p>传输效率⾮常差，所以通常 UDP 的报⽂应该⼩于 MTU。</p>
</li>
</ol>
<h1 id="TCP-和-UDP-应⽤场景"><a href="#TCP-和-UDP-应⽤场景" class="headerlink" title="TCP 和 UDP 应⽤场景"></a>TCP 和 UDP 应⽤场景</h1><p>由于 TCP 是⾯向连接，能保证数据的可靠性交付，因此经常⽤于：</p>
<ol>
<li>FTP ⽂件传输</li>
<li>HTTP / HTTPS</li>
</ol>
<p>由于 UDP ⾯向⽆连接，它可以随时发送数据，再加上UDP本身的处理既简单⼜⾼效，因此经常⽤于：</p>
<ol>
<li>包总量较少的通信，如 DNS 、 SNMP 等</li>
<li>视频、⾳频等多媒体通信</li>
<li>⼴播通信</li>
</ol>
<h3 id="UDP-为什么是不可靠的？bind-和-connect-对于-UDP-的作用是什么"><a href="#UDP-为什么是不可靠的？bind-和-connect-对于-UDP-的作用是什么" class="headerlink" title="UDP 为什么是不可靠的？bind 和 connect 对于 UDP 的作用是什么"></a>UDP 为什么是不可靠的？bind 和 connect 对于 UDP 的作用是什么</h3><p>UDP 只有一个 socket 接收缓冲区，没有 socket 发送缓冲区，即只要有数据就发，不管对方是否可以正确接收。而在对方的 socket 接收缓冲区满了之后，新来的数据报无法进入到 socket 接受缓冲区，此数据报就会被丢弃，因此 UDP 不能保证数据能够到达目的地，此外，UDP 也没有流量控制和重传机制，故UDP的数据传输是不可靠的。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>UDP</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 配置 SFTP 服务器</title>
    <url>/2021/08/01/Ubuntu-%E9%85%8D%E7%BD%AE-SFTP-%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="安装SFTP服务"><a href="#安装SFTP服务" class="headerlink" title="安装SFTP服务"></a>安装SFTP服务</h1><blockquote>
<p>sftp是Secure File Transfer Protocol的缩写，安全文件传送协议。可以为传输文件提供一种安全的网络的加密方法。<strong>sftp 与 ftp 有着几乎一样的语法和功能。</strong>SFTP 为 SSH的其中一部分，是一种传输档案至 Blogger 伺服器的安全方式。其实<strong>在SSH软件包中，已经包含了一个叫作SFTP(Secure File Transfer Protocol)的安全文件信息传输子系统</strong>。 <strong>SFTP本身没有单独的守护进程，它必须使用sshd守护进程（端口号默认是22）来完成相应的连接和答复操作，所以从某种意义上来说，SFTP并不像一个服务器程序，而更像是一个客户端程序。</strong>SFTP同样是使用加密传输认证信息和传输的数据，所以，使用SFTP是非常安全的。但是<strong>，由于这种传输方式使用了加密/解密技术，所以传输效率比普通的FTP要低得多</strong>，如果您对网络安全性要求更高时，可以使用SFTP代替FTP。</p>
</blockquote>
<p>Ubuntu默认只安装openssh-client，需要手动安装openssh-server或者sftp-server。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install openssh-server</span><br></pre></td></tr></table></figure>



<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>在Ubuntu系统上开通sftp文件服务，允许某些用户上传及下载文件。</p>
<p>但是这些用户只能使用sftp传输文件，不能使用SSH终端访问服务器，并且sftp不能访问系统文件。</p>
<p>系统管理员则既能使用sftp传输文件，也能使用SSH远程管理服务器。</p>
<h1 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h1><h2 id="sftp用户、用户组的创建"><a href="#sftp用户、用户组的创建" class="headerlink" title="sftp用户、用户组的创建"></a>sftp用户、用户组的创建</h2><ul>
<li>添加sftp用户，创建 sftp 用户组</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo adduser alice</span><br><span class="line">sudo addgroup sftp-users</span><br><span class="line"><span class="comment"># 将alice从所有其他用户组中移除并加入到sftp-users组，并且关闭其Shell访问</span></span><br><span class="line"><span class="comment">#/bin/false也可以替换为/sbin/nologin，目的是不允许该用户登录到系统中</span></span><br><span class="line">sudo usermod -G sftp-users -s /bin/<span class="literal">false</span> alice</span><br></pre></td></tr></table></figure>



<ul>
<li>创建sftp服务器的管理员身份，并且加入 ssh用户组（不限制他的shell操作权限）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo adduser admin</span><br><span class="line">sudo addgroup ssh-users</span><br><span class="line"><span class="comment"># -a 表示以追加形式将 admin 加入 ssh-users </span></span><br><span class="line">sudo usermod -a -G ssh-users admin</span><br></pre></td></tr></table></figure>


<h2 id="创建文件服务器目录"><a href="#创建文件服务器目录" class="headerlink" title="创建文件服务器目录"></a>创建文件服务器目录</h2><ul>
<li>创建服务器文件目录</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建监狱目录</span></span><br><span class="line">sudo mkdir /home/sftp_root</span><br><span class="line"><span class="comment"># 普通用户能够写入的共享文件目录</span></span><br><span class="line">sudo mkdir /home/sftp_root/shared</span><br><span class="line"><span class="comment"># 设置共享文件夹的拥有者为管理员、用户组为 sftp-users</span></span><br><span class="line">sudo chown admin:sftp-users /home/sftp_root/shared</span><br><span class="line"><span class="comment"># 拥有者、sftp用户组的成员具有一切权限</span></span><br><span class="line">sudo chmod 770 /home/sftp_root/shared</span><br></pre></td></tr></table></figure>



<p>默认允许所有用户或者用户组登录，若仅允许指定用户或者用户组访问，按照以下格式配置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以空格间隔</span></span><br><span class="line">AllowUsers user1 user2 </span><br><span class="line">AllowGroups group1 group2 </span><br></pre></td></tr></table></figure>

<h2 id="权限配置"><a href="#权限配置" class="headerlink" title="权限配置"></a>权限配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>

<p>在sshd_config文件的最后，添加以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">AllowGroups ssh-users sftp-users</span><br><span class="line">Match Group sftp-users</span><br><span class="line">ChrootDirectory /home/sftp_root</span><br><span class="line">AllowTcpForwarding no</span><br><span class="line">X11Forwarding no</span><br><span class="line">ForceCommand internal-sftp</span><br></pre></td></tr></table></figure>

<p>这样配置的目的是：</p>
<ul>
<li><p>只允许ssh-uers及sftp-users通过SSH访问系统，其中ssh-uers用户组可以使用ssh，并且不受其他限制。</p>
<p>而SFTP用户组仅能使用SFTP进行访问，且不能使用shell</p>
</li>
<li><p>针对sftp-users用户，额外增加一些设置：将“/home/sftp_root”设置为该组用户的系统根目录（因此它们将不能访问该目录之外的其他系统文件;</p>
</li>
<li><p>禁止TCP Forwarding和X11 Forwarding</p>
</li>
</ul>
<p>另外需要注意的是：<strong>ChrootDirectory的权限问题，你设定的目录必须是root用户所有</strong>，否则就会出现问题。所以请确保sftp用户根目录的所有人是root, 权限是 750 或者 755。</p>
<p>需要注意的一点的是，现在所有需要远程连接的用户都必须加入 ssh-users 才行。</p>
<p>如将用户 songyangji 加入 ，这样ta就可以使用ssh连接本机。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo usermod -a -G ssh-users songyangji</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>限制ssh连接的访问IP</strong></li>
</ul>
<p>仍然是</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Authentication:</span></span><br><span class="line">AllowUsers root@10.10.10.*        <span class="comment">#限制root用户只能通过10.10.10.*网段登录访问</span></span><br><span class="line">AllowUsers charles@10.10.10.*        <span class="comment">#限制charles用户只能通过10.10.10.*网段登录访问</span></span><br><span class="line">AllowUsers john@10.10.10.*</span><br></pre></td></tr></table></figure>


<h1 id="重启SSH"><a href="#重启SSH" class="headerlink" title="重启SSH"></a>重启SSH</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 亦可</span></span><br><span class="line"><span class="comment"># /etc/init.d/ssh restart</span></span><br><span class="line">service ssh restart</span><br></pre></td></tr></table></figure>





<blockquote>
<p>参考博客</p>
<p><a href="https://www.jianshu.com/p/6b588a712513">搭建sftp服务器</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux配置</tag>
        <tag>FTP</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-主从复制</title>
    <url>/2021/12/09/Redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。</p>
<p>默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。</p>
<p><strong>主从复制的作用</strong></p>
<p>主从复制的作用主要包括：</p>
<ol>
<li><p><strong>数据备份</strong>：主从复制实现了<strong>数据的热备份</strong>，是持久化之外的一种数据冗余方式。</p>
</li>
<li><p>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</p>
</li>
<li><p><strong>负载均衡</strong>：在主从复制的基础上，配合<strong>读写分离</strong>，可以<strong>由主节点提供写服务，由从节点提供读服务</strong>（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</p>
<p>默认情况下，从库只能读，不可写。</p>
</li>
<li><p>高可用基石：除了上述作用以外，<strong>主从复制还是哨兵和集群能够实施的基础</strong>，因此说主从复制是Redis高可用的基础。</p>
</li>
</ol>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ol>
<li><strong>建立复制</strong></li>
</ol>
<p>需要注意，主从复制的开启，完全是在从节点发起的；不需要我们在主节点做任何事情。</p>
<p>从节点开启主从复制，有3种方式：</p>
<p>（1）配置文件</p>
<p>在从服务器的配置文件中加入：slaveof masterip masterport</p>
<p>（2）启动命令</p>
<p>redis-server启动命令后加入 –slaveof masterip masterport</p>
<p>（3）客户端命令</p>
<p>Redis服务器启动后，直接通过客户端执行命令：slaveof masterip masterport，则该Redis实例成为从节点。</p>
<p>上述3种方式是等效的，下面以客户端命令的方式为例，看一下当执行了slaveof后，Redis主节点和从节点的变化。</p>
<ol start="2">
<li><strong>改变主库</strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">slaveof masterip masterport</span><br></pre></td></tr></table></figure>



<ol start="3">
<li><strong>停止复制</strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">slaveof no one</span><br></pre></td></tr></table></figure>










<h2 id="上手实战"><a href="#上手实战" class="headerlink" title="上手实战"></a>上手实战</h2><p><strong>启动一主二从的集群架构</strong></p>
<p>分别在3个shell窗口中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-server</span><br><span class="line">redis-server --port 6380 --slaveof 127.0.0.1 6379</span><br><span class="line">redis-server --port 6381 --slaveof 127.0.0.1 6379</span><br></pre></td></tr></table></figure>

<p>当然这里也可以在配置文件里修改然后指定配置文件启动。</p>
<p><strong>使用客户端连接</strong></p>
<p>分别在3个shell窗口中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -p 6379</span><br><span class="line">redis-cli -p 6380</span><br><span class="line">redis-cli -p 6381</span><br></pre></td></tr></table></figure>





<p>使用<code>info replication</code>检查复制状态：</p>
<p><strong>主库状态</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="meta">#</span><span class="bash"> Replication</span></span><br><span class="line">role:master # 角色：主库</span><br><span class="line">connected_slaves:2 # 从库数量</span><br><span class="line">slave0:ip=127.0.0.1,port=6380,state=online,offset=224,lag=0 # ip、端口、状态、复制偏移量</span><br><span class="line">slave1:ip=127.0.0.1,port=6381,state=online,offset=224,lag=1 </span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:4b6a1f35a960797cfce477656751eb3add4b320a</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:224</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1  # 复制缓冲区</span><br><span class="line">repl_backlog_size:1048576 # 复制缓冲区大小（默认是1MB）</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:224</span><br></pre></td></tr></table></figure>





<p><strong>从库状态</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line"><span class="meta">#</span><span class="bash"> Replication</span></span><br><span class="line">role:slave # 角色：从库</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:3</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:238 # 从库偏移量</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1 # 从库只读（默认）</span><br><span class="line">replica_announced:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:4b6a1f35a960797cfce477656751eb3add4b320a</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:238 # 主库 偏移量 (二者相同表示复制没有延迟)</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:238</span><br></pre></td></tr></table></figure>



<h2 id="主从复制的步骤"><a href="#主从复制的步骤" class="headerlink" title="主从复制的步骤"></a>主从复制的步骤</h2><h3 id="连接建立阶段"><a href="#连接建立阶段" class="headerlink" title="连接建立阶段"></a>连接建立阶段</h3><p>该阶段的主要作用是在主从节点之间建立连接，为数据同步做好准备。</p>
<ol>
<li><p><strong>保存主节点信息</strong><br>从节点服务器内部维护了两个字段，即masterhost和masterport字段，用于存储主节点的ip和port信息。需要注意的是，slaveof是异步命令，从节点完成主节点ip和port的保存后，向发送slaveof命令的客户端直接返回OK，实际的复制操作在这之后才开始进行。</p>
</li>
<li><p><strong>建立socket连接</strong><br>从节点每秒1次调用复制定时函数replicationCron()，如果发现了有主节点可以连接，便会根据主节点的ip和port，创建socket连接。如果连接成功，则：<strong>从节点为该socket建立一个专门处理复制工作的文件事件处理器，负责后续的复制工作，如接收RDB文件、接收命令传播等</strong>。<strong>主节点接收到从节点的socket连接后（即accept之后），为该socket创建相应的客户端状态，并将从节点看做是连接到主节点的一个客户端，后面的步骤会以从节点向主节点发送命令请求的形式来进行</strong>。</p>
</li>
<li><p><strong>发送ping命令检测</strong><br>从节点成为主节点的客户端之后，发送ping命令进行首次请求，<strong>目的是检查socket连接是否可用，以及主节点当前是否能够处理请求</strong>。从节点发送ping命令后，可能出现3种情况：</p>
<p>（1）返回pong：说明socket连接正常，且主节点当前可以处理请求，复制过程继续。</p>
<p>（2）超时：一定时间后从节点仍未收到主节点的回复，说明socket连接不可用，则从节点断开socket连接，并重连。</p>
<p>（3）返回pong以外的结果：如果主节点返回其他结果，如正在处理超时运行的脚本，说明主节点当前无法处理命令，则从节点断开socket连接，并重连。</p>
</li>
</ol>
<h3 id="数据同步阶段"><a href="#数据同步阶段" class="headerlink" title="数据同步阶段"></a>数据同步阶段</h3><p>主从节点之间的连接建立以后，便可以开始进行数据同步，该阶段可以理解为从节点数据的初始化。具体执行的方式是：从节点向主节点发送<code>psync</code>命令（Redis2.8以前是<code>sync</code>命令），开始同步。</p>
<p><strong>数据同步阶段是主从复制最核心的阶段</strong>，根据主从节点当前状态的不同，可以分为<strong>全量复制</strong>和<strong>增量复制</strong>，下面会有一章专门讲解这两种复制方式以及psync命令的执行过程，这里不再详述。</p>
<h3 id="命令传播阶段"><a href="#命令传播阶段" class="headerlink" title="命令传播阶段"></a>命令传播阶段</h3><p>数据同步阶段完成后，主从节点进入命令传播阶段；在这个阶段主节点将自己执行的写命令发送给从节点，从节点接收命令并执行，从而保证主从节点数据的一致性。</p>
<p>在命令传播阶段，除了发送写命令，主从节点还维持着<strong>心跳机制：PING和REPLCONF ACK</strong>。由于心跳机制的原理涉及增量复制，因此将在介绍了部分复制的相关内容后单独介绍该心跳机制。</p>
<p><strong>延迟与不一致</strong></p>
<p>需要注意的是，命令传播是异步的过程，即主节点发送写命令后并不会等待从节点的回复；因此实际上主从节点之间很难保持实时的一致性，延迟在所难免。</p>
<p>数据不一致的程度，与<strong>主从节点之间的网络状况</strong>、<strong>主节点写命令的执行频率</strong>、以及<strong>主节点中的repl-disable-tcp-nodelay配置</strong>等有关。</p>
<p><code>repl-disable-tcp-nodelay no</code>：该配置作用于命令传播阶段，控制主节点是否禁止与从节点的TCP_NODELAY；默认no，即不禁止TCP_NODELAY。当设置为yes时，TCP会对包进行合并从而减少带宽，但是发送的频率会降低，从节点数据延迟增加，一致性变差；具体发送频率与Linux内核的配置有关，默认配置为40ms。当设置为no时，TCP会立马将主节点的数据发送给从节点，带宽增加但延迟变小。</p>
<p>一般来说，只有当应用对Redis数据不一致的容忍度较高，且主从节点之间网络状况不好时，才会设置为yes；多数情况使用默认值no。</p>
<h2 id="数据同步阶段（全量复制和部分复制）"><a href="#数据同步阶段（全量复制和部分复制）" class="headerlink" title="数据同步阶段（全量复制和部分复制）"></a>数据同步阶段（全量复制和部分复制）</h2><p>在Redis2.8以前，从节点向主节点发送<code>sync</code>命令请求同步数据，此时的同步方式是全量复制；</p>
<p>在Redis2.8及以后，从节点可以发送<code>psync</code>命令请求同步数据，此时<strong>根据主从节点当前状态的不同</strong>，同步方式可能是全量复制或部分复制。后文介绍以Redis2.8及以后版本为例。</p>
<ol>
<li>全量复制：<strong>用于初次复制或其他无法进行部分复制的情况</strong>，<strong>将主节点中的所有数据都发送给从节点</strong>，是一个非常重量级的操作。</li>
<li>部分复制：<strong>用于网络中断等情况后的复制</strong>，<strong>只将中断期间主节点执行的写命令发送给从节点</strong>，与全量复制相比更加高效。需要注意的是，<strong>如果网络中断时间过长，导致主节点没有能够完整地保存中断期间执行的写命令，则无法进行部分复制，仍使用全量复制</strong>。</li>
</ol>
<h3 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h3><p>Redis通过<code>psync</code>命令进行全量复制的过程如下：</p>
<p>（1）从节点判断无法进行部分复制，向主节点发送全量复制的请求；或从节点发送部分复制的请求，但主节点判断无法进行部分复制；具体判断过程需要在讲述了部分复制原理后再介绍。</p>
<p>（2）主节点收到全量复制的命令后，执行bgsave，<strong>在后台生成RDB文件</strong>，<strong>并使用一个缓冲区（称为复制缓冲区）记录从现在开始执行的所有写命令。</strong></p>
<p>（3）主节点的bgsave执行完成后，<strong>将RDB文件发送给从节点</strong>；从节点首先清除自己的旧数据，然后载入接收的RDB文件，将数据库状态更新至主节点执行bgsave时的数据库状态。</p>
<p>（4）主节点<strong>将前述复制缓冲区中的所有写命令发送给从节点</strong>，从节点执行这些写命令，将数据库状态更新至主节点的最新状态</p>
<p>（5）如果<strong>从节点开启了AOF，则会触发bgrewriteaof的执行</strong>，从而保证AOF文件更新至主节点的最新状态。</p>
<p>通过全量复制的过程可以看出，全量复制是非常重型的操作：</p>
<p>（1）主节点通过bgsave命令fork子进程进行RDB持久化，该过程是非常消耗CPU、内存(页表复制)、硬盘IO的；</p>
<p>（2）主节点通过网络将RDB文件发送给从节点，对主从节点的带宽都会带来很大的消耗；</p>
<p>（3）<strong>从节点清空老数据、载入新RDB文件的过程是阻塞的</strong>，无法响应客户端的命令；如果从节点执行bgrewriteaof，也会带来额外的消耗。</p>
<blockquote>
<p>可以使用无硬盘复制，也就是说在复制初始化阶段，主节点不会把RDB写到磁盘上之后再一次性发给客户端，而是通过网络直接发个从节点。</p>
</blockquote>
<h3 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h3><p>由于全量复制在主节点数据量较大时效率太低，因此Redis2.8开始提供部分复制，用于处理网络中断时的数据同步。</p>
<blockquote>
<p>虽然不同版本的redis的复制有差异，不过前后兼容。</p>
</blockquote>
<p>部分复制的实现，依赖于三个重要的概念：</p>
<p>（1）<strong>复制偏移量</strong></p>
<p><strong>主节点和从节点分别维护一个复制偏移量（offset）</strong>，代表的是<strong>主节点向从节点传递的字节数</strong>；主节点每次向从节点传播N个字节数据时，主节点的offset增加N；从节点每次收到主节点传来的N个字节数据时，从节点的offset增加N。</p>
<p><strong>复制偏移量offset用于判断主从节点的数据库状态是否一致</strong>：如果二者offset相同，则一致；如果offset不同，则不一致，此时可以根据两个offset找出从节点缺少的那部分数据。</p>
<p>例如，如果主节点的offset是1000，而从节点的offset是500，那么部分复制就需要将offset为501-1000的数据传递给从节点。而offset为501-1000的数据存储的位置，就是下面要介绍的复制积压缓冲区。</p>
<p>（2）<strong>复制积压缓冲区</strong></p>
<p><strong>复制积压缓冲区是由主节点维护的、固定长度的、先进先出(FIFO)队列</strong>，默认大小1MB；当主节点开始有从节点时创建，其作用是备份主节点最近发送给从节点的数据。<strong>注意，无论主节点有一个还是多个从节点，都只需要一个复制积压缓冲区</strong>。</p>
<p>在命令传播阶段，<strong>主节点除了将写命令发送给从节点，还会发送一份给复制积压缓冲区，作为写命令的备份</strong>；除了存储写命令，复制积压缓冲区中还存储了其中的每个字节对应的复制偏移量（offset）。由于复制积压缓冲区定长且是先进先出，所以它保存的是主节点最近执行的写命令；<strong>时间较早的写命令会被挤出缓冲区</strong>。</p>
<p>由于该缓冲区长度固定且有限，因此可以备份的写命令也有限，<strong>当主从节点offset的差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制。</strong>反过来说，为了提高网络中断时部分复制执行的概率，可以根据需要增大复制积压缓冲区的大小(通过配置<code>repl-backlog-size</code>)；例如如果网络中断的平均时间是60s，而主节点平均每秒产生的写命令(特定协议格式)所占的字节数为100KB，则复制积压缓冲区的平均需求为6MB，保险起见，可以设置为12MB，来保证绝大多数断线情况都可以使用部分复制。</p>
<p><strong>从节点将自己的消费offset发送给主节点后，主节点根据offset和缓冲区大小决定能否执行部分复制</strong>：</p>
<ul>
<li>如果offset偏移量之后的数据，仍然都在复制积压缓冲区里，则执行部分复制；</li>
<li>如果offset偏移量之后的数据已不在复制积压缓冲区中（数据已被挤出），则执行全量复制。</li>
</ul>
<p>（3）<strong>服务器运行ID(runid)</strong></p>
<p>**每个Redis节点(无论主从)，在启动时都会自动生成一个随机ID(每次启动都不一样)**，由40个随机的十六进制字符组成；runid用来唯一识别一个Redis节点。通过info Server命令，可以查看节点的runid。</p>
<p>主从节点初次复制时，主节点将自己的runid发送给从节点，从节点将这个runid保存起来；</p>
<p><strong>当断线重连时，从节点会将这个runid发送给主节点；主节点根据runid判断能否进行部分复制</strong>：</p>
<ul>
<li>如果从节点保存的runid与主节点现在的runid相同，说明主从节点之前同步过，主节点会继续尝试使用部分复制(到底能不能部分复制还要看offset和复制积压缓冲区的情况)；</li>
<li>如果从节点保存的runid与主节点现在的runid不同，说明从节点在断线前同步的Redis节点并不是当前的主节点，只能进行全量复制。</li>
</ul>
<h2 id="命令传播阶段（心跳机制）"><a href="#命令传播阶段（心跳机制）" class="headerlink" title="命令传播阶段（心跳机制）"></a>命令传播阶段（心跳机制）</h2><h3 id="主-gt-从-PING"><a href="#主-gt-从-PING" class="headerlink" title="主-&gt;从 : PING"></a>主-&gt;从 : PING</h3><p>每隔指定的时间，主节点会向从节点发送<code>PING</code>命令，这个PING命令的作用，主要是为了让从节点进行超时判断。</p>
<p>PING发送的频率由repl-ping-slave-period参数控制，单位是秒，默认值是10s。</p>
<p>关于该PING命令究竟是由主节点发给从节点，还是相反，有一些争议；因为在Redis的官方文档中，对该参数的注释中说明是从节点向主节点发送PING命令。</p>
<h3 id="从-gt-主：REPLCONF-ACK"><a href="#从-gt-主：REPLCONF-ACK" class="headerlink" title="从-&gt;主：REPLCONF ACK"></a>从-&gt;主：REPLCONF ACK</h3><p>在命令传播阶段，从节点会向主节点发送<code>REPLCONF ACK</code>命令，频率是每秒1次；命令格式为：<code>REPLCONF ACK &#123;offset&#125;</code>，其中offset指从节点保存的复制偏移量。REPLCONF ACK命令的作用包括：</p>
<p>（1）<strong>实时监测主从节点网络状态</strong>：<strong>该命令会被主节点用于复制超时的判断</strong>。此外，在主节点中使用info Replication，可以看到其从节点的状态中的lag值，代表的是主节点上次收到该REPLCONF ACK命令的时间间隔，在正常情况下，该值应该是0或1。</p>
<p>（2）<strong>检测命令丢失</strong>：从节点发送了自身的offset，主节点会与自己的offset对比，如果从节点数据缺失（如网络丢包），主节点会重新推送缺失的数据（这里也会利用复制积压缓冲区）。注意<strong>，offset和复制积压缓冲区，不仅可以用于部分复制，也可以用于处理命令丢失等情形</strong>；区别在于前者是在断线重连后进行的，而后者是在主从节点没有断线的情况下进行的。</p>
<p>（3）<strong>辅助保证从节点的数量和延迟</strong>：Redis主节点中使用<code>min-slaves-to-write</code>和<code>min-slaves-max-lag</code>参数，来保证主节点在不安全的情况下不会执行写命令；</p>
<p>所谓不安全，是指从节点数量太少，或延迟过高。</p>
<p>例如<code>min-slaves-to-write</code>和<code>min-slaves-max-lag</code>分别是3和10，含义是如果从节点数量小于3个，或所有从节点的延迟值都大于10s，则主节点拒绝执行写命令。</p>
<p>而这里从节点延迟值的获取，就是通过主节点接收到REPLCONF ACK命令的时间来判断的，即前面所说的info Replication中的lag值。</p>
<h1 id="实际应用的问题"><a href="#实际应用的问题" class="headerlink" title="实际应用的问题"></a>实际应用的问题</h1><h2 id="1-读写分离及其中的问题"><a href="#1-读写分离及其中的问题" class="headerlink" title="1. 读写分离及其中的问题"></a>1. 读写分离及其中的问题</h2><h3 id="（1）延迟与不一致问题"><a href="#（1）延迟与不一致问题" class="headerlink" title="（1）延迟与不一致问题"></a>（1）延迟与不一致问题</h3><p>由于<strong>主从复制的命令传播是异步的</strong>，延迟与数据的不一致不可避免。如果应用对数据不一致的接受程度程度较低，可能的优化措施包括：优化主从节点之间的网络环境（如在同机房部署）；监控主从节点延迟（通过offset）判断，<strong>如果从节点延迟过大，通知应用不再通过该从节点读取数据</strong>；<strong>使用集群同时扩展写负载和读负载等</strong>。</p>
<p>在命令传播阶段以外的其他情况下，从节点的数据不一致可能更加严重，例如连接在数据同步阶段，或从节点失去与主节点的连接时等。从节点的<code>slave-serve-stale-data</code>参数便与此有关：它控制这种情况下从节点的表现；如果为yes（默认值），则从节点仍能够响应客户端的命令，如果为no，则从节点只能响应info、slaveof等少数命令。该参数的设置与应用对数据一致性的要求有关；<strong>如果对数据一致性要求很高，则应设置为no</strong>。</p>
<h3 id="（2）数据过期问题"><a href="#（2）数据过期问题" class="headerlink" title="（2）数据过期问题"></a>（2）数据过期问题</h3><p>在单机版Redis中，存在两种删除策略：</p>
<ul>
<li>惰性删除：服务器不会主动删除数据，只有当客户端查询某个数据时，服务器判断该数据是否过期，如果过期则删除。</li>
<li>定期删除：服务器执行定时任务删除过期数据，但是考虑到内存和CPU的折中（删除会释放内存，但是频繁的删除操作对CPU不友好），该删除的频率和执行时间都受到了限制。</li>
</ul>
<p>在主从复制场景下，<strong>为了主从节点的数据一致性，从节点不会主动删除数据</strong>，而是由主节点控制从节点中过期数据的删除。由于主节点的惰性删除和定期删除策略，都不能保证主节点及时对过期数据执行删除操作，因此，当客户端通过Redis从节点读取数据时，很容易读取到已经过期的数据。</p>
<p><strong>Redis 3.2中，从节点在读取数据时，增加了对数据是否过期的判断</strong>：如果该数据已过期，则不返回给客户端；将Redis升级到3.2可以解决数据过期问题。</p>
<h3 id="（3）故障切换问题"><a href="#（3）故障切换问题" class="headerlink" title="（3）故障切换问题"></a>（3）故障切换问题</h3><p><strong>在没有使用哨兵的读写分离场景下</strong>，应用针对读和写分别连接不同的Redis节点；当主节点或从节点出现问题而发生更改时，需要及时修改应用程序读写Redis数据的连接；连接的切换可以手动进行，或者自己写监控程序进行切换，但前者响应慢、容易出错，后者实现复杂，成本都不算低。(所以后面有<strong>哨兵机制</strong>)</p>
<h2 id="2-各场景下复制的选择及优化技巧"><a href="#2-各场景下复制的选择及优化技巧" class="headerlink" title="2. 各场景下复制的选择及优化技巧"></a>2. 各场景下复制的选择及优化技巧</h2><p>在介绍了Redis复制的种种细节之后，现在我们可以来总结一下，在下面常见的场景中，何时使用部分复制，以及需要注意哪些问题。</p>
<h3 id="（1）第一次建立复制"><a href="#（1）第一次建立复制" class="headerlink" title="（1）第一次建立复制"></a>（1）第一次建立复制</h3><p>此时全量复制不可避免，但仍有几点需要注意：</p>
<p><strong>如果主节点的数据量较大，应该尽量避开流量的高峰期</strong>，避免造成阻塞；</p>
<p><strong>如果有多个从节点需要建立对主节点的复制，可以考虑将几个从节点错开</strong>，避免主节点带宽占用过大。</p>
<p><strong>如果从节点过多，也可以调整主从复制的拓扑结构，由一主多从结构变为树状结构</strong>（中间的节点既是其主节点的从节点，也是其从节点的主节点）；但使用树状结构应该谨慎：虽然主节点的直接从节点减少，降低了主节点的负担，但是多层从节点的延迟增大，数据一致性变差；且结构复杂，维护相当困难。</p>
<h3 id="（2）主节点重启"><a href="#（2）主节点重启" class="headerlink" title="（2）主节点重启"></a>（2）主节点重启</h3><p>主节点重启可以分为两种情况来讨论，一种是故障导致宕机，另一种则是有计划的重启。</p>
<p><strong>主节点宕机</strong></p>
<p>主节点宕机重启后，runid会发生变化，因此不能进行部分复制，只能全量复制。</p>
<p>实际上在主节点宕机的情况下，应进行故障转移处理，将其中的一个从节点升级为主节点，其他从节点从新的主节点进行复制；且故障转移应尽量的自动化，后面文章将要介绍的哨兵便可以进行自动的故障转移。</p>
<p><strong>安全重启：debug reload</strong></p>
<p>在一些场景下，可能希望对主节点进行重启，例如主节点内存碎片率过高，或者<strong>希望调整一些只能在启动时调整的参数</strong>。如果使用普通的手段重启主节点，会使得runid发生变化，可能导致不必要的全量复制。</p>
<p>为了解决这个问题，Redis提供了<code>debug reload</code>的重启方式：重启后，主节点的runid和offset都不受影响，避免了全量复制。</p>
<p>如下图所示，debug reload重启后runid和offset都未受影响：</p>
<h3 id="（3）从节点重启"><a href="#（3）从节点重启" class="headerlink" title="（3）从节点重启"></a>（3）从节点重启</h3><p>从节点宕机重启后，其保存的主节点的runid会丢失，因此即使再次执行slaveof，也无法进行部分复制。</p>
<h3 id="（4）网络中断"><a href="#（4）网络中断" class="headerlink" title="（4）网络中断"></a>（4）网络中断</h3><p>如果主从节点之间出现网络问题，造成短时间内网络中断，可以分为多种情况讨论。</p>
<p>第一种情况：网络问题时间极为短暂，只造成了短暂的丢包，主从节点都没有判定超时（未触发repl-timeout）；此时只需要通过REPLCONF ACK来补充丢失的数据即可。</p>
<p>第二种情况：网络问题时间很长，主从节点判断超时（触发了repl-timeout），且丢失的数据过多，超过了复制积压缓冲区所能存储的范围；此时主从节点无法进行部分复制，只能进行全量复制。<strong>为了尽可能避免这种情况的发生，应该根据实际情况适当调整复制积压缓冲区的大小</strong>；此外及时发现并修复网络中断，也可以减少全量复制。</p>
<p>第三种情况：介于前述两种情况之间，主从节点判断超时，且丢失的数据仍然都在复制积压缓冲区中；此时主从节点可以进行部分复制。</p>
<h2 id="3-复制相关的配置"><a href="#3-复制相关的配置" class="headerlink" title="3. 复制相关的配置"></a>3. 复制相关的配置</h2><p>这一节总结一下与复制有关的配置，说明这些配置的作用、起作用的阶段，以及配置方法等；通过了解这些配置，一方面加深对Redis复制的了解，另一方面掌握这些配置的方法，可以优化Redis的使用，少走坑。</p>
<p>配置大致可以分为主节点相关配置、从节点相关配置以及与主从节点都有关的配置，下面分别说明。</p>
<h3 id="（1）与主从节点都有关的配置"><a href="#（1）与主从节点都有关的配置" class="headerlink" title="（1）与主从节点都有关的配置"></a>（1）与主从节点都有关的配置</h3><p>首先介绍最特殊的配置，它决定了该节点是主节点还是从节点：</p>
<ol>
<li><p>slaveof masterip masterport：Redis启动时起作用；作用是建立复制关系，开启了该配置的Redis服务器在启动后成为从节点。该注释默认注释掉，即Redis服务器默认都是主节点。</p>
</li>
<li><p>repl-timeout 60：与各个阶段<strong>主从节点连接超时判断</strong>有关，见前面的介绍。</p>
</li>
</ol>
<h3 id="（2）主节点相关配置"><a href="#（2）主节点相关配置" class="headerlink" title="（2）主节点相关配置"></a>（2）主节点相关配置</h3><ol>
<li><p>repl-diskless-sync no：作用于全量复制阶段，控制主节点是否使用diskless复制（无盘复制）。所谓diskless复制，是指在全量复制时，主节点不再先把数据写入RDB文件，而是直接写入slave的socket中，整个过程中不涉及硬盘；diskless复制在磁盘IO很慢而网速很快时更有优势。需要注意的是，截至Redis3.0，diskless复制处于实验阶段，默认是关闭的。</p>
</li>
<li><p>repl-diskless-sync-delay 5：该配置作用于全量复制阶段，当主节点使用diskless复制时，该配置决定主节点向从节点发送之前停顿的时间，单位是秒；只有当diskless复制打开时有效，默认5s。之所以设置停顿时间，是基于以下两个考虑：(1)向slave的socket的传输一旦开始，新连接的slave只能等待当前数据传输结束，才能开始新的数据传输 (2)多个从节点有较大的概率在短时间内建立主从复制。</p>
</li>
<li><p>client-output-buffer-limit slave 256MB 64MB 60：与<strong>全量复制阶段主节点的缓冲区大小</strong>有关，见前面的介绍。</p>
</li>
<li><p>repl-disable-tcp-nodelay no：与<strong>命令传播阶段的延迟</strong>有关，见前面的介绍。</p>
</li>
<li><p>masterauth master-password：与连接建立阶段的身份验证有关，见前面的介绍。</p>
</li>
<li><p>repl-ping-slave-period 10：与<strong>命令传播阶段主从节点的超时判断</strong>有关，见前面的介绍。</p>
</li>
<li><p>repl-backlog-size 1mb：<strong>复制积压缓冲区的大小</strong>，见前面的介绍。</p>
</li>
<li><p>repl-backlog-ttl 3600：当主节点没有从节点时，复制积压缓冲区保留的时间，这样当断开的从节点重新连进来时，可以进行部分复制；默认3600s。如果设置为0，则永远不会释放复制积压缓冲区。</p>
</li>
<li><p>min-slaves-to-write 3：规定了<strong>主节点的最小从节点数目</strong>。</p>
</li>
<li><p>min-slaves-max-lag 10：<strong>从节点对应的最大延迟</strong>，见前面的介绍。</p>
</li>
</ol>
<h3 id="（3）从节点相关配置"><a href="#（3）从节点相关配置" class="headerlink" title="（3）从节点相关配置"></a>（3）从节点相关配置</h3><ol>
<li><p>slave-serve-stale-data yes：与<strong>从节点数据陈旧时是否响应客户端命令</strong>有关，见前面的介绍。</p>
</li>
<li><p>slave-read-only yes：<strong>从节点是否只读</strong>；默认是只读的。由于从节点开启写操作容易导致主从节点的数据不一致，因此该配置尽量不要修改。</p>
</li>
</ol>
<blockquote>
<p><a href="https://www.cnblogs.com/kismetv/p/9236731.html"><a href="https://www.cnblogs.com/kismetv/p/9236731.html">深入学习Redis（3）：主从复制 </a></a></p>
</blockquote>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
        <tag>Redis</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal使用、源码解析</title>
    <url>/2021/08/05/ThreadLocal%E4%BD%BF%E7%94%A8%E3%80%81%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            ThreadLocal&lt;Node&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">            threadLocal.set(<span class="keyword">new</span> Node());</span><br><span class="line"><span class="comment">//            System.out.println(threadLocal.get());</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">实现了一个线程ID工具类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-----来自源码文档demo</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadId</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Atomic integer containing the next thread ID to be assigned</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger nextId = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Thread local variable containing each thread&#x27;s ID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; threadId =</span><br><span class="line">            ThreadLocal.withInitial(nextId::getAndIncrement);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns the current thread&#x27;s unique ID, assigning it if necessary</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> threadId.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;A: &quot;</span>+ThreadId.get());</span><br><span class="line">            System.out.println(<span class="string">&quot;A: &quot;</span>+ThreadId.get());</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;B: &quot;</span>+ThreadId.get());</span><br><span class="line">            System.out.println(<span class="string">&quot;B: &quot;</span>+ThreadId.get());</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;C: &quot;</span>+ThreadId.get());</span><br><span class="line">            System.out.println(<span class="string">&quot;C: &quot;</span>+ThreadId.get());</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此ThreadLocal对象的“自定义”的哈希吗</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态的线程安全的循环计数器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode =</span><br><span class="line">        <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 连续的 ThreadLocal的哈希值的增量差异（此 magic number 可以产生离散程度很好的哈希表）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取下一个 hash 值的工具方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回当前线程获取此 thread-local 对象的初始值</span></span><br><span class="line">    <span class="comment">// 可以用匿名内部类（lambda表达式代替）覆盖此方法，以提供初始值</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadLocal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回此线程局部变量的当前线程中的值</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	步骤：</span></span><br><span class="line"><span class="comment">    	1、获取当前线程</span></span><br><span class="line"><span class="comment">    	2、获取此线程拥有的 ThreadLocalMap</span></span><br><span class="line"><span class="comment">    	3、在 ThreadLocalMap 中根据此 ThreadLocal 对象拿到值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                T result = (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  	<span class="comment">/*</span></span><br><span class="line"><span class="comment">    	步骤：</span></span><br><span class="line"><span class="comment">    	1、获取当前线程</span></span><br><span class="line"><span class="comment">    	2、获取此线程拥有的 ThreadLocalMap</span></span><br><span class="line"><span class="comment">    	3、调用map 的 setter 方法（ 如果未初始化，则先初始化 ）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 创建此线程的自己的 ThreadLocalMap</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// ThreadLocal 允许线程”删除“它的线程本地量</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">         <span class="keyword">if</span> (m != <span class="keyword">null</span>) &#123;</span><br><span class="line">             m.remove(<span class="keyword">this</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个线程有自己的 ThreadLocalMap实例，用 Thread 类的 threadLocals 字段设置</span></span><br><span class="line">    <span class="comment">// 然后在某个 ThreadLocalMap实例 中根据 threadLocal实例 取值</span></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程的threadLocals</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ThreadLocal的内部类-ThreadLocalMap"><a href="#ThreadLocal的内部类-ThreadLocalMap" class="headerlink" title="ThreadLocal的内部类 ThreadLocalMap"></a>ThreadLocal的内部类 ThreadLocalMap</h2><blockquote>
<p>ThreadLocalMap 是一种定制的哈希映射，仅适用于维护线程本地值。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// table 的默认容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有需要就扩容，容量大小为 2 的整数次幂</span></span><br><span class="line">    <span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of entries in the table.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一次进行 resize 的阈值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threshold; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 负载因子为 2/3 </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setThreshold</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        threshold = len * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取模意义下的 ”后一个位置“</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取模意义下的 ”前一个位置“</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prevIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化惰性构造</span></span><br><span class="line">    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">        table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">        <span class="comment">// 一样的技巧 —— 位运算代替取模</span></span><br><span class="line">        <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">        table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        setThreshold(INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the entry associated with key.  This method</span></span><br><span class="line"><span class="comment">     * itself handles only the fast path: a direct hit of existing</span></span><br><span class="line"><span class="comment">     * key. It otherwise relays to getEntryAfterMiss.  This is</span></span><br><span class="line"><span class="comment">     * designed to maximize performance for direct hits, in part</span></span><br><span class="line"><span class="comment">     * by making this method readily inlinable.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  key the thread local object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the entry associated with key, or null if no such</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">        Entry e = table[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Version of getEntry method for use when key is not found in</span></span><br><span class="line"><span class="comment">     * its direct hash slot.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  key the thread local object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  i the table index for key&#x27;s hash code</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  e the entry at table[i]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the entry associated with key, or null if no such</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == key)</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">                expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                i = nextIndex(i, len);</span><br><span class="line">            e = tab[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set the value associated with key.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the thread local object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to be set</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We don&#x27;t use a fast path as with get() because it is at</span></span><br><span class="line">        <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">        <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">        <span class="comment">// path would fail more often than not.</span></span><br><span class="line"></span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> len = tab.length;</span><br><span class="line">        <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">             e != <span class="keyword">null</span>;</span><br><span class="line">             e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                e.value = value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                replaceStaleEntry(key, value, i);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">        <span class="keyword">int</span> sz = ++size;</span><br><span class="line">        <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">            rehash();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Remove the entry for key.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> len = tab.length;</span><br><span class="line">        <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">             e != <span class="keyword">null</span>;</span><br><span class="line">             e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">                e.clear();</span><br><span class="line">                expungeStaleEntry(i);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Replace a stale entry encountered during a set operation</span></span><br><span class="line"><span class="comment">     * with an entry for the specified key.  The value passed in</span></span><br><span class="line"><span class="comment">     * the value parameter is stored in the entry, whether or not</span></span><br><span class="line"><span class="comment">     * an entry already exists for the specified key.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * As a side effect, this method expunges all stale entries in the</span></span><br><span class="line"><span class="comment">     * &quot;run&quot; containing the stale entry.  (A run is a sequence of entries</span></span><br><span class="line"><span class="comment">     * between two null slots.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  value the value to be associated with key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  staleSlot index of the first stale entry encountered while</span></span><br><span class="line"><span class="comment">     *         searching for key.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> len = tab.length;</span><br><span class="line">        Entry e;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Back up to check for prior stale entry in current run.</span></span><br><span class="line">        <span class="comment">// We clean out whole runs at a time to avoid continual</span></span><br><span class="line">        <span class="comment">// incremental rehashing due to garbage collector freeing</span></span><br><span class="line">        <span class="comment">// up refs in bunches (i.e., whenever the collector runs).</span></span><br><span class="line">        <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</span><br><span class="line">             (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">             i = prevIndex(i, len))</span><br><span class="line">            <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find either the key or trailing null slot of run, whichever</span></span><br><span class="line">        <span class="comment">// occurs first</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">             (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">             i = nextIndex(i, len)) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If we find key, then we need to swap it</span></span><br><span class="line">            <span class="comment">// with the stale entry to maintain hash table order.</span></span><br><span class="line">            <span class="comment">// The newly stale slot, or any other stale slot</span></span><br><span class="line">            <span class="comment">// encountered above it, can then be sent to expungeStaleEntry</span></span><br><span class="line">            <span class="comment">// to remove or rehash all of the other entries in run.</span></span><br><span class="line">            <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                e.value = value;</span><br><span class="line"></span><br><span class="line">                tab[i] = tab[staleSlot];</span><br><span class="line">                tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Start expunge at preceding stale entry if it exists</span></span><br><span class="line">                <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                    slotToExpunge = i;</span><br><span class="line">                cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If we didn&#x27;t find stale entry on backward scan, the</span></span><br><span class="line">            <span class="comment">// first stale entry seen while scanning for key is the</span></span><br><span class="line">            <span class="comment">// first still present in the run.</span></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If key not found, put new entry in stale slot</span></span><br><span class="line">        tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">        tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If there are any other stale entries in run, expunge them</span></span><br><span class="line">        <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Expunge a stale entry by rehashing any possibly colliding entries</span></span><br><span class="line"><span class="comment">     * lying between staleSlot and the next null slot.  This also expunges</span></span><br><span class="line"><span class="comment">     * any other stale entries encountered before the trailing null.  See</span></span><br><span class="line"><span class="comment">     * Knuth, Section 6.4</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> staleSlot index of slot known to have null key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the index of the next null slot after staleSlot</span></span><br><span class="line"><span class="comment">     * (all between staleSlot and this slot will have been checked</span></span><br><span class="line"><span class="comment">     * for expunging).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">        tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">        tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">        Entry e;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">             (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">             i = nextIndex(i, len)) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.value = <span class="keyword">null</span>;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line">                size--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                    tab[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                    <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                    <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                        h = nextIndex(h, len);</span><br><span class="line">                    tab[h] = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Heuristically scan some cells looking for stale entries.</span></span><br><span class="line"><span class="comment">     * This is invoked when either a new element is added, or</span></span><br><span class="line"><span class="comment">     * another stale one has been expunged. It performs a</span></span><br><span class="line"><span class="comment">     * logarithmic number of scans, as a balance between no</span></span><br><span class="line"><span class="comment">     * scanning (fast but retains garbage) and a number of scans</span></span><br><span class="line"><span class="comment">     * proportional to number of elements, that would find all</span></span><br><span class="line"><span class="comment">     * garbage but would cause some insertions to take O(n) time.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i a position known NOT to hold a stale entry. The</span></span><br><span class="line"><span class="comment">     * scan starts at the element after i.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n scan control: &#123;<span class="doctag">@code</span> log2(n)&#125; cells are scanned,</span></span><br><span class="line"><span class="comment">     * unless a stale entry is found, in which case</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> log2(table.length)-1&#125; additional cells are scanned.</span></span><br><span class="line"><span class="comment">     * When called from insertions, this parameter is the number</span></span><br><span class="line"><span class="comment">     * of elements, but when from replaceStaleEntry, it is the</span></span><br><span class="line"><span class="comment">     * table length. (Note: all this could be changed to be either</span></span><br><span class="line"><span class="comment">     * more or less aggressive by weighting n instead of just</span></span><br><span class="line"><span class="comment">     * using straight log n. But this version is simple, fast, and</span></span><br><span class="line"><span class="comment">     * seems to work well.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if any stale entries have been removed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cleanSomeSlots</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> len = tab.length;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">            Entry e = tab[i];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                n = len;</span><br><span class="line">                removed = <span class="keyword">true</span>;</span><br><span class="line">                i = expungeStaleEntry(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> removed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Re-pack and/or re-size the table. First scan the entire</span></span><br><span class="line"><span class="comment">     * table removing stale entries. If this doesn&#x27;t sufficiently</span></span><br><span class="line"><span class="comment">     * shrink the size of the table, double the table size.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use lower threshold for doubling to avoid hysteresis</span></span><br><span class="line">        <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">            resize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Double the capacity of the table.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Entry[] oldTab = table;</span><br><span class="line">        <span class="keyword">int</span> oldLen = oldTab.length;</span><br><span class="line">        <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;</span><br><span class="line">        Entry[] newTab = <span class="keyword">new</span> Entry[newLen];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Entry e : oldTab) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    e.value = <span class="keyword">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>)</span><br><span class="line">                        h = nextIndex(h, newLen);</span><br><span class="line">                    newTab[h] = e;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setThreshold(newLen);</span><br><span class="line">        size = count;</span><br><span class="line">        table = newTab;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Expunge all stale entries in the table.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> len = tab.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            Entry e = tab[j];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>)</span><br><span class="line">                expungeStaleEntry(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<blockquote>
<p>(Weakly Reachable )[<a href="https://www.cs.fsu.edu/~jtbauer/cis3931/tutorial/refobjs/about/weak.html]">https://www.cs.fsu.edu/~jtbauer/cis3931/tutorial/refobjs/about/weak.html]</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu、MacOS环境下下载安装 RabbitMQ</title>
    <url>/2021/10/09/Ubuntu%E3%80%81MacOS%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%20RabbitMQ/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>先更新一下资源。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>

<p>由于rabbitMq需要erlang语言的支持，在安装rabbitMq之前需要安装erlang。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install -y erlang-nox</span><br></pre></td></tr></table></figure>

<p>安装rabbitmq </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install -y rabbitmq-server</span><br></pre></td></tr></table></figure>


<p>默认下载的地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">songyangji@SongyangJi-Ubuntu-DeskStop:/etc/rabbitmq$ whereis rabbitmq</span><br><span class="line">rabbitmq: /usr/lib/rabbitmq /etc/rabbitmq /usr/share/rabbitmq</span><br></pre></td></tr></table></figure>

<h2 id="开启、关闭"><a href="#开启、关闭" class="headerlink" title="开启、关闭"></a>开启、关闭</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># start</span></span><br><span class="line">sudo service rabbitmq-server start</span><br><span class="line"></span><br><span class="line"><span class="comment"># stop</span></span><br><span class="line">sudo service rabbitmq-server stop</span><br></pre></td></tr></table></figure>


<p>直接到/sbin目录下执行也是可以的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动 start</span></span><br><span class="line">sudo /sbin/service rabbitmq-server start</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止 stop</span></span><br><span class="line">sudo /sbin/service rabbitmq-server stop</span><br></pre></td></tr></table></figure>

<h2 id="启动Web管理端"><a href="#启动Web管理端" class="headerlink" title="启动Web管理端"></a>启动Web管理端</h2><p>安装了Rabbitmq后，默认也安装了该管理工具，执行命令即可启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/rabbitmq</span><br><span class="line">sudo rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</span><br></pre></td></tr></table></figure>

<p>访问 localhost:15672<br>出现一下即可。<br><img src="https://img-blog.csdnimg.cn/20210402155642536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0ODQ2MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="MacOS"><a href="#MacOS" class="headerlink" title="MacOS"></a>MacOS</h1><h2 id="下载-1"><a href="#下载-1" class="headerlink" title="下载"></a>下载</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew update</span><br><span class="line">brew install rabbitmq</span><br></pre></td></tr></table></figure>

<h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> RABBITMQ_HOME=/opt/homebrew/Cellar/rabbitmq/3.8.13</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$RABBITMQ_HOME</span>/sbin</span><br></pre></td></tr></table></figure>


<h2 id="启动、关闭"><a href="#启动、关闭" class="headerlink" title="启动、关闭"></a>启动、关闭</h2><p>这里是借助 brew 去管理的。如果直接使用  rabbitmq提供的脚本启动也是可以的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew services start rabbitmq</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew services stop rabbitmq</span><br></pre></td></tr></table></figure>

<p>访问Web端是一样的。</p>
]]></content>
      <categories>
        <category>消息中间件</category>
      </categories>
      <tags>
        <tag>Message Queue</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP-传输控制协议</title>
    <url>/2021/11/16/TCP/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="TCP简介"><a href="#TCP简介" class="headerlink" title="TCP简介"></a>TCP简介</h1><h3 id="TCP是什么"><a href="#TCP是什么" class="headerlink" title="TCP是什么"></a>TCP是什么</h3><p><strong>传输控制协议</strong>（英语：<strong>T</strong>ransmission <strong>C</strong>ontrol <strong>P</strong>rotocol，缩写：<strong>TCP</strong>）是一种<strong>面向连接</strong>的、<strong>可靠</strong>的、<strong>基于字节流</strong>的<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E5%B1%82">传输层</a>通信协议，由IETF的<a href="https://zh.wikipedia.org/wiki/RFC">RFC</a> <a href="https://tools.ietf.org/html/rfc793">793</a>定义。</p>
<ul>
<li>⾯向连接：⼀定是⼀对⼀才能连接，不能像 UDP 协议可以⼀个主机同时向多个主机发送消息，也就是⼀</li>
</ul>
<p>对多是⽆法做到的；</p>
<ul>
<li><p>可靠的：⽆论的⽹络链路中出现了怎样的链路变化，TCP 都可以保证⼀个报⽂⼀定能够到达接收端；</p>
</li>
<li><p>字节流：消息是没有边界的，所以⽆论我们消息有多⼤都可以进⾏传输。并且消息是有序的，当</p>
</li>
</ul>
<p>前⼀个消息没有收到的时候，即使它先收到了后⾯的字节，那么也不能扔给应⽤层去处理，同时对重</p>
<p>复的报⽂会⾃动丢弃。</p>
<h3 id="TCP的功能与角色"><a href="#TCP的功能与角色" class="headerlink" title="TCP的功能与角色"></a>TCP的功能与角色</h3><p>在因特网协议族（Internet protocol suite）中，TCP层是位于<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE">IP</a>层之上，<em>应用层</em>之下的中间层。不同主机的应用层之间经常需要可靠的、像<em>管道</em>一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换。</p>
<p>在简化的计算机网络<a href="https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B">OSI模型</a>中，它完成第四层传输层所指定的功能。<a href="https://zh.wikipedia.org/wiki/%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE">用户数据报协议</a>（UDP）是同一层内另一个重要的传输协议。</p>
<p>应用层向TCP层发送用于网间传输的、字节表示的数据流。</p>
<p>然后<strong>TCP把数据流分割成适当长度的报文段</strong>（通常受该计算机连接的网络的数据链路层的<a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E4%BC%A0%E8%BE%93%E5%8D%95%E5%85%83">最大传输单元</a>（MTU）的限制）。</p>
<p>之后TCP把结果包传给IP层，由它来透过网络将包传送给接收端实体的TCP层。</p>
<h3 id="TCP-是如何保证可靠性的"><a href="#TCP-是如何保证可靠性的" class="headerlink" title="TCP 是如何保证可靠性的"></a>TCP 是如何保证可靠性的</h3><ul>
<li><strong>数据分块</strong>：应用数据被分割成 TCP 认为最适合发送的数据块。</li>
<li><strong>序列号和确认应答</strong>：TCP 给发送的每一个包进行编号，在传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答，即发送 ACK 报文，这个 ACK 报文当中带有对应的确认序列号，告诉发送方成功接收了哪些数据以及下一次的数据从哪里开始发。除此之外，接收方可以根据序列号对数据包进行排序，把有序数据传送给应用层，并丢弃重复的数据。</li>
<li><strong>校验和</strong>： TCP 将保持它首部和数据部分的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到报文段的检验和有差错，TCP 将丢弃这个报文段并且不确认收到此报文段。</li>
<li><strong>流量控制</strong>： TCP 连接的双方都有一个固定大小的缓冲空间，发送方发送的数据量不能超过接收端缓冲区的大小。当接收方来不及处理发送方的数据，会提示发送方降低发送的速率，防止产生丢包。TCP 通过滑动窗口协议来支持流量控制机制。</li>
<li><strong>拥塞控制</strong>： 当网络某个节点发生拥塞时，减少数据的发送。</li>
<li><strong>ARQ协议</strong>： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>
<li><strong>超时重传</strong>： 当 TCP 发出一个报文段后，它启动一个定时器，等待目的端确认收到这个报文段。如果超过某个时间还没有收到确认，将重发这个报文段。</li>
</ul>
<p>下面的内容和其他文章会详细叙述这一点。</p>
<h2 id="什么是-TCP-连接"><a href="#什么是-TCP-连接" class="headerlink" title="什么是 TCP 连接"></a>什么是 TCP 连接</h2><p>⽤于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括<strong>Socket</strong>、序列号和窗⼝</p>
<p>⼤⼩称为连接。</p>
<ol>
<li>Socket：由 IP 地址和端⼝号组成;</li>
<li>序列号：⽤来解决乱序问题等;</li>
<li>窗⼝⼤⼩：⽤来做流量控制</li>
</ol>
<p>TCP 四元组可以唯⼀的确定⼀个连接，四元组包括如下：</p>
<ul>
<li>源地址</li>
<li>源端⼝</li>
<li>⽬的地址</li>
<li>⽬的端⼝</li>
</ul>
<blockquote>
<p>一个套接字由相关五元组构成，协议、本地地址、本地端口、远程地址、远程端口。</p>
</blockquote>
<h2 id="TCP的可靠性简单介绍"><a href="#TCP的可靠性简单介绍" class="headerlink" title="TCP的可靠性简单介绍"></a>TCP的可靠性简单介绍</h2><p>TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收（<strong>序号的作用: 1.包不丢失  2.包不重复 3. 有序接受</strong>）。</p>
<p>然后接收端实体对已成功收到的包发回一个相应的确认信息（ACK）；如果发送端实体在合理的<a href="https://zh.wikipedia.org/wiki/%E4%BE%86%E5%9B%9E%E9%80%9A%E8%A8%8A%E5%BB%B6%E9%81%B2">往返时延</a>（RTT）内未收到确认，那么对应的数据包就被假设为已丢失并进行重传。</p>
<p>TCP用一个<a href="https://zh.wikipedia.org/wiki/%E6%A0%A1%E9%AA%8C%E5%92%8C">校验和</a>函数来检验数据是否有错误，在发送和接收时都要计算校验和。</p>
<blockquote>
<p>数据在TCP层称为流（Stream），数据分组称为分段（Segment）。作为比较，数据在IP层称为Datagram，数据分组称为分片（Fragment）。 UDP 中分组称为Message。 </p>
</blockquote>
<h2 id="TCP-连接数有多少"><a href="#TCP-连接数有多少" class="headerlink" title="TCP 连接数有多少"></a>TCP 连接数有多少</h2><blockquote>
<p>有⼀个 IP 的服务器监听了⼀个端⼝，它的 TCP 的最⼤连接数是多少？</p>
</blockquote>
<p><strong>理论最大值</strong></p>
<ul>
<li><p>Client 最大 TCP 连接数<br>client 在每次发起 TCP 连接请求时，<strong>如果自己并不指定端口的话，系统会随机选择一个本地端口</strong>（local port），<strong>该端口是独占的</strong>，不能和其他 TCP 连接共享。TCP 端口的数据类型是 unsigned short，因此本地端口个数最大只有 65536，除了端口 0 不能使用外，其他端口在空闲时都可以正常使用，这样可用端口最多有 65535 （2的16次方）个。</p>
</li>
<li><p>Server最大 TCP 连接数<br>server 通常固定在某个本地端口上监听，等待 client 的连接请求。不考虑地址重用（Unix 的 SO_REUSEADDR 选项）的情况下，即使 server 端有多个 IP，本地监听端口也是独占的，因此 server 端 TCP 连接 4 元组中只有客户端的 IP 地址和端口号是可变的，因此<strong>最大 TCP 连接=客户端 IP 数 × 客户端 port 数</strong>，对 IPV4，在不考虑 IP 地址分类的情况下，最大 TCP 连接数约为 2 的 32 次方（IP 数）× 2 的 16 次方（port 数），也就是 server 端单机最大 TCP 连接数约为 2 的 48 次方。</p>
</li>
</ul>
<ol>
<li><p>主要是⽂件描述符限制，socket 都是作为⽂件来处理，所以⾸先要通过 ulimit 配置⽂件描述符的数⽬；</p>
</li>
<li><p>内存限制，每个 TCP 连接都要占⽤⼀定内存，操作系统的内存是有限的；</p>
</li>
<li><p>IP协议的规定（一些 IP 地址和端口具有特殊含义，没有对外开放）。</p>
</li>
</ol>
<p>对 server 端，通过增加内存、修改最大文件描述符个数等参数，<strong>单机最大并发 TCP 连接数超过 10 万</strong> 是没问题的。</p>
<h1 id="TCP段的头"><a href="#TCP段的头" class="headerlink" title="TCP段的头"></a>TCP段的头</h1><p><img src="/2021/11/16/TCP/tcp-header.png"></p>
<ul>
<li><p>来源连接端口（16位长）－发送端连接端口；</p>
</li>
<li><p>目的连接端口（16位长）－接收端连接端口；</p>
</li>
<li><p>序列号（seq，32位长）</p>
<ul>
<li>如果含有同步化标志（SYN），则此为最初的序列号；第一个数据比特的序列码为本序列号+1；</li>
<li>如果没有同步化标志（SYN），则此为第一个数据比特的序列码。</li>
</ul>
</li>
<li><p>确认号（ack，32位长）— <strong>下一次期望收到的数据的开始序列号</strong>，也即已经收到的数据的字节长度加1。</p>
</li>
<li><p>数据偏移（4位长）— 以4字节为单位计算出的数据段开始地址的偏移值（因为选项部分长度是可变的），也就是<strong>TCP头部长度</strong>。</p>
</li>
<li><p>保留（3比特长）— 须置0。</p>
</li>
<li><p>标志符（9比特长）</p>
<ul>
<li>NS — ECN-nonce。ECN显式拥塞通知（Explicit Congestion Notification）是对TCP的扩展，定义于 RFC 3540 （2003）。ECN允许拥塞控制的端对端通知而避免丢包。ECN为一项可选功能，如果底层网络设施支持，则可能被启用ECN的两个端点使用。在ECN成功协商的情况下，ECN感知路由器可以在IP头中设置一个标记来代替丢弃数据包，以标明阻塞即将发生。数据包的接收端回应发送端的表示，降低其传输速率，就如同在往常中检测到包丢失那样。</li>
<li>CWR — Congestion Window Reduced，定义于 RFC 3168（2001）。</li>
<li>ECE — ECN-Echo有两种意思，取决于SYN标志的值，定义于 RFC 3168（2001）。</li>
<li>URG — 为1表示高优先级数据包，紧急指针字段有效。</li>
<li><strong>ACK</strong> — 为1表示<strong>确认号（ack）</strong>字段有效，用于表示已经接收到消息了</li>
<li>PSH — 为1表示是带有PUSH标志的数据，指示接收方应该尽快将这个报文段交给应用层而不用等待缓冲区装满。</li>
<li><strong>RST</strong> — 为1<strong>表示出现严重差错</strong>，可能需要重新创建TCP连接。还可以<strong>用于拒绝非法的报文段和拒绝连接请求</strong>。</li>
<li><strong>SYN</strong> — 为1表示这是<strong>连接请求或是连接接受请求</strong>，<strong>用于创建连接和使顺序号同步</strong>。</li>
<li><strong>FIN</strong> — 为1表示<strong>发送方没有数据要传输</strong>了，要求释放连接。</li>
</ul>
</li>
<li><p><strong>窗口</strong>（WIN，16位长）— 表示从确认号开始，本报文的<strong>发送方可以接收的字节数</strong>，即接收窗口大小。用于流量控制。</p>
</li>
<li><p>校验和（Checksum，16位长）—对整个的TCP报文段<strong>，包括TCP头部和TCP数据</strong>，以16位字进行计算所得。这是一个强制性的字段。</p>
</li>
<li><p>紧急指针（16位长）—本报文段中的紧急数据的最后一个字节的序号。</p>
</li>
<li><p>选项字段 — 最多40字节（必须是4字节的倍数）。每个选项的开始是1字节的kind字段，说明选项的类型，</p>
<p>每个选项具有<strong>类型-长度-值</strong>的结构。</p>
<ul>
<li>0：选项表结束（1字节）</li>
<li>1：无操作（1字节）用于选项字段之间的字边界对齐。</li>
<li>2：<strong>最大报文段长度</strong>（4字节，<em>Maximum Segment Size</em>，<strong>MSS</strong>）通常在创建连接而设置SYN标志的数据包中指明这个选项，指明本端所能接收的最大长度的报文段。通常将MSS设置为（<strong>MTU - 40</strong>）字节，携带TCP报文段的IP数据报的长度就不会超过MTU（MTU最大长度为1518字节，最短为64字节），从而避免本机发生IP分片。<strong>只能出现在同步报文段中</strong>，否则将被忽略。</li>
<li>3：<strong>窗口扩大因子</strong>（3字节，wscale），取值0-14。用来把TCP的窗口的值左移的位数，使窗口值乘倍。<strong>只能出现在同步报文段中</strong>，否则将被忽略。这是因为现在的TCP接收数据缓冲区（接收窗口）的长度通常大于65535字节。</li>
<li>4：sackOK—发送端支持并同意使用SACK选项。</li>
<li>5：SACK实际工作的选项。</li>
<li>8：<strong>时间戳</strong>（10字节，TCP Timestamps Option，TSopt）。一旦在连接建立阶段启用了它，那么每个数据包都要包含这个选项，主要用来计算来回时间样值，该值被用来估算多长时间之后数据包可以被认为丢失。<ul>
<li>发送端的时间戳（Timestamp Value field，TSval，4字节）</li>
<li>时间戳回显应答（Timestamp Echo Reply field，TSecr，4字节）</li>
</ul>
</li>
<li>19：MD5摘要，将TCP伪首部、校验和为0的TCP首部、TCP数据段、通信双方约定的密钥（可选）计算出<a href="https://zh.wikipedia.org/wiki/MD5">MD5</a>摘要值并附加到该选项中，作为类似对TCP报文的签名。通过 <a href="https://tools.ietf.org/html/rfc2385">RFC 2385</a> 引入，主要用于增强<a href="https://zh.wikipedia.org/wiki/%E8%BE%B9%E7%95%8C%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE">BGP</a>通信的安全性。</li>
<li>29：安全摘要，通过 <a href="https://tools.ietf.org/html/rfc5925">RFC 5925</a> 引入，将“MD5摘要”的散列方法更换为<a href="https://zh.wikipedia.org/wiki/SHA%E5%AE%B6%E6%97%8F">SHA散列算法</a>。</li>
</ul>
</li>
</ul>
<h1 id="TCP-连接管理有限状态自动机"><a href="#TCP-连接管理有限状态自动机" class="headerlink" title="TCP 连接管理有限状态自动机"></a>TCP 连接管理有限状态自动机</h1><h2 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h2><p>有限状态机 (FSM : Finite State Machine) 又称有限状态自动机，简称状态机，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型。FSM 的四个基本概念如下：</p>
<ol>
<li>状态 state: 描述机器在特定时间上处于的 环境(circumstance)或状况(status)</li>
<li>转换 Transition: 从一种状态到另一种状态的行为(act)</li>
<li>事件 Event: 导致状态发生变化的事情</li>
<li>动作 Action: 机器从一种状态转换之前对事件所做的响应</li>
</ol>
<p>FSM通过解释协议可以处于的所有不同状态、可以在每个状态中发生的事件、针对事件采取的操作以及结果发生的转换来描述协议。协议通常在第一次运行时以特定的开始状态启动。尔后，它遵循一系列步骤使其进入常规操作状态，并根据特定类型的输入或其他情况移动到其他状态。状态机之所以称为有限状态机，是因为只有有限数量的状态。</p>
<p>建立连接和释放连接所需要的步骤，可以用一个有限状态自动机来表示，该状态自动机的11种状态如下。</p>
<p>在每一种状态中，都存在特定的合法事件：当一个合法事件发生时，可能需要采取某个动作；当发生其他事件时，则报告一个错误。</p>
<p>下表为TCP状态码列表，以<strong>S</strong>指代服务器，<strong>C</strong>指代客户端，<strong>S&amp;C</strong>表示两者，<strong>S/C</strong>表示两者之一：</p>
<ul>
<li><p>LISTEN S</p>
<p>服务器等待从任意远程TCP端口的连接请求。侦听状态。</p>
</li>
<li><p>SYN-SENT C</p>
<p>客户在发送连接请求后等待匹配的连接请求。通过connect()函数向服务器发出一个同步（SYNC）信号后进入此状态。</p>
</li>
<li><p>SYN-RECEIVED S</p>
<p>服务器已经收到并发送同步（SYNC）信号之后等待确认（ACK）请求。</p>
</li>
<li><p>ESTABLISHED S&amp;C</p>
<p>服务器与客户的连接已经打开，收到的数据可以发送给用户。数据传输步骤的正常情况。此时连接两端是平等的。这称作全连接。</p>
</li>
<li><p>FIN-WAIT-1 S&amp;C</p>
<p>（服务器或客户）主动关闭端调用close（）函数发出FIN请求包，表示<strong>本方的数据发送全部结束</strong>，等待TCP连接另一端的ACK确认包或FIN&amp;ACK请求包。</p>
</li>
<li><p>FIN-WAIT-2 S&amp;C</p>
<p>主动关闭端在FIN-WAIT-1状态下收到ACK确认包，进入等待远程TCP的连接终止请求的半关闭状态。这时<strong>主动关闭端可以接收数据，但不再发送数据</strong>。</p>
</li>
<li><p>CLOSE-WAIT S&amp;C</p>
<p>被动关闭端接到FIN后，就发出ACK以回应FIN请求，并进入等待本地用户的连接终止请求的半关闭状态。这时<strong>被动关闭端可以发送数据，但不再接收数据</strong>。</p>
</li>
<li><p>CLOSING S&amp;C</p>
<p>在发出FIN后，又收到对方发来的FIN后，进入等待对方对己方的连接终止（FIN）的确认（ACK）的状态。少见。</p>
</li>
<li><p>LAST-ACK S&amp;C</p>
<p>被动关闭端全部数据发送完成之后，<strong>向主动关闭端发送FIN，进入等待确认包</strong>的状态。</p>
</li>
<li><p>TIME-WAIT S/C</p>
<p>主动关闭端接收到FIN后，就发送ACK包，<strong>等待足够时间以确保被动关闭端收到了终止请求的确认包</strong>。（按照RFC 793，一个连接可以在TIME-WAIT保证最大四分钟，即最大分段寿命（Maximum Segment Lifetime）的2倍）</p>
</li>
<li><p>CLOSED S&amp;C<br>完全没有连接。</p>
</li>
</ul>
<p><img src="/2021/11/16/TCP/tcpfsm.jpg" alt="img"></p>
<p>另附一张图：</p>
<img src="tcp-state.jpg" style="zoom:60%;" />









<h1 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h1><h2 id="三次握手的过程"><a href="#三次握手的过程" class="headerlink" title="三次握手的过程"></a>三次握手的过程</h2><p><strong>图示</strong></p>
<p><img src="/2021/11/16/TCP/3way.png"></p>
<p><strong>文字描述</strong>（可能更清楚）</p>
<ol>
<li>A –&gt; B  SYN my sequence number is X</li>
<li> A &lt;– B  ACK your sequence number is X</li>
<li>A &lt;– B  SYN my sequence number is Y</li>
<li> A –&gt; B  ACK your sequence number is Y</li>
</ol>
<p>2与3都是 B 发送给 A，因此可以合并在一起，因此称为<code>three way (or three message) handshake</code>。</p>
<p>三次握手是 TCP 连接的建立过程。在握手之前，主动打开连接的客户端结束 CLOSE 阶段，被动打开的服务器也结束 CLOSE 阶段，并进入 LISTEN 阶段。随后进入三次握手阶段：</p>
<p>① 首先客户端向服务器发送一个 SYN 包，并等待服务器确认，其中：</p>
<ul>
<li>标志位为 SYN，表示请求建立连接；</li>
<li>序号为 Seq = x（x 一般取随机数）；</li>
<li>随后客户端进入 SYN-SENT 阶段。</li>
</ul>
<p>② 服务器接收到客户端发来的 SYN 包后，对该包进行确认后结束 LISTEN 阶段，并返回一段 TCP 报文，其中：</p>
<ul>
<li>标志位为 SYN 和 ACK，表示确认客户端的报文 Seq 序号有效，服务器能正常接收客户端发送的数据，并同意创建新连接；</li>
<li>序号为 Seq = y；</li>
<li>确认号为 Ack = x + 1，表示收到客户端的序号 Seq 并将其值加 1 作为自己确认号 Ack 的值。</li>
<li>随后服务器端进入 SYN-RECV 阶段。</li>
</ul>
<p>③ 客户端接收到发送的 SYN + ACK 包后，明确了从客户端到服务器的数据传输是正常的，从而结束 SYN-SENT 阶段。并返回最后一段报文。其中：</p>
<ul>
<li>标志位为 ACK，表示确认收到服务器端同意连接的信号；</li>
<li>序号为 Seq = x + 1，表示收到服务器端的确认号 Ack，并将其值作为自己的序号值；</li>
<li>确认号为 Ack= y + 1，表示收到服务器端序号 seq，并将其值加 1 作为自己的确认号 Ack 的值。</li>
<li>随后客户端进入 ESTABLISHED。当服务器端收到来自客户端确认收到服务器数据的报文后，得知从服务器到客户端的数据传输是正常的，从而结束 SYN-RECV 阶段，进入 ESTABLISHED 阶段，从而完成三次握手。</li>
</ul>
<h2 id="三次握手的意义"><a href="#三次握手的意义" class="headerlink" title="三次握手的意义"></a>三次握手的意义</h2><blockquote>
<p>常见问题：TCP 为什么是三次握手，而不是两次或四次？</p>
</blockquote>
<p>三次握手本身这个说法就是有点问题的。（有点抬杠）</p>
<p>其实三次握手这个说法不好，其实是双方各一次握手，各一次确认，其中一次握手和确认合并在一起，其实质就是双向握手+双向确认的过程。<br>这个解释也正是上面的文字描述的过程。</p>
<h3 id="教科书的回答"><a href="#教科书的回答" class="headerlink" title="教科书的回答"></a>教科书的回答</h3><p>在谢希仁著《计算机网络》第四版中讲“三次握手”的目的是<strong>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误</strong>。</p>
<p>在另一部经典的《计算机网络》一书中讲“三次握手”的目的是为了解决<strong>网络中存在延迟的重复分组</strong>的问题。</p>
<p>这两种不用的表述其实阐明的是同一个问题。</p>
<p>下面会对这两个问题作出详细解释。</p>
<h3 id="最简洁的回答"><a href="#最简洁的回答" class="headerlink" title="最简洁的回答"></a>最简洁的回答</h3><p>简单说，让双方都证实对方能发收。<br>知道对方能收是因为收到对方的因为收到而发的回应。</p>
<ol>
<li>A发，B收， B知道A能发</li>
<li>B发，A收， A知道B能发收</li>
<li>A发，B收， B知道A能收</li>
</ol>
<h3 id="综合全面的回答"><a href="#综合全面的回答" class="headerlink" title="综合全面的回答"></a>综合全面的回答</h3><ul>
<li>三次握手才可以阻止重复历史连接的初始化（主要原因）</li>
<li>三次握手才可以同步双方的初始序列号</li>
<li>三次握手才可以避免资源浪费</li>
</ul>
<h3 id="阻止重复历史连接的初始化"><a href="#阻止重复历史连接的初始化" class="headerlink" title="阻止重复历史连接的初始化"></a>阻止重复历史连接的初始化</h3><p>我们来看看 RFC 793 指出的 TCP 连接使用三次握手的<strong>首要原因</strong>：</p>
<p><em>The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.</em></p>
<p>简单来说，三次握手的<strong>首要原因是为了防止旧的重复连接初始化造成混乱。</strong></p>
<p>网络环境是错综复杂的，往往并不是如我们期望的一样，先发送的数据包，就先到达目标主机，相反可能会由于网络拥堵等原因，会使得旧的数据包，先到达目标主机，那么这种情况下 TCP 三次握手是如何避免的呢？</p>
<img src="avoid-old-duplicate-CR.jpg" style="zoom:50%;" />





<p>客户端连续发送多次 SYN 建立连接的报文，在网络拥堵等情况下：</p>
<ul>
<li>一个旧 SYN 报文比最新的 SYN  报文早到达了服务端；</li>
<li>那么此时服务端就会回一个 <code>SYN + ACK</code> 报文给客户端；</li>
<li>客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送 <code>RST</code> 报文给服务端，表示中止这一次连接。</li>
</ul>
<p>如果是两次握手连接，就不能判断当前连接是否是历史连接，三次握手则可以在客户端（发送方）准备发送第三次报文时，客户端因有足够的上下文来判断当前连接是否是历史连接：</p>
<ul>
<li>如果是历史连接（序列号过期或超时），则第三次握手发送的报文是 <code>RST</code> 报文，以此中止历史连接；</li>
<li>如果不是历史连接，则第三次发送的报文是 <code>ACK</code> 报文，通信双方就会成功建立连接；</li>
</ul>
<p>所以， TCP 使用三次握手建立连接的最主要原因是<strong>防止历史连接初始化了连接。</strong></p>
<h3 id="同步双方的初始序列号"><a href="#同步双方的初始序列号" class="headerlink" title="同步双方的初始序列号"></a>同步双方的初始序列号</h3><p>TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它的作用：</p>
<ul>
<li>接收方可以去除重复的数据；</li>
<li>接收方可以根据数据包的序列号按序接收；</li>
<li>可以标识发送出去的数据包中， 哪些是已经被对方收到的；</li>
</ul>
<p>可见，序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的 <code>SYN</code> 报文的时候，需要服务端回一个 <code>ACK</code> 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，<strong>这样一来一回，才能确保双方的初始序列号能被可靠的同步。</strong></p>
<img src="4and3way.jpg" style="zoom:50%;" />



<p>四次握手其实也能够可靠的同步双方的初始化序号，但由于<strong>第二步和第三步可以优化成一步</strong>，所以就成了「三次握手」。</p>
<p>而两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。</p>
<h3 id="避免资源浪费"><a href="#避免资源浪费" class="headerlink" title="避免资源浪费"></a>避免资源浪费</h3><p>如果只有「两次握手」，当客户端的 <code>SYN</code> 请求连接在网络中阻塞，客户端没有接收到 <code>ACK</code> 报文，就会重新发送 <code>SYN</code> ，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的 <code>ACK</code> 确认信号，所以每收到一个 <code>SYN</code> 就只能先主动建立一个连接，这会造成什么情况呢？</p>
<p>如果客户端的 <code>SYN</code> 阻塞了，重复发送多次 <code>SYN</code> 报文，那么服务器在收到请求后就会<strong>建立多个冗余的无效链接，造成不必要的资源浪费。</strong></p>
<img src="2-way.jpg" alt="img" style="zoom:50%;" />



<p>即两次握手会造成消息滞留情况下，服务器重复接受无用的连接请求 <code>SYN</code> 报文，而造成重复分配资源。</p>
<h3 id="回归本质的回答"><a href="#回归本质的回答" class="headerlink" title="回归本质的回答"></a>回归本质的回答</h3><p>这个问题的本质是, 信道不可靠, 每个包能到达跟下一个包能到达没有什么必然的联系。</p>
<p>但是通信双发需要就某个问题达成一致，而要解决这个问题,  无论你在消息中包含什么信息, 三次通信是理论上的最小值. 所以三次握手不是TCP本身的要求, 而是为了满足”在不可靠信道上可靠地传输信息”这一需求所导致的。</p>
<p>理论上讲不论握手多少次都不能确认一条信道是“可靠”的，但通过3次握手可以至少确认它是“可用”的，再往上加握手次数不过是提高“它是可用的”这个结论的可信程度。</p>
<p>这个问题在谢希仁版《计算机网络》里说了。</p>
<p><strong>三次是保证双方互相明确对方能收能发的最低值。</strong></p>
<p>因此,如果信道是可靠的, 即无论什么时候发出消息, 对方一定能收到，或者你不关心是否要保证对方收到你的消息, 那就能像UDP那样直接发送消息就可以了。</p>
<p>这可视为对“三次握手”目的的另一种解答思路。</p>
<h2 id="面试常见问题汇总"><a href="#面试常见问题汇总" class="headerlink" title="面试常见问题汇总"></a>面试常见问题汇总</h2><h3 id="三次握手的握手信息对方没有收到会怎么样"><a href="#三次握手的握手信息对方没有收到会怎么样" class="headerlink" title="三次握手的握手信息对方没有收到会怎么样"></a>三次握手的握手信息对方没有收到会怎么样</h3><h1 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h1><h2 id="四次挥手的过程"><a href="#四次挥手的过程" class="headerlink" title="四次挥手的过程"></a>四次挥手的过程</h2><p><strong>TCP连接是全双工的，但是在释放连接的时候最好把它看成是一对单双工连接。</strong></p>
<ol>
<li>客户端打算关闭连接，此时会发送⼀个 TCP ⾸部 FIN 标志位被置为 1 的报⽂，也即 FIN 报⽂，之后客</li>
</ol>
<p>户端进⼊ FIN_WAIT_1 状态。</p>
<ol start="2">
<li><p>服务端收到该报⽂后，就向客户端发送 ACK 应答报⽂，接着服务端进⼊ CLOSED_WAIT 状态。</p>
</li>
<li><p>客户端收到服务端的 ACK 应答报⽂后，之后进⼊ FIN_WAIT_2 状态。</p>
</li>
<li><p>等待服务端处理完数据后，也向客户端发送 FIN 报⽂，之后服务端进⼊ LAST_ACK 状态。</p>
</li>
<li><p>客户端收到服务端的 FIN 报⽂后，回⼀个 ACK 应答报⽂，之后进⼊ TIME_WAIT 状态</p>
</li>
<li><p>服务器收到了 ACK 应答报⽂后，就进⼊了 CLOSED 状态，⾄此服务端已经完成连接的关闭。</p>
</li>
</ol>
<p>客户端在经过 2MSL ⼀段时间后，⾃动进⼊ CLOSED 状态，⾄此客户端也完成连接的关闭。</p>
<p><strong>你可以看到，每个⽅向都需要⼀个 FIN 和⼀个 ACK，因此通常被称为四次挥⼿。</strong></p>
<p><strong>图示</strong></p>
<img src="4way.png" style="zoom:50%;" />





<p><strong>双⽅都可以主动断开连接</strong>，断开连接后主机中的<em>资源</em>将被释放。</p>
<p>这⾥⼀点需要注意是：主动关闭连接的，才有 <strong>TIME_WAIT</strong> 状态。</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="为什么挥⼿需要四次"><a href="#为什么挥⼿需要四次" class="headerlink" title="为什么挥⼿需要四次"></a>为什么挥⼿需要四次</h3><p>再来回顾下四次挥⼿双⽅发 FIN 包的过程，就能理解为什么需要四次了。</p>
<p>关闭连接时:</p>
<ol>
<li><p>客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。</p>
</li>
<li><p>服务器收到客户端的 FIN 报⽂时，先回⼀个 ACK 应答报⽂，⽽服务端可能还有数据需要处理和发送，等</p>
</li>
</ol>
<p>服务端不再发送数据时，才发送 FIN 报⽂给客户端来表示同意现在关闭连接。</p>
<p>从上⾯过程可知，<strong>服务端通常需要等待完成数据的发送和处理</strong>，所以<strong>服务端的 ACK 和 FIN ⼀般都会分开发</strong></p>
<p><strong>送</strong>，从⽽⽐三次握⼿导致多了⼀次。</p>
<blockquote>
<p>举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</p>
</blockquote>
<h3 id="为什么需要-TIME-WAIT-状态"><a href="#为什么需要-TIME-WAIT-状态" class="headerlink" title="为什么需要 TIME_WAIT 状态"></a>为什么需要 TIME_WAIT 状态</h3><p>主动发起关闭连接的⼀⽅，才会有 TIME-WAIT 状态。</p>
<p>需要 TIME-WAIT 状态，主要是两个原因：</p>
<ol>
<li><p>防⽌具有相同四元组的旧数据包被收到；</p>
</li>
<li><p>保证<em>被动关闭连接</em>的⼀⽅能被正确的关闭，即保证最后的 ACK 能让被动关闭⽅接收，从⽽帮助其正常关</p>
</li>
</ol>
<p>闭；</p>
<p><strong>原因1:防⽌旧连接的数据包</strong></p>
<p>假设 TIME-WAIT 没有等待时间或时间过短，被延迟的数据包抵达后会发⽣什么呢？</p>
<img src="timewait1.png" style="zoom:50%;" />



<ul>
<li><p>如上图⻩⾊框框服务端在关闭连接之前发送的 SEQ = 301 报⽂，被⽹络延迟了。</p>
</li>
<li><p>这时有相同端⼝的 TCP <strong>连接被复⽤</strong>后，被延迟的 SEQ = 301 抵达了客户端，那么客户端是有可能正常接收</p>
<p>这个过期的报⽂，这就会产⽣数据错乱等严᯿的问题。</p>
</li>
</ul>
<p>所以，TCP 就设计出了这么⼀个机制，经过 <strong>2MSL</strong> 这个时间，<strong>⾜以让两个⽅向上的数据包都被丢弃</strong>，使得原来</p>
<p>连接的数据包在⽹络中都⾃然消失，再出现的数据包⼀定都是新建⽴连接所产⽣的。</p>
<p><strong>原因2:保证连接正确关闭</strong></p>
<p>在 RFC 793 指出 TIME-WAIT 另⼀个重要的作⽤是：</p>
<blockquote>
<p> <em>TIME-WAIT - represents waiting for enough time to pass to be sure the remote TCP received theacknowledgment of its connection termination request.</em></p>
</blockquote>
<p>也就是说，TIME-WAIT 作⽤是<strong>等待⾜够的时间以确保最后的ACK能让被动关闭⽅接收</strong>，从⽽帮助其正常关闭。</p>
<p>假设 TIME-WAIT 没有等待时间或时间过短，断开连接会造成什么问题呢？</p>
<img src="timewait2.png" style="zoom:50%;" />



<ul>
<li><p>如上图红⾊框框客户端四次挥⼿的最后⼀个 ACK 报⽂如果在⽹络中被丢失了，此时如果客户端 TIME-WAIT 过短或没有，则就直接进⼊了 CLOSED 状态了，那么服务端则会⼀直处在 LASE_ACK 状态。</p>
</li>
<li><p>当客户端发起建⽴连接的 SYN 请求报⽂后，服务端会发送 RST 报⽂给客户端，连接建⽴的过程就会被</p>
</li>
</ul>
<p>终⽌。</p>
<p>如果 TIME-WAIT 等待⾜够⻓的情况就会遇到两种情况：</p>
<ul>
<li><p>服务端正常收到四次挥⼿的最后⼀个 ACK 报⽂，则服务端正常关闭连接。</p>
</li>
<li><p>服务端没有收到四次挥⼿的最后⼀个 ACK 报⽂时，则会重发 FIN 关闭连接报⽂并等待新的 ACK 报</p>
</li>
</ul>
<p>⽂。</p>
<p>所以客户端在 TIME-WAIT 状态等待 2MSL 时间后，就可以保证双⽅的连接都可以正常的关闭。</p>
<blockquote>
<p> 一个极端的情况：如果客户端第四次挥⼿ack丢失，服务端超时重发的fin报⽂也丢失，客户端timewait时间超过了2msl，这个时候会发⽣什么？认为连接已经关闭吗？</p>
<p>当客户端 timewait 时间超过了 2MSL，则客户端就直接进⼊关闭状态。</p>
<p>服务端超时重发 fin 报⽂的次数如果超过 <code>tcp_orphan_retries</code> ⼤⼩后，服务端也会关闭 TCP 连接。</p>
</blockquote>
<h3 id="为什么-TIME-WAIT-等待的时间是-2MSL"><a href="#为什么-TIME-WAIT-等待的时间是-2MSL" class="headerlink" title="为什么 TIME_WAIT 等待的时间是 2MSL"></a>为什么 TIME_WAIT 等待的时间是 2MSL</h3><p><strong>MSL</strong> 是 <code>Maximum Segment Lifetime</code>，报⽂最⼤⽣存时间，<strong>它是任何 TCP 报⽂在⽹络上存在的最⻓时间</strong>，超过这个时</p>
<p>间报⽂将被丢弃。因为 TCP 报⽂基于是 IP 协议的，⽽ IP 头中有⼀个 TTL 字段，是 IP 数据报可以经过的最⼤路</p>
<p>由数，每经过⼀个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报⽂通知源主机。</p>
<blockquote>
<p>MSL 与 TTL 的区别： MSL 的单位是时间;</p>
<p>TTL 是经过路由跳数。所以 <strong>MSL</strong> 应该要⼤于等于 <strong>TTL</strong> 消耗为 <strong>0</strong> 的时间，以确保报⽂已被⾃然消亡。</p>
</blockquote>
<p>TIME_WAIT 等待 2 倍的 MSL，⽐较合理的解释是： ⽹络中可能存在来⾃发送⽅的数据包，当这些发送⽅的数据包</p>
<p>被接收⽅处理后⼜会向对⽅发送响应，所以⼀来⼀回需要等待 2 倍的时间。</p>
<p>2 MSL 即是服务器端发出 FIN 报文和客户端发出的 ACK 报文所能保持有效的最大时长。</p>
<p><strong>第1个MSL用于被动关闭方等待最终ACK报文的超时，第2MSL用于被动关闭方重新发送FIN报文的传输时间。</strong></p>
<blockquote>
<p>如果重传的 Fin 也丢失了咋办，超过了两个2msl的时间。主动方（举例里客户端）也close了。而被动方（举例里服务端）还在last-ack阶段，会不会出问题。感觉这种情况有点极端就是了。</p>
</blockquote>
<p>⽐如，如果被动关闭⽅没有收到断开连接的最后的 ACK 报⽂，就会触发超时重发 Fin 报⽂，另⼀⽅接收到 FIN 后，会重发 ACK 给被动关闭⽅， ⼀来⼀去正好 2 个 MSL。</p>
<p><strong>2MSL 的时间是从客户端接收到FIN后发送ACK后开始计时的</strong>。如果在 TIME-WAIT 时间内，因为客户端的 ACK<br>没有传输到服务端，客户端⼜接收到了服务端重发的 FIN 报⽂，那么 <strong>2MSL</strong> 时间将重新计时。 </p>
<p>在 Linux 系统⾥ 2MSL 默认是 60 秒，那么⼀个 MSL 也就是 30 秒。<strong>Linux</strong> 系统停留在 <strong>TIME_WAIT</strong> 的时间为固定的 <strong>60</strong> 秒。</p>
<p>其定义在 Linux 内核代码⾥的名称为 TCP_TIMEWAIT_LEN：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCP_TIMEWAIT_LEN (60*HZ) <span class="comment">/* how long to wait to destroy TIME-WAIT</span></span></span><br><span class="line"><span class="meta"><span class="comment"></span></span></span><br><span class="line"><span class="meta"><span class="comment">state, about 60 seconds *</span></span></span><br></pre></td></tr></table></figure>

<p>如果要修改 TIME_WAIT 的时间⻓度，只能修改 Linux 内核代码⾥<code>TCP_TIMEWAIT_LEN</code>的值，并<strong>重新编译 Linux</strong></p>
<p><strong>内核</strong>。</p>
<h3 id="TIME-WAIT-过多的危害"><a href="#TIME-WAIT-过多的危害" class="headerlink" title="TIME_WAIT 过多的危害"></a>TIME_WAIT 过多的危害</h3><p>考虑高并发短连接的业务场景，在<strong>高并发短连接</strong>的 TCP 服务器上，当服务器处理完请求后主动请求关闭连接，这样服务器上会有大量的连接处于 TIME_WAIT 状态。服务器维护每一个连接需要一个 socket，也就是每个连接会占用一个文件描述符，而文件描述符的使用是有上限的，如果持续高并发，会导致一些正常的连接失败。</p>
<p>所以，过多的 TIME-WAIT 状态主要的危害有两种：</p>
<ol>
<li><p>内存资源占⽤；</p>
</li>
<li><p>对端⼝资源的占⽤，⼀个 TCP 连接⾄少消耗⼀个本地端⼝；</p>
</li>
</ol>
<p>第⼆个危害是会造成严重的后果的，要知道，端⼝资源也是有限的，⼀般可以开启的端⼝为 32768～61000 ，也</p>
<p>可以通过如下参数设置指定<code>net.ipv4.ip_local_port_range</code>。</p>
<p>如果发起连接⼀⽅的 <strong>TIME_WAIT</strong> 状态过多，占满了所有端⼝资源，则会导致⽆法创建新连接。</p>
<p>对于客户端和服务端而言， TIME-WAIT 状态的危害的侧重点并不一样：</p>
<ul>
<li><strong>客户端受端⼝资源限制</strong>：客户端TIME_WAIT过多，就会导致端⼝资源被占⽤，因为端⼝就65536个，被占满就会导致⽆法创建新连</li>
</ul>
<p>接。</p>
<ul>
<li><p><strong>服务端受系统资源限制</strong>：</p>
<p>由于⼀个 TCP 四元组表示 TCP 连接，理论上服务端可以建⽴很多连接，服务端只监听⼀个端⼝，但是会把</p>
<p>连接扔给处理线程，所以理论上监听的端⼝可以继续监听。但是线程池处理不了那么多⼀直不断的连接了。</p>
<p>所以当服务端出现⼤ᰁ TIMEWAIT 时，系统资源容易被耗尽。</p>
</li>
</ul>
<h3 id="如何解决TIME-WAIT过多"><a href="#如何解决TIME-WAIT过多" class="headerlink" title="如何解决TIME_WAIT过多"></a>如何解决TIME_WAIT过多</h3><p>这⾥给出优化 TIME-WAIT 的⼏个⽅式，都是有利有弊：</p>
<ol>
<li>打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项；</li>
<li>net.ipv4.tcp_max_tw_buckets</li>
<li>使⽤ SO_LINGER ，应⽤强制使⽤ RST 关闭。</li>
<li>使用 SO_REUSEADDR</li>
</ol>
<p><strong>⽅式⼀：<em>net.ipv4.tcp_tw_reuse</em> 和 <em>tcp_timestamps</em></strong></p>
<p>如下的 Linux 内核参数开启后，则可以复⽤处于 <strong>TIME_WAIT</strong> 的 <strong>socket</strong> 为新的连接所⽤。</p>
<p>有⼀点需要注意的是，<strong>tcp_tw_reuse</strong> 功能<strong>只能⽤于客户端</strong>（连接发起⽅），因为开启了该功能，在调⽤ <strong>connect()</strong> 函数时，内核会随机找⼀个 <strong>time_wait</strong> 状态超过 <strong>1</strong> 秒的连接给新的连接复⽤。</p>
<p><code>net.ipv4.tcp_tw_reuse = 1</code></p>
<p>使⽤这个选项，还有⼀个前提，需要打开对 TCP 时间戳的⽀持，即</p>
<p><code>net.ipv4.tcp_timestamps=1</code>(默认即为 1)</p>
<p>这个时间戳的字段是在 TCP 头部的option⾥，⽤于记录 TCP 发送⽅的当前时间戳和从对端接收到的最新时间</p>
<p>戳。</p>
<p><strong>由于引⼊了时间戳，我们在前⾯提到的 2MSL 问题就不复存在了，因为重复复的数据包会因为时间戳过期被⾃然丢弃</strong>。</p>
<p><strong>⽅式⼆：<em>net.ipv4.tcp_max_tw_buckets</em></strong></p>
<p>这个值默认为 18000，当系统中处于 TIME_WAIT 的连接⼀旦超过这个值时，系统就会将后⾯的 <strong>TIME_WAIT</strong> 连接</p>
<p>状态重置。</p>
<p>这个⽅法过于暴⼒，⽽且治标不治本，带来的问题远⽐解决的问题多，不推荐使⽤。</p>
<p><strong>⽅式三：程序中使⽤ <em>SO_LINGER</em></strong></p>
<p>我们可以通过设置 socket 选项，来设置调⽤ close 关闭连接⾏为。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span> <span class="title">so_linger</span>;</span></span><br><span class="line"></span><br><span class="line">so_linger.l_onoff = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">so_linger.l_linger = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">setsockopt(s, SOL_SOCKET, SO_LINGER, &amp;so_linger,<span class="keyword">sizeof</span>(so_linger));</span><br></pre></td></tr></table></figure>



<p>如果 l_onoff 为⾮ 0， 且 l_linger 值为 0，那么调⽤ close 后，会⽴该发送⼀个 RST 标志给对端，该 TCP 连接</p>
<p>将跳过四次挥⼿，也就跳过了 TIME_WAIT 状态，直接关闭。</p>
<p>但这为跨越 TIME_WAIT 状态提供了⼀个可能，不过是⼀个⾮常危险的⾏为，不值得提倡。</p>
<p>**方式四：socket设置SO_REUSEADDR **</p>
<p> SO_REUSEADDR 是⽤户态的选项，⽤于「连接的服务⽅」，⽤来告诉操作系统内核，如果端⼝已被占⽤，</p>
<p>但是 TCP 连接状态位于 TIME_WAIT ，可以重⽤端⼝。如果端⼝忙，⽽ TCP 处于其他状态，重⽤会有</p>
<p>“Address already in use” 的错误信息。</p>
<p>注意 <code>SO_REUSEADDR</code>和<code>net.ipv4.tcp_tw_reuse</code>的区别：</p>
<ol>
<li>tcp_tw_reuse 是内核选项，主要⽤在连接的发起⽅（客户端）。TIME_WAIT 状态的连接创建时间超过 1 秒</li>
</ol>
<p>后，新的连接才可以被复⽤，注意，这⾥是「连接的发起⽅」；</p>
<ol start="2">
<li>SO_REUSEADDR 是⽤户态的选项，⽤于「连接的服务⽅」，⽤来告诉操作系统内核，如果端⼝已被占⽤，</li>
</ol>
<p>但是 TCP 连接状态位于 TIME_WAIT ，可以᯿⽤端⼝。如果端⼝忙，⽽ TCP 处于其他状态，重⽤会有</p>
<p>“Address already in use” 的错误信息。</p>
<p>tcp_tw_reuse 是为了缩短 time_wait 的时间，避免出现⼤ᰁ的 time_wait 连接⽽占⽤系统资源，解决的是 accept</p>
<p>后的问题。</p>
<p>SO_REUSEADDR 是为了解决 time_wait 状态带来的端⼝占⽤问题，以及⽀持同⼀个 port 对应多个 ip，解决的是</p>
<p>bind 时的问题。</p>
<blockquote>
<p><a href="https://leetcode-cn.com/leetbook/read/networks-interview-highlights/ek40dd/">计算机网络面试突击</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE">传输控制协议</a></p>
<p><a href="https://www.cnblogs.com/shengs/p/10140678.html">服务器最大TCP连接数及调优汇总</a></p>
</blockquote>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>TreeMap、TreeSet源码</title>
    <url>/2021/07/30/TreeMap%E3%80%81TreeSet%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a><code>TreeMap</code></h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">NavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 比较器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 树根</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键值对的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    几个构造器方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        comparator = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> K&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        comparator = <span class="keyword">null</span>;</span><br><span class="line">        putAll(m);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(SortedMap&lt;K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        comparator = m.comparator();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            buildFromSorted(m.size(), m.entrySet().iterator(), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.io.IOException cannotHappen) &#123;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException cannotHappen) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// O(n*log(n))</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getEntry(key) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// O(n)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 内部 Entry 的遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = getFirstEntry(); e != <span class="keyword">null</span>; e = successor(e))</span><br><span class="line">            <span class="keyword">if</span> (valEquals(value, e.value))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">        <span class="keyword">return</span> (p==<span class="keyword">null</span> ? <span class="keyword">null</span> : p.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator() &#123;</span><br><span class="line">        <span class="keyword">return</span> comparator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最小键</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">firstKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key(getFirstEntry());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最大键</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">lastKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key(getLastEntry());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    一系列获取 entry 的 方法，</span></span><br><span class="line"><span class="comment">    然后再通过 entry 去操纵键值对</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getFirstEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; p = root;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">while</span> (p.left != <span class="keyword">null</span>)</span><br><span class="line">                p = p.left;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getLastEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; p = root;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">while</span> (p.right != <span class="keyword">null</span>)</span><br><span class="line">                p = p.right;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据键值查找 entry </span></span><br><span class="line">    <span class="comment">// O(logn)</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Offload comparator-based version for sake of performance</span></span><br><span class="line">        <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> getEntryUsingComparator(key);</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 从 树根开始，按照 BST 的搜索方式进行搜索</span></span><br><span class="line">        Entry&lt;K,V&gt; p = root;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> cmp = k.compareTo(p.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                p = p.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                p = p.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntryUsingComparator</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 算法与上面一致</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    下面四个方法的时间复杂度都是 O(logn)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回与大于或等于给定键的最小键相关联的键值映射，如果没有此键，则 null</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getCeilingEntry</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; p = root;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> cmp = compare(key, p.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.left != <span class="keyword">null</span>)</span><br><span class="line">                    p = p.left;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// key &lt; p.key 且 p 无 左孩子，那么 p.key 即为大于 key 中的最小键</span></span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p = p.right;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 下面的迭代需要注意一下，</span></span><br><span class="line">                    <span class="comment">// 向上回溯</span></span><br><span class="line">                    <span class="comment">// 需要找到第一个在p右边的祖先节点</span></span><br><span class="line">                    Entry&lt;K,V&gt; parent = p.parent;</span><br><span class="line">                    Entry&lt;K,V&gt; ch = p;</span><br><span class="line">                    <span class="keyword">while</span> (parent != <span class="keyword">null</span> &amp;&amp; ch == parent.right) &#123;</span><br><span class="line">                        ch = parent;</span><br><span class="line">                        parent = parent.parent;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> parent;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 刚好相等</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回与小于或等于给定键的最大键相关联的键值映射，如果没有此键，则 null </span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getFloorEntry</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 算法同上</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回与严格大于给定键的最小键相关联的键值映射，如果没有此键，则 null</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getHigherEntry</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 算法同上</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回严格小于给定键的最大键相关联的键值映射，如果没有此键，则 null </span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getLowerEntry</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 算法同上</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; t = root;</span><br><span class="line">        <span class="comment">// 树为空</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            compare(key, key); <span class="comment">// 类型检查、判空检查</span></span><br><span class="line">            root = <span class="keyword">new</span> Entry&lt;&gt;(key, value, <span class="keyword">null</span>);</span><br><span class="line">            size = <span class="number">1</span>;</span><br><span class="line">            modCount++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> cmp;</span><br><span class="line">        <span class="comment">// 记录轨迹</span></span><br><span class="line">        Entry&lt;K,V&gt; parent;</span><br><span class="line">        <span class="comment">// 区分使用比较器与否</span></span><br><span class="line">        Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line">        <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                parent = t;</span><br><span class="line">                cmp = cpr.compare(key, t.key);</span><br><span class="line">                <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                    t = t.left;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                    t = t.right;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 找到键，直接 setV</span></span><br><span class="line">                    <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">            &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不使用比较器</span></span><br><span class="line">        &#125;</span><br><span class="line">        Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            parent.left = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            parent.right = e;</span><br><span class="line">        <span class="comment">// 调用红黑树的平衡算法</span></span><br><span class="line">        fixAfterInsertion(e);</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用 deleteEntry;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        V oldValue = p.value;</span><br><span class="line">        deleteEntry(p);</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// O(1)</span></span><br><span class="line">    <span class="comment">// 只要 root = null， 经过可达性分析之后一整棵树都会被 GC</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        root = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// NavigableMap API methods</span></span><br><span class="line">    <span class="comment">// 下面省略了一系列的 NavigableMap接口的方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">firstEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exportEntry(getFirstEntry());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">lastEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exportEntry(getLastEntry());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ............</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    省略了视图类的代码</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 首次请求此视图时，初始化为包含条目集视图实例的字段。 </span></span><br><span class="line">    <span class="comment">// 视图是无状态的，因此没有理由创建多个视图。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意，是视图，而不是快照</span></span><br><span class="line">    <span class="comment">// 实现方法是通过通过内部类获取迭代器访问元素的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> EntrySet entrySet;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> KeySet&lt;K&gt; navigableKeySet;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;K,V&gt; descendingMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> navigableKeySet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> NavigableSet&lt;K&gt; <span class="title">navigableKeySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        KeySet&lt;K&gt; nks = navigableKeySet;</span><br><span class="line">        <span class="keyword">return</span> (nks != <span class="keyword">null</span>) ? nks : (navigableKeySet = <span class="keyword">new</span> KeySet&lt;&gt;(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Collection&lt;V&gt; vs = values;</span><br><span class="line">        <span class="keyword">if</span> (vs == <span class="keyword">null</span>) &#123;</span><br><span class="line">            vs = <span class="keyword">new</span> Values();</span><br><span class="line">            values = vs;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vs;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">        EntrySet es = entrySet;</span><br><span class="line">        <span class="keyword">return</span> (es != <span class="keyword">null</span>) ? es : (entrySet = <span class="keyword">new</span> EntrySet());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 下面是作者包装的一些小方法（省略大部分）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 exportEntry方法返回包装后的不可变的 Entry 因为内部的 Entry是可变的</span></span><br><span class="line">    <span class="keyword">static</span> &lt;K,V&gt; Map.<span class="function">Entry&lt;K,V&gt; <span class="title">exportEntry</span><span class="params">(TreeMap.Entry&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (e == <span class="keyword">null</span>) ? <span class="keyword">null</span> :</span><br><span class="line">            <span class="keyword">new</span> AbstractMap.SimpleImmutableEntry&lt;&gt;(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">computeRedLevel</span><span class="params">(<span class="keyword">int</span> sz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m = sz - <span class="number">1</span>; m &gt;= <span class="number">0</span>; m = m / <span class="number">2</span> - <span class="number">1</span>)</span><br><span class="line">             level++;</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 树的节点类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; left;</span><br><span class="line">    Entry&lt;K,V&gt; right;</span><br><span class="line">    <span class="comment">// 因为需要向上回溯，需要父指针</span></span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="comment">// 染色标记</span></span><br><span class="line">    <span class="keyword">boolean</span> color = BLACK;</span><br><span class="line"></span><br><span class="line">    Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        V oldValue = <span class="keyword">this</span>.value;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(logn)</span></span><br><span class="line"><span class="comment">// 后继节点，即下一个key</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">successor</span><span class="params">(Entry&lt;K,V&gt; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 存在右子树，则从右子树的根一直向左走</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; p = t.right;</span><br><span class="line">        <span class="keyword">while</span> (p.left != <span class="keyword">null</span>)</span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 向上回溯</span></span><br><span class="line">        <span class="comment">// 需要找到第一个在p右边的祖先节点</span></span><br><span class="line">        Entry&lt;K,V&gt; p = t.parent;</span><br><span class="line">        Entry&lt;K,V&gt; ch = t;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; ch == p.right) &#123;</span><br><span class="line">            ch = p;</span><br><span class="line">            p = p.parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前驱节点，即下一个key（算法与上面是对称的）</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">Entry&lt;K,V&gt; <span class="title">predecessor</span><span class="params">(Entry&lt;K,V&gt; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; p = t.left;</span><br><span class="line">        <span class="keyword">while</span> (p.right != <span class="keyword">null</span>)</span><br><span class="line">            p = p.right;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Entry&lt;K,V&gt; p = t.parent;</span><br><span class="line">        Entry&lt;K,V&gt; ch = t;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; ch == p.left) &#123;</span><br><span class="line">            ch = p;</span><br><span class="line">            p = p.parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    和《算法导论》采用的哑结点NIL略有不同，而是采用了包装过的访问器，</span></span><br><span class="line"><span class="comment">    避免对空指针一系列的判断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回颜色</span></span><br><span class="line"><span class="comment">// 如果为空，返回黑色，实际上就是对应哑结点NIL的黑色</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">colorOf</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (p == <span class="keyword">null</span> ? BLACK : p.color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回父节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">Entry&lt;K,V&gt; <span class="title">parentOf</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (p == <span class="keyword">null</span> ? <span class="keyword">null</span>: p.parent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不空，设置颜色</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">setColor</span><span class="params">(Entry&lt;K,V&gt; p, <span class="keyword">boolean</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>)</span><br><span class="line">        p.color = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左孩子</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">Entry&lt;K,V&gt; <span class="title">leftOf</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (p == <span class="keyword">null</span>) ? <span class="keyword">null</span>: p.left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右孩子</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">Entry&lt;K,V&gt; <span class="title">rightOf</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (p == <span class="keyword">null</span>) ? <span class="keyword">null</span>: p.right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">左/右旋操作比一般的写的要复杂，主要复杂在对parent指针的更新上。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 左旋</span></span><br><span class="line"><span class="comment">/** From CLR */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateLeft</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; r = p.right;</span><br><span class="line">        </span><br><span class="line">        p.right = r.left;</span><br><span class="line">        <span class="keyword">if</span> (r.left != <span class="keyword">null</span>)</span><br><span class="line">            r.left.parent = p;</span><br><span class="line">            </span><br><span class="line">        r.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            root = r;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.parent.left == p)</span><br><span class="line">            p.parent.left = r;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p.parent.right = r;</span><br><span class="line">            </span><br><span class="line">        r.left = p;</span><br><span class="line">        p.parent = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右旋</span></span><br><span class="line"><span class="comment">/** From CLR */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateRight</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; l = p.left;</span><br><span class="line">        p.left = l.right;</span><br><span class="line">        <span class="keyword">if</span> (l.right != <span class="keyword">null</span>) l.right.parent = p;</span><br><span class="line">        l.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            root = l;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.parent.right == p)</span><br><span class="line">            p.parent.right = l;</span><br><span class="line">        <span class="keyword">else</span> p.parent.left = l;</span><br><span class="line">        l.right = p;</span><br><span class="line">        p.parent = l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 在插入节点之后调用平衡算法</span></span><br><span class="line"><span class="comment">/** From CLR */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterInsertion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注意这里，必须染成红色，否则无法保证 红黑树第五条性质 ———— 任一节点的到叶节点的任一路径的黑高相同，但是会导致第二性质、第三性质的破坏 </span></span><br><span class="line">    x.color = RED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="keyword">null</span> &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == rightOf(parentOf(x))) &#123;</span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    rotateLeft(x);</span><br><span class="line">                &#125;</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                rotateRight(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 算法是对称的，“左”换成“右”即可</span></span><br><span class="line">            Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    rotateRight(x);</span><br><span class="line">                &#125;</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                rotateLeft(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root.color = BLACK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 供 remove 调用</span></span><br><span class="line"><span class="comment">// 这部分和《算法导论》的处理差别很大</span></span><br><span class="line"><span class="comment">// 个人认为 Josh Bloch and Doug Lea 的处理比 CLR 的更优雅一点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteEntry</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p 有两个孩子，用后继节点的键值代替 p 的键值</span></span><br><span class="line">    <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; s = successor(p);</span><br><span class="line">        p.key = s.key;</span><br><span class="line">        p.value = s.value;</span><br><span class="line">        <span class="comment">// 现在其实去删 p 的后继 s </span></span><br><span class="line">        p = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start fixup at replacement node, if it exists.</span></span><br><span class="line">    Entry&lt;K,V&gt; replacement = (p.left != <span class="keyword">null</span> ? p.left : p.right);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意下面的 p 可能已经不是原来的 p 了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (replacement != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// p要被替换，构建双向链接</span></span><br><span class="line">        replacement.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            root = replacement;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">            p.parent.left  = replacement;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p.parent.right = replacement;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Null out links so they are OK to use by fixAfterDeletion.</span></span><br><span class="line">        <span class="comment">// 这行代码可以被省略掉吗？</span></span><br><span class="line">        p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Fix replacement</span></span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">            fixAfterDeletion(replacement);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下面两种情况实际上是一种情况的细化</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 此时，p 没有孩子，且 p 就是根</span></span><br><span class="line">        root = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 此时 p 没有孩子，但是 p 并不是根</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果要删的 p 的颜色是红色，不会引起5条性质中任一条性质的破坏</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里先调整后删除也是可以的（虽然《算法导论》上仍然是先删除后调整）</span></span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">            fixAfterDeletion(p);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (p.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">                p.parent.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.right)</span><br><span class="line">                p.parent.right = <span class="keyword">null</span>;</span><br><span class="line">            p.parent = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除节点之后的平衡调整</span></span><br><span class="line"><span class="comment">/** From CLR */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterDeletion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x != root &amp;&amp; colorOf(x) == BLACK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; sib = rightOf(parentOf(x));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line">                setColor(sib, BLACK);</span><br><span class="line">                setColor(parentOf(x), RED);</span><br><span class="line">                rotateLeft(parentOf(x));</span><br><span class="line">                sib = rightOf(parentOf(x));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colorOf(leftOf(sib))  == BLACK &amp;&amp;</span><br><span class="line">                colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                setColor(sib, RED);</span><br><span class="line">                x = parentOf(x);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                    setColor(leftOf(sib), BLACK);</span><br><span class="line">                    setColor(sib, RED);</span><br><span class="line">                    rotateRight(sib);</span><br><span class="line">                    sib = rightOf(parentOf(x));</span><br><span class="line">                &#125;</span><br><span class="line">                setColor(sib, colorOf(parentOf(x)));</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(rightOf(sib), BLACK);</span><br><span class="line">                rotateLeft(parentOf(x));</span><br><span class="line">                x = root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// symmetric</span></span><br><span class="line">            Entry&lt;K,V&gt; sib = leftOf(parentOf(x));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line">                setColor(sib, BLACK);</span><br><span class="line">                setColor(parentOf(x), RED);</span><br><span class="line">                rotateRight(parentOf(x));</span><br><span class="line">                sib = leftOf(parentOf(x));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK &amp;&amp;</span><br><span class="line">                colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                setColor(sib, RED);</span><br><span class="line">                x = parentOf(x);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                    setColor(rightOf(sib), BLACK);</span><br><span class="line">                    setColor(sib, RED);</span><br><span class="line">                    rotateLeft(sib);</span><br><span class="line">                    sib = leftOf(parentOf(x));</span><br><span class="line">                &#125;</span><br><span class="line">                setColor(sib, colorOf(parentOf(x)));</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(leftOf(sib), BLACK);</span><br><span class="line">                rotateRight(parentOf(x));</span><br><span class="line">                x = root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setColor(x, BLACK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h1 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a><code>TreeSet</code></h1><p><code>TreeSet</code>的实现完全基于<code>TreeMap</code>, value使用一个哑值即可。<br>以便代码复用的最大化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">NavigableSet</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用 TreeMap 实现 TreeSet</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态的、所有键隐含的值，仅仅起一个哨兵作用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;E,Object&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.navigableKeySet().iterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">descendingIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.descendingKeySet().iterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> NavigableSet&lt;E&gt; <span class="title">descendingSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeSet&lt;&gt;(m.descendingMap());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.containsKey(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.remove(o)==PRESENT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        m.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.firstKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">last</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.lastKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">lower</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.lowerKey(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">floor</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.floorKey(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">ceiling</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.ceilingKey(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">higher</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.higherKey(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java集合类</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Java集合类</tag>
        <tag>源码系列</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper入门</title>
    <url>/2021/10/19/ZooKeeper%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="安装、配置"><a href="#安装、配置" class="headerlink" title="安装、配置"></a>安装、配置</h1><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p><a href="https://www.apache.org/dyn/closer.lua/zookeeper/zookeeper-3.7.0/apache-zookeeper-3.7.0-bin.tar.gz">下载链接</a></p>
<p>下载、解压之后，目录结构如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jisongyang@SongyangJi-MacBookAir apache-zookeeper-3.7.0-bin % ls -el</span><br><span class="line">total 48</span><br><span class="line">-rw-r--r--@  1 1000        1000   11358  3 17  2021 LICENSE.txt</span><br><span class="line">-rw-r--r--@  1 1000        1000     432  3 17  2021 NOTICE.txt</span><br><span class="line">-rw-r--r--@  1 1000        1000    2214  3 17  2021 README.md</span><br><span class="line">-rw-r--r--@  1 1000        1000    3570  3 17  2021 README_packaging.md</span><br><span class="line">drwxr-xr-x@ 18 jisongyang  1000     576  8 12 19:55 bin</span><br><span class="line">drwxr-xr-x@  6 1000        1000     192  8 12 03:39 conf</span><br><span class="line">drwxr-xr-x@ 25 1000        1000     800  3 17  2021 docs</span><br><span class="line">drwxr-xr-x  60 root        wheel   1920  8 11 18:41 lib</span><br><span class="line">drwxr-xr-x   5 root        wheel    160  9 12 12:49 logs</span><br></pre></td></tr></table></figure>

<p>照往常一样，配置一下环境变量。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>要启动需要一个配置文件，在 conf 在创建：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure>

<h2 id="单机运行"><a href="#单机运行" class="headerlink" title="单机运行"></a>单机运行</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>因为我放在了 /usr/local 目录下，加上sudo。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo zkServer start</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## 查看状态</span></span></span><br></pre></td></tr></table></figure>
<p>zkServer status</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这里的standalone指的是单机模。</span><br><span class="line"></span><br><span class="line">### 关闭</span><br><span class="line">&#96;&#96;&#96;shell</span><br><span class="line">sudo zkServer stop</span><br></pre></td></tr></table></figure>



<h1 id="客户端相关"><a href="#客户端相关" class="headerlink" title="客户端相关"></a>客户端相关</h1><h2 id="zkCli"><a href="#zkCli" class="headerlink" title="zkCli"></a>zkCli</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/zkCli.sh</span><br></pre></td></tr></table></figure>
<p>指定服务器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/zkCli.sh -server 127.0.0.1:2181</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">当然还有其他启动参数，不再一一介绍。</span><br><span class="line"></span><br><span class="line">输入`help`,查看命令：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>[zkshell: 0] help<br>ZooKeeper -server host:port cmd args<br>addauth scheme auth<br>close<br>config [-c] [-w] [-s]<br>connect host:port<br>create [-s] [-e] [-c] [-t ttl] path [data] [acl]<br>delete [-v version] path<br>deleteall path<br>delquota [-n|-b] path<br>get [-s] [-w] path<br>getAcl [-s] path<br>getAllChildrenNumber path<br>getEphemerals path<br>history<br>listquota path<br>ls [-s] [-w] [-R] path<br>ls2 path [watch]<br>printwatches on|off<br>quit<br>reconfig [-s] [-v version] [[-file path] | [-members serverID=host:port1:port2;port3[,…]<em>]] | [-add serverId=host:port1:port2;port3[,…]]</em> [-remove serverId[,…]*]<br>redo cmdno<br>removewatches path [-c|-d|-a] [-l]<br>rmr path<br>set [-s] [-v version] path data<br>setAcl [-s] [-v version] [-R] path acl<br>setquota -n|-b val path<br>stat [-w] path<br>sync path</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">最简单的如&#96;ls &#x2F;&#96;命令列出所有节点。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## zkui</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ 下载</span><br><span class="line"></span><br><span class="line">下载链接：https:&#x2F;&#x2F;github.com&#x2F;DeemOpen&#x2F;zkui</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;shell</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;DeemOpen&#x2F;zkui.git</span><br></pre></td></tr></table></figure>



<ul>
<li>安装</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd zkui/ # 进入工程界面</span><br><span class="line">mvn clean install # 进行maven打包，执行成功后会生成target文件夹，其中有jar文件。</span><br></pre></td></tr></table></figure>



<ul>
<li>配置</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> zkui web页面访问端口</span></span><br><span class="line">serverPort=9090</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> zookeeper集群的IP地址和端口（这里配置为单机模式）</span></span><br><span class="line">zkServer=localhost:2181</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置登录zkui的用户名和密码，这里我们将用户名和密码都设置为admin</span></span><br><span class="line">userSet = &#123;&quot;users&quot;: [&#123; &quot;username&quot;:&quot;admin&quot; , &quot;password&quot;:&quot;admin&quot;,&quot;role&quot;: &quot;ADMIN&quot; &#125;,&#123; &quot;username&quot;:&quot;appconfig&quot; , &quot;password&quot;:&quot;appconfig&quot;,&quot;role&quot;: &quot;USER&quot; &#125;]&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>启动</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup java -jar target/zkui-2.0-SNAPSHOT-jar-with-dependencies.jar &amp;</span><br></pre></td></tr></table></figure>






<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://zookeeper.apache.org/">Zookeeper官网</a></p>
<p><a href="http://ningg.top/zookeeper-getting-started/">ZooKeeper 初探：安装、使用</a></p>
<p><a href="https://www.jianshu.com/p/746799d3db07">安装zkui</a></p>
]]></content>
      <categories>
        <category>ZooKeeper</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>ZooKeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-Info命令输出详解</title>
    <url>/2021/12/09/Redis-Info%E5%91%BD%E4%BB%A4%E8%BE%93%E5%87%BA%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Redis-Info-输出详解"><a href="#Redis-Info-输出详解" class="headerlink" title="Redis Info 输出详解"></a>Redis Info 输出详解</h1><p>Redis 的 info 命令是使用频率很高的一个命令，它主要是显示 Redis 服务器当前状态，故我们经常用于监控Redis 服务器。我收集了一些参数解释，方便随时查询</p>
<h1 id="Info命令简介"><a href="#Info命令简介" class="headerlink" title="Info命令简介"></a>Info命令简介</h1><p>在使用Redis的过程中，可能会遇到很多问题，需要我们去诊断、去观察Redis的健康情况。Redis给我们提供了的 <code>info</code> 命令，可以让我们近距离的接触它，观察它各方面的信息、运行状况。下面让我们看看 <code>info</code> 命令都给我们带来了哪些信息。</p>
<p>命令格式：<code>INFO [section]</code></p>
<p>Info 指令显示的信息分为 9 大块，每块都有很多参数。我们也可以通过给定可选的参数 section ，可以让命令只返回某一部分的信息。这 9 块分别是:</p>
<ul>
<li><code>server</code> 部分记录了 Redis 服务器的信息</li>
<li><code>clients</code> 部分记录了已连接客户端的信息</li>
<li><code>memory</code> 部分记录了服务器的内存信息</li>
<li><code>persistence</code> 部分记录了跟 RDB 持久化和 AOF 持久化有关的信息</li>
<li><code>stats</code> 部分记录了一般统计信息</li>
<li><code>replication</code> 部分记录了主/从复制的相关信息</li>
<li><code>cpu</code> 部分记录了 CPU 的计算量统计信息</li>
<li><code>cluster</code> 部分记录了和集群有关的信息</li>
<li><code>keyspace</code> 部分记录了数据库相关的统计信息</li>
</ul>
<blockquote>
<p>不同版本的 Redis 可能对返回的一些域进行了增加或删减。 因此，一个健壮的客户端程序在对 INFO [section] 命令的输出进行分析时，应该能够跳过不认识的域，并且妥善地处理丢失不见的域。</p>
</blockquote>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h2><table>
<thead>
<tr>
<th>参数名称</th>
<th>参数含义</th>
</tr>
</thead>
<tbody><tr>
<td>redis_version</td>
<td>Redis 的服务器版本</td>
</tr>
<tr>
<td>redis_git_sha1</td>
<td>Redis 的服务器版本</td>
</tr>
<tr>
<td>redis_git_dirty</td>
<td>Git dirty flag</td>
</tr>
<tr>
<td>redis_build_id</td>
<td></td>
</tr>
<tr>
<td>redis_mode</td>
<td>运行模式：单机（集群）</td>
</tr>
<tr>
<td>os</td>
<td>Redis 服务器的宿主操作系统</td>
</tr>
<tr>
<td>arch_bits</td>
<td>架构（32 或 64 位）</td>
</tr>
<tr>
<td>multiplexing_api</td>
<td>Redis 所使用的事件处理机制，如epoll</td>
</tr>
<tr>
<td>gcc_version</td>
<td>编译 Redis 时所使用的 GCC 版本</td>
</tr>
<tr>
<td>process_id</td>
<td>服务器进程的 PID</td>
</tr>
<tr>
<td>run_id</td>
<td>Redis 服务器的随机标识符（用于 Sentinel 和集群）</td>
</tr>
<tr>
<td>tcp_port</td>
<td>TCP/IP 监听端口</td>
</tr>
<tr>
<td>uptime_in_seconds</td>
<td>自 Redis 服务器启动以来，经过的秒数</td>
</tr>
<tr>
<td>uptime_in_days</td>
<td>自 Redis 服务器启动以来，经过的天数</td>
</tr>
<tr>
<td>hz</td>
<td>redis内部调度（进行关闭timeout的客户端，删除过期key等等）频率，程序规定serverCron每秒运行10次。</td>
</tr>
<tr>
<td>lru_clock</td>
<td>以分钟为单位进行自增的时钟，用于 LRU 管理</td>
</tr>
<tr>
<td>executable</td>
<td>启动脚本路径</td>
</tr>
<tr>
<td>config_file</td>
<td>启动时指定的配置文件（redis.conf）路径</td>
</tr>
</tbody></table>
<h2 id="Clients"><a href="#Clients" class="headerlink" title="Clients"></a>Clients</h2><table>
<thead>
<tr>
<th>参数名称</th>
<th>参数含义</th>
</tr>
</thead>
<tbody><tr>
<td>connected_clients</td>
<td>已连接客户端的数量（不包括通过从属服务器连接的客户端）</td>
</tr>
<tr>
<td>client_longest_output_list</td>
<td>当前连接的客户端当中，最长的输出列表</td>
</tr>
<tr>
<td>client_longest_input_buf</td>
<td>当前连接的客户端当中，最大输入缓存</td>
</tr>
<tr>
<td>blocked_clients</td>
<td>正在等待阻塞命令（BLPOP、BRPOP、BRPOPLPUSH）的客户端的数量</td>
</tr>
</tbody></table>
<h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><table>
<thead>
<tr>
<th>参数名称</th>
<th>参数含义</th>
</tr>
</thead>
<tbody><tr>
<td>used_memory</td>
<td>使用内存（B）</td>
</tr>
<tr>
<td>used_memory_human</td>
<td>人类可读的格式的使用内存（MB）</td>
</tr>
<tr>
<td>used_memory_rss</td>
<td>操作系统角度，返回redis已分配的内存（即常驻内存），这个值和top、ps命令的输出一致</td>
</tr>
<tr>
<td>used_memory_rss_human</td>
<td>如上</td>
</tr>
<tr>
<td>used_memory_peak</td>
<td>内存使用的峰值</td>
</tr>
<tr>
<td>used_memory_peak_human</td>
<td>如上</td>
</tr>
<tr>
<td>total_system_memory</td>
<td>整个系统内存</td>
</tr>
<tr>
<td>total_system_memory_human</td>
<td>如上</td>
</tr>
<tr>
<td>used_memory_lua</td>
<td>Lua脚本存储占用的内存</td>
</tr>
<tr>
<td>used_memory_lua_human</td>
<td>如上</td>
</tr>
<tr>
<td>maxmemory</td>
<td>Redis实例的最大内存配置</td>
</tr>
<tr>
<td>maxmemory_human</td>
<td>如上</td>
</tr>
<tr>
<td>maxmemory_policy</td>
<td>当达到maxmemory时的淘汰策略</td>
</tr>
<tr>
<td>mem_fragmentation_ratio</td>
<td>used_memory_rss/used_memory的值。一般情况下，used_memory_rss略高于used_memory，当内存碎片较多时，则mem_fragmentation_ratio会较大，可以反映内存碎片是否很多</td>
</tr>
<tr>
<td>mem_allocator</td>
<td>内存分配器。可以是libc 、 jemalloc 或者 tcmalloc</td>
</tr>
</tbody></table>
<p>在理想情况下， <code>used_memory_rss</code> 的值应该只比 <code>used_memory</code> 稍微高一点儿。 当 <code>rss &gt; used</code> ，且两者的值相差较大时，表示存在（内部或外部的）内存碎片。 内存碎片的比率可以通过 <code>mem_fragmentation_ratio</code> 的值看出。 当 <code>used &gt; rss</code> 时，表示 Redis 的部分内存被操作系统换出到交换空间（swap）了，在这种情况下，操作可能会产生明显的延迟，需要重点关注。即：<code>mem_fragmentation_ratio</code> 小于1时</p>
<h2 id="Persistence"><a href="#Persistence" class="headerlink" title="Persistence"></a>Persistence</h2><table>
<thead>
<tr>
<th>参数名称</th>
<th>参数含义</th>
</tr>
</thead>
<tbody><tr>
<td>loading</td>
<td>服务器是否正在载入持久化文件</td>
</tr>
<tr>
<td>rdb_changes_since_last_save</td>
<td>离最近一次成功生成rdb文件，写入命令的个数</td>
</tr>
<tr>
<td>rdb_bgsave_in_progress</td>
<td>服务器是否正在创建rdb文件</td>
</tr>
<tr>
<td>rdb_last_save_time</td>
<td>最近一次成功rdb文件的时间戳</td>
</tr>
<tr>
<td>rdb_last_bgsave_status</td>
<td>最近一次成功rdb文件的状态</td>
</tr>
<tr>
<td>rdb_last_bgsave_time_sec</td>
<td>最近一次成功rdb文件的耗时</td>
</tr>
<tr>
<td>rdb_current_bgsave_time_sec</td>
<td>若当前正在创建rdb文件，指当前的创建操作已经耗费的时间</td>
</tr>
<tr>
<td>aof_enabled</td>
<td>aof是否开启</td>
</tr>
<tr>
<td>aof_rewrite_in_progress</td>
<td>aof的rewrite操作是否在进行中</td>
</tr>
<tr>
<td>aof_rewrite_scheduled</td>
<td>rewrite任务计划，当客户端发送bgrewriteaof指令，如果当前rewrite子进程正在执行，那么将客户端请求的bgrewriteaof变为计划任务，待aof子进程结束后执行rewrite</td>
</tr>
<tr>
<td>aof_last_rewrite_time_sec</td>
<td>最近一次aof rewrite耗费时长</td>
</tr>
<tr>
<td>aof_current_rewrite_time_sec</td>
<td>若当前正在执行aof rewrite，指当前的已经耗费的时间</td>
</tr>
<tr>
<td>aof_last_bgrewrite_status</td>
<td>最近一次aof bgrewrite的状态</td>
</tr>
<tr>
<td>aof_last_write_status</td>
<td>最近一次aof写入状态</td>
</tr>
<tr>
<td>开启 aof 后增加的一些info信息</td>
<td></td>
</tr>
<tr>
<td>aof_current_size</td>
<td>aof文件当前大小</td>
</tr>
<tr>
<td>aof_base_size</td>
<td>服务器启动时或者最近一次AOF重写后，文件的大小</td>
</tr>
<tr>
<td>aof_pending_rewrite</td>
<td>同上面的aof_rewrite_scheduled</td>
</tr>
<tr>
<td>aof_buffer_length</td>
<td>aof 缓冲区的大小</td>
</tr>
<tr>
<td>aof_rewrite_buffer_length</td>
<td>aof 重写缓冲区的大小</td>
</tr>
<tr>
<td>aof_pending_bio_fsync</td>
<td>后台IO队列中，等待fsync任务的个数</td>
</tr>
<tr>
<td>aof_delayed_fsync</td>
<td>被延迟的 fsync 调用数量</td>
</tr>
</tbody></table>
<h2 id="Stats"><a href="#Stats" class="headerlink" title="Stats"></a>Stats</h2><table>
<thead>
<tr>
<th>参数名称</th>
<th>参数含义</th>
</tr>
</thead>
<tbody><tr>
<td>total_connections_received</td>
<td>自启动起连接过的总数。如果连接过多，说明短连接严重或连接池使用有问题，需调研代码的连接设置</td>
</tr>
<tr>
<td>total_commands_processed</td>
<td>自启动起运行命令的总数</td>
</tr>
<tr>
<td>instantaneous_ops_per_sec</td>
<td>每秒执行的命令数，相当于QPS</td>
</tr>
<tr>
<td>total_net_input_bytes</td>
<td>网络入口流量字节数</td>
</tr>
<tr>
<td>total_net_output_bytes</td>
<td>网络出口流量字节数</td>
</tr>
<tr>
<td>instantaneous_input_kbps</td>
<td>网络入口kps</td>
</tr>
<tr>
<td>instantaneous_output_kbps</td>
<td>网络出口kps</td>
</tr>
<tr>
<td>rejected_connections</td>
<td>拒绝的连接个数，由于maxclients限制，拒绝新连接的个数</td>
</tr>
<tr>
<td>sync_full</td>
<td>主从完全同步成功次数</td>
</tr>
<tr>
<td>sync_partial_ok</td>
<td>主从部分同步成功次数</td>
</tr>
<tr>
<td>sync_partial_err</td>
<td>主从部分同步失败次数</td>
</tr>
<tr>
<td>expired_keys</td>
<td>自启动起过期的key的总数</td>
</tr>
<tr>
<td>evicted_keys</td>
<td>使用内存大于maxmemory后，淘汰的key的总数</td>
</tr>
<tr>
<td>keyspace_hits</td>
<td>在main dictionary字典中成功查到的key个数</td>
</tr>
<tr>
<td>keyspace_misses</td>
<td>同上，未命中的key的个数</td>
</tr>
<tr>
<td>pubsub_channels</td>
<td>发布/订阅频道数</td>
</tr>
<tr>
<td>pubsub_patterns</td>
<td>发布/订阅模式数</td>
</tr>
<tr>
<td>latest_fork_usec</td>
<td>上次的fork操作使用的时间（单位ms）</td>
</tr>
<tr>
<td>migrate_cached_sockets</td>
<td>是否已经缓存了到该地址的连接</td>
</tr>
<tr>
<td>slave_expires_tracked_keys</td>
<td>从实例到期key数量</td>
</tr>
<tr>
<td>active_defrag_hits</td>
<td>主动碎片整理命中次数</td>
</tr>
<tr>
<td>active_defrag_misses</td>
<td>主动碎片整理未命中次数</td>
</tr>
<tr>
<td>active_defrag_key_hits</td>
<td>主动碎片整理key命中次数</td>
</tr>
<tr>
<td>active_defrag_key_misses</td>
<td>主动碎片整理key未命中次数</td>
</tr>
</tbody></table>
<h2 id="Replication"><a href="#Replication" class="headerlink" title="Replication"></a>Replication</h2><table>
<thead>
<tr>
<th>参数名称</th>
<th>参数含义</th>
</tr>
</thead>
<tbody><tr>
<td>role</td>
<td>当前实例的角色master还是slave</td>
</tr>
<tr>
<td>connected_slaves:</td>
<td>slave的数量</td>
</tr>
<tr>
<td>master_replid</td>
<td>主实例启动随机字符串</td>
</tr>
<tr>
<td>master_replid2</td>
<td>主实例启动随机字符串2</td>
</tr>
<tr>
<td>slave0</td>
<td>slave机器的信息、状态</td>
</tr>
<tr>
<td>master_repl_offset</td>
<td>主从同步偏移量,此值如果和上面的offset相同说明主从一致没延迟，与master_replid可被用来标识主实例复制流中的位置。</td>
</tr>
<tr>
<td>second_repl_offset</td>
<td>主从同步偏移量2,此值如果和上面的offset相同说明主从一致没延迟</td>
</tr>
<tr>
<td>repl_backlog_active</td>
<td>复制缓冲区是否开启</td>
</tr>
<tr>
<td>repl_backlog_size</td>
<td>复制缓冲区大小</td>
</tr>
<tr>
<td>repl_backlog_first_byte_offset</td>
<td>复制缓冲区里偏移量的大小</td>
</tr>
<tr>
<td>repl_backlog_histlen</td>
<td>此值等于 master_repl_offset - repl_backlog_first_byte_offset,该值不会超过repl_backlog_size的大小</td>
</tr>
</tbody></table>
<h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><table>
<thead>
<tr>
<th>参数名称</th>
<th>参数含义</th>
</tr>
</thead>
<tbody><tr>
<td>used_cpu_sys</td>
<td>Redis 服务器耗费的系统 CPU</td>
</tr>
<tr>
<td>used_cpu_user</td>
<td>Redis 服务器耗费的用户 CPU</td>
</tr>
<tr>
<td>used_cpu_sys_children</td>
<td>后台进程耗费的系统 CPU</td>
</tr>
<tr>
<td>used_cpu_user_children</td>
<td>后台进程耗费的用户 CPU</td>
</tr>
</tbody></table>
<h2 id="Keyspace"><a href="#Keyspace" class="headerlink" title="Keyspace"></a>Keyspace</h2><table>
<thead>
<tr>
<th>参数名称</th>
<th>参数含义</th>
</tr>
</thead>
<tbody><tr>
<td>dbXXX:keys=XXX,expires=XXX</td>
<td>各个数据库（0-15）的 key 的数量，带有生存期的 key 的数量，平均存活时间</td>
</tr>
</tbody></table>
<p><strong>实例</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Server</span></span><br><span class="line">redis_version:3.2.3					 # Redis 的版本</span><br><span class="line">redis_git_sha1:00000000				 # Redis 的版本</span><br><span class="line">redis_git_dirty:0</span><br><span class="line">redis_build_id:9e93d0c7997bcfef</span><br><span class="line">redis_mode:standalone				 # 运行模式：单机（集群）</span><br><span class="line">os:Linux 2.6.32-431.el6.x86_64 x86_64 # 操作系统</span><br><span class="line">arch_bits:64						  # 操作系统位数</span><br><span class="line">multiplexing_api:epoll				 # redis所使用的事件处理机制</span><br><span class="line">gcc_version:4.4.7					 # gcc版本号</span><br><span class="line">process_id:1606						 # 当前 Redis 服务器进程id</span><br><span class="line">run_id:17e79b1966f1f891eff203a8e496151ee8a3a7a7</span><br><span class="line">tcp_port:7001						 # 端口号</span><br><span class="line">uptime_in_seconds:4360189			 # 运行时间(秒)</span><br><span class="line">uptime_in_days:50					 # 运行时间(天)</span><br><span class="line">hz:10								 # redis内部调度（进行关闭timeout的客户端，删除过期key等等）频率，程序规定serverCron每秒运行10次。</span><br><span class="line">lru_clock:5070330					 # Redis的逻辑时钟</span><br><span class="line">executable:/usr/local/bin/redis-server			# 启动脚本路径</span><br><span class="line">config_file:/opt/redis3/conf/redis_7001.conf	# 启动指定的配置文件路径</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Clients</span></span><br><span class="line">connected_clients:660				 # 连接的客户端数量</span><br><span class="line">client_longest_output_list:0		 # 当前连接的客户端当中，最长的输出列表</span><br><span class="line">client_biggest_input_buf:0			 # 当前连接的客户端当中，最大输入缓存</span><br><span class="line">blocked_clients:0					 # 阻塞的客户端数量</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Memory</span></span><br><span class="line">used_memory:945408832				# 使用内存（B）</span><br><span class="line">used_memory_human:901.61M			# 使用内存（MB）	</span><br><span class="line">used_memory_rss:1148919808			# 系统给redis分配的内存（即常驻内存），这个值和top命令的输出一致</span><br><span class="line">used_memory_rss_human:1.07G</span><br><span class="line">used_memory_peak:1162079480			# 内存使用的峰值</span><br><span class="line">used_memory_peak_human:1.08G		</span><br><span class="line">total_system_memory:6136483840		# 整个系统内存</span><br><span class="line">total_system_memory_human:5.72G</span><br><span class="line">used_memory_lua:122880				# Lua脚本存储占用的内存</span><br><span class="line">used_memory_lua_human:120.00K		</span><br><span class="line">maxmemory:2147483648				# Redis实例的最大内存配置</span><br><span class="line">maxmemory_human:2.00G</span><br><span class="line">maxmemory_policy:allkeys-lru		# 当达到maxmemory时的淘汰策略</span><br><span class="line">mem_fragmentation_ratio:1.22		# used_memory_rss/used_memory的比例。一般情况下，used_memory_rss略高于used_memory，当内存碎片较多时，则mem_fragmentation_ratio会较大，可以反映内存碎片是否很多</span><br><span class="line">mem_allocator:jemalloc-4.0.3		# 内存分配器</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Persistence</span>	</span><br><span class="line">loading:0								  # 服务器是否正在载入持久化文件</span><br><span class="line">rdb_changes_since_last_save:82423954	  #	离最近一次成功生成rdb文件，写入命令的个数                      </span><br><span class="line">rdb_bgsave_in_progress:0		          # 服务器是否正在创建rdb文件           </span><br><span class="line">rdb_last_save_time:1560991229		      # 最近一次成功rdb文件的时间戳               </span><br><span class="line">rdb_last_bgsave_status:ok		          # 最近一次成功rdb文件的状态           </span><br><span class="line">rdb_last_bgsave_time_sec:-1		          # 最近一次成功rdb文件的耗时            </span><br><span class="line">rdb_current_bgsave_time_sec:-1		      # 若当前正在创建rdb文件，指当前的创建操作已经耗费的时间                </span><br><span class="line">aof_enabled:0		                      # aof是否开启</span><br><span class="line">aof_rewrite_in_progress:0		          # aof的rewrite操作是否在进行中            </span><br><span class="line">aof_rewrite_scheduled:0		              # rewrite任务计划，当客户端发送bgrewriteaof指令，如果当前rewrite子进程正在执行，那么将客户端请求的bgrewriteaof变为计划任务，待aof子进程结束后执行rewrite        </span><br><span class="line">aof_last_rewrite_time_sec:-1		      # 最近一次aof rewrite耗费时长              </span><br><span class="line">aof_current_rewrite_time_sec:-1		      # 若当前正在执行aof rewrite，指当前的已经耗费的时间                </span><br><span class="line">aof_last_bgrewrite_status:ok		      # 最近一次aof bgrewrite的状态         </span><br><span class="line">aof_last_write_status:ok		          # 最近一次aof写入状态  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启aof后增加的一些info信息</span></span><br><span class="line">-----------------------------  </span><br><span class="line">aof_current_size:0                 # aof当前大小</span><br><span class="line">aof_base_size:0                    # aof上次启动或rewrite的大小</span><br><span class="line">aof_pending_rewrite:0              # 同上面的aof_rewrite_scheduled</span><br><span class="line">aof_buffer_length:0                # aof buffer的大小</span><br><span class="line">aof_rewrite_buffer_length:0        # aof rewrite buffer的大小</span><br><span class="line">aof_pending_bio_fsync:0            # 后台IO队列中等待fsync任务的个数</span><br><span class="line">aof_delayed_fsync:0                # 延迟的fsync计数器 </span><br><span class="line">-----------------------------           </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Stats</span></span><br><span class="line">total_connections_received:15815		# 自启动起连接过的总数。如果连接过多，说明短连接严重或连接池使用有问题，需调研代码的连接设置</span><br><span class="line">total_commands_processed:502953838      # 自启动起运行命令的总数</span><br><span class="line">instantaneous_ops_per_sec:7             # 每秒执行的命令数，相当于QPS</span><br><span class="line">total_net_input_bytes:532510481889      # 网络入口流量字节数</span><br><span class="line">total_net_output_bytes:1571444057940    # 网络出口流量字节数</span><br><span class="line">instantaneous_input_kbps:0.37           # 网络入口kps</span><br><span class="line">instantaneous_output_kbps:0.59          # 网络出口kps</span><br><span class="line">rejected_connections:0                  # 拒绝的连接个数，由于maxclients限制，拒绝新连接的个数</span><br><span class="line">sync_full:1                             # 主从完全同步成功次数</span><br><span class="line">sync_partial_ok:0                       # 主从部分同步成功次数</span><br><span class="line">sync_partial_err:0                      # 主从部分同步失败次数</span><br><span class="line">expired_keys:4404930                    # 自启动起过期的key的总数</span><br><span class="line">evicted_keys:0                          # 使用内存大于maxmemory后，淘汰的key的总数</span><br><span class="line">keyspace_hits:337104556                 # 在main dictionary字典中成功查到的key个数</span><br><span class="line">keyspace_misses:22865229                # 同上，未命中的key的个数</span><br><span class="line">pubsub_channels:1                       # 发布/订阅频道数</span><br><span class="line">pubsub_patterns:0                       # 发布/订阅模式数</span><br><span class="line">latest_fork_usec:707                    # 上次的fork操作使用的时间（单位ms）</span><br><span class="line">migrate_cached_sockets:0                # 是否已经缓存了到该地址的连接</span><br><span class="line">slave_expires_tracked_keys:0			# 从实例到期key数量</span><br><span class="line">active_defrag_hits:0                    # 主动碎片整理命中次数</span><br><span class="line">active_defrag_misses:0                  # 主动碎片整理未命中次数</span><br><span class="line">active_defrag_key_hits:0                # 主动碎片整理key命中次数</span><br><span class="line">active_defrag_key_misses:0              # 主动碎片整理key未命中次数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Replication</span></span><br><span class="line">role:master							  # 当前实例的角色master还是slave</span><br><span class="line">connected_slaves:1					  # slave的数量</span><br><span class="line">master_replid:8f81c045a2cb00f16a7fc5c90a95e02127413bcc		# 主实例启动随机字符串</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000     # 主实例启动随机字符串2</span><br><span class="line">slave0:ip=172.17.12.251,port=7002,state=online,offset=506247209326,lag=1	# slave机器的信息、状态</span><br><span class="line">master_repl_offset:506247209478		  # 主从同步偏移量,此值如果和上面的offset相同说明主从一致没延迟，与master_replid可被用来标识主实例复制流中的位置。</span><br><span class="line">second_repl_offset					  # 主从同步偏移量2,此值如果和上面的offset相同说明主从一致没延迟</span><br><span class="line">repl_backlog_active:1				  # 复制缓冲区是否开启</span><br><span class="line">repl_backlog_size:157286400			  # 复制缓冲区大小</span><br><span class="line">repl_backlog_first_byte_offset:506089923079		# 复制缓冲区里偏移量的大小</span><br><span class="line">repl_backlog_histlen:157286400		  # 此值等于 master_repl_offset - repl_backlog_first_byte_offset,该值不会超过repl_backlog_size的大小</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> CPU</span></span><br><span class="line">used_cpu_sys:6834.06				  # 将所有redis主进程在核心态所占用的CPU时求和累计起来</span><br><span class="line">used_cpu_user:8282.10				  # 将所有redis主进程在用户态所占用的CPU时求和累计起来</span><br><span class="line">used_cpu_sys_children:0.11			  # 后台进程的核心态cpu使用率</span><br><span class="line">used_cpu_user_children:0.91           # 后台进程的用户态cpu使用率</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Cluster</span></span><br><span class="line">cluster_enabled:0		# 实例是否启用集群模式</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Keyspace		<span class="comment"># 各个数据库（0-15）的 key 的数量，带有生存期的 key 的数量，平均存活时间</span></span></span><br><span class="line">db0:keys=267906,expires=109608,avg_ttl=3426011859194</span><br><span class="line">db1:keys=182,expires=179,avg_ttl=503527626</span><br><span class="line">db8:keys=6,expires=0,avg_ttl=0</span><br><span class="line">db15:keys=2,expires=0,avg_ttl=0</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Unix/Linux 中的五种 IO 模型</title>
    <url>/2021/11/20/Unix%E4%B8%AD%E7%9A%84%E4%BA%94%E7%A7%8D%20IO%20%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>IO模型的选择在Linux网络编程中十分重要，在Unix/Linux环境中主要提供了五种不同的IO模型，分别是</p>
<ol>
<li>阻塞式IO（blocking IO）；</li>
<li>非阻塞式IO（nonblocking IO）；</li>
<li>IO多路复用（ IO multiplexing）；</li>
<li>信号驱动式IO（signal driven IO）；</li>
<li>异步IO（asynchronous IO）。</li>
</ol>
<p>通常一个输入操作包含两个不同阶段：</p>
<ol>
<li>等待数据准备好</li>
<li> 从内核向进程复制数据</li>
</ol>
<img src="Unix中的五种 IO 模型/blockread.png" style="zoom:40%;" />



<p>对于网络IO而言，对于一个网络套接字上的输入操作，第一步通常涉及到发生系统调用，用户态切换到内核态并等待数据从网络中到达，当所有等待分组到达时，数据被复制到内核中的某个缓冲区。第二步则是将数据从内核缓冲区复制到应用进程缓冲区。</p>
<p>磁盘文件的IO比较特殊，内核采用缓冲区cache加速磁盘IO请求。因而<strong>一旦请求的数据到达内核缓冲区cache，对磁盘的write()操作立即返回</strong>，而不用等待将数据写入磁盘后再返回（除非在打开文件时指定了O_SYNC标志）。与之相对应的read()操作将数据从内核缓冲区cache移动到用户的缓冲区中，如果请求的数据不在内核缓冲区cache中，<strong>内核会让进程休眠</strong>，同时执行对磁盘的读操作。</p>
<p>所以实际上在磁盘IO中，等待阶段是不存在的，因为磁盘文件并不像网络IO那样，需要等待远程传输数据。</p>
<h1 id="阻塞式I-O"><a href="#阻塞式I-O" class="headerlink" title="阻塞式I/O"></a>阻塞式I/O</h1><p>Linux中，默认情况下所有的socket都是阻塞的。这里有必要辨析以下阻塞和非阻塞这两个概念，这两个概念<strong>描述的是用户线程调用内核I/O操作的方式</strong>，其中阻塞是指I/O操作需要彻底完成后才返回到用户空间；而非阻塞则是指I/O操作被调用后立即返回给用户一个状态值，不需要等到I/O操作彻底完成。</p>
<p>除非特别指定，几乎所有的I/O接口都是阻塞型的，即系统调用时不返回调用结果，只有当该系统调用获得结果或者超时出错才返回。这样的机制给网络编程带来了较大的影响，当线程因处理数据而处于阻塞状态时，线程将无法执行任何运算或者相应任何网络请求。</p>
<p>![](Unix中的五种 IO 模型/blockIO.png)</p>
<p>在服务器端使用阻塞I/O模型时结合<strong>多进程/多线程</strong>技术。</p>
<p>让每一个连接都拥有独立的进程/线程，任何一个连接的阻塞都不会影响到其他连接。（选择多进程还是多线程并无统一标准，因为进程的开销大于线程，所以在连接数较大的情况下推荐使用多线程。而进程相较于线程具有更高的安全性，所以如果单个服务执行体需要消耗较多的CPU资源，如需要进行大规模或长时间的数据运算或文件访问推荐使用多进程）。</p>
<p>当连接数规模继续增大，无论使用多线程还是多进程都会严重占据系统资源，降低系统对外界的响应效率，线程或者进程本身也更容易陷入假死。</p>
<p>此时可以采用“线程池”或“连接池”来降低创建和销毁进程/线程的频率，减少系统开销。</p>
<p>总之这里的线程模型实际上是<strong>一个socket对应一个进程/线程。</strong></p>
<h1 id="非阻塞式IO"><a href="#非阻塞式IO" class="headerlink" title="非阻塞式IO"></a>非阻塞式IO</h1><p>进程把一个套接字设置成非阻塞是在通知内核：<strong>当请求的I/O操作非得把本进程投入睡眠才能完成时，不要把本进程投入睡眠，而是返回一个错误</strong>。</p>
<p> 因此如果在打开文件时设定了O_NONBLOCK标志，则会以非阻塞方式打开文件。</p>
<p>如果I/O系统调用不能立即完成，则会返回错误而不是阻塞进程。非阻塞式I/O可以<strong>实现周期性检查</strong>（轮询）某个文件描述符是否可执行I/O操作。比如，设定一个输入文件描述符为非阻塞式的，然后周期性的执行非阻塞式读操作。如果需要同时检测多个文件描述符，则将其都设为非阻塞，然后一次轮询。但是这种<strong>轮询的效率不高</strong>，在轮询频率不高的情况下，程序响应I/O事件的延迟将难以接受。换句话说，在一个紧凑的循环中做轮询就是在<strong>浪费CPU时间</strong>，因为多数时间调用会立即出错并返回。</p>
<p>![](Unix中的五种 IO 模型/nonBlockIO.png)</p>
<blockquote>
<p>对于不能满足非阻塞式I/O操作，System V会返回EAGAIN错误而源于Berkeley的4.3BSD返回EWOULDBLOCK。如今大多数系统都把这两个错误码定义为相同的值。（可查看<code>&lt;sys/errno.h&gt;</code>）</p>
</blockquote>
<h1 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h1><p>![](Unix中的五种 IO 模型/iomulti.png)</p>
<p>I/O多路复用（也叫做事件驱动I/O）通过系统调用<code>select()</code>、<code>poll</code>、或者<code>epoll()</code>实现<strong>进程同时检查多个文件描述符</strong>，以找出其中任何一个是否可执行I/O操作。通过上图可以看出I/O多路复用与阻塞I/O模型差别并不大，事实上还要差一些，因为这里使用了两个系统调用而阻塞I/O只是用了一个系统调用。</p>
<p>但是<strong>I/O多路复用的优势是单个线程/进程可以同时处理多个连接</strong>。因此如果处理的连接数不是特别多的情况下使用I/O多路复用模型的web server不一定比使用多线程技术的阻塞I/O模型好。</p>
<p><strong>事实上，这种IO多路复用方式实际上也正是各种高性能网络框架以及高性能的网络服务器使用的最多的模式。</strong>所以，这也是我们学习的重点。</p>
<h1 id="信号驱动式I-O"><a href="#信号驱动式I-O" class="headerlink" title="信号驱动式I/O"></a>信号驱动式I/O</h1><p>![](Unix中的五种 IO 模型/sigio.png)</p>
<p>信号驱动I/O中，当文件描述符上可执行I/O操作时，进程请求内核为自己发送一个信号，之后进程可以执行其他任务直到I/O就绪为止，此时内核会发送信号给进程。建立一个针对套接字的信号驱动式I/O需要进程执行以下三个步骤：</p>
<ol>
<li>建立<code>SIGIO</code>信号处理函数</li>
<li>设置该套接字的属主，通常使用<code>fcntl</code>的<code>F_SETOWN</code>命令设置</li>
<li>开启该套接字的信号驱动式I/O，通常通过使用<code>fcnt</code>的<code>F_SETFL</code>命令打开<code>O_ASYNC</code>标志完成</li>
</ol>
<p>使用信号驱动式I/O模型的主要优点是<strong>在等待数据到达期间，进程不会被阻塞</strong>。</p>
<p><strong>信号驱动式I/O的应用</strong></p>
<ul>
<li><p>对于UDP上的使用比较简单，<code>SIGIO</code>信号只有在数据报到达套接字或者套接字发生异步错误时产生。因此当捕获对于某个UDP套接字的<code>SIGIO</code>信号时，我们调用recvfrom或者读入到达的数据报或者获取发生的异步错误。</p>
</li>
<li><p><strong>信号驱动式I/O对于TCP套接字几乎无用</strong>，主要原因是<code>SIGIO</code>信号产生会过于频繁，并且其出现并没有告知我们发生了什么事件。比如，当一个进程既读又写一个TCP套接字时，当有数据到达或者当前写出的数据得到确认时，<code>SIGIO</code>信号都会产生，而信号处理函数无法区分这两种情况。 <strong>应该只考虑对监听TCP套接字使用<code>SIGIO</code>，因为对于监听TCP套接字产生<code>SIGIO</code>的唯一条件是某个新连接的完成</strong>。</p>
</li>
</ul>
<h1 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h1><p>![](Unix中的五种 IO 模型/aio.png)</p>
<p>对于I/O操作主要有两种分别是异步I/O和同步I/O，对于同步I/O会导致请求进程阻塞，直到I/O操作完成，即必须等待I/O操作完成以后控制权才返回给用户进程；而异步I/O不会导致请求进程阻塞，即无需等待I/O操作完成就将控制权返回给用户进程。</p>
<ul>
<li><p>异步I/O模型的工作机制</p>
<p>告知内核启动某个操作，并让内核在整个操作（包括将数据从内核复制到进程缓冲区）完成后通知我们。主要方式是调用<code>aio_read</code>函数向内核传递描述符、缓冲区指针、缓冲区大小（与read相同的三个参数）和文件偏移，并告知内核当整个操作完成时如何通知用户进程。该系统调用立即返回，在等待I/O完成期间进程不被阻塞。</p>
</li>
<li><p>与信号驱动式I/O模型的区别<br>信号驱动式I/O是由内核告诉我们<strong>何时可以启动一个I/O操作</strong>，而异步I/O模型则是由内核通知我们<strong>I/O操作何时完成</strong>。</p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>5种IO模式的对比：</p>
<p>![](Unix中的五种 IO 模型/compareIO.png)</p>
<p>前4中模型的区别主要在于第一阶段，因为它们的第二阶段都是一样的：在数据从内核复制到用户空间的缓冲区期间，进程阻塞于<code>read</code>调用。</p>
<p>相反异步模型在这两个阶段都要进行处理，在完成的时候才会通知调用者已经完成。</p>
<h2 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h2><p>阻塞与非阻塞的区分是在第一阶段，也就是等待数据报有没有到的情况。</p>
<h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><ul>
<li><p>同步I/O会导致请求进程阻塞，直到I/O操作完成，即必须等待I/O操作完成以后控制权才返回给用户进程；</p>
</li>
<li><p>异步I/O不会导致请求进程阻塞，即无需等待I/O操作完成就将控制权返回给用户进程。</p>
</li>
</ul>
<h2 id="非阻塞与异步的区别"><a href="#非阻塞与异步的区别" class="headerlink" title="非阻塞与异步的区别"></a>非阻塞与异步的区别</h2><p>在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。</p>
]]></content>
      <categories>
        <category>IO</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/03/08/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua脚本以及在redis中使用lua</title>
    <url>/2021/11/30/lua/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="什么是lua"><a href="#什么是lua" class="headerlink" title="什么是lua"></a>什么是lua</h1><h2 id="Mac安装-lua"><a href="#Mac安装-lua" class="headerlink" title="Mac安装 lua"></a>Mac安装 lua</h2><p><strong>安装</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew search lua</span><br><span class="line">brew install lua</span><br></pre></td></tr></table></figure>

<p><strong>进入shell</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lua</span><br></pre></td></tr></table></figure>

<p><strong>运行脚本文件</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x test_lua.lua</span><br><span class="line">/test_lua.lua</span><br></pre></td></tr></table></figure>


<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p><strong>行注释</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 这是注释</span></span><br></pre></td></tr></table></figure>


<p><strong>段注释</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">这是块注释</span></span><br><span class="line"><span class="comment">这是块注释</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure>





<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(b) <span class="comment">-- 无初始值为 nil</span></span><br></pre></td></tr></table></figure>


<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>在redis脚本中不能使用全局变量，只能使用局部变量（其实是为了防止脚本之间相互影响）</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">local</span> b</span><br><span class="line"><span class="keyword">local</span> c, d</span><br><span class="line"><span class="keyword">local</span> e, f, g = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br></pre></td></tr></table></figure>


<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="空"><a href="#空" class="headerlink" title="空"></a>空</h3><p>没有赋值的变量或者表的字段即为nil，空。</p>
<h3 id="布尔"><a href="#布尔" class="headerlink" title="布尔"></a>布尔</h3><p>只有true，false。</p>
<h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p>包括整数、浮点数，1、2.0、3.5e10</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> s1 = <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">local</span> s2 = <span class="string">&quot;abc&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><p>lua中唯一的数据结构，既可以当数组，也可以当字典。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">a = &#123;&#125;</span><br><span class="line">b = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">c = &#123;<span class="string">&#x27;s1&#x27;</span>, <span class="string">&#x27;s2&#x27;</span>, <span class="string">&#x27;s3&#x27;</span>&#125;</span><br><span class="line">d = &#123;<span class="number">1</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;a&#x27;</span>&#125;</span><br><span class="line">c[<span class="number">1</span>] <span class="comment">-- &#x27;s1&#x27;</span></span><br><span class="line">d[<span class="number">1</span>] = d[<span class="number">1</span>] + <span class="number">1</span></span><br></pre></td></tr></table></figure>


<p><strong>注意：Lua规定数组的索引从 1 开始的，而不是 0</strong></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">(函数列表)</span></span></span><br><span class="line">  函数题</span><br><span class="line"><span class="keyword">end</span> </span><br></pre></td></tr></table></figure>


<p>例子1</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m</span><span class="params">(a,b)</span></span></span><br><span class="line">  <span class="keyword">return</span> a*b</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>递归</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span><span class="params">(n)</span></span></span><br><span class="line">  <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> fun(n - <span class="number">2</span>) + fun(n - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">5</span>&gt;<span class="number">10</span>) <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;10&#x27;</span>);</span><br><span class="line"><span class="keyword">elseif</span> <span class="number">15</span>&gt;<span class="number">10</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;15&#x27;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件表达式 <span class="keyword">do</span></span><br><span class="line">  语句块</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">sum = <span class="number">0</span></span><br><span class="line">num = <span class="number">1</span></span><br><span class="line"><span class="comment">-- 注意 do 和 end</span></span><br><span class="line"><span class="keyword">while</span> num &lt;= <span class="number">100</span> <span class="keyword">do</span></span><br><span class="line">    sum = sum + num</span><br><span class="line">    num = num + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;sum =&quot;</span>,sum)</span><br></pre></td></tr></table></figure>



<h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 = 初值, 终值, 步长 <span class="keyword">do</span></span><br><span class="line">  语句块</span><br><span class="line"><span class="keyword">end</span>  </span><br></pre></td></tr></table></figure>

<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="comment">-- 默认步长是1</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, <span class="number">100</span> <span class="keyword">do</span></span><br><span class="line">    sum = sum + i</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>另一个格式</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> var1, var2, ..., varn <span class="keyword">in</span> 迭代器 <span class="keyword">do</span></span><br><span class="line">  语句块</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>





<p><strong>表的遍历</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- #获取表的长度</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, #a <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">print</span>(i)</span><br><span class="line">  <span class="built_in">print</span>(a[i])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 ipairs</span></span><br><span class="line"><span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">ipairs</span>(a) <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">print</span>(index)</span><br><span class="line">  <span class="built_in">print</span>(value)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h1 id="常用库"><a href="#常用库" class="headerlink" title="常用库"></a>常用库</h1><h2 id="String库"><a href="#String库" class="headerlink" title="String库"></a>String库</h2><ol>
<li>获取长度<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(#a) <span class="comment">-- 长度为3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">len</span>(<span class="string">&#x27;abc&#x27;</span>))</span><br></pre></td></tr></table></figure></li>
</ol>
<ol start="2">
<li>大小写转换<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>.<span class="built_in">lower</span>(s)</span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">upper</span>(s)</span><br></pre></td></tr></table></figure></li>
</ol>
<ol start="3">
<li>子串<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 闭区间，end可以取到</span></span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">sub</span>(s, start, [,<span class="keyword">end</span>])</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Table-库"><a href="#Table-库" class="headerlink" title="Table 库"></a>Table 库</h2><p>暂略。</p>
<h2 id="Math-库"><a href="#Math-库" class="headerlink" title="Math 库"></a>Math 库</h2><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">math</span>.<span class="built_in">max</span>(x, ...)</span><br><span class="line"><span class="built_in">math</span>.<span class="built_in">min</span>(x, ...)</span><br><span class="line"><span class="built_in">math</span>.<span class="built_in">abs</span>(x)</span><br></pre></td></tr></table></figure>





<h1 id="Redis和Lua"><a href="#Redis和Lua" class="headerlink" title="Redis和Lua"></a>Redis和Lua</h1><h3 id="lua使用redis"><a href="#lua使用redis" class="headerlink" title="lua使用redis"></a>lua使用redis</h3><p>在lua脚本使用<code>redis.call</code></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">redis.call(<span class="string">&#x27;set&#x27;</span>,<span class="string">&#x27;key1&#x27;</span>,<span class="string">&#x27;val1&#x27;</span>)</span><br><span class="line"><span class="keyword">local</span> v = redis.call(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> v</span><br></pre></td></tr></table></figure>

<h3 id="redis-cli中使用lua"><a href="#redis-cli中使用lua" class="headerlink" title="redis-cli中使用lua"></a>redis-cli中使用lua</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">EVAL script numkeys key [key ...] arg [arg ...]</span><br></pre></td></tr></table></figure>



<h3 id="KEYS-和-ARGV"><a href="#KEYS-和-ARGV" class="headerlink" title="KEYS 和 ARGV"></a>KEYS 和 ARGV</h3><p>使用 <code>KEYS</code>获取键，使用<code>ARGV</code>获取值。</p>
<blockquote>
<p>注意索引从 1 开始。</p>
</blockquote>
<h3 id="原子性和执行时间"><a href="#原子性和执行时间" class="headerlink" title="原子性和执行时间"></a>原子性和执行时间</h3><p>Redis执行lua脚本是原子的，也就是在一个脚本执行期间不会执行其他命令。</p>
<p>所有其他的命令都必须在脚本执行完成后才能执行。</p>
<p>为了防止一个脚本执行时间太长，Redis提供<code>lua-time-limit</code>限制脚本的最长运行时间（默认是 5 秒），</p>
<p>时间到了，就可以接受其他命令，但这个脚本的执行就无法无确保原子性了，因为它还没有只执行完。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
        <tag>Redis</tag>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL —— Redo log</title>
    <url>/2021/12/09/redolog/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="RedoLog介绍"><a href="#RedoLog介绍" class="headerlink" title="RedoLog介绍"></a>RedoLog介绍</h1><h2 id="引言——MySQL如何做到事务的持久性"><a href="#引言——MySQL如何做到事务的持久性" class="headerlink" title="引言——MySQL如何做到事务的持久性"></a>引言——MySQL如何做到事务的持久性</h2><p>MySQL中如何修改数据呢，先从磁盘中加载数据页到InnoDB buffer pool中，然后从InnoDB buffer pool 中取出页面，进行读写操作。</p>
<p>那么如何做到事务的持久性呢，也就是说如何确保InnoDB buffer pool中的脏页一定会被刷新到磁盘从而做到持久化呢？</p>
<p>一种最简单的方法，在事务提交成功之前，确保脏页被刷新到磁盘，换句话说，只有在脏页写到磁盘上之后，事务提交才算成功。</p>
<p>不过这种方案有缺点：</p>
<ol>
<li><strong>每次都刷新一个完整的页到磁盘性能开销很大</strong>。比如，一个页面中只有几个字节被修改的时候，刷新完整的页面到磁盘很浪费。</li>
<li><strong>磁盘的随机IO很慢</strong>，一个事务修改的很多页面可能并不相邻，这个时候每个事务结束前都这样同步刷新的磁盘随机IO代价很大。</li>
</ol>
<p>MySQL采取的做法是，仅仅记录下那些修改的操作，譬如<strong>修改某个表空间的某个页面的某个偏移量的某几个字节</strong>，然后将这样的记录及时写到文件中。然后每次事务提交前只需要刷新这样的日志文件到磁盘即可。</p>
<p>而这样的日志文件就是 <strong>rodo log</strong> 了。</p>
<p>刷新redo-log而不是完整的数据页到磁盘的好处有：</p>
<ol>
<li>redo日志相对来讲比较紧凑，占用的空间比较小；</li>
<li>redo日志是顺序写入磁盘的，磁盘的顺序IO效率很高。</li>
</ol>
<h2 id="redo日志格式"><a href="#redo日志格式" class="headerlink" title="redo日志格式"></a>redo日志格式</h2><p>redo log 包括两部分：</p>
<ol>
<li><p>一个是内存中的日志缓冲(redo log buffer)；</p>
</li>
<li><p>另一个是磁盘上的日志文件(redo log file)。</p>
</li>
</ol>
<p>下面依次介绍</p>
<ol>
<li>type：这条redo日志的格式；</li>
<li>space ID：表空间 ID；</li>
<li>page number：页号；</li>
<li>data：这条redo日志的具体内容。</li>
</ol>
<p>具体来说redo日志的种类有非常多，这里就不细谈了。</p>
<p>挖个坑。</p>
<h2 id="Mini-transaction-的概念"><a href="#Mini-transaction-的概念" class="headerlink" title="Mini-transaction 的概念"></a>Mini-transaction 的概念</h2><p>MySQL对底层页面的一次原子性的访问成为一个Mini-Transaction（MTR）</p>
<p>一个MTR产生多个redo日志。</p>
<p>之所以把它成为迷你的一个事务，是因为在进行崩溃恢复的时候需要把这一组redo日志作为一个不可分割的整体来处理。</p>
<img src="mtr.png" style="zoom:30%;" />



<h2 id="redo日志的管理"><a href="#redo日志的管理" class="headerlink" title="redo日志的管理"></a>redo日志的管理</h2><h3 id="log-block"><a href="#log-block" class="headerlink" title="log block"></a>log block</h3><p>redo日志放在大小为512字节的log block 中。每一个block被分为 3 部分：</p>
<ul>
<li>log block header</li>
<li>log block body</li>
<li>log block trailer</li>
</ul>
<p>而真正的redo日志是被放在占用 496 字节的 block body 中的。</p>
<h3 id="redo-log-buffer"><a href="#redo-log-buffer" class="headerlink" title="redo log buffer"></a>redo log buffer</h3><p>为了解决磁盘速度过慢的问题，写入redo日志也不是直接立即写到磁盘中的。</p>
<p>于是，MySQL向操作系统申请了一大片内存，称为redo 日志缓冲区，也成为 redo buffer，</p>
<p>一个redo buffer有若干的 log block 构成。可以指定<code>innodb_log_buffer_size</code>来指定 log buffer 的大小。</p>
<p>向 log buffer 中写入redo日志也是顺序写入的。</p>
<h2 id="redo-log的刷盘时机"><a href="#redo-log的刷盘时机" class="headerlink" title="redo log的刷盘时机"></a>redo log的刷盘时机</h2><p>redo日志总留在log buffer中，总是不安全的，只要没有写到稳定的存储介质（磁盘、固定硬盘等等）中就不能保证持久性。</p>
<p>那么在什么情况下，redo日志会被写到磁盘上呢？</p>
<ol>
<li><p>事务提交时：道理很好理解，事务提交还没有将redo log 刷盘就无法做到持久性；</p>
</li>
<li><p>log buffer 空间不足时：log buffer 这块内存总是有限大小的，那么在redo log不够使用时，也需要即使把redo log 刷新到磁盘。InnoDB在日志量达到总容量的额50% 时，就会刷盘；</p>
</li>
<li><p>后台线程定时刷新；</p>
</li>
<li><p>正常关闭服务器时；</p>
</li>
<li><p>做checkpoint时。</p>
</li>
</ol>
<h2 id="redo日志文件"><a href="#redo日志文件" class="headerlink" title="redo日志文件"></a>redo日志文件</h2><p>之前谈的所有的redo log其实都是内存性的结构，那么存在在稳定介质中的便是 redo日志文件了。</p>
<p>磁盘上的日志文件不止一个，而是以一个日志文件组的形式出现，一个日志文件组由多个日志文件组成，名字形式为”ib_logfile[数字]”。<br>每个日志文件的大小由<code>innodb_log_file_size</code>指定，默认是 48 MB。<br>日志文件组文件的个数由<code>innodb_log_files_in_group</code>指定，默认是2个。</p>
<p>所以，总体的日志文件的大小便是<strong>innodb_log_file_size*innodb_log_files_in_group</strong>，</p>
<p>如果以循环的方法向redo日志文件中写入数据，那岂不是新写入的会覆盖旧写入的吗？</p>
<p>如何解决这个问题，MySQL提出了 checkpoint的概念（后面或介绍）。</p>
<p>每个日志的文件格式是一样的，日志组内的其他的日志文件也是具有相同的格式。</p>
<p>前2048个字节存储一些管理信息，后面的字节，实际上就是对内存中的log buffer的镜像。</p>
<h2 id="log-sequence-number相关"><a href="#log-sequence-number相关" class="headerlink" title="log-sequence-number相关"></a>log-sequence-number相关</h2><h3 id="lsn"><a href="#lsn" class="headerlink" title="lsn"></a>lsn</h3><p>InndoDB设计了名为lsn的全局变量，用来记录当前已经写入的<strong>lsn</strong>值，初始值为8704，然后不断递增。</p>
<p>lsn指的是写入的redo 日志量，这包括了写到了 log buffer 中但没有刷新到磁盘的redo日志。</p>
<h3 id="flushed-to-disk-lsn"><a href="#flushed-to-disk-lsn" class="headerlink" title="flushed_to_disk_lsn"></a>flushed_to_disk_lsn</h3><p>相应的，InndoDB设计者提出了一个表示刷新到磁盘中的redo日志量的全局变量<strong>flushed_to_disk_lsn</strong>。</p>
<p>一开始，lsn等于flushed_to_disk_lsn，随着系统的运行，redo日志不断写入log buffer，但又没有即使刷盘，那么flushed_to_disk_lsn便和lsn拉开了差距。</p>
<h3 id="checkpoint-lsn"><a href="#checkpoint-lsn" class="headerlink" title="checkpoint_lsn"></a>checkpoint_lsn</h3><p>redo日志的大小总是有限的，那么就有必要对其进行重复利用。</p>
<p>具体的，如果redo日志对应的脏页已经刷新到磁盘，那么此时就没有必要再去保留这样的redo日志，</p>
<p>于是InnodB使用<strong>checkpoint_lsn</strong>表示当前系统中可以被覆盖redo日志总量是多少，这个变量的初始值也是8704。</p>
<p>MySQL中有后台线程在脏页刷新到磁盘的时候执行一次checkpoint操作，就是查看是否可以增加checkpoint_lsn（但是不是说只要刷新脏页就一定执行一次checkpoint操作）。</p>
<h2 id="innodb-flush-log-at-trx-commit"><a href="#innodb-flush-log-at-trx-commit" class="headerlink" title="innodb_flush_log_at_trx_commit"></a>innodb_flush_log_at_trx_commit</h2><p>它的取值有3种：</p>
<ul>
<li>0 ：事务提交时不会立即向磁盘同步redo日志。这样会加快处理速度，但是失去持久性这一保证，不可取。</li>
<li>1 ：事务提交时必须将redo日志同步到磁盘，这样可以保证事务的持久性。默认值就是1。</li>
<li>2：这是一个折中的选择，事务提交的时候需要同步到操作系统的写磁盘的缓冲区，但不一定要真正写到磁盘上。所以，如果数据库挂了，但是操作系统还没挂，持久性还是可以保证的；反之，持久性还是无法保证。</li>
</ul>
<h1 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h1><p>redo日志最重要的甚至是唯一的功能就是在数据库崩溃的时候提供数据恢复的保证了。</p>
<p>崩溃恢复的时候先找到恢复的起点。然后顺着日志文件就可以将数据正确恢复起来。</p>
<p>但是这个过程可以加快。</p>
<p>为了避免页面的随机IO，可以实现将redo文件的所有redo文件按照<strong>spaceID和pageNumber</strong><br>为键，然后组织成一张哈希表，然后遍历这张hash表就可以一次性完成对一个页面的恢复。<br>当然，同一个页面的redo日志必须安装时间顺序排序。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Socket编程 —— 使用 select、poll、epoll</title>
    <url>/2021/11/20/socket/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h2><img src="socket/socket-state.png" style="zoom:50%;" />



<ol>
<li><p>服务端和客户端初始化 socket ，得到⽂件描述符；</p>
</li>
<li><p>服务端调⽤ bind ，将绑定在 IP 地址和端⼝;</p>
</li>
<li><p>服务端调⽤ listen ，进⾏监听；</p>
</li>
<li><p>服务端调⽤ accept ，等待客户端连接；</p>
</li>
<li><p>客户端调⽤ connect ，向服务器端的地址和端⼝发起连接请求；</p>
</li>
<li><p>服务端 accept 返回⽤于传输的 socket 的⽂件描述符；</p>
</li>
<li><p>客户端调⽤ write 写⼊数据；服务端调⽤ read 读取数据；</p>
</li>
<li><p>客户端断开连接时，会调⽤ close ，那么服务端 read 读取数据的时候，就会读取到了 EOF ，待处理完</p>
</li>
</ol>
<p>数据后，服务端调⽤ close ，表示连接关闭。</p>
<p>这⾥需要注意的是，服务端调⽤ accept 时，连接成功了会返回⼀个已完成连接的 socket，后续⽤来传输数据。</p>
<p>所以，监听的 socket 和真正⽤来传送数据的 socket，是两个 socket，⼀个叫作<strong>监听 socket</strong>，⼀个叫作<strong>已完成连接 socket</strong>。</p>
<p>成功连接建⽴之后，双⽅开始通过 read 和 write 函数来读写数据，就像往⼀个⽂件流⾥⾯写东⻄⼀样。</p>
<h2 id="select函数"><a href="#select函数" class="headerlink" title="select函数"></a>select函数</h2><h2 id="poll-函数"><a href="#poll-函数" class="headerlink" title="poll 函数"></a>poll 函数</h2><h2 id="epoll-函数"><a href="#epoll-函数" class="headerlink" title="epoll 函数"></a>epoll 函数</h2><h3 id="相关接口"><a href="#相关接口" class="headerlink" title="相关接口"></a>相关接口</h3><p>epoll API是Linux专有的特性，相较于<code>select</code>和<code>poll</code>，<code>epoll</code>更加灵活且<strong>没有描述符限制</strong>。<code>epoll</code>设计也与<code>select</code>和<code>poll</code>不同，主要包含以下三个接口：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>下面依次介绍。</p>
</blockquote>
<h4 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create()"></a>epoll_create()</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">int epoll_create(int size)；//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大</span><br></pre></td></tr></table></figure>

<p>创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大，这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值，<em>参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议</em>。<br>当创建好epoll句柄后，它就会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</p>
<h4 id="int-epoll-ctl"><a href="#int-epoll-ctl" class="headerlink" title="int epoll_ctl()"></a>int epoll_ctl()</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *ev)</span></span>; <span class="comment">//修改兴趣列表（事件注册函数）</span></span><br></pre></td></tr></table></figure>

<p>该函数是对指定描述符fd执行op操作。</p>
<ul>
<li>epfd：是epoll_create()的返回值。</li>
<li>op：表示op操作，用三个宏来表示：1. <code>EPOLL_CTL_ADD</code>注册新的fd到epfd中；2. <code>EPOLL_CTL_MOD</code>修改已经注册的fd的监听事件；3. <code>EPOLL_CTL_DEL</code>从<code>epfd</code>中删除一个fd。</li>
<li>fd：是需要监听的fd（文件描述符）</li>
<li>epoll_event：是告诉内核需要监听什么事，struct epoll_event结构如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">  <span class="keyword">__uint32_t</span> events;  <span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data;  <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>events可以是以下几个宏的集合</strong>：</p>
<ol>
<li>EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</li>
<li>EPOLLOUT：表示对应的文件描述符可以写；</li>
<li>EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</li>
<li>EPOLLERR：表示对应的文件描述符发生错误；</li>
<li>EPOLLHUP：表示对应的文件描述符被挂断；</li>
<li>EPOLLET： bsEPOLL设为边缘触发（Edge Triggered)模式，这是相对于水平触发(Level Triggered）来说的。</li>
<li>EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里。</li>
</ol>
<p>其中<code>data</code>的类型为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span>    *ptr; <span class="comment">//pointer to user defined data</span></span><br><span class="line">  <span class="keyword">int</span>     fd; <span class="comment">//file descriptor</span></span><br><span class="line">  uint_32 u32; <span class="comment">//32-bit integer</span></span><br><span class="line">  uint_64 u64; <span class="comment">//64-bit integer</span></span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br></pre></td></tr></table></figure>

<p><strong><code>data</code>字段是唯一可以获知同这个事件相关的文件描述符的途径</strong>，因此调用<code>epoll_ctl()</code>将文件描述符添加到兴趣列表中时，应该要么将<code>ev.data.fd</code>设为文件描述符，要么将<code>ev.data.ptr</code>设为指向包含该文件描述的结构体。</p>
<h4 id="int-epoll-wait"><a href="#int-epoll-wait" class="headerlink" title="int epoll_wait()"></a>int epoll_wait()</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *evlist, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>数组<code>evlist</code>的空间由调用者负责申请</p>
<p>等待epfd上的io事件，最多返回maxevents个事件。<br>参数evlist用来从内核得到事件的集合，maxevents告之内核这个evlist有多大，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</p>
<h3 id="epoll的工作模式"><a href="#epoll的工作模式" class="headerlink" title="epoll的工作模式"></a>epoll的工作模式</h3><p>epoll对文件描述符的操作有两种模式：<strong>LT（level trigger）</strong>和<strong>ET（edge trigger）</strong>。LT模式是默认模式，LT模式与ET模式的区别如下：</p>
<p><strong>LT模式</strong>：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<strong>应用程序可以不立即处理该事件</strong>。下次调用epoll_wait时，会再次响应应用程序并通知此事件。<br><strong>ET模式</strong>：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<strong>应用程序必须立即处理该事件</strong>。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p>
<p>LT模式下，主要缓冲区数据一次没有处理完，那么下次<code>epoll_wait</code>返回时，还会返回这个句柄；</p>
<p>而ET模式下，缓冲区数据一次没处理结束，那么下次是不会再通知了，只在第一次返回．所以在ET模式下，一般是通过while循环，一次性读完全部数据．epoll默认使用的是LT．</p>
<h4 id="1-LT模式"><a href="#1-LT模式" class="headerlink" title="1. LT模式"></a>1. LT模式</h4><p>LT(level triggered)是默认的工作方式，并且<strong>同时支持block和no-block</strong> socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。</p>
<h4 id="2-ET模式"><a href="#2-ET模式" class="headerlink" title="2. ET模式"></a>2. ET模式</h4><p>ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)</p>
<p><strong>ET模式在很大程度上减少了epoll事件被重复触发的次数</strong>，因此效率要比LT模式高。epoll工作在ET模式的时候，<strong>必须使用非阻塞套接口</strong>，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>
<p><strong>假如有这样一个例子：</strong></p>
<ol>
<li>我们已经把一个用来从管道中读取数据的文件句柄(RFD)添加到epoll描述符</li>
<li>这个时候从管道的另一端被写入了2KB的数据</li>
<li>调用epoll_wait(2)，并且它会返回RFD，说明它已经准备好读取操作</li>
<li>然后我们读取了1KB的数据</li>
<li>调用epoll_wait(2)（两种工作模式有不同的差别）</li>
</ol>
<p><strong>LT模式：</strong><br>如果是LT模式，那么在第5步调用epoll_wait(2)之后，仍然能受到通知。</p>
<p><strong>ET模式：</strong><br>只有在监视的文件句柄上发生了某个事件的时候 ET 工作模式才会汇报事件。因此在第5步的时候，调用者可能会放弃等待仍在存在于文件输入缓冲区内的剩余数据。</p>
<h3 id="epoll的实现原理"><a href="#epoll的实现原理" class="headerlink" title="epoll的实现原理"></a>epoll的实现原理</h3><p>在linux，一切皆文件．所以当调用<code>epoll_create</code>时，内核给这个<code>epoll</code>分配一个文件描述符，但是这个不是普通的文件，而是只服务于epoll。</p>
<p>当内核初始化epoll时，会开辟一块内核高速缓冲区，用于放置我们监听的对端socket，这些socket会以<strong>红黑树的形式</strong>保存在内核的<code>cache</code>里，以支持快速的查找，插入，删除。</p>
<p>同时，建立了一个<strong>list链表，用于存储准备就绪的事件</strong>．所以调用<code>epoll_wait</code>时，在timeout时间内，只是简单的观察这个list链表是否有数据，如果没有，则睡眠至超时时间到返回；如果有数据，则在超时时间到，拷贝至用户态<code>events</code>数组中．</p>
<p><em>那么，这个准备就绪list链表是怎么维护的呢？</em><br>当我们执行<code>epoll_ctl()</code>时，除了把socket_fd放到epoll系统里对应的红黑树上之外，还会<strong>给内核中断处理程序注册一个回调函数</strong>，告诉内核，<strong>如果这个句柄的中断到了，就把它放到准备就绪list链表里</strong>。所以，当一个socket上有数据到了，内核在把网卡上的数据copy到内核中后就来把socket插入到准备就绪链表里了。</p>
<p>epoll主要由两个结构体：eventpoll与epitem。epitem是每一个IO所对应的的事件。比如 <code>epoll_ctl()</code>的<code>EPOLL_CTL_ADD</code>操作的时候，就需要创建一个<code>epitem</code>。<code>eventpoll</code>是每一个epoll所对应的。比如<code>epoll_create</code>就是创建一个<code>eventpoll</code>。如下图所示，<code>eventpoll</code> 包含了 <code>lock</code>、<code>mtx</code>、<code>wq（等待队列）</code>与 <code>rdlist</code> 等成员，其中 <code>rdlist</code> 和 <code>rbr</code> 是我们所关心的。</p>
]]></content>
      <categories>
        <category>IO</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>IO</tag>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL —— Undo log</title>
    <url>/2021/12/09/undolog/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="undo-log的作用"><a href="#undo-log的作用" class="headerlink" title="undo log的作用"></a>undo log的作用</h2><p>为了保证事务的原子性，InnoDB引入了undo日志，undo日志记载了回滚操作所需的内容。</p>
<p>undo是<strong>逻辑日志</strong>，只是将数据库逻辑地恢复到原来的样子；所有修改都被逻辑地取消了，但是数据结构和页本身在回滚之后可能不大相同。</p>
<p>undo log有两个作用：<strong>提供回滚</strong>和**多版本并发控制(MVCC)**。</p>
<h2 id="事务id"><a href="#事务id" class="headerlink" title="事务id"></a>事务id</h2><p>在事务在对表中的记录进行修改的时候，会为这个事务分配一个唯一的事务id，这个事务id是递增的，所以事务id越小越先执行。未被分配事务id的事务的id默认是0。</p>
<h2 id="各种类型的Undo-log"><a href="#各种类型的Undo-log" class="headerlink" title="各种类型的Undo log"></a>各种类型的Undo log</h2><p>InnoDB对不同场景的设计了不同类型的undo日志，比如TRX_UNDO_INSERT_REC, TRX_UNDO_DEL_MARK_REC.</p>
<p>TRX_UNDO_UPD_EXIST_REC等等。</p>
<p>除了insert产生的undo日志中没有roll_pointer字段，其他的一般都有roll_pointer这个字段，这个字段就支撑了回滚和MVCC的功能。</p>
<p><img src="/2021/12/09/undolog/undolog.png"></p>
<h2 id="Undo-log-的管理"><a href="#Undo-log-的管理" class="headerlink" title="Undo log 的管理"></a>Undo log 的管理</h2><p>类型为FIL_PAGE_UNDO_LOG的页面，是专门用来存储undo日志的，不妨称为Undo页面。</p>
<p>一个事务写的undo日志可能在一个页面中放不下，所以MySQL使用链表来组织这些undo页面。</p>
<p>在一个事务执行过程中，最多分配4个页面链表，</p>
<p>分别是</p>
<ol>
<li>针对普通表的insert undo 链表；</li>
<li>针对普通表的update undo 链表；</li>
<li>针对临时表的insert undo 链表；</li>
<li>针对临时表的update undo 链表；</li>
</ol>
<p>每个undo页面链表都对应一个Undo Log Segment。Undo页面链表的第一个页中有一个名为Undo Log Segment Header的部分，用来存储关于这个段的信息。</p>
<p>同一个事务向一个undo链表写入的undo日志算是一个组，每个组都以一个Undo Log Header 部分开头。</p>
<h2 id="undo及redo如何记录事务"><a href="#undo及redo如何记录事务" class="headerlink" title="undo及redo如何记录事务"></a>undo及redo如何记录事务</h2><h3 id="Undo-Redo事务的简化过程"><a href="#Undo-Redo事务的简化过程" class="headerlink" title="Undo + Redo事务的简化过程"></a>Undo + Redo事务的简化过程</h3><p>假设有A、B两个数据，值分别为1,2，开始一个事务，事务的操作内容为：把1修改为3，2修改为4，那么实际的记录如下（简化）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A.事务开始.</span><br><span class="line">B.记录A&#x3D;1到undo log.</span><br><span class="line">C.修改A&#x3D;3.</span><br><span class="line">D.记录A&#x3D;3到redo log.</span><br><span class="line">E.记录B&#x3D;2到undo log.</span><br><span class="line">F.修改B&#x3D;4.</span><br><span class="line">G.记录B&#x3D;4到redo log.</span><br><span class="line">H.将redo log写入磁盘。</span><br><span class="line">I.事务提交</span><br></pre></td></tr></table></figure>

<p><strong>注意是先写 undo log，再操作，最后再写redo log</strong></p>
<h3 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h3><p>前面说到未提交的事务和回滚了的事务也会记录Redo Log，因此在进行恢复时,这些事务要进行特殊的的处理。有2种不同的恢复策略：</p>
<ul>
<li>进行恢复时，只重做已经提交了的事务。</li>
<li>进行恢复时，<strong>重做所有事务包括未提交的事务和回滚了的事务，然后通过Undo Log回滚那些未提交的事务</strong>。</li>
</ul>
<p>MySQL数据库InnoDB存储引擎使用了B策略, InnoDB存储引擎中的恢复机制有几个特点：</p>
<ul>
<li><p><strong>在重做Redo Log时，并不关心事务性</strong>。 恢复时，没有BEGIN，也没有COMMIT,ROLLBACK的行为。也不关心每个日志是哪个事务的。尽管事务ID等事务相关的内容会记入Redo Log，这些内容只是被当作要操作的数据的一部分。</p>
</li>
<li><p>使用B策略就<strong>必须要将Undo Log持久化</strong>，而且<strong>必须要在写Redo Log之前将对应的Undo Log写入磁盘</strong>。Undo和Redo Log的这种关联，使得持久化变得复杂起来。</p>
<p>为了降低复杂度，<strong>InnoDB将Undo Log看作数据，因此记录Undo Log的操作也会记录到redo log中</strong>。</p>
<p><strong>这样undo log就可以像数据一样缓存起来</strong>，<strong>而不用在redo log之前写入磁盘了</strong>。</p>
<p>包含Undo Log操作的Redo Log，看起来是这样的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">记录1: &lt;trx1, Undo log insert &lt;undo_insert …&gt;&gt; # 记录的 undo-log</span><br><span class="line">记录2: &lt;trx1, insert …&gt; # 重做日志本身</span><br><span class="line">记录3: &lt;trx2, Undo log insert &lt;undo_update …&gt;&gt;</span><br><span class="line">记录4: &lt;trx2, update …&gt;</span><br><span class="line">记录5: &lt;trx3, Undo log insert &lt;undo_delete …&gt;&gt;</span><br><span class="line">记录6: &lt;trx3, delete …&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>到这里，还有一个问题没有弄清楚。既然Redo没有事务性，那岂不是会重新执行被回滚了的事务？<br>确实是这样。同时Innodb也会将事务回滚时的操作也记录到redo log中。<strong>回滚操作本质上也是对数据进行修改，因此回滚时对数据的操作也会记录到Redo Log中</strong>。</p>
<p><strong>一个回滚了的事务的Redo Log</strong>，看起来是这样的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">记录1: &lt;trx1, Undo log insert &lt;undo_insert …&gt;&gt; # 记录的 undo-log</span><br><span class="line">记录2: &lt;trx1, insert A…&gt; # 重做日志本身</span><br><span class="line">记录3: &lt;trx1, Undo log insert &lt;undo_update …&gt;&gt;</span><br><span class="line">记录4: &lt;trx1, update B…&gt;</span><br><span class="line">记录5: &lt;trx1, Undo log insert &lt;undo_delete …&gt;&gt;</span><br><span class="line">记录6: &lt;trx1, delete C…&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 下面是对应的回滚操作</span></span><br><span class="line">记录7: &lt;trx1, insert C&gt; </span><br><span class="line">记录8: &lt;trx1, update B to old value&gt;</span><br><span class="line">记录9: &lt;trx1, delete A&gt;</span><br></pre></td></tr></table></figure>


<p><strong>一个被回滚了的事务在恢复时的操作就是先redo再undo，因此不会破坏数据的一致性</strong>。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的各种遍历（递归与迭代实现）以及使用中序、（前序 | 后序）还原二叉树</title>
    <url>/2021/11/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%84%E7%A7%8D%E9%81%8D%E5%8E%86%EF%BC%88%E9%80%92%E5%BD%92%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%AE%9E%E7%8E%B0%EF%BC%89%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E4%B8%AD%E5%BA%8F%E3%80%81%EF%BC%88%E5%89%8D%E5%BA%8F-%E5%90%8E%E5%BA%8F%EF%BC%89%E8%BF%98%E5%8E%9F%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>这里就用力扣上面的各种题目要模板了。</p>
</blockquote>
<h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><h2 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/submissions/">102. 二叉树的层序遍历</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>;</span><br><span class="line">            <span class="keyword">while</span>(size--)&#123;</span><br><span class="line">                TreeNode* r =  q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="built_in">list</span>.push_back(r-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(r-&gt;left) q.push(r-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(r-&gt;right) q.push(r-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">list</span>.size())&#123;</span><br><span class="line">                ans.push_back(<span class="built_in">list</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="前序遍历、中序遍历、后序遍历的递归写法"><a href="#前序遍历、中序遍历、后序遍历的递归写法" class="headerlink" title="前序遍历、中序遍历、后序遍历的递归写法"></a>前序遍历、中序遍历、后序遍历的递归写法</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a><br><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a><br><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        preOrder(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        ans.push_back(root-&gt;val);</span><br><span class="line">        preOrder(root-&gt;left);</span><br><span class="line">        preOrder(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序</span></span><br><span class="line">```cpp</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        inOrder(root);</span><br><span class="line">        <span class="keyword">return</span> ans;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        inOrder(root-&gt;left);</span><br><span class="line">        ans.push_back(root-&gt;val);</span><br><span class="line">        inOrder(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        postorder(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        postorder(root-&gt;left);</span><br><span class="line">        postorder(root-&gt;right);</span><br><span class="line">        ans.push_back(root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="前序遍历、中序遍历、后序遍历的迭代写法"><a href="#前序遍历、中序遍历、后序遍历的迭代写法" class="headerlink" title="前序遍历、中序遍历、后序遍历的迭代写法"></a>前序遍历、中序遍历、后序遍历的迭代写法</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前序遍历最好写</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span>(root) st.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">            TreeNode* p = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            ans.push_back(p-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;right) st.push(p-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;left) st.push(p-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="comment">// 左 根 右，所以一直往左走，将经过的节点入栈，直到没有左孩子，然后输出现在的根，然后处理右子树。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">while</span>(root || st.size())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root)&#123;</span><br><span class="line">                st.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            ans.push_back(root-&gt;val);</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更加直观的标记法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;TreeNode*,<span class="keyword">bool</span>&gt; P;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;P&gt; st;</span><br><span class="line">        <span class="keyword">if</span>(root) st.push(&#123;root,<span class="literal">false</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">            P p = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            <span class="keyword">if</span>(p.second)&#123;</span><br><span class="line">                ans.push_back(p.first-&gt;val);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p.second = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(p.first-&gt;right) st.push(&#123;p.first-&gt;right,<span class="literal">false</span>&#125;);</span><br><span class="line">                st.push(p);</span><br><span class="line">                <span class="keyword">if</span>(p.first-&gt;left) st.push(&#123;p.first-&gt;left,<span class="literal">false</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="comment">// 直观的标记法</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;TreeNode*,<span class="keyword">bool</span>&gt; P;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;P&gt; st;</span><br><span class="line">        st.push(&#123;root,<span class="literal">false</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">            P p = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            <span class="keyword">if</span>(!p.first) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(p.second)&#123;</span><br><span class="line">                ans.push_back(p.first-&gt;val);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p.second = <span class="literal">true</span>;</span><br><span class="line">                st.push(p);</span><br><span class="line">                st.push(&#123;p.first-&gt;right,<span class="literal">false</span>&#125;);</span><br><span class="line">                st.push(&#123;p.first-&gt;left,<span class="literal">false</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span>(root) st.push(root);</span><br><span class="line">        TreeNode* pre =  <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(st.top()-&gt;left || st.top()-&gt;right)&#123;</span><br><span class="line">                TreeNode* node = st.top();</span><br><span class="line">                <span class="comment">// 如果左右子树已经访问过了,直接跳出,不要在入栈</span></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(node-&gt;right == pre) <span class="keyword">break</span>;</span><br><span class="line">                    st.push(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(node-&gt;left == pre) <span class="keyword">break</span>;</span><br><span class="line">                    st.push(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(st.top()-&gt;val);</span><br><span class="line">            pre = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="Morris遍历"><a href="#Morris遍历" class="headerlink" title="Morris遍历"></a>Morris遍历</h2><p><del>挖个坑，以后填吧</del></p>
<h1 id="从中序遍历和前-后-序遍历构造二叉树"><a href="#从中序遍历和前-后-序遍历构造二叉树" class="headerlink" title="从中序遍历和前(后)序遍历构造二叉树"></a>从中序遍历和前(后)序遍历构造二叉树</h1><ul>
<li>注意：这种构造方法，首先必须要求有<strong>中序遍历</strong>（否则无法划分左右边界）。</li>
<li>其次，必须保证个元素的唯一性，否则构造出的二叉树不唯一。</li>
</ul>
<p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = preorder.size();</span><br><span class="line">        <span class="keyword">return</span> create(<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>,n<span class="number">-1</span>,preorder,inorder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">create</span><span class="params">(<span class="keyword">int</span> preL,<span class="keyword">int</span> preR,<span class="keyword">int</span> inL,<span class="keyword">int</span> inR,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preL&gt;preR)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> val  = preorder[preL];</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=inL;i&lt;=inR;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i]==val)&#123;</span><br><span class="line">                idx = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> numLeft = idx-inL;</span><br><span class="line">        node-&gt;left = create(preL+<span class="number">1</span>,preL+numLeft,inL,idx<span class="number">-1</span>,preorder,inorder);</span><br><span class="line">        node-&gt;right = create(preL+numLeft+<span class="number">1</span>,preR,idx+<span class="number">1</span>,inR,preorder,inorder);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = inorder.size();</span><br><span class="line">        <span class="keyword">return</span> create(<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>,n<span class="number">-1</span>,inorder,postorder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">create</span><span class="params">(<span class="keyword">int</span> postL,<span class="keyword">int</span> postR,<span class="keyword">int</span> inL,<span class="keyword">int</span> inR,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(postL&gt;postR)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(postorder[postR]); </span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = inL;i&lt;=inR;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i]==postorder[postR])&#123;</span><br><span class="line">                idx = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> numLeft = idx-inL;</span><br><span class="line">        root-&gt;left = create(postL,postL+numLeft<span class="number">-1</span>,inL,idx<span class="number">-1</span>,inorder,postorder);</span><br><span class="line">        root-&gt;right = create(postL+numLeft,postR<span class="number">-1</span>,idx+<span class="number">1</span>,inR,inorder,postorder);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<ul>
<li><p><a href="https://ac.nowcoder.com/acm/contest/6781/A">先序遍历与后序遍历序列，求其中序遍历序列</a></p>
<ul>
<li>题意：<br>给定一棵有n个结点的二叉树的先序遍历与后序遍历序列，求其中序遍历序列。<br>若某节点只有一个子结点，则此处将其看作左儿子结点<br>（题目来自牛客网）</li>
</ul>
</li>
</ul>
<p>做法也是一样的，找出根节点，然后根据规则，划分左右子树。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        Node* left= <span class="literal">nullptr</span>,*right= <span class="literal">nullptr</span>;</span><br><span class="line">        Node(<span class="keyword">int</span> val):val(val)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Node* root;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回所求中序序列</span></span><br><span class="line"><span class="comment">     * @param n int整型 二叉树节点数量</span></span><br><span class="line"><span class="comment">     * @param pre int整型vector 前序序列</span></span><br><span class="line"><span class="comment">     * @param suf int整型vector 后序序列</span></span><br><span class="line"><span class="comment">     * @return int整型vector</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node* p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p== <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        inOrder(p-&gt;left);</span><br><span class="line">        inOrderList.push_back(p-&gt;val);</span><br><span class="line">        inOrder(p-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Node* <span class="title">create</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pre,<span class="keyword">int</span> pl,<span class="keyword">int</span> pr, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; suf,<span class="keyword">int</span> sl,<span class="keyword">int</span> sr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pl&gt;pr) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        Node* p = <span class="keyword">new</span> Node(pre[pl]);</span><br><span class="line">        <span class="keyword">if</span>(pl&lt;pr)&#123;</span><br><span class="line">            <span class="keyword">int</span> idx = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=sl;i&lt;=sr;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(suf[i] == pre[pl+<span class="number">1</span>])&#123;</span><br><span class="line">                    idx = i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> lenOfLeft = idx-sl+<span class="number">1</span>;</span><br><span class="line">            p-&gt;left = create(pre,pl+<span class="number">1</span>,pl+lenOfLeft,suf,sl,sl+lenOfLeft<span class="number">-1</span>);</span><br><span class="line">            p-&gt;right = create(pre,pl+lenOfLeft+<span class="number">1</span>,pr,suf,sl+lenOfLeft,sr<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inOrderList;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pre, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; suf)</span> </span>&#123;</span><br><span class="line">        root = create(pre,<span class="number">0</span>,n<span class="number">-1</span>,suf,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">        inOrder(root);</span><br><span class="line">        <span class="keyword">return</span> inOrderList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="从中序遍历和前-后-序遍历构造二叉树-1"><a href="#从中序遍历和前-后-序遍历构造二叉树-1" class="headerlink" title="从中序遍历和前(后)序遍历构造二叉树"></a>从中序遍历和前(后)序遍历构造二叉树</h1><blockquote>
<p>暂时没找到相关题目。<br>大致思路是，根据层次遍历的有序性</p>
</blockquote>
<p><a href="https://blog.csdn.net/yw2018/article/details/105880159?utm_medium=distribute.pc_relevant_t0.none-task-blog-searchFromBaidu-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-searchFromBaidu-1.control">别人的博客</a></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Spring自动配置的一些注解</title>
    <url>/2021/09/16/%E5%85%B3%E4%BA%8ESpring%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="ConditionalXXX注解族"><a href="#ConditionalXXX注解族" class="headerlink" title="@ConditionalXXX注解族"></a>@ConditionalXXX注解族</h2><h3 id="ConditionalOnProperty"><a href="#ConditionalOnProperty" class="headerlink" title="@ConditionalOnProperty"></a>@ConditionalOnProperty</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123; ElementType.TYPE, ElementType.METHOD &#125;)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Conditional(OnPropertyCondition.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ConditionalOnProperty &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Alias for &#123;<span class="doctag">@link</span> #name()&#125;.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the names</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * A prefix that should be applied to each property. The prefix automatically ends</span></span><br><span class="line"><span class="comment">    * with a dot if not specified. A valid prefix is defined by one or more words</span></span><br><span class="line"><span class="comment">    * separated with dots (e.g. &#123;<span class="doctag">@code</span> &quot;acme.system.feature&quot;&#125;).</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the prefix</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">String <span class="title">prefix</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The name of the properties to test. If a prefix has been defined, it is applied to</span></span><br><span class="line"><span class="comment">    * compute the full key of each property. For instance if the prefix is</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> app.config&#125; and one value is &#123;<span class="doctag">@code</span> my-value&#125;, the full key would be</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> app.config.my-value&#125;</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * Use the dashed notation to specify each property, that is all lower case with a &quot;-&quot;</span></span><br><span class="line"><span class="comment">    * to separate words (e.g. &#123;<span class="doctag">@code</span> my-long-property&#125;).</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the names</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   String[] name() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The string representation of the expected value for the properties. If not</span></span><br><span class="line"><span class="comment">    * specified, the property must &lt;strong&gt;not&lt;/strong&gt; be equal to &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the expected value</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">String <span class="title">havingValue</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Specify if the condition should match if the property is not set. Defaults to</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> if should match if the property is missing</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">matchIfMissing</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>@ConditionalOnClass<br>@ConditionalOnBean<br>@ConditionalOnMissingBean</p>
<p>@ConditionalOnSingleCandidate</p>
<p><a href="https://spring.hhui.top/spring-blog/2018/10/19/181019-SpringBoot%E5%9F%BA%E7%A1%80%E7%AF%87Bean%E4%B9%8B%E6%9D%A1%E4%BB%B6%E6%B3%A8%E5%85%A5-ConditionalOnProperty/">一篇很齐全的博客</a></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring核心</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer题解-1</title>
    <url>/2021/12/03/%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3-1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">剑指 Offer 09. 用两个栈实现队列</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st1,st2;</span><br><span class="line">    CQueue() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        st1.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(st1.size() + st2.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 将 st1 其中的元素全都取出来的，顺序就是FIFO的顺序了</span></span><br><span class="line">        <span class="keyword">if</span>(st2.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!st1.empty())&#123;</span><br><span class="line">                <span class="keyword">int</span> val = st1.top();</span><br><span class="line">                st1.pop();</span><br><span class="line">                st2.push(val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> val = st2.top();</span><br><span class="line">        st2.pop();</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="剑指-Offer-10-I-斐波那契数列"><a href="#剑指-Offer-10-I-斐波那契数列" class="headerlink" title="剑指 Offer 10- I. 斐波那契数列"></a><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = (a + b) % mod;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>矩阵加速</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mod = (<span class="keyword">int</span>)<span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] A = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] B = pow(A, n);</span><br><span class="line">        <span class="keyword">return</span> B[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 矩阵乘法，返回新数组</span></span><br><span class="line">    <span class="keyword">int</span>[][] mul(<span class="keyword">int</span>[][] A, <span class="keyword">int</span>[][] B) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = A.length, n = B[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> len = A[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] ans = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; len; k++) &#123;</span><br><span class="line">                    <span class="comment">// 小心溢出</span></span><br><span class="line">                    res = (<span class="keyword">int</span>)((res + (<span class="keyword">long</span>)A[i][k] * B[k][j] ) % mod);</span><br><span class="line">                &#125;</span><br><span class="line">                ans[i][j] = res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快速幂计算</span></span><br><span class="line">    <span class="keyword">int</span>[][] pow(<span class="keyword">int</span>[][] A, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] ans = <span class="keyword">new</span> <span class="keyword">int</span>[A.length][A[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.length; i++) &#123;</span><br><span class="line">            ans[i][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                ans = mul(ans, A);</span><br><span class="line">            &#125;</span><br><span class="line">            A = mul(A, A);</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="剑指-Offer-03-数组中重复的数字"><a href="#剑指-Offer-03-数组中重复的数字" class="headerlink" title="剑指 Offer 03. 数组中重复的数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">剑指 Offer 03. 数组中重复的数字</a></h4><p>unfinished</p>
<p>如何做到<code>O(1)</code>?。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 每次要么做到 nums[i] == i， 要么做到 nums[nums[i]] == nums[i]</span></span><br><span class="line">        <span class="comment">// 也就是说，每次都有一个元素被放到正确的地方。</span></span><br><span class="line">        <span class="comment">// 可以想想为什么是 O(n) 的</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == i) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[nums[i]] == nums[i]) <span class="keyword">return</span> nums[i]; <span class="comment">// 实际上也避免了死循环</span></span><br><span class="line">            swap(nums[i],nums[nums[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h4 id="剑指-Offer-04-二维数组中的查找"><a href="#剑指-Offer-04-二维数组中的查找" class="headerlink" title="剑指 Offer 04. 二维数组中的查找"></a><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">剑指 Offer 04. 二维数组中的查找</a></h4><p><strong>单调的思维</strong> ，一句话解释，每一行的最后一个小于等于 target的元素的位置是单调的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size();</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="comment">// 从右上角进行搜索</span></span><br><span class="line">        <span class="keyword">int</span> j = n - <span class="number">1</span> , i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; i &lt; m) &#123;</span><br><span class="line">            <span class="comment">// 移动到第一个小于等于 target的地方</span></span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; matrix[i][j] &gt; target) j--;</span><br><span class="line">            <span class="comment">// 检查</span></span><br><span class="line">            <span class="keyword">if</span>(j &gt;= <span class="number">0</span> &amp;&amp; matrix[i][j] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 此时 matrix[i][j]是小于 target的</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="剑指-Offer-11-旋转数组的最小数字"><a href="#剑指-Offer-11-旋转数组的最小数字" class="headerlink" title="剑指 Offer 11. 旋转数组的最小数字"></a><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">剑指 Offer 11. 旋转数组的最小数字</a></h4><p>如果没有重复元素的话：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 判断 nums[mid]在那一段</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[r]) &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h4 id="剑指-Offer-07-重建二叉树"><a href="#剑指-Offer-07-重建二叉树" class="headerlink" title="剑指 Offer 07. 重建二叉树"></a><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">剑指 Offer 07. 重建二叉树</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = preorder.size();</span><br><span class="line">        <span class="keyword">return</span> create(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, preorder, inorder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回某子树的根</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">create</span><span class="params">(<span class="keyword">int</span> preL, <span class="keyword">int</span> preR, <span class="keyword">int</span> inL, <span class="keyword">int</span> inR,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preL &gt; preR)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> val  = preorder[preL]; <span class="comment">// 首个元素就是 根 root</span></span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        <span class="comment">// 在中序遍历找出 根</span></span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = inL; i &lt;= inR; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == val)&#123;</span><br><span class="line">                idx = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> numLeft = idx - inL; <span class="comment">// 左子树节点的数量</span></span><br><span class="line">        node-&gt;left = create(preL + <span class="number">1</span>, preL + numLeft, inL, idx - <span class="number">1</span>, preorder, inorder);</span><br><span class="line">        node-&gt;right = create(preL + numLeft + <span class="number">1</span>, preR, idx + <span class="number">1</span>, inR, preorder, inorder);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="剑指-Offer-14-I-剪绳子"><a href="#剑指-Offer-14-I-剪绳子" class="headerlink" title="剑指 Offer 14- I. 剪绳子"></a><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/">剑指 Offer 14- I. 剪绳子</a></h4><p>简单DP</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 注意提给的限制，就是 段数大于 1 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="comment">// max(dp[j], j) 分别对应切割的最大值 和 不切割的情况</span></span><br><span class="line">                dp[i] = max(dp[i], max(dp[j], j) * (i - j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>数学求导推导：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            据 数学证明：</span></span><br><span class="line"><span class="comment">            当 n &gt;= 3时，因数 拆分成 3 的计算结果 较大</span></span><br><span class="line"><span class="comment">            当 n &lt; 3时，因数越大，计算结果越大</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">long</span> result = <span class="number">1L</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">4</span>) &#123;</span><br><span class="line">            result = result * <span class="number">3</span> % mod;</span><br><span class="line">            n -= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            将 最后一个 因数 计算在内</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        result = result * n % mod;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="剑指-Offer-12-矩阵中的路径"><a href="#剑指-Offer-12-矩阵中的路径" class="headerlink" title="剑指 Offer 12. 矩阵中的路径"></a><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">剑指 Offer 12. 矩阵中的路径</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> ans = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; g;</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="keyword">bool</span> vis[<span class="number">210</span>][<span class="number">210</span>];</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word == <span class="string">&quot;&quot;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        s = word;</span><br><span class="line">        g = board;</span><br><span class="line">        m = g.size();</span><br><span class="line">        n = g[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">                dfs(i, j, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == s.size()) &#123;</span><br><span class="line">            ans = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[pos] != g[i][j]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pos == s.size() - <span class="number">1</span>) &#123;</span><br><span class="line">            ans = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="comment">//特判，走到头了，无需再走</span></span><br><span class="line"></span><br><span class="line">        vis[i][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = i + dx[k];</span><br><span class="line">            <span class="keyword">int</span> y = j + dy[k];</span><br><span class="line">            <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n &amp;&amp; !vis[x][y]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(x, y, pos + <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[i][j] = <span class="number">0</span>; <span class="comment">//回溯</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>时间复杂度的上限：$O*(M<em>N</em>3^L)$</p>
<h4 id="剑指-Offer-25-合并两个排序的链表"><a href="#剑指-Offer-25-合并两个排序的链表" class="headerlink" title="剑指 Offer 25. 合并两个排序的链表"></a><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">剑指 Offer 25. 合并两个排序的链表</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* dum = <span class="keyword">new</span> ListNode(<span class="number">-1</span>), *cur = dum;</span><br><span class="line">        ListNode *p1 = l1, *p2 = l2;</span><br><span class="line">        <span class="keyword">while</span>(p1 &amp;&amp; p2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p1-&gt;val &lt; p2-&gt;val) &#123;</span><br><span class="line">                cur-&gt;next = p1;</span><br><span class="line">                p1 = p1-&gt;next; </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur-&gt;next = p2;</span><br><span class="line">                p2 = p2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = p1 ? p1 : p2;</span><br><span class="line">        <span class="keyword">return</span> dum-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="剑指-Offer-26-树的子结构"><a href="#剑指-Offer-26-树的子结构" class="headerlink" title="剑指 Offer 26. 树的子结构"></a><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">剑指 Offer 26. 树的子结构</a></h4><p>unfinished</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!B || !A) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(check(A, B)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isSubStructure(A-&gt;left,B) || isSubStructure(A-&gt;right,B))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查 a 是否包含 b, 必须各自以 a、b 为根</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(TreeNode* a,TreeNode* b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!b)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!a)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;val==b-&gt;val &amp;&amp; check(a-&gt;left,b-&gt;left) &amp;&amp; check(a-&gt;right,b-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="剑指-Offer-27-二叉树的镜像"><a href="#剑指-Offer-27-二叉树的镜像" class="headerlink" title="剑指 Offer 27. 二叉树的镜像"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">剑指 Offer 27. 二叉树的镜像</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mirrorTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        swap(root-&gt;left, root-&gt;right);</span><br><span class="line">        mirrorTree(root-&gt;left);</span><br><span class="line">        mirrorTree(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="剑指-Offer-28-对称的二叉树"><a href="#剑指-Offer-28-对称的二叉树" class="headerlink" title="剑指 Offer 28. 对称的二叉树"></a><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/">剑指 Offer 28. 对称的二叉树</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> check(root, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(TreeNode* a, TreeNode* b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="literal">nullptr</span> &amp;&amp; a == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>((a &amp;&amp; !b) || (!a &amp;&amp; b)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;val == b-&gt;val &amp;&amp; check(a-&gt;left, b-&gt;right) &amp;&amp; check(a-&gt;right, b-&gt;left);  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="剑指-Offer-21-调整数组顺序使奇数位于偶数前面"><a href="#剑指-Offer-21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="剑指 Offer 21. 调整数组顺序使奇数位于偶数前面"></a><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</a></h4><p>循环不变量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">exchange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// [0 , i] [i + 1,..]</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]&amp;<span class="number">1</span>) &#123;</span><br><span class="line">                swap(nums[++i], nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h4 id="剑指-Offer-29-顺时针打印矩阵"><a href="#剑指-Offer-29-顺时针打印矩阵" class="headerlink" title="剑指 Offer 29. 顺时针打印矩阵"></a><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">剑指 Offer 29. 顺时针打印矩阵</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; g)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> m = g.size();</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">int</span> n = g[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>, high = <span class="number">0</span>, low = m - <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">while</span>(cnt &lt; m * n) &#123;</span><br><span class="line">            <span class="comment">// 注意对 cnt 的限制</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = left; j &lt;= right &amp;&amp; cnt &lt; m * n; j++) &#123;</span><br><span class="line">                ans.push_back(g[high][j]);</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = high + <span class="number">1</span>; i &lt;= low &amp;&amp; cnt &lt; m * n; i++) &#123;</span><br><span class="line">                ans.push_back(g[i][right]);</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = right - <span class="number">1</span>; j &gt;= left &amp;&amp; cnt &lt; m * n; j--) &#123;</span><br><span class="line">                ans.push_back(g[low][j]);</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = low - <span class="number">1</span>; i &gt;= high + <span class="number">1</span> &amp;&amp; cnt &lt; m * n; i--) &#123;</span><br><span class="line">                ans.push_back(g[i][left]);  </span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            ++left;</span><br><span class="line">            --right;</span><br><span class="line">            ++high;</span><br><span class="line">            --low;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="剑指-Offer-19-正则表达式匹配"><a href="#剑指-Offer-19-正则表达式匹配" class="headerlink" title="剑指 Offer 19. 正则表达式匹配"></a><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/">剑指 Offer 19. 正则表达式匹配</a></h4><p>unfinished</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> f[<span class="number">30</span>][<span class="number">40</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.size(), n = p.size();</span><br><span class="line">        s = <span class="string">&quot; &quot;</span> + s;</span><br><span class="line">        p = <span class="string">&quot; &quot;</span> + p;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> ok = [&amp;](<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> p[j] == <span class="string">&#x27;.&#x27;</span> || s[i] == p[j];</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(p[j] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    f[i][j] = f[i][j - <span class="number">2</span>]; <span class="comment">// 题给数据保证不越界</span></span><br><span class="line">                    <span class="keyword">if</span>(ok(i, j - <span class="number">1</span>)) &#123;</span><br><span class="line">                        f[i][j] |= f[i - <span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    f[i][j] = ok(i, j) ? f[i - <span class="number">1</span>][j - <span class="number">1</span>] : <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="剑指-Offer-17-打印从1到最大的n位数"><a href="#剑指-Offer-17-打印从1到最大的n位数" class="headerlink" title="剑指 Offer 17. 打印从1到最大的n位数"></a><a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/">剑指 Offer 17. 打印从1到最大的n位数</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">printNumbers</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">&quot;1&quot;</span> , x = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) s += <span class="string">&quot;0&quot;</span>, x+= <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        incr(x);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">while</span>(x &lt; s)&#123;</span><br><span class="line">            ans.push_back(stoi(x));</span><br><span class="line">            incr(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除前导 0 </span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">pretty</span><span class="params">(<span class="built_in">string</span> &amp;s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;s.size() &amp;&amp; s[i] == <span class="string">&#x27;0&#x27;</span>) i++;</span><br><span class="line">        <span class="keyword">if</span>(i == s.size())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">incr</span><span class="params">(<span class="built_in">string</span> &amp;s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = s.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 子串的低位 对应 数字的高位</span></span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = s[j] - <span class="string">&#x27;0&#x27;</span> + <span class="number">1</span>; <span class="comment">// 既有可能一开始加的 1 ，也要可能是进位上来的 1 </span></span><br><span class="line">            <span class="keyword">if</span>(cnt &lt; <span class="number">10</span>)&#123;</span><br><span class="line">                ++s[j]; <span class="comment">// 字符的增加</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s[j--] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="剑指-Offer-24-反转链表"><a href="#剑指-Offer-24-反转链表" class="headerlink" title="剑指 Offer 24. 反转链表"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">剑指 Offer 24. 反转链表</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* res = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="keyword">while</span>(p) &#123;</span><br><span class="line">            <span class="keyword">auto</span> q = p-&gt;next;</span><br><span class="line">            p-&gt;next = res;</span><br><span class="line">            res = p;</span><br><span class="line">            p = q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="剑指-Offer-30-包含min函数的栈"><a href="#剑指-Offer-30-包含min函数的栈" class="headerlink" title="剑指 Offer 30. 包含min函数的栈"></a><a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/">剑指 Offer 30. 包含min函数的栈</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// min是一个单调减的栈</span></span><br><span class="line">    Deque&lt;Integer&gt; st = <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;(), min = <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;(); </span><br><span class="line">  	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        st.push(x);</span><br><span class="line">        <span class="keyword">if</span>(min.isEmpty()|| min.peek() &gt;= x) &#123;</span><br><span class="line">            min.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = st.pop();</span><br><span class="line">        <span class="keyword">if</span>(x == min.peek()) &#123;</span><br><span class="line">            min.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> st.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="剑指-Offer-40-最小的k个数"><a href="#剑指-Offer-40-最小的k个数" class="headerlink" title="剑指 Offer 40. 最小的k个数"></a><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">剑指 Offer 40. 最小的k个数</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        qsort(arr, <span class="number">0</span>, (<span class="keyword">int</span>)arr.size() - <span class="number">1</span>, k);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt; r || k &lt;= <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">// 注意 k &lt;= 0</span></span><br><span class="line">        <span class="keyword">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = a[(l + r) / <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123; ++i; &#125; <span class="keyword">while</span>(a[i] &lt; x);</span><br><span class="line">            <span class="keyword">do</span> &#123; --j; &#125; <span class="keyword">while</span>(a[j] &gt; x);</span><br><span class="line">            <span class="keyword">if</span>(i &lt; j) &#123;</span><br><span class="line">                swap(a[i], a[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k &gt;= j - l + <span class="number">1</span>) &#123; <span class="comment">// 注意这里是 &gt;= (否则下面会递归爆栈)</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> idx = l; idx &lt;= j; idx++) &#123;</span><br><span class="line">                ans.push_back(a[idx]);</span><br><span class="line">            &#125;</span><br><span class="line">            qsort(a, j + <span class="number">1</span>, r, k - (j - l + <span class="number">1</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            qsort(a, l, j, k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="剑指-Offer-41-数据流中的中位数"><a href="#剑指-Offer-41-数据流中的中位数" class="headerlink" title="剑指 Offer 41. 数据流中的中位数"></a><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/">剑指 Offer 41. 数据流中的中位数</a></h4><p>unfinished</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    PriorityQueue&lt;Integer&gt; pq1, pq2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pq1 = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);</span><br><span class="line">        pq2 = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pq1.size() == pq2.size()) &#123;</span><br><span class="line">            pq2.offer(num);</span><br><span class="line">            pq1.offer(pq2.poll());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pq1.offer(num);</span><br><span class="line">            pq2.offer(pq1.poll());   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pq1.size() == pq2.size()) &#123;</span><br><span class="line">            <span class="keyword">double</span> res = (pq1.peek() + pq2.peek()) / <span class="number">2.0</span>;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pq1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="剑指-Offer-31-栈的压入、弹出序列"><a href="#剑指-Offer-31-栈的压入、弹出序列" class="headerlink" title="剑指 Offer 31. 栈的压入、弹出序列"></a><a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/">剑指 Offer 31. 栈的压入、弹出序列</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟就好</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validateStackSequences</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pushed, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; popped)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x : pushed) &#123;</span><br><span class="line">            st.push(x);</span><br><span class="line">            <span class="comment">// 能出栈就立即出栈，否则后面进栈的元素就会影响顺序</span></span><br><span class="line">            <span class="keyword">while</span>(!st.empty() &amp;&amp; st.top() == popped[pos] )&#123;</span><br><span class="line">                st.pop();</span><br><span class="line">                ++pos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="剑指-Offer-42-连续子数组的最大和"><a href="#剑指-Offer-42-连续子数组的最大和" class="headerlink" title="剑指 Offer 42. 连续子数组的最大和"></a><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">剑指 Offer 42. 连续子数组的最大和</a></h4><p>前缀和</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1e9</span>, preMin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            cnt += x;</span><br><span class="line">            ans = max(ans, cnt - preMin);</span><br><span class="line">            preMin = min(preMin, cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="剑指-Offer-36-二叉搜索树与双向链表"><a href="#剑指-Offer-36-二叉搜索树与双向链表" class="headerlink" title="剑指 Offer 36. 二叉搜索树与双向链表"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">剑指 Offer 36. 二叉搜索树与双向链表</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### [剑指 Offer <span class="number">39.</span> 数组中出现次数超过一半的数字](https:<span class="comment">//leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">领导者算法</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">class Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> majorityElement(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> leader, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">0</span>) &#123;</span><br><span class="line">                cnt = <span class="number">1</span>;</span><br><span class="line">                leader = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] == leader) &#123;</span><br><span class="line">                    ++cnt;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    --cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h4 id="剑指-Offer-37-序列化二叉树"><a href="#剑指-Offer-37-序列化二叉树" class="headerlink" title="剑指 Offer 37. 序列化二叉树"></a><a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/">剑指 Offer 37. 序列化二叉树</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 层次遍历这棵树，null 值使用 “ ”表示</span></span><br><span class="line">        List&lt;String&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = q.poll();</span><br><span class="line">            <span class="keyword">if</span>(node == null) &#123;</span><br><span class="line">                <span class="built_in">list</span>.add(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">list</span>.add(<span class="string">&quot;&quot;</span> + node.val);</span><br><span class="line">            &#125;</span><br><span class="line">            q.offer(node.left);</span><br><span class="line">            q.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sb.append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(<span class="built_in">list</span>.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        String[] split = data.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(split.length == <span class="number">0</span> || <span class="string">&quot; &quot;</span>.equals(split[<span class="number">0</span>])) <span class="keyword">return</span> null;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(split[pos++]));</span><br><span class="line">        <span class="comment">// 如何重建这棵树？</span></span><br><span class="line">        Deque&lt;TreeNode&gt; q = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(q.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            <span class="keyword">int</span> len = size;</span><br><span class="line">            List&lt;TreeNode&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            List&lt;String&gt; valList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">// 一次性取出这一层所有的节点，以及用于构建左右子树的字符串</span></span><br><span class="line">            <span class="keyword">while</span>(size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">list</span>.add(q.poll());</span><br><span class="line">                valList.add(split[pos++]);</span><br><span class="line">                valList.add(split[pos++]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                TreeNode node = <span class="built_in">list</span>.get(i);</span><br><span class="line">                String leftS = valList.get(i * <span class="number">2</span>);</span><br><span class="line">                String rightS = valList.get(i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">                node.left = node.right = null;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="string">&quot; &quot;</span>.equals(leftS)) &#123;</span><br><span class="line">                    node.left = <span class="keyword">new</span> TreeNode(Integer.parseInt(leftS));</span><br><span class="line">                    q.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="string">&quot; &quot;</span>.equals(rightS)) &#123;</span><br><span class="line">                    node.right = <span class="keyword">new</span> TreeNode(Integer.parseInt(rightS));</span><br><span class="line">                    q.offer(node.right);</span><br><span class="line">                &#125;              </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="剑指-Offer-36-二叉搜索树与双向链表-1"><a href="#剑指-Offer-36-二叉搜索树与双向链表-1" class="headerlink" title="剑指 Offer 36. 二叉搜索树与双向链表"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">剑指 Offer 36. 二叉搜索树与双向链表</a></h4><p>unfinished</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node *first = <span class="literal">nullptr</span>, *last = <span class="literal">nullptr</span>; </span><br><span class="line">    <span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        help(root);</span><br><span class="line">        <span class="comment">// 循环链表的要求</span></span><br><span class="line">        first-&gt;left = last;</span><br><span class="line">        last-&gt;right = first;  </span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">help</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        help(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(last) &#123;</span><br><span class="line">            last-&gt;right = root;</span><br><span class="line">            root-&gt;left = last;</span><br><span class="line">            last = root;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            first = last = root;</span><br><span class="line">        &#125;</span><br><span class="line">        help(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="剑指-Offer-38-字符串的排列"><a href="#剑指-Offer-38-字符串的排列" class="headerlink" title="剑指 Offer 38. 字符串的排列"></a><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">剑指 Offer 38. 字符串的排列</a></h4><p>关键是如何去重（当然不能使用set）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="built_in">string</span> s,temp;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vis;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">permutation</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将字符排序（用于去重）</span></span><br><span class="line">        sort(s.begin(),s.end());</span><br><span class="line">        <span class="keyword">this</span>-&gt;s = s;</span><br><span class="line">        len = s.size();</span><br><span class="line">        vis = <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(len,<span class="literal">false</span>);</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == len) &#123;</span><br><span class="line">            ans.push_back(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[i]) &#123;</span><br><span class="line">                <span class="comment">// 判断条件注意一下</span></span><br><span class="line">                <span class="comment">// 比如有两个相同字符 c，这两个可以接连选，当然也可以接连不选（也就是11 、00都是可以接受的）</span></span><br><span class="line">                <span class="comment">// 但是 10、01只能要一个，我们选择 10</span></span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; s[i] == s[i<span class="number">-1</span>] &amp;&amp; !vis[i<span class="number">-1</span>]) <span class="keyword">continue</span>; <span class="comment">// key point</span></span><br><span class="line">                temp.push_back(s[i]);</span><br><span class="line">                vis[i] = <span class="number">1</span>;</span><br><span class="line">                dfs(pos+<span class="number">1</span>);</span><br><span class="line">                temp.pop_back();</span><br><span class="line">                vis[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="剑指-Offer-43-1～n-整数中-1-出现的次数"><a href="#剑指-Offer-43-1～n-整数中-1-出现的次数" class="headerlink" title="剑指 Offer 43. 1～n 整数中 1 出现的次数"></a><a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/">剑指 Offer 43. 1～n 整数中 1 出现的次数</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> mul = <span class="number">1</span>; n &gt;= mul; mul *= <span class="number">10</span>) &#123;</span><br><span class="line">            ans += (n/(mul * <span class="number">10</span>)) * mul;</span><br><span class="line">            ans += min(max( n % (mul * <span class="number">10</span>) - mul + <span class="number">1</span>, <span class="number">0LL</span>), mul); <span class="comment">// 0LL 表示 long long 的整形量</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h4 id="剑指-Offer-35-复杂链表的复制"><a href="#剑指-Offer-35-复杂链表的复制" class="headerlink" title="剑指 Offer 35. 复杂链表的复制"></a><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">剑指 Offer 35. 复杂链表的复制</a></h4><p>unfinished</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;Node*, Node*&gt; cachedNode;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!cachedNode.count(head)) &#123;</span><br><span class="line">            Node* headNew = <span class="keyword">new</span> Node(head-&gt;val);</span><br><span class="line">            cachedNode[head] = headNew;</span><br><span class="line">            headNew-&gt;next = copyRandomList(head-&gt;next);</span><br><span class="line">            headNew-&gt;random = copyRandomList(head-&gt;random);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cachedNode[head];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法题</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer题解-2</title>
    <url>/2021/12/06/%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3-2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="剑指-Offer-44-数字序列中某一位的数字"><a href="#剑指-Offer-44-数字序列中某一位的数字" class="headerlink" title="剑指 Offer 44. 数字序列中某一位的数字"></a><a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/">剑指 Offer 44. 数字序列中某一位的数字</a></h4><p>unfinished</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">1</span>, mul = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 重要点，一个 d 位数有 9*10^(d - 1)个，那么就一共有 d* 9*10^(d - 1) 位</span></span><br><span class="line">        <span class="keyword">while</span>(n &gt; (<span class="keyword">long</span> <span class="keyword">long</span> )d * <span class="number">9</span> * mul) &#123;</span><br><span class="line">            n -= d * <span class="number">9</span> * mul; </span><br><span class="line">            ++d;</span><br><span class="line">            mul *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 0  1  2  3  4</span></span><br><span class="line">        <span class="comment">// 00 11 22 33 44</span></span><br><span class="line">        <span class="keyword">int</span> num = mul + (n - <span class="number">1</span>)/ d;  <span class="comment">// 索引要 - 1</span></span><br><span class="line">        <span class="keyword">int</span> pos = (n - <span class="number">1</span>)% d;</span><br><span class="line">        <span class="built_in">string</span> s = to_string(num);</span><br><span class="line">        <span class="keyword">return</span> s[pos] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="剑指-Offer-33-二叉搜索树的后序遍历序列"><a href="#剑指-Offer-33-二叉搜索树的后序遍历序列" class="headerlink" title="剑指 Offer 33. 二叉搜索树的后序遍历序列"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">剑指 Offer 33. 二叉搜索树的后序遍历序列</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> ans = <span class="literal">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">verifyPostorder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        help(postorder, <span class="number">0</span>, postorder.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">help</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> root = v[r];</span><br><span class="line">        <span class="keyword">int</span> pos = l;</span><br><span class="line">        <span class="keyword">while</span>(pos &lt; r &amp;&amp; v[pos] &lt; root) ++pos;</span><br><span class="line">        <span class="keyword">int</span> idx = pos;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = idx ; i &lt;= r - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(v[i] &lt; root) &#123;</span><br><span class="line">                ans = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        help(v, l, idx - <span class="number">1</span>);</span><br><span class="line">        help(v, idx, r - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="剑指-Offer-34-二叉树中和为某一值的路径"><a href="#剑指-Offer-34-二叉树中和为某一值的路径" class="headerlink" title="剑指 Offer 34. 二叉树中和为某一值的路径"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">剑指 Offer 34. 二叉树中和为某一值的路径</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:     </span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pathSum(TreeNode* root, <span class="keyword">int</span> targetSum) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> ans;</span><br><span class="line">        dfs(root,targetSum);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        temp.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">int</span> s = sum - root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; s == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.push_back(temp);</span><br><span class="line">            temp.pop_back(); <span class="comment">// 回溯</span></span><br><span class="line">            <span class="keyword">return</span>;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) dfs(root-&gt;left, s);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) dfs(root-&gt;right, s);</span><br><span class="line">        temp.pop_back(); <span class="comment">// 回溯</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="剑指-Offer-57-和为s的两个数字"><a href="#剑指-Offer-57-和为s的两个数字" class="headerlink" title="剑指 Offer 57. 和为s的两个数字"></a><a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/">剑指 Offer 57. 和为s的两个数字</a></h4><p>双指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = nums[l] + nums[r];</span><br><span class="line">            <span class="keyword">if</span>(sum == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;nums[l], nums[r]&#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target) &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="剑指-Offer-56-I-数组中数字出现的次数"><a href="#剑指-Offer-56-I-数组中数字出现的次数" class="headerlink" title="剑指 Offer 56 - I. 数组中数字出现的次数"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">剑指 Offer 56 - I. 数组中数字出现的次数</a></h4><p>unfinished</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">singleNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            res ^= x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 任意挑一个不为1的位，以此为依据分成两组</span></span><br><span class="line">        <span class="keyword">int</span> bit = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((bit &amp; res) == <span class="number">0</span>) &#123;</span><br><span class="line">            bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            <span class="comment">// 这个 bit 就能把数字区分开成两组</span></span><br><span class="line">            <span class="keyword">if</span>(x &amp; bit) &#123;</span><br><span class="line">                a ^= x;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                b ^= x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;a, b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="剑指-Offer-56-II-数组中数字出现的次数-II"><a href="#剑指-Offer-56-II-数组中数字出现的次数-II" class="headerlink" title="剑指 Offer 56 - II. 数组中数字出现的次数 II"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/">剑指 Offer 56 - II. 数组中数字出现的次数 II</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">// 对每一个数都统计一下每一个bit</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            <span class="comment">// 从低位到高位依次提取</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">                cnt[i] += (x &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 从低位到高位</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i] % <span class="number">3</span>) &#123;</span><br><span class="line">                ans |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="剑指-Offer-51-数组中的逆序对"><a href="#剑指-Offer-51-数组中的逆序对" class="headerlink" title="剑指 Offer 51. 数组中的逆序对"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">剑指 Offer 51. 数组中的逆序对</a></h4><p>unfinished（最简洁的写法）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        b.resize(nums.size());</span><br><span class="line">        help(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">help</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r)/<span class="number">2</span>;</span><br><span class="line">        help(nums, l, m);</span><br><span class="line">        help(nums, m + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">int</span> i = l, j = m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = l; k &lt;= r; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j &gt; r || i &lt;= m &amp;&amp; nums[i] &lt;= nums[j]) b[k] = nums[i++];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += m - i + <span class="number">1</span>;</span><br><span class="line">                b[k] = nums[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = l; k &lt;= r; k++) &#123;</span><br><span class="line">            nums[k] = b[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="剑指-Offer-45-把数组排成最小的数"><a href="#剑指-Offer-45-把数组排成最小的数" class="headerlink" title="剑指 Offer 45. 把数组排成最小的数"></a><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">剑指 Offer 45. 把数组排成最小的数</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s1,<span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s12 = s1+s2;</span><br><span class="line">        <span class="built_in">string</span> s21 = s2+s1;</span><br><span class="line">        <span class="keyword">return</span> s12 &lt; s21;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ss;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums)&#123;</span><br><span class="line">            ss.push_back(to_string(x));</span><br><span class="line">        &#125;</span><br><span class="line">        sort(ss.begin(), ss.end(),</span><br><span class="line">            [](<span class="built_in">string</span>&amp;s1, <span class="built_in">string</span> &amp;s2) &#123; <span class="keyword">return</span> s1 + s2 &lt; s2 + s1; &#125;</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span>&amp; s:ss)&#123;</span><br><span class="line">            ans += s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h4 id="剑指-Offer-57-II-和为s的连续正数序列"><a href="#剑指-Offer-57-II-和为s的连续正数序列" class="headerlink" title="剑指 Offer 57 - II. 和为s的连续正数序列"></a><a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/">剑指 Offer 57 - II. 和为s的连续正数序列</a></h4><p>滑动窗口</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; findContinuousSequence(<span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">2</span>; l &lt; r;) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = (l + r) * (r - l + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(sum == target) &#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">                    a.push_back(i);</span><br><span class="line">                &#125;</span><br><span class="line">                ans.push_back(a);</span><br><span class="line">                ++l; <span class="comment">// l移动</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target) &#123;</span><br><span class="line">                ++r;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h4 id="剑指-Offer-47-礼物的最大价值"><a href="#剑指-Offer-47-礼物的最大价值" class="headerlink" title="剑指 Offer 47. 礼物的最大价值"></a><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">剑指 Offer 47. 礼物的最大价值</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; g)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = g.size(), n = g[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; f(m , <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="comment">// f[0][0] = grid[0][0];</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">                res = max(res, g[i][j] + (i ? f[i - <span class="number">1</span>][j] : <span class="number">0</span>));</span><br><span class="line">                res = max(res, g[i][j] + (j ? f[i][j - <span class="number">1</span>] : <span class="number">0</span>));</span><br><span class="line">                f[i][j] = res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>









<h4 id="剑指-Offer-46-把数字翻译成字符串"><a href="#剑指-Offer-46-把数字翻译成字符串" class="headerlink" title="剑指 Offer 46. 把数字翻译成字符串"></a><a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">剑指 Offer 46. 把数字翻译成字符串</a></h4><p>记忆化搜索</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        s = to_string(num);</span><br><span class="line">        len = s.size();</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == len) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(mp.count(i)) &#123;</span><br><span class="line">            <span class="keyword">return</span> mp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(i + <span class="number">1</span> &lt;= len) &#123;</span><br><span class="line">            res += dfs(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i + <span class="number">2</span> &lt;= len) &#123;</span><br><span class="line">            <span class="keyword">bool</span> f = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;0&#x27;</span>) f = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>((s[i] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + s[i + <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span> &gt; <span class="number">25</span>) f = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(f) &#123;</span><br><span class="line">                res += dfs(i + <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mp[i] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s = to_string(num);</span><br><span class="line">        <span class="keyword">int</span> m = s.size();</span><br><span class="line">        s = <span class="string">&quot; &quot;</span> + s;</span><br><span class="line">        <span class="keyword">int</span> f[<span class="number">40</span>] = &#123;<span class="number">1</span>&#125;; <span class="comment">// 空串的分割种数为 1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            f[i] = f[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = stoi(s.substr(i - <span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">                <span class="keyword">if</span>(x &gt;= <span class="number">10</span> &amp;&amp; x &lt;= <span class="number">25</span>) f[i] += f[i - <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="剑指-Offer-48-最长不含重复字符的子字符串"><a href="#剑指-Offer-48-最长不含重复字符的子字符串" class="headerlink" title="剑指 Offer 48. 最长不含重复字符的子字符串"></a><a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">剑指 Offer 48. 最长不含重复字符的子字符串</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; s.size(); r++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r &amp;&amp; st.count(s[r])) &#123;</span><br><span class="line">                st.erase(s[l++]);</span><br><span class="line">            &#125;</span><br><span class="line">            st.insert(s[r]);</span><br><span class="line">            ans = max(ans, r - l + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="剑指-Offer-53-I-在排序数组中查找数字-I"><a href="#剑指-Offer-53-I-在排序数组中查找数字-I" class="headerlink" title="剑指 Offer 53 - I. 在排序数组中查找数字 I"></a><a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">剑指 Offer 53 - I. 在排序数组中查找数字 I</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> l = lower_bound(nums.begin(), nums.end(), target);</span><br><span class="line">        <span class="keyword">if</span>(l == nums.end() || *l != target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> r = upper_bound(nums.begin(), nums.end(), target);</span><br><span class="line">        <span class="keyword">return</span> r - l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="剑指-Offer-52-两个链表的第一个公共节点"><a href="#剑指-Offer-52-两个链表的第一个公共节点" class="headerlink" title="剑指 Offer 52. 两个链表的第一个公共节点"></a><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">剑指 Offer 52. 两个链表的第一个公共节点</a></h4><p>unfinished</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="literal">nullptr</span> || headB == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *pA = headA, *pB = headB;</span><br><span class="line">        <span class="keyword">while</span> (pA != pB) &#123;</span><br><span class="line">            pA = pA == <span class="literal">nullptr</span> ? headB : pA-&gt;next;</span><br><span class="line">            pB = pB == <span class="literal">nullptr</span> ? headA : pB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="剑指-Offer-53-II-0～n-1中缺失的数字"><a href="#剑指-Offer-53-II-0～n-1中缺失的数字" class="headerlink" title="剑指 Offer 53 - II. 0～n-1中缺失的数字"></a><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/">剑指 Offer 53 - II. 0～n-1中缺失的数字</a></h4><p>二分</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span> ,r = a.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 找到第一个错位的索引</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l) /<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(a[m] == m)&#123;</span><br><span class="line">                l = m + <span class="number">1</span>; </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a[l] != l ? l : a.size(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h4 id="剑指-Offer-54-二叉搜索树的第k大节点"><a href="#剑指-Offer-54-二叉搜索树的第k大节点" class="headerlink" title="剑指 Offer 54. 二叉搜索树的第k大节点"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">剑指 Offer 54. 二叉搜索树的第k大节点</a></h4><p>不要使用中序遍历拿出所有的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans, k ;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;k = k;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root || k &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(--k == <span class="number">0</span>) &#123; <span class="comment">// 没访问一个节点， --k</span></span><br><span class="line">            ans = root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="剑指-Offer-49-丑数"><a href="#剑指-Offer-49-丑数" class="headerlink" title="剑指 Offer 49. 丑数"></a><a href="https://leetcode-cn.com/problems/chou-shu-lcof/">剑指 Offer 49. 丑数</a></h4><p>优先队列</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">long</span>&gt; vis;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;<span class="keyword">long</span>, <span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;, greater&lt;<span class="keyword">long</span>&gt;&gt; pq;</span><br><span class="line">        pq.push(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> a[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">            ans = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y : a) &#123;</span><br><span class="line">                <span class="keyword">long</span> x = ans * y;</span><br><span class="line">                <span class="keyword">if</span>(!vis.count(x)) &#123;</span><br><span class="line">                    vis.insert(x);</span><br><span class="line">                    pq.push(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<p>动态规划</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> p2 = <span class="number">1</span>, p3 = <span class="number">1</span>, p5 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num2 = dp[p2] * <span class="number">2</span>, num3 = dp[p3] * <span class="number">3</span>, num5 = dp[p5] * <span class="number">5</span>;</span><br><span class="line">            dp[i] = min(min(num2, num3), num5);</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == num2) &#123;</span><br><span class="line">                p2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == num3) &#123;   <span class="comment">// 注意是 if （去重）</span></span><br><span class="line">                p3++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == num5) &#123;</span><br><span class="line">                p5++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h4 id="剑指-Offer-59-II-队列的最大值"><a href="#剑指-Offer-59-II-队列的最大值" class="headerlink" title="剑指 Offer 59 - II. 队列的最大值"></a><a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/">剑指 Offer 59 - II. 队列的最大值</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq; <span class="comment">// 递减</span></span><br><span class="line"></span><br><span class="line">    MaxQueue() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dq.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> dq.front();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        q.push(value);</span><br><span class="line">        <span class="keyword">while</span>(dq.size() &amp;&amp; dq.back() &lt; value) &#123;</span><br><span class="line">            dq.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        dq.push_back(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(q.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> x = q.front(); </span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(dq.front() == x) dq.pop_front();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="剑指-Offer-59-I-滑动窗口的最大值"><a href="#剑指-Offer-59-I-滑动窗口的最大值" class="headerlink" title="剑指 Offer 59 - I. 滑动窗口的最大值"></a><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">剑指 Offer 59 - I. 滑动窗口的最大值</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">int</span> K;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        K = k;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="comment">// 初始</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; k; i++) &#123;</span><br><span class="line">            add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结果集大小</span></span><br><span class="line">        <span class="keyword">int</span> sz = nums.size() - k + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(sz--) &#123;</span><br><span class="line">            ans.push_back(dq.front());</span><br><span class="line">            <span class="keyword">if</span>(i &lt; nums.size()) add(nums[i++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        q.push(x);</span><br><span class="line">        <span class="keyword">while</span>(dq.size() &amp;&amp; dq.back() &lt; x) &#123;</span><br><span class="line">            dq.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        dq.push_back(x);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(q.size() == K + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(x == dq.front()) dq.pop_front();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h4 id="剑指-Offer-65-不用加减乘除做加法"><a href="#剑指-Offer-65-不用加减乘除做加法" class="headerlink" title="剑指 Offer 65. 不用加减乘除做加法"></a><a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/">剑指 Offer 65. 不用加减乘除做加法</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 理论知识</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> C = <span class="number">0</span>, S; <span class="comment">// C表示临时进位，S表示临时结果</span></span><br><span class="line">        <span class="keyword">int</span> X, Y;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i) &#123;</span><br><span class="line">            X = a &amp; <span class="number">1</span>;</span><br><span class="line">            Y = b &amp; <span class="number">1</span>;</span><br><span class="line">            S = C ^ X ^ Y;</span><br><span class="line">            C = (X&amp;Y) | ((X | Y) &amp; C); <span class="comment">// key point</span></span><br><span class="line">            sum = sum | (S &lt;&lt; i);</span><br><span class="line">            a &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="剑指-Offer-60-n个骰子的点数"><a href="#剑指-Offer-60-n个骰子的点数" class="headerlink" title="剑指 Offer 60. n个骰子的点数"></a><a href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/">剑指 Offer 60. n个骰子的点数</a></h4><p>unfinished</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">dicesProbability</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">6</span>, <span class="number">1.0</span> / <span class="number">6.0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">tmp</span><span class="params">(<span class="number">5</span> * i + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dp.size(); j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">6</span>; k++) &#123;</span><br><span class="line">                    tmp[j + k] += dp[j] / <span class="number">6.0</span>; <span class="comment">// 概率论的加法公式</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="剑指-Offer-62-圆圈中最后剩下的数字"><a href="#剑指-Offer-62-圆圈中最后剩下的数字" class="headerlink" title="剑指 Offer 62. 圆圈中最后剩下的数字"></a><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">剑指 Offer 62. 圆圈中最后剩下的数字</a></h4><p>unfinished</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; len++) &#123;</span><br><span class="line">            <span class="comment">// (m ---&gt; 0, m + idx ---&gt; idx) 模len意义下 </span></span><br><span class="line">            <span class="comment">// aka. old_idx = (new_idx + m) % len;</span></span><br><span class="line">            idx = (m + idx) % len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> idx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0 1 2 3 4    2   3 </span></span><br><span class="line"><span class="comment">3 4 0 1      0   0      </span></span><br><span class="line"><span class="comment">1 3 4        4   1 </span></span><br><span class="line"><span class="comment">1 3          1   1        </span></span><br><span class="line"><span class="comment">3            -   0 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>







<h4 id="剑指-Offer-55-II-平衡二叉树"><a href="#剑指-Offer-55-II-平衡二叉树" class="headerlink" title="剑指 Offer 55 - II. 平衡二叉树"></a><a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/">剑指 Offer 55 - II. 平衡二叉树</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> ans = <span class="literal">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        len(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">len</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> llen = len(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> rlen = len(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(rlen - llen) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            ans = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(llen, rlen) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h4 id="剑指-Offer-61-扑克牌中的顺子"><a href="#剑指-Offer-61-扑克牌中的顺子" class="headerlink" title="剑指 Offer 61. 扑克牌中的顺子"></a><a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/">剑指 Offer 61. 扑克牌中的顺子</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">isStraight</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> joker = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(nums); <span class="comment">// 数组排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>) joker++; <span class="comment">// 统计大小王数量</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == nums[i + <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 若有重复，提前返回 false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">4</span>] - nums[joker] &lt; <span class="number">5</span>; <span class="comment">// 最大牌 - 最小牌 &lt; 5 则可构成顺子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="剑指-Offer-68-II-二叉树的最近公共祖先"><a href="#剑指-Offer-68-II-二叉树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - II. 二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - II. 二叉树的最近公共祖先</a></h4><p>unfinished</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root || root == p || root == q)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* lc = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">        TreeNode* rc = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span>(!lc) <span class="keyword">return</span> rc; <span class="comment">//左边这棵树既没有p，也没有q，看右边即可</span></span><br><span class="line">        <span class="keyword">if</span>(!rc) <span class="keyword">return</span> lc; <span class="comment">//右边这棵树既没有p，也没有q，看左边即可</span></span><br><span class="line">        <span class="comment">// 如果左边一个、右边一个，root就是lca。</span></span><br><span class="line">        <span class="keyword">return</span> root; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="剑指-Offer-68-I-二叉搜索树的最近公共祖先"><a href="#剑指-Offer-68-I-二叉搜索树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - I. 二叉搜索树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</a></h4><p>或者使用更一般的做法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> val = root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val &lt; val &amp;&amp; q-&gt;val &lt; val) <span class="keyword">return</span> lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val &gt; val &amp;&amp; q-&gt;val &gt; val) <span class="keyword">return</span> lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





]]></content>
      <tags>
        <tag>算法题</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>大整数取模、最大公约数与最小公倍数、快速幂与慢速乘、矩阵乘法加速</title>
    <url>/2021/11/11/%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8F%96%E6%A8%A1%E3%80%81%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E4%B8%8E%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0%E3%80%81%E5%BF%AB%E9%80%9F%E5%B9%82%E4%B8%8E%E6%85%A2%E9%80%9F%E4%B9%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="大整数取模"><a href="#大整数取模" class="headerlink" title="大整数取模"></a>大整数取模</h2><p>Description：<br>输入一个字符串 a 代表一个很大的数，一个32位整数b，问a能否整除b。<br><a href="https://vjudge.net/problem/LightOJ-1214">Large Division LightOJ - 1214 
</a><br>亲测 10ms。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大整数取模</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        b = <span class="built_in">abs</span>(b);</span><br><span class="line">        ll sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>]==<span class="string">&#x27;-&#x27;</span>) a.erase(a.begin());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;a.length();j++)&#123;</span><br><span class="line">            sum = sum*<span class="number">10</span> + a[j]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            sum%=b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;Case %d: not divisible\n&quot;</span>,i);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Case %d: divisible\n&quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>亲测，500ms左右，发现Java的BigDecimal速度还是比较慢的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">int</span> t=sc.nextInt();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++) &#123;</span><br><span class="line">			String as = sc.next();</span><br><span class="line">			String bs = sc.next();</span><br><span class="line">			BigDecimal a = <span class="keyword">new</span> BigDecimal(as);</span><br><span class="line">			BigDecimal b = <span class="keyword">new</span> BigDecimal(bs);</span><br><span class="line">			<span class="keyword">if</span>(a.divideAndRemainder(b)[<span class="number">1</span>].compareTo(<span class="keyword">new</span> BigDecimal(<span class="number">0</span>))==<span class="number">0</span>) &#123;</span><br><span class="line">				System.out.printf(<span class="string">&quot;Case %d: divisible\n&quot;</span>,i);</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.printf(<span class="string">&quot;Case %d: not divisible\n&quot;</span>,i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sc.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">其中；</span><br><span class="line">a.divideAndRemainder(b)返回一个数组，[<span class="number">0</span>]是整除数，[<span class="number">1</span>]是余数。</span><br><span class="line">A.compareTo（B）-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>分别对应 &lt;,=,&gt;</span><br></pre></td></tr></table></figure>
<h2 id="最大公约数与最小公倍数"><a href="#最大公约数与最小公倍数" class="headerlink" title="最大公约数与最小公倍数"></a>最大公约数与最小公倍数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b==<span class="number">0</span>?a: gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">lcm</span><span class="params">(ll a,ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a/gcd(a,b)*b;  <span class="comment">// 先除再乘，否则可能中间溢出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速幂与慢速乘"><a href="#快速幂与慢速乘" class="headerlink" title="快速幂与慢速乘"></a>快速幂与慢速乘</h2><p>小栗子<br>快速幂： ${ {2^7=2<em>2^6=2</em>(2^3)^2=2*(2*(2^2))^2} }$</p>
<p>也就是：${ {2^{2^2+2^1+2^0} } }$<br>时间复杂度：O(logn)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快速幂</span></span><br><span class="line"><span class="function">ll <span class="title">pow</span><span class="params">(ll a,ll n,ll p)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) ans=ans*a%p;  <span class="comment">//如果无需取模，去掉 %p即可</span></span><br><span class="line">        a=a*a%p;  <span class="comment">// 是 平方</span></span><br><span class="line">        n/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>慢速乘$ { { 3<em>7=3</em>(2^2+2^1+2^0) } } $</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//慢速乘,大数相乘，速度慢，而且容易溢出</span></span><br><span class="line"><span class="function">ll <span class="title">mul</span><span class="params">(ll a,ll b,ll p)</span></span>&#123;  <span class="comment">//将b分解成 和</span></span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans=(ans+a)%p;</span><br><span class="line">        a=a*<span class="number">2</span>%p;  <span class="comment">//是乘 2</span></span><br><span class="line">        b/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常见问法：<br><a href="https://vjudge.net/problem/LightOJ-1282">Leading and Trailing LightOJ - 1282</a><br>输出一个大数的最右面3位（%1000即可），和最左面3位。<br>如果要输出最左面的3位呢？<br>${ {n^k=10^p} }$<br>p应该是个带小数的浮点数m,取对数 ${ {p=k*log_{10}(n)} }$,(p的小数部分)*100取整就是答案，因为p的整数部分只控制多少位。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fmod</span>(a,b) 浮点数的取余数。<span class="built_in">fmod</span>(a,<span class="number">1</span>)即可取出小数。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//快速幂</span></span><br><span class="line"><span class="function">ll <span class="title">pow</span><span class="params">(ll a,ll n,ll p)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) ans=ans*a%p;  <span class="comment">//如果无需取模，去掉 %p即可</span></span><br><span class="line">        a=a*a%p;  <span class="comment">// 是 平方</span></span><br><span class="line">        n/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++)&#123;</span><br><span class="line">        ll n,k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">        ll ans2 = <span class="built_in">pow</span>(n, k,<span class="number">1000</span>);</span><br><span class="line">        ll ans1 = <span class="built_in">pow</span>(<span class="number">10.0</span>,<span class="number">2.0</span>+<span class="built_in">fmod</span>((<span class="keyword">double</span>)k*<span class="built_in">log10</span>((<span class="keyword">double</span>)n), <span class="number">1</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %lld %03lld\n&quot;</span>,i,ans1,ans2);</span><br><span class="line">        <span class="comment">//注意题目要求最右边的3位数字，如果3，则应该输出003</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="矩阵加速"><a href="#矩阵加速" class="headerlink" title="矩阵加速"></a>矩阵加速</h2><p>步骤：</p>
<ol>
<li><strong>求出递推矩阵</strong>（也是最重要的一步）；</li>
<li><strong>矩阵乘法</strong>；</li>
<li><strong>矩阵快速幂</strong>；</li>
<li><strong>矩阵乘向量得出结果</strong>。</li>
</ol>
<p>例： <a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mod = (<span class="keyword">int</span>)<span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] A = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] B = pow(A, n);</span><br><span class="line">        <span class="keyword">return</span> B[<span class="number">1</span>][<span class="number">0</span>]; <span class="comment">// 实际上是 矩阵B*列向量[1,0]的结果</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 矩阵乘法，返回新数组</span></span><br><span class="line">    <span class="keyword">int</span>[][] mul(<span class="keyword">int</span>[][] A, <span class="keyword">int</span>[][] B) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = A.length, n = B[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> len = A[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] ans = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; len; k++) &#123;</span><br><span class="line">                    <span class="comment">// 小心溢出</span></span><br><span class="line">                    res = (<span class="keyword">int</span>)((res + (<span class="keyword">long</span>)A[i][k] * B[k][j] ) % mod);</span><br><span class="line">                &#125;</span><br><span class="line">                ans[i][j] = res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快速幂计算</span></span><br><span class="line">    <span class="keyword">int</span>[][] pow(<span class="keyword">int</span>[][] A, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] ans = <span class="keyword">new</span> <span class="keyword">int</span>[A.length][A[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.length; i++) &#123;</span><br><span class="line">            ans[i][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                ans = mul(ans, A);</span><br><span class="line">            &#125;</span><br><span class="line">            A = mul(A, A);</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>如何解析c语言程序的命令行参数？—— Argtable3使用教程</title>
    <url>/2021/09/23/%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%90c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%EF%BC%9F%E2%80%94%E2%80%94-Argtable3%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="如何构建符合-POSIX-实用程序约定的Shell-CLI"><a href="#如何构建符合-POSIX-实用程序约定的Shell-CLI" class="headerlink" title="如何构建符合 POSIX 实用程序约定的Shell-CLI"></a>如何构建符合 POSIX 实用程序约定的Shell-CLI</h1><h2 id="What-is-Argtable"><a href="#What-is-Argtable" class="headerlink" title="What is Argtable"></a>What is Argtable</h2><p>Argtable是一款开源的ANSI C library，用来解析GNU样式的命令行选项。它通过定义可用于指定命令行语法的声明式API，从而简化了命令行的分析。<br>argtable将自动生成一致的错误处理逻辑和命令行语法的文本描述，这对于一个健壮的cli程序来说，是非常必要的，但是很繁琐。</p>
<h2 id="Introduction-of-Argtable3"><a href="#Introduction-of-Argtable3" class="headerlink" title="Introduction of Argtable3"></a>Introduction of Argtable3</h2><p>解析程序的命令行一直以来都是一个分散注意力的主要编程任务。Argtable3 库通过允许程序员<strong>将源代码中的命令行选项直接定义为静态的结构数组</strong>来简化作业， 然后**<br>将该数组传递给argtable3库函数，这些函数就会相应地解析命令行。从命令行中提取的值直接保存到用户定义的程序变量中<strong>，主程序就可以访问这些变量。<br>argtable3还可以从同一数组中生成命令行语法的描述，以便显示为联机帮助。根据第三条BSD许可条款，此库是免费的。 注意：</strong>argtable3不向后兼容**。</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="demo-code"><a href="#demo-code" class="headerlink" title="demo code"></a>demo code</h3><ul>
<li><p>入门小例子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入 argtable3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;argtable3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* global arg_xxx structs */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arg_lit</span> *<span class="title">help</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arg_end</span> *<span class="title">end</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* the global arg_xxx structs are initialised within the argtable */</span></span><br><span class="line">    <span class="keyword">void</span> *argtable[] = &#123;</span><br><span class="line">            help = arg_litn(<span class="literal">NULL</span>, <span class="string">&quot;help&quot;</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;display this help and exit&quot;</span>),</span><br><span class="line">            end = arg_end(<span class="number">20</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> exitcode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> program[] = <span class="string">&quot;argtable&quot;</span>;</span><br><span class="line">    arg_parse(argc, argv, argtable);</span><br><span class="line">    <span class="comment">/* special case: &#x27;--help&#x27; takes precedence over error reporting */</span></span><br><span class="line">    <span class="keyword">if</span> (help-&gt;count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s&quot;</span>, program);</span><br><span class="line">        arg_print_syntax(<span class="built_in">stdout</span>, argtable, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Demonstrate command-line parsing in argtable3.\n\n&quot;</span>);</span><br><span class="line">        arg_print_glossary(<span class="built_in">stdout</span>, argtable, <span class="string">&quot;  %-25s %s\n&quot;</span>);</span><br><span class="line">        exitcode = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* deallocate each non-null entry in argtable[] */</span></span><br><span class="line">        arg_freetable(argtable, <span class="keyword">sizeof</span>(argtable) / <span class="keyword">sizeof</span>(argtable[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> exitcode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./argtable --help</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Usage: argtable [--<span class="built_in">help</span>]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Demonstrate command-line parsing <span class="keyword">in</span> argtable3.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#  --help                    display this help and exit</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="how-it-works"><a href="#how-it-works" class="headerlink" title="how it works"></a>how it works</h3><p>Argtable3 提供了一组<strong>arg_xxx结构</strong>，一个用于它支持的每种类型的参数（<strong>文字、整数、双精度、字符串、文件名</strong>等），<br>并且每个结构都能够在命令行上处理该参数的多次出现。此外，<strong>可以为每个选项提供可互换使用的替代短选项 (-x)或长选项 (–xx) 形式</strong>。<br>事实上，每个选项甚至可以选择多个替代的短选项或长选项，或两者兼而有之。</p>
<p>要定义命令行选项，您必须为arg_xxx所需的每种类型的参数（<strong>文字、整数、双精度、字符串、文件名</strong>等）创建一个结构体，并将它们整理到我们称为参数表（<strong>argument table</strong>）的数组中。<br>参数表中结构的顺序定义了命令行选项的预期顺序，不过<strong>解析顺序实际上只对未标记的选项重要</strong>（和python的函数传参规则类似）。<br><strong>参数表本身只是一个void指针数组</strong>（<code>void* arg_table[]</code>），<br>按照惯例，每个arg_xxx结构都有一个已知的<strong>arg_hdr结构体</strong>作为其第一个条目，Argtable3 函数使用它来标识结构体。</p>
<h4 id="arg-hdr"><a href="#arg-hdr" class="headerlink" title="arg_hdr"></a>arg_hdr</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">arg_hdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> flag;             <span class="comment">/* Modifier flags: ARG_TERMINATOR, ARG_HASVALUE. */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* shortopts; <span class="comment">/* String defining the short options */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* longopts;  <span class="comment">/* String defiing the long options */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* datatype;  <span class="comment">/* Description of the argument data type */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* glossary;  <span class="comment">/* Description of the option as shown by arg_print_glossary function */</span></span><br><span class="line">    <span class="keyword">int</span> mincount;          <span class="comment">/* Minimum number of occurences of this option accepted */</span></span><br><span class="line">    <span class="keyword">int</span> maxcount;          <span class="comment">/* Maximum number of occurences if this option accepted */</span></span><br><span class="line">    <span class="keyword">void</span>* parent;          <span class="comment">/* Pointer to parent arg_xxx struct */</span></span><br><span class="line">    arg_resetfn* resetfn;  <span class="comment">/* Pointer to parent arg_xxx reset function */</span></span><br><span class="line">    arg_scanfn* scanfn;    <span class="comment">/* Pointer to parent arg_xxx scan function */</span></span><br><span class="line">    arg_checkfn* checkfn;  <span class="comment">/* Pointer to parent arg_xxx check function */</span></span><br><span class="line">    arg_errorfn* errorfn;  <span class="comment">/* Pointer to parent arg_xxx error function */</span></span><br><span class="line">    <span class="keyword">void</span>* priv;            <span class="comment">/* Pointer to private header data for use by arg_xxx functions */</span></span><br><span class="line">&#125; <span class="keyword">arg_hdr_t</span>;</span><br></pre></td></tr></table></figure>
<p>最基本的一个类型，所有的其他类型都包含这个类型。一一解释下里面的参数的含义:</p>
<ul>
<li>shortopts: 参数的短名称，比如ls -a 中的a就是短名称;</li>
<li>longopts: 参数中的长名称，比如ls —all 中的all就是长名称;</li>
<li>datatype: 参数的数据类型有, , NULL, ,(时间类型传入format字符串),(rex类型传入匹配串),等;</li>
<li>glossary: 对于参数的描述;</li>
<li>mincount: 参数最少的个数(可以规定是否必须有参数比如设置为0为非必须，1…n为必须);</li>
<li>maxcount: 参数最多的个数，采用Unix风格的，如kernel.exe -l 1 -l 2 -l 3</li>
<li>其他参数非必须。</li>
</ul>
<h4 id="arg-xxx结构体族"><a href="#arg-xxx结构体族" class="headerlink" title="arg_xxx结构体族"></a>arg_xxx结构体族</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 整数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arg_int</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arg_hdr</span> <span class="title">hdr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">int</span> *ival;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 文字</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arg_lit</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arg_hdr</span> <span class="title">hdr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 双精度浮点数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arg_dbl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arg_hdr</span> <span class="title">hdr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">double</span> *dval;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arg_str</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arg_hdr</span> <span class="title">hdr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> **sval;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arg_rex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arg_hdr</span> <span class="title">hdr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> **sval;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arg_file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arg_hdr</span> <span class="title">hdr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> **filename;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> **basename;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> **extension;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arg_date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arg_hdr</span> <span class="title">hdr</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *format;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">tm_val</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="详细介绍-arg-int"><a href="#详细介绍-arg-int" class="headerlink" title="详细介绍 arg_int"></a>详细介绍 arg_int</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arg_int</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arg_hdr</span> <span class="title">hdr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">int</span> *ival;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结构体的第一个数据成员hdr保存了 Argtable3 库函数使用的私有数据。它包含参数的标签字符串等内容（<strong>可以理解为元数据</strong>）。<br>直接公开地访问这些数据是可以的，但很少需要这样做。<br>它的ival成员变量指向持有从命令行提取出的数组，count为数组的长度。ival 数组的存储在arg_int构造时分配。<br><strong>这必须通过arg_int构造函数完成。</strong><br>注意，<strong>你永远不应该自己手动实例化任何arg_xxx结构，而是始终使用提供的构造函数来分配结构，并在完成后使用 arg_freetable 释放它。</strong></p>
<ul>
<li>举例<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arg_int</span> *<span class="title">s</span>;</span></span><br><span class="line">s = arg_intn(<span class="literal">NULL</span>, <span class="string">&quot;scalar&quot;</span>, <span class="string">&quot;&lt;n&gt;&quot;</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="string">&quot;foo value&quot;</span>);</span><br></pre></td></tr></table></figure>
完成s后将指向一个包含5 个元素数组的内存块的结构体arg_int。<br>甚至，你还可以设置多个别名，短选项被赋予一串单个字符，而长选项被赋予一个逗号分隔的字符串。<br>例如：<code>s = arg_intn(&quot;kKx&quot;, &quot;scalar,foo&quot;, &quot;&lt;n&gt;&quot;, 3, 5, &quot;foo value&quot;);</code></li>
</ul>
<p><img src="/2021/09/23/%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%90c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%EF%BC%9F%E2%80%94%E2%80%94-Argtable3%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/example.png" alt="example.png"><br>如图所示，该<code>s-&gt;hdr</code>结构保留对构造函数的字符串参数的引用等。<br>该<code>s-&gt;count</code>变量初始化为零，因为它表示<code>s-&gt;ival</code>解析命令行后存储在数组中的有效值的数量。<br><code>s-&gt;ival</code>数组的大小由<code>s-&gt;hdr.maxcount</code>给出。</p>
<ul>
<li>实例代码<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入 argtable3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;argtable3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* global arg_xxx structs */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arg_int</span> *<span class="title">int_arrays</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arg_end</span> *<span class="title">end</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* the global arg_xxx structs are initialised within the argtable */</span></span><br><span class="line">    <span class="keyword">void</span> *argtable[] = &#123;</span><br><span class="line">            int_arrays = arg_intn(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;array&quot;</span>, <span class="string">&quot;&lt;number&gt;&quot;</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&quot;please input an integer&quot;</span>),</span><br><span class="line">            end = arg_end(<span class="number">20</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> exitcode = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> nerrors = arg_parse(argc, argv, argtable);</span><br><span class="line">    <span class="keyword">if</span> (nerrors == <span class="number">0</span>) &#123;</span><br><span class="line">        exitcode = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> *a = int_arrays-&gt;ival;</span><br><span class="line">        <span class="keyword">int</span> len = int_arrays-&gt;count;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;input numbers are as following:\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> exitcode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 运行</span></span><br><span class="line">./argtable -a 1 -a 2 --array 3</span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> input numbers are as following:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1  2  3</span>  </span><br></pre></td></tr></table></figure></li>
</ul>
<p>其他的参数结构体使用方法大同小异。</p>
<h4 id="The-Argument-Table-参数表"><a href="#The-Argument-Table-参数表" class="headerlink" title="The Argument Table (参数表)"></a>The Argument Table (参数表)</h4><p>在构建完各种类型参数的结构体之后，我们需要统一将它们组装到一个结构体数组里面，类型为<code>void **</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arg_lit</span> *<span class="title">a</span> =</span> arg_litn(<span class="string">&quot;a&quot;</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;the -a option&quot;</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arg_lit</span> *<span class="title">b</span> =</span> arg_litn(<span class="string">&quot;b&quot;</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;the -b option&quot;</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arg_lit</span> *<span class="title">c</span> =</span> arg_litn(<span class="string">&quot;c&quot;</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;the -c option&quot;</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arg_int</span> *<span class="title">scal</span> =</span> arg_intn(<span class="literal">NULL</span>, <span class="string">&quot;scalar&quot;</span>, <span class="string">&quot;&lt;n&gt;&quot;</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;foo value&quot;</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arg_lit</span> *<span class="title">verb</span> =</span> arg_litn(<span class="string">&quot;v&quot;</span>, <span class="string">&quot;verbose&quot;</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;verbose output&quot;</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arg_file</span> *<span class="title">o</span> =</span> arg_filen(<span class="string">&quot;o&quot;</span>, <span class="literal">NULL</span>,<span class="string">&quot;myfile&quot;</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;output file&quot;</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arg_file</span> *<span class="title">file</span> =</span> arg_filen(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="string">&quot;&lt;file&gt;&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;input files&quot;</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arg_end</span> *<span class="title">end</span> =</span> arg_end(<span class="number">20</span>);</span><br><span class="line"><span class="comment">// 这就是我们的参数列表</span></span><br><span class="line"><span class="keyword">void</span> *argtable[] = &#123;a, b, c, scal, verb, o, file, end&#125;; </span><br></pre></td></tr></table></figure>

<p>其中，<code>arg_end</code> 结构体是一个特殊的结构体，因为它不代表任何命令行选项。<br>它主要标记 argtable 数组的结尾，同时它也存储在处理命令行参数时遇到的任何解析器错误。<br>传递给arg_end构造函数的整数参数是它将存储的最大错误数，任何更多的错误都将被丢弃并替换为单个错误消息“错误太多”。<br><strong><code>arg_end</code>必须要有。</strong></p>
<p>你还可以使用<code>arg_nullcheck</code>检查参数表中是否有空指针，（感觉这个功能很鸡肋）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (arg_nullcheck(argtable) != <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;error: insufficient memory\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="解析命令行"><a href="#解析命令行" class="headerlink" title="解析命令行"></a>解析命令行</h4><p>我们使用<code>arg_parse</code>函数来做到这一点，它返回它遇到的解析错误的数量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> nerrors = arg_parse(argc, argv, argtable);</span><br></pre></td></tr></table></figure>
<p>如果没有错误的话（<code>nerrors == 0</code>），那么我们已经成功解析了命令行,你想要在命令行中提取的数据也都存在了参数表这个<code>void**</code>里面，正常地访问它即可。</p>
<h4 id="设置默认值"><a href="#设置默认值" class="headerlink" title="设置默认值"></a>设置默认值</h4><p>对此的解决方法很简单，直接在调用<code>arg_parse</code>之前设置<code>arg_table</code>的值，在命令行中有用户输入的值才会被覆盖。<br>其余的，就是你一开始设置的默认值。</p>
<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>如果 arg_parse 函数报告错误，那么我们需要显示它们，因为 arg_parse 本身不会这样做。<br>使用<code>arg_print_errors</code>即可，arg_end的内部结构无需关心。<br>函数定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">arg_print_errors</span><span class="params">(FILE* fp, struct arg_end* end, <span class="keyword">const</span> <span class="keyword">char</span>* progname)</span></span>;</span><br></pre></td></tr></table></figure>
<p>使用实例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">If (nerrors &gt; <span class="number">0</span>)</span><br><span class="line">    arg_print_errors(<span class="built_in">stdout</span>, end, <span class="string">&quot;myprog&quot;</span>); <span class="comment">// stdout 文件描述符</span></span><br></pre></td></tr></table></figure>
<p>arg_parse函数不打印错误消息是因为它可以被多次调用以使用替代参数表解析命令行，而不会过早显示无关的错误消息。<br>因此，我们可以为那些具有互斥命令行选项集的程序定义单独的参数表，依次尝试每个参数表，直到找到一个成功的候选者。<br>如果所有参数表都不能满足，那么我们可以选择打印所有参数表的错误消息，或者可能只显示与最匹配的错误信息。无论如何，我们可以控制显示哪些消息。</p>
<h4 id="显示选项语法及帮助"><a href="#显示选项语法及帮助" class="headerlink" title="显示选项语法及帮助"></a>显示选项语法及帮助</h4><p>如果您希望您的程序显示在线帮助，您可以使用<code>arg_print_syntax</code>函数来显示从参数表派生的命令行语法。<br>该函数实际上有两种形式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">arg_print_syntax</span><span class="params">(FILE *fp, <span class="keyword">void</span> **argtable, <span class="keyword">const</span> <span class="keyword">char</span> *suffix)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">arg_print_syntaxv</span><span class="params">(FILE *fp, <span class="keyword">void</span> **argtable, <span class="keyword">const</span> <span class="keyword">char</span> *suffix)</span></span>;</span><br></pre></td></tr></table></figure>
<p>你可以使用<code>void arg_print_glossary(FILE *fp, void **argtable, const char *format);</code>来输出提示。</p>
<p>在文章的开始的示例中已经展示过这两个函数的使用方法了，这里不再赘述。</p>
<h4 id="打扫干净"><a href="#打扫干净" class="headerlink" title="打扫干净"></a>打扫干净</h4><p>在我们的程序结束时，我们需要释放分配给每个arg_xxx结构的内存。我们可以通过分别调用<code>arg_freetable</code>来做到这一点，<br>但有函数可以更方便地为我们做到这一点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">arg_freetable(argtable, <span class="keyword">sizeof</span>(argtable) / <span class="keyword">sizeof</span>(argtable[<span class="number">0</span>]));</span><br></pre></td></tr></table></figure>
<p>它将遍历一个参数表并代表我们调用它的每个元素。<br>请注意，第二个参数<code>sizeof(argtable)/sizeof(argtable[0])</code>仅表示 argtable 数组中的元素数。（使用了内存对齐？）<br>完成此功能后，所有 argtable 数组条目都将设置为NULL。</p>
<h3 id="完整的使用Argtable3的流程图"><a href="#完整的使用Argtable3的流程图" class="headerlink" title="完整的使用Argtable3的流程图"></a>完整的使用Argtable3的流程图</h3><p><img src="/2021/09/23/%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%90c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%EF%BC%9F%E2%80%94%E2%80%94-Argtable3%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/flowchart.png" alt="流程图"></p>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://www.argtable.org/tutorial/">Argtable3教程介绍</a><br><a href="https://github.com/argtable/argtable3/releases/">github地址</a></p>
]]></content>
      <tags>
        <tag>c语言</tag>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>对Jsch的Seession与Channel的线程安全性的测试</title>
    <url>/2021/08/02/%E5%AF%B9Jsch%E7%9A%84Seession%E4%B8%8EChannel%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E7%9A%84%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li><ul>
<li>10000个文件(每个文件只有 12 byte)</li>
</ul>
<ol>
<li>1 session 1 channel<br>串行： 37 s<br>并行(4 核)： 死锁<br>或者 throw new SftpException()、at com.jcraft.jsch.ChannelSftp._realpath(ChannelSftp.java:2362)<br>等各种异常</li>
<li>1 session n channels<br>串行：200 s<br>并行(4 核)：25 s (但是文件下载有丢失)</li>
<li>n sessions 1 channel<br>串行：1200 s<br>并行(4 核)：320 s</li>
</ol>
</li>
<li><p>100个文件(每个文件有 12 MB)</p>
<ol>
<li><p>1 session 1 channel<br>串行： 19 s<br>并行(4 核)： 死锁<br>或者 throw new SftpException()、at com.jcraft.jsch.ChannelSftp._realpath(ChannelSftp.java:2362)<br>等各种异常, 总之文件传输失败</p>
</li>
<li><p>1 session n channels<br>串行：20 s<br>并行(4 核)：18s (但是文件下载有丢失)</p>
</li>
<li><p>n sessions 1 channel<br>串行：35 s<br>并行(4 核)：10 s</p>
</li>
</ol>
</li>
<li><p>10个文件(每个文件有 120 MB)</p>
<ol>
<li><p>1 session 1 channel<br>串行： 18 s<br>并行(4 核)： 死锁<br>或者 throw new SftpException()、at com.jcraft.jsch.ChannelSftp._realpath(ChannelSftp.java:2362)<br>等各种异常, 总之文件传输失败</p>
</li>
<li><p>1 session n channels<br>串行：18 s<br>并行(4 核)：19 s </p>
</li>
<li><p>n sessions 1 channel<br>串行：19 s<br>并行(4 核)：8 s </p>
</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>FTP</category>
      </categories>
  </entry>
  <entry>
    <title>常见排序算法笔记（插入排序、希尔排序、归并排序、快速排序、堆排序、计数排序、基数排序）</title>
    <url>/2021/11/03/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%EF%BC%88%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F%E3%80%81%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E3%80%81%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>这篇博客主要梳理了一些排序算法，为了测试算法的正确性，于是选择了力扣上的一道裸题去测试。算法的正确性相对来讲可以保证。</p>
</blockquote>
<ul>
<li>[LeetCode912. 排序数组]<br><a href="https://leetcode-cn.com/problems/sort-an-array/">传送门</a></li>
</ul>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">insertion_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;nums.size();j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = j<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> key = nums[j];</span><br><span class="line">            <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; nums[i]&gt;key)&#123;</span><br><span class="line">                nums[i+<span class="number">1</span>] = nums[i];</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[i+<span class="number">1</span>] = key;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">shell_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> gap = n/<span class="number">2</span>;gap&gt;=<span class="number">1</span>;gap/=<span class="number">2</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=gap;j&lt;nums.size();j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> i = j-gap;</span><br><span class="line">                <span class="keyword">int</span> key = nums[j];</span><br><span class="line">                <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; nums[i]&gt;key)&#123;</span><br><span class="line">                    nums[i+gap] = nums[i];</span><br><span class="line">                    i -= gap;</span><br><span class="line">                &#125;</span><br><span class="line">                nums[i+gap] = key;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><ul>
<li><p><strong>递归写法</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        merge_sort(nums,<span class="number">0</span>,nums.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = l+(r-l)/<span class="number">2</span>;</span><br><span class="line">        merge_sort(nums,l,mid);</span><br><span class="line">        merge_sort(nums,mid+<span class="number">1</span>,r);</span><br><span class="line">        helper_merge(nums,l,r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper_merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">int</span> mid = l+(r-l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> i = l;</span><br><span class="line">        <span class="keyword">int</span> j = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;=nums[j]) temp.push_back(nums[i++]);</span><br><span class="line">            <span class="keyword">else</span> temp.push_back(nums[j++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid) temp.push_back(nums[i++]);</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=r) temp.push_back(nums[j++]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++)&#123;</span><br><span class="line">            nums[i] = temp[i-l];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p> <strong>迭代写法</strong></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> maxIndex;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> gap = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        maxIndex = nums.size() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(gap &lt; nums.size())&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>;l&lt;maxIndex;l += <span class="number">2</span>*gap)&#123;</span><br><span class="line">                <span class="keyword">int</span> r = maxIndex-l+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 如果剩下的元素小于等于 gap，那么在上一轮已经排好了，跳过</span></span><br><span class="line">                <span class="keyword">if</span>(r &lt;= gap) <span class="keyword">continue</span>;</span><br><span class="line">                merge(nums,l,gap);</span><br><span class="line">            &#125;</span><br><span class="line">            gap *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> l1,<span class="keyword">int</span> gap)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">int</span> r1 = l1+gap<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> l2 = r1+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> r2 = min(maxIndex,l2+gap<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 双指针合并</span></span><br><span class="line">        <span class="keyword">int</span> i = l1, j = l2;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= r1 &amp;&amp; j &lt;= r2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; nums[j])&#123;</span><br><span class="line">                temp.push_back(nums[i++]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp.push_back(nums[j++]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= r1) temp.push_back(nums[i++]);        </span><br><span class="line">        <span class="keyword">while</span>(j &lt;= r2) temp.push_back(nums[j++]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pos = l1;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:temp)&#123;</span><br><span class="line">            nums[pos++] = x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快排的最核心的地方就是如何根据一个基准值将一个数组分成两部分。</p>
<p>yxc 版本</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * 将给定数组排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int整型一维数组 待排序的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] MySort (<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        qsort(arr, <span class="number">0</span> , arr.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = a[(l + r)/<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;i++; &#125; <span class="keyword">while</span>(a[i] &lt; x);</span><br><span class="line">            <span class="keyword">do</span> &#123;j--; &#125; <span class="keyword">while</span>(a[j] &gt; x);</span><br><span class="line">            <span class="keyword">if</span>(i &lt; j) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = a[i];</span><br><span class="line">                a[i] = a[j];</span><br><span class="line">                a[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时 i == j 或者 i &gt; j, a[j] &lt;= x (基准值)</span></span><br><span class="line">        <span class="comment">// 注意是 j</span></span><br><span class="line">        qsort(a, l, j);</span><br><span class="line">        qsort(a, j + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<ul>
<li><p><strong>《啊哈算法》的版本(双向指针)</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()&lt;=<span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        quick_sort(nums,<span class="number">0</span>,nums.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> base = nums[l];</span><br><span class="line">        <span class="keyword">int</span> i = l , j = r;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; nums[j]&gt;=base) j--;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; nums[i]&lt;=base) i++;</span><br><span class="line">            swap(nums[i],nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 基准值归位</span></span><br><span class="line">        <span class="comment">// 此时 i==j 并且 nums[i]&lt;base 因为是j指针先移动的</span></span><br><span class="line">        nums[l] = nums[i];</span><br><span class="line">        nums[i] = base;</span><br><span class="line">        quick_sort(nums,l,i<span class="number">-1</span>);</span><br><span class="line">        quick_sort(nums,i+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>《算法导论》的版本(同向指针)</strong></p>
<ul>
<li><strong>循环不变量法</strong><br>[l,i] 都小于等于x,<br>[i+1,j] 都大于x，<br>[j+1,r-1] 尚未处理，<br>nums[r] 是基准值。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()&lt;=<span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        quick_sort(nums,<span class="number">0</span>,nums.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> p = partion(nums,l,r);</span><br><span class="line">        quick_sort(nums,l,p<span class="number">-1</span>);</span><br><span class="line">        quick_sort(nums,p+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环不变量 [l,i] 都小于等于x,</span></span><br><span class="line">    <span class="comment">// [i+1,j] 都大于x</span></span><br><span class="line">    <span class="comment">// [j+1,r-1] 尚未处理</span></span><br><span class="line">    <span class="comment">// nums[r] 是基准值</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partion</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = nums[r];</span><br><span class="line">        <span class="keyword">int</span> i = l<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=l;j&lt;r;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]&lt;=x)&#123;</span><br><span class="line">            	i++;</span><br><span class="line">            	<span class="comment">// 此时nums[i]大于x,而nums[j]小于等于x</span></span><br><span class="line">            	<span class="comment">// 一交换 循环不变量保持</span></span><br><span class="line">                swap(nums[j],nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[i+<span class="number">1</span>],nums[r]);</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<ul>
<li><strong>随机化版本也很简单</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()&lt;=<span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">        randomed_quick_sort(nums,<span class="number">0</span>,nums.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">randomed_quick_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> i = rand() % (r - l + <span class="number">1</span>) + l; <span class="comment">// 随机选一个作为我们的主元 [0,r-l]+l = [l,r]</span></span><br><span class="line">        swap(nums[i],nums[r]);</span><br><span class="line">        <span class="keyword">int</span> p = partion(nums,l,r);</span><br><span class="line">        randomed_quick_sort(nums,l,p<span class="number">-1</span>);</span><br><span class="line">        randomed_quick_sort(nums,p+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环不变量 [l,i] 都小于等于x,</span></span><br><span class="line">    <span class="comment">// [i+1,j] 都大于x</span></span><br><span class="line">    <span class="comment">// [j+1,r-1] 尚未处理</span></span><br><span class="line">    <span class="comment">// nums[r] 是基准值</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partion</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = nums[r];</span><br><span class="line">        <span class="keyword">int</span> i = l<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=l;j&lt;r;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]&lt;=x)&#123;</span><br><span class="line">            	i++;</span><br><span class="line">            	<span class="comment">// 此时nums[i]大于x,而nums[j]小于等于x</span></span><br><span class="line">            	<span class="comment">// 一交换 循环不变量保持</span></span><br><span class="line">                swap(nums[j],nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[i+<span class="number">1</span>],nums[r]);</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> heap[<span class="number">50010</span>], size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> least = x;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">2</span>*x;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">2</span>*x+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=size &amp;&amp; heap[l]&lt;heap[least]) least = l;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;=size &amp;&amp; heap[r]&lt;heap[least]) least = r;</span><br><span class="line">        <span class="keyword">if</span>(least!=x)&#123;</span><br><span class="line">            swap(heap[x],heap[least]);</span><br><span class="line">            down(least);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 建堆 </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build_heap</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        size = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++) heap[i+<span class="number">1</span>] = nums[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=size/<span class="number">2</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">            down(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 依次取出堆顶，然后调整堆。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(size)&#123;</span><br><span class="line">            nums[pos++] = heap[<span class="number">1</span>];</span><br><span class="line">            heap[<span class="number">1</span>] = heap[size--];</span><br><span class="line">            down(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        build_heap(nums);</span><br><span class="line">        heap_sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>力扣的数据：$[-50000,50000]$，用一个线性函数将所有元素映射到区间$[0,100000]$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line">    <span class="keyword">int</span> bin[N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums)&#123;</span><br><span class="line">            bin[f(x)] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;bin[i];j++)&#123;</span><br><span class="line">                ans.push_back(g(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num + <span class="number">50000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id - <span class="number">50000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>


<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortByKth</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bin[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums)&#123;</span><br><span class="line">            bin[ f(x,k) ].push_back(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;bin[i].size();j++)&#123;</span><br><span class="line">                nums[pos++] = bin[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num % <span class="number">10</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> &amp;x:nums) x += <span class="number">50000</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">5</span>;k++)&#123;</span><br><span class="line">            sortByKth(nums,k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> &amp;x:nums) x -= <span class="number">50000</span>;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统-—堆和栈</title>
    <url>/2021/12/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E2%80%94%E5%A0%86%E5%92%8C%E6%A0%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="进程内存的段式划分"><a href="#进程内存的段式划分" class="headerlink" title="进程内存的段式划分"></a>进程内存的段式划分</h1><p>一个由C/C++编译的程序占用的内存分为以下几个部分<br>（从上到下，<strong>从内存高地址到内存低地址</strong>）<br>1、栈区（stack） — 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。（高地址）</p>
<p>2、堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表（当然还有其它的管理方式）。</p>
<p>3、全局区（静态区）（static）—全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。</p>
<p>4、文字常量区 — 常量字符串就是放在这里的。 程序结束后由系统释放。</p>
<p>5、程序代码区——存放函数体的二进制代码。（低地址）</p>
<p>下面是一个例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>; <span class="comment">//全局初始化区</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *p1; <span class="comment">//全局未初始化区</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> b; <span class="comment">//栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> s[] = <span class="string">&quot;abc&quot;</span>; <span class="comment">//s在栈,&quot;abc&quot;在常量区</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *p2; <span class="comment">//栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *p3 = <span class="string">&quot;123456&quot;</span>; <span class="comment">// 123456在常量区，p3在栈上。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c = <span class="number">0</span>; <span class="comment">//全局（静态）初始化区</span></span><br><span class="line"></span><br><span class="line">    p1 = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    p2 = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="number">20</span>); <span class="comment">// 分配的10和20字节的区域就在堆区</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h1><h2 id="申请方式"><a href="#申请方式" class="headerlink" title="申请方式"></a>申请方式</h2><p><strong>stack:</strong></p>
<p>由系统自动分配。<br>例如，声明在函数中一个局部变量 int b; 系统自动在栈中为b开辟空间</p>
<p><strong>heap:</strong></p>
<p>需要程序员自己申请，并指明大小，在c中malloc函数</p>
<p>如<code>p1 = (char *)malloc(10)</code>;</p>
<p>在C++中用new运算符, 如 <code>p2 = new char[10]</code>;</p>
<p>但是注意p1、p2本身是在栈中的。</p>
<h2 id="申请后系统的响应"><a href="#申请后系统的响应" class="headerlink" title="申请后系统的响应"></a>申请后系统的响应</h2><p><strong>栈：</strong>只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。</p>
<p><strong>堆：</strong>首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。<br>另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。</p>
<h2 id="申请大小的限制"><a href="#申请大小的限制" class="headerlink" title="申请大小的限制"></a>申请大小的限制</h2><p><strong>栈：</strong>栈是<strong>向低地址扩展</strong>的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），在Linux默认是8M。如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。</p>
<p><strong>堆：</strong>堆是<strong>向高地址扩展</strong>的数据结构，是不连续的内存区域。这是由于系统是用链表（还有其他综合手段）来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</p>
<h2 id="申请效率的比较"><a href="#申请效率的比较" class="headerlink" title="申请效率的比较"></a>申请效率的比较</h2><p><strong>栈</strong>由系统自动分配，速度较快。但程序员是无法控制的。</p>
<p><strong>堆</strong>是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一块内存，虽然用起来最不方便。但是速度快，也最灵活。</p>
<h2 id="堆和栈中的存储内容"><a href="#堆和栈中的存储内容" class="headerlink" title="堆和栈中的存储内容"></a>堆和栈中的存储内容</h2><p><strong>栈：</strong> 在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。</p>
<p><strong>堆：</strong>一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。</p>
<h2 id="堆和栈中的存储内容-1"><a href="#堆和栈中的存储内容-1" class="headerlink" title="堆和栈中的存储内容"></a>堆和栈中的存储内容</h2><p><code>char s1[] = “aaaaaaaaaaaaaaa”;</code></p>
<p><code>char *s2 = “bbbbbbbbbbbbbbbbb”;</code></p>
<p>aaaaaaaaaaa是在运行时刻赋值的；</p>
<p>而bbbbbbbbbbb是在编译时就确定的；</p>
<p>但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。</p>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">    char a &#x3D; 1;</span><br><span class="line"></span><br><span class="line">    char c[] &#x3D; &quot;1234567890&quot;;</span><br><span class="line"></span><br><span class="line">    char *p &#x3D; &quot;1234567890&quot;;</span><br><span class="line"></span><br><span class="line">    a &#x3D; c[1];</span><br><span class="line"></span><br><span class="line">    a &#x3D; p[1];</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的汇编代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10: a &#x3D; c[1];</span><br><span class="line"></span><br><span class="line">00401067 8A 4D F1 mov cl,byte ptr [ebp-0Fh]</span><br><span class="line"></span><br><span class="line">0040106A 88 4D FC mov byte ptr [ebp-4],cl</span><br><span class="line"></span><br><span class="line">11: a &#x3D; p[1];</span><br><span class="line"></span><br><span class="line">0040106D 8B 55 EC mov edx,dword ptr [ebp-14h]</span><br><span class="line"></span><br><span class="line">00401070 8A 42 01 mov al,byte ptr [edx+1]</span><br><span class="line"></span><br><span class="line">00401073 88 45 FC mov byte ptr [ebp-4],al</span><br></pre></td></tr></table></figure>



<p>第一种在读取时直接就把字符串中的元素读到寄存器cl中，而第二种则要先把指针值读到edx中，再根据edx读取字符串，显然慢了。</p>
<h1 id="堆的动态管理"><a href="#堆的动态管理" class="headerlink" title="堆的动态管理"></a>堆的动态管理</h1><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>堆是一块巨大的内存空间，常常占据着整个<strong>虚拟空间</strong>的绝大部分。在这片空间里，程序可以请求一块连续内存，并自由地使用，这块内存在程序主动放弃之前都会一直保持有效。下面是申请空间最简单的例子。　</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">free</span> (p)&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>进程的内存管理并没有交给操作系统内核管理</strong>，这样做性能较差，因为每次程序申请或者释放对空间都要进行系统调用。我们知道系统调用的性能开销是很大的，当程序对堆的操作比较频繁时，这样做的结果是会严重影响程序性能的。比较好的做法就是程序向操作系统申请一块适当大小的堆空间，然后由程序自己管理这块空间，而具体来讲，<strong>管理着堆空间分配往往是程序的运行库。</strong></p>
<blockquote>
<p>运行库相当于向操作系统批发了一块较大的堆空间，然后“零售”给程序用。当全部“售完”或程序有大量的内存需求时，在根据实际需求向操作系统“进货”。当然运行库在向零售堆空间时，必须管理它批发来的堆空间，不能把同一块地址出售两次，导致地址的冲突。我们首先来了解运行库是怎么向操作系统批发内存的。我们以linux为例。</p>
</blockquote>
<h2 id="Linux进程堆管理"><a href="#Linux进程堆管理" class="headerlink" title="Linux进程堆管理"></a>Linux进程堆管理</h2><p>　进程地址空间中，除了可执行文件、共享库和栈之外，剩余的未分配的空间都可以被用来作为堆空间。Linux下的进程管理稍微有些复杂，因为它提供了两种堆分配方式，即两个系统调用：一个是brk()系统调用，另外一个是mmap()。brk()的C语言形式声明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">brk</span><span class="params">(<span class="keyword">void</span>* end_data_segment)</span></span></span><br></pre></td></tr></table></figure>

<p>　　</p>
<p><strong>brk()的作用实际上就是设置进程数据段的结束地址，即它可以扩大或者缩小数据段</strong>（Linux下数据段和BSS合并在一起统称为数据段）。如果我们将数据段的结束地址向高地址移动，那么扩大的那部分空间就可以被我们使用，把这块空间拿来作为堆空间是最常见的做法之一。Giblic中还有一个函数叫做sbrk，它的功能与brk类似，只不过参数和返回值略有不同。sbrk以一个增量作为参数，即需要增加（负数为减少）的空间大小，返回值是增加（或减少）后数据段结束地址，这个函数实际上是对brk系统调用的包装，它通过brk()实现的。</p>
<p>　　mmap()的作用和Windows系统下的VirtualAlloc很相似，它的作用就是向操作系统申请一段虚拟地址空间，当然这块虚拟地址空间可以映射到某个文件（这也是系统调用的最初的作用），当它不将地址空间映射到某个文件时，我们又称这块空间为匿名空间，匿名空间就可以拿来做堆空间。它的声明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> *mmap&#123;<span class="keyword">void</span> *start,  <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd,<span class="keyword">off_t</span> offset);</span><br></pre></td></tr></table></figure>

<p>　　mmap的前两个参数分别用于指定需要申请的空间的起始地址和长度，如果起始地址设置为0，那么linux系统会自动挑选合适的起始地址。prot/flags这两个参数用于设置申请的空间的权限（可读，可写，可执行）以及映像类型（文件映射、匿名空间等），最后两个参数用于文件映射时指定文件描述符和文件偏移的，我们在这里并不关心它们。</p>
<p><strong>glibc的malloc函数是这样处理用户空间请求的</strong></p>
<ol>
<li>对于小于128kb的请求来说，它会在现有的堆空间里面，按照堆分配算法为它分配一块空间并返回；</li>
<li>对于大于128KB的请求来说，它会使用mmap()函数为它分配一块匿名空间，然后再这个匿名空间中为用户分配空间。</li>
</ol>
<p>当然我们直接使用mmap也可以轻而易举地实现malloc函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> nbytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ret = mmap(<span class="number">0</span>, nbytes, PROT_READ | PROT_WRITE,</span><br><span class="line">                               MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == MAP_FAILED)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>由于mmap()函数与VirtualAlloc()类似，它们都是系统虚拟空间申请函数，它们申请的空间起始地址和大小都必须是系统页的大小的整数倍。</p>
<h2 id="堆空间的管理算法"><a href="#堆空间的管理算法" class="headerlink" title="堆空间的管理算法"></a>堆空间的管理算法</h2><p>在动态分配内存后，那么我们就要来思考如何管理这块大的内存。主要有三种方法，空闲链表和位图法以及对象池。</p>
<h3 id="空闲链表"><a href="#空闲链表" class="headerlink" title="空闲链表"></a>空闲链表</h3><p>空闲链表（Free List)的方法实际上就是把堆中各个空闲的块按照链表的方式连接起来，当用户请求一块空间时，可以遍历整个链表，直到找到合适大小的块并且将它拆分；当用户释放空间时将它合并到空闲链表中。</p>
<p>空闲链表是这样一种结构，在堆里的每一个空闲空间的开头（或结尾）有一个头，头结构里记录了上一个和下一个空闲块的地址，也就是说，所有的空闲块形成了一个链表。如下所示：</p>
<p><img src="/2021/12/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E2%80%94%E5%A0%86%E5%92%8C%E6%A0%88/list.png"></p>
<p>当按照地址顺序在链表中存放进程和空闲区时，有几种算法可以用来为创建的进程（从磁盘换入的已存在的内存）分配内存。当存储管理器知道要为进程分配多大的内存时，有如下几种算法。</p>
<ol>
<li><strong>首次适配（first fit)算法</strong></li>
</ol>
<p>存储管理器沿着段链表进行搜索，直到找到一个足够大的空闲区，除非空闲区大小和要分配的空间大小正好一样，否则将该空闲去分为两部分，一部分供进程使用，另一部分形成新的空闲区。首次适配算法是一种速度很快的算法，因为它尽可能少地搜索链表节点。</p>
<ol start="2">
<li><strong>下次适配（next fit）算法</strong></li>
</ol>
<p>它的工作方式和首次适配算法不同，不同点是每次找到合适的区间都记录当时的位置。以便在下次寻访空闲区时从上次结束的地方开始搜索，而不是像首次适配算法那样每次从头开始。下次适配算法的性能略低于首次适配算法。</p>
<ol start="3">
<li><strong>最佳适配（best fit）算法</strong></li>
</ol>
<p>最佳适配算法搜索整个链表，找出能够容纳进程的最小的空闲区。最佳适配算法师徒找出最接近实际需要的空闲区，以最好地匹配请求和可用空闲区，而不是先拆分一个以后可能会用到的最大的空闲区。但是它的缺点是产生较多的业内碎片。</p>
<ol start="4">
<li><strong>最差适配（worst fit）算法</strong></li>
</ol>
<p>总是分配最大的可用空闲区。</p>
<ol start="5">
<li><strong>快速适配（quick fit）算法</strong></li>
</ol>
<p>它为那些常用大小的空闲区维护单独的链表。例如，有一个n项的链表，该表的第一项指向大小为4KB的空闲区链表表头的指针，第二项是指向大小为8KB的空闲区链表表头的指针，第三项是指向大小为12KB的空闲区链表表头的指针，以此类推。像21KB这样的空闲区即可以放在20KB的链表中也可以放在一个专门存放大小比较特别的空闲区的链表中。</p>
<p>快速适配算法寻找一个指定大小的空闲区是十分快速的，但它和所有将空闲区按大小排序的方案一样都有一个共同的缺点，即在一个进程终止或被换出时，寻找它的邻块，查看是否可以合并的过程是非常耗时的。如果不进行合并，内存将会很快分裂出大量的进程无法利用的小空闲区。</p>
<h3 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h3><p>位图的核心思想是<strong>将整个堆划分为大量的块</strong>，<strong>每个块的大小相同</strong>。</p>
<p>当用户请求内存的时候，总是分配整数个块的空间给用户，第一个块我们称之为已分配区域的头，其余的称为已分配区域的主体。而我们可以使用一个整数数组来记录块的使用情况。由于每个块只有头/主体/空闲三种状态，因此仅仅需要两位即可表示一个块，因此称为位图。假设堆的大小为1MB，那么让一个块大小为128字节，那么总共就有1M/128=8k个块，可以用8k/（32/2）=512个int来存储。这有512个int的数组就是一个位图，其中每两位代表一个块。当用户请求300字节的内存时，堆分配给用户3个块，并将相应的位图的相应位置标记为头或躯体。</p>
<p><img src="/2021/12/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E2%80%94%E5%A0%86%E5%92%8C%E6%A0%88/map.png"></p>
<p>这个堆分配了3片内存，分别有2/4/1个块，用虚线标出。其对应的位图将是：</p>
<p>(HIGH) 11 00 00 10 10 10 11 00 00 00 00 00 00 00 10 11 (LOW）</p>
<p>其中11表示H(头），10表示主体（Body），00表示空闲（Free）。</p>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>以上介绍的堆管理方法是最为基本的两种，实际上在一些场合，被分配对象的大小是较为固定的几个值，这时候我们可以针对这样的特征设计一个更为高效的堆算法，称为对象池。<br>对象池的思路很简单，如果每一次分配的空间大小都一样，那么就可以按照这个每次请求分配的大小作为一个单位，把整个堆空间划分为大量的小块，每次请求的时候只需要找到一个小块就可以了。<br>对象池的管理方法可以采用空闲链表，也可以采用位图，与它们的区别仅仅在于它假定了每次请求的都是一个固定的大小，因此实现起来比较容易。由于每次总是只请求一个单位的内存，因此请求得到满足的速度非常快，无须查找一个足够大的空间。</p>
<h3 id="综合运用多种算法"><a href="#综合运用多种算法" class="headerlink" title="综合运用多种算法"></a>综合运用多种算法</h3><p>实际上很多实际应用中，<strong>堆的分配算法往往是采用多种算法复合而成</strong>。</p>
<p>比如对于glibc来说，</p>
<p>它对于小于64字节的空间申请时采用类似于对象池的方法；</p>
<p>对于大于512字节的空间申请采用的是最佳适配算法；</p>
<p>对于大于64字节而小于512字节的，它会根据情况采用上述方法中的折中策略；</p>
<p>对于大于128KB的申请，它会使用mmap机制直接向操作系统申请空间。                                                           </p>
<blockquote>
<p>参考链接</p>
<p><a href="https://www.cnblogs.com/vincently/p/4671739.html">堆和动态内存管理</a></p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>敖丙的文章链接</title>
    <url>/2021/12/01/%E6%95%96%E4%B8%99%E7%9A%84%E6%96%87%E7%AB%A0%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我会从下图中的知识点去写这个系列，很多细节的点，可能想得不是很完善，大家可以去<a href="#%E5%85%AC%E4%BC%97%E5%8F%B7">【公众号】</a>获取或者加我<a href="#%E5%BE%AE%E4%BF%A1">【微信】</a>提意见(别忘记<strong>Star</strong>哟)。</p>
<p>原创文章每周最少两篇，公众号首发文章，<a href="https://space.bilibili.com/130763764">【B站】</a>首发视频，比博客早一到两篇。</p>
<p align="center">
    <a href="https://github.com/AobingJava/JavaFamily" target="_blank">
        <img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g98588lrx2j305k05kgm0.jpg" width=""/>
    </a>
</p>



<p align="center">
  <a href="#微信"><img src="https://img.shields.io/badge/weChat-微信群-blue.svg" alt="微信群"></a>
  <a href="#公众号"><img src="https://img.shields.io/badge/%E5%85%AC%E4%BC%97%E5%8F%B7-三太子敖丙-lightgrey.svg" alt="公众号"></a>
  <a href="https://space.bilibili.com/130763764"><img src="https://img.shields.io/badge/bilibili-哔哩哔哩-critical" alt="投稿"></a>
  <a href="https://www.toutiao.com/c/user/3270187212/#mid=1557137040287746"><img src="https://img.shields.io/badge/toutiao-头条-9cf" alt="投稿"></a>
  <a href="https://juejin.im/user/59b416065188257e671b670a"><img src="https://img.shields.io/badge/juejin-掘金-blue.svg" alt="公众号"></a>
  <a href="https://www.zhihu.com/people/aobingJava/activities"><img src="https://img.shields.io/badge/zhihu-知乎-informational" alt="投稿"></a>
  <a href="https://me.csdn.net/qq_35190492"><img src="https://img.shields.io/badge/csdn-CSDN-red.svg" alt="投稿"></a>
  <a href="https://my.oschina.net/javaFamily"><img src="https://img.shields.io/badge/oschina-开源中国-green" alt="投稿"></a>
  <a href="https://www.cnblogs.com/aobing/"><img src="https://img.shields.io/badge/cnblogs-博客园-important.svg" alt="投稿"></a>
</p>


<p><img src="/%E6%95%96%E4%B8%99%E7%9A%84%E6%96%87%E7%AB%A0%E9%93%BE%E6%8E%A5/0082zybply1gcb2u3keh9j30p02j4h2r.jpg"><br><img src="/%E6%95%96%E4%B8%99%E7%9A%84%E6%96%87%E7%AB%A0%E9%93%BE%E6%8E%A5/007S8ZIlgy1gf8flovpg1j30u07l7hdx.jpg"></p>
<h4 id="后端面试点合集"><a href="#后端面试点合集" class="headerlink" title="后端面试点合集"></a><a href="https://mp.weixin.qq.com/s/gBr3UfC1HRcw4U-ZMmtRaQ">后端面试点合集</a></h4><h4 id="脑图在线编辑地址"><a href="#脑图在线编辑地址" class="headerlink" title="脑图在线编辑地址"></a><a href="https://www.processon.com/view/5e86b713e4b0bf3ebcf4e376">脑图在线编辑地址</a></h4><h1 id="目录-善用Ctrl-F"><a href="#目录-善用Ctrl-F" class="headerlink" title="目录(善用Ctrl+F)"></a>目录(善用Ctrl+F)</h1><p><strong>注 : 没链接的是还没写(耐心等待更新吧)</strong></p>
<ul>
<li><p>学习路线</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/co6ZiALBCUHxc-8SpcKxPw">后端技术学些啥</a></li>
<li><a href="https://mp.weixin.qq.com/s/mYfVAo8-jkPFwhbqDZyQzw">从毕业到技术专家我做了啥</a></li>
<li><a href="https://mp.weixin.qq.com/s/z2S1EjWQDwKm5Ud36IenNw">秒杀系统设计</a></li>
<li><a href="https://mp.weixin.qq.com/s/RRHN8t017ofOvb4nvlCStg">全栈秒杀系统设计</a></li>
<li><a href="https://mp.weixin.qq.com/s/KWb3POodisbOEsQVblsoGw">秒杀系统2.0</a></li>
</ul>
</li>
<li><p>Java基础核心串讲</p>
<ul>
<li><p>Java基础知识</p>
<ul>
<li><p><a href="https://mp.weixin.qq.com/s/-xFSHf7Gz3FUcafTJUIGWQ">Java基础面试16问</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/FgBCop2zFfcX5ZszE0NoCQ">零拷贝</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/DEd0VY3dhR6B0hjQSEtB7Q">一次相亲经历，我彻底搞懂了什么叫阻塞非阻塞，同步异步</a></p>
</li>
</ul>
</li>
<li><p>计算机操作系统与Linux</p>
<ul>
<li><p><a href="https://mp.weixin.qq.com/s/dP8AJbvGgvYIXDy3zeXCRg">52图初探Linux通用知识</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/j2msue1Hjcwd9z1U2p0TDQ">图解 | 计算机文件系统</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/11MRrxmiyZybTUbjRDRubQ">浏览器的秘密藏在这31张图里</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/24vBHgtw5efC9V9yYqknNg">大厂面试Linux就这5个问题</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/7iQ5jO_qfYbwKdM21qywYg">Linux 内核 vs Windows 内核</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/7bSwKiPmtJbs7FtRWZZqpA">学习linux命令，看这篇2w多字的命令详解就够了</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/TbIPlBtkK_zCyt54cCX8dw">Linux IO 模型</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/eWHQ8co0jF_a26Xz8ZQLjg">带宽、延时、吞吐率、PPS 这些都是啥？</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/FaHKGRI69TqDj0AJtNiVoA">进程和线程基础知识全家桶，30 张图一套带走</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/oexktPKDULqcZQeplrFunQ">20 张图揭开内存管理的迷雾</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/59xyIj1nIFp2TtkKFYnR-g">看完这篇操作系统，和面试官扯皮就没问题了。</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/mblyh6XrLj1bCwL0Evs-Vg">进程间通信</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/CGqy0j5WvarN6mTmYB8vSA">进程之间究竟有哪些通信方式？</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/fKHOf_CzG8HYXHlg54V_rg">键盘敲入 A 字母时，操作系统期间发生了什么…</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/UT2JrfpkA5OUC9fJJ_MirQ">一口气搞懂「文件系统」，就靠这 25 张图了</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/x-AZQO5uiuu5svIvScotzA">「网络IO套路」当时就靠它追到女友</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/hjywA21UrvZSzdgvAr6fQA">10 张图打开 CPU 缓存一致性的大门</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/TJghsMRqkzBIsoHjGiEwFw">敖丙说了这么多次 I/O，可你知道其中的原理么？</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/EVequWGVMWV5Ki2llFzdHg">迄今为止把同步/异步/阻塞/非阻塞/BIO/NIO/AIO讲的这么清楚的好文章（快快珍藏）</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/px6-YnPEUCEqYIp_YHhDzg">原来 8 张图，就能学废 Reactor 和 Proactor</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/ws6bgcv6dKIIJDwYYliMAg">2.5w字 + 36 张图+一周时间：爆肝操作系统面试题</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/uM1ZNT8UwfvhqoscK8FJiQ">计算机时间到底是怎么来的？</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/CMWlDywI1zbgJSoeGTBmuw">IO 多路复用</a></p>
</li>
</ul>
</li>
<li><p>计算机网络  </p>
<ul>
<li><p><a href="https://mp.weixin.qq.com/s/WfcozFAdXbOJ0EIcZEfLVg">计算机网络</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/3FTuMZaUrT9Vw-ZScJkQbg">熬夜整理的20道计算机网络面试题</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/drPVkRbCsDIlX6Ls2pDmqA">什么是单点登录(SSO)</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/I6BLwbIpfGEJnxjDcPXc1A">键入网址后，期间发生了什么？</a></p>
</li>
<li><p>HTTP/HTTPS</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/AK1Pb9rx0q5Hf8dq6HNOhw">图解HTTP协议</a></li>
<li><a href="https://mp.weixin.qq.com/s/21JaXwdfSjItj5SgOwhapg">全网最透彻HTTPS（面试常问）</a></li>
<li><a href="https://mp.weixin.qq.com/s/ljtDM1d2KgtxAAhwUFSHkg">一文领略 HTTP 的前世今生</a></li>
<li><a href="https://mp.weixin.qq.com/s/amOya0M00LwpL5kCS96Y6w">硬核！30 张图解 HTTP 常见的面试题</a></li>
<li><a href="https://mp.weixin.qq.com/s/t7ZYT6wBBbFYVBPOSztpRg">面试 HTTP ，99% 的面试官都爱问这些问题</a></li>
<li><a href="https://mp.weixin.qq.com/s/Mi3zM-oyMoxxdzSlSnHpQQ">中间人攻击</a></li>
</ul>
</li>
<li><p>TCP/IP    </p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/LUtk6u_zv0w8g8GIGWEuCw">万字长文 | 23 个问题 TCP 疑难杂症全解析</a></li>
<li><a href="https://mp.weixin.qq.com/s/jTDU-zxP1INTYLpGLypjXQ">实战！敖丙用“大白鲨”让你看见 TCP</a></li>
<li><a href="https://mp.weixin.qq.com/s/ytV7RZSyFXyvPW_lKhv8hw">面试官：换人！他连 TCP 这几个参数都不懂</a></li>
<li><a href="https://mp.weixin.qq.com/s/lkX2Mb2aCj8ugOaRmVVBqw">TCP/IP 基础知识总结</a></li>
<li><a href="https://mp.weixin.qq.com/s/tRXlq1hErqKQLMMLcxoXvg">TCP 半连接队列和全连接队列满了会发生什么？又该如何应对？</a></li>
<li><a href="https://mp.weixin.qq.com/s/NL7Jzh0lYoA395yzaGxBHw">跟着动画学习TCP三次握手和四次挥手</a></li>
<li><a href="https://mp.weixin.qq.com/s/rX3A_FA19n4pI9HicIEsXg">敖丙用近 40 张图解被问千百遍的 TCP 三次握手和四次挥手面试题</a></li>
<li><a href="https://mp.weixin.qq.com/s/HjOUsKn8eLfDogbBX3hPnA">你还在为 TCP 重传、滑动窗口、流量控制、拥塞控制发愁吗？看完图解就不愁了</a></li>
<li><a href="https://mp.weixin.qq.com/s/p9oA9YTZLoXVooUOSNQCMg">IP 基础知识“全家桶”，敖丙45 张图一套带走你</a></li>
<li><a href="https://mp.weixin.qq.com/s/3KF0IxLum8EOtcF0ZNIiPA">敖丙听说你 ping 用的很 6 ？给我图解一下 ping 的工作原理！</a></li>
<li><a href="https://mp.weixin.qq.com/s/BK2H7JQIo6zOrXYg9RcbeA">一文搞定 UDP 和 TCP 高频面试题！</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>7种常见的设计模式和使用场景</p>
<ul>
<li><p><a href="https://mp.weixin.qq.com/s/dW0L-PoBeTFHhD29HJO0BQ">单例模式</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/j42vn-A_rdWZP3aixXB8Ag">工厂模式</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/b8xa3o4fKDme2438oJTakw">流程引擎</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/h7iEyxgN34FPn191S8qUpA">建造者模式</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/fORmbucHuPVMS2z3q-mV3A">原型模式</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/l9EdvpAMukIDOgaN7x3b4w">责任链模式</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/_hVGgJxefoVXFHFNXC-U6A">观察者模式</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/AFbt7VJMASenD2S8KbPKJQ">策略模式</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/HOnQf-S-w6A19tGnoIXBrg">策略模式2.0</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/oGm4ET-NDp4BSVi0p2MZxA">模板方法</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/QHgg4CcU6VlA0gtzzQ_JLQ">迭代器模式</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/dtmeTLsML6TYM8F8ch2FGQ">命令模式&amp;中介者模式</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/a1kVL71OlUwZJrsyCE0I-A">对象池模式&amp;解释器模式</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/lNw1yjn_xMOLpzbunaS10A">代理模式</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/O0sIOyE2rgTPyj54_QRx_g">使用Java8改造后的模板方法模式真的是yyds</a></p>
</li>
</ul>
</li>
<li><p>Java必会基础与新版本特性</p>
<ul>
<li><p><a href="https://mp.weixin.qq.com/s/U5FkL9zyzr0PkAp8MJJ8BQ">枚举</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/Du2huBEkI7IR3noPeK_67g">从String中移除空白字符的多种方式！？差别竟然这么大！</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/6nJ-6cDLW6TfysWV5ZB3Iw">双亲委派原则</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/-NQoKpBTXwGUxd2hUbCU2Q">Java 16 新特征，真香！</a></p>
</li>
</ul>
</li>
<li><p>线上问题排查</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/8YBJn8x7Sf9dai9jNkX6Tg">线上问题如何排查？</a></li>
<li><a href="https://mp.weixin.qq.com/s/TnLl2OW9XJLSZihcpgP7VQ">RT 过长，排查思路</a>  </li>
</ul>
</li>
</ul>
</li>
<li><p>集合框架</p>
<ul>
<li><p><a href="https://mp.weixin.qq.com/s/bVOSat47L0Hskfx9akAN6Q">Java 集合框架看这一篇就够了</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/eSCVJclB-IaJYkPKsWSkRA">Java 集合中「堆」是啥？</a></p>
</li>
<li><p>HashMap</p>
<ul>
<li><p><a href="https://mp.weixin.qq.com/s/0Gf2DzuzgEx0i3mHVvhKNQ">HashMap</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/VtIpj-uuxFj5Bf6TmTJMTw">面试官：HashMap 为什么线程不安全？</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/ktre8-C-cP_2HZxVW5fomQ">万万没想到，HashMap默认容量的选择，竟然背后有这么多思考！？</a></p>
</li>
</ul>
</li>
<li><p>ConcurrentHashMap</p>
<ul>
<li><p><a href="https://mp.weixin.qq.com/s/AixdbEiXf3KfE724kg2YIw">ConcurrentHashMap &amp; Hashtable（文末送书）</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/My4P_BBXDnAGX1gh630ZKw">我就知道面试官接下来要问我 ConcurrentHashMap 底层原理了</a></p>
</li>
</ul>
</li>
<li><p>ArrayList</p>
<ul>
<li><p><a href="https://mp.weixin.qq.com/s/WoGclm7SsbURGigI3Mwr3w">ArrayList</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/3PNWmtS-bEZgZjd9wyMiDA">ArrayList源码解析，老哥，来一起复习一哈？</a></p>
</li>
</ul>
</li>
<li><p>Vector  </p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/0cMrE87iUxLBw_qTBMYMgA">面试官问我同步容器（如Vector）的所有操作一定是线程安全的吗？我懵了！</a></li>
</ul>
</li>
</ul>
</li>
<li><p>深入浅出JVM</p>
<ul>
<li><p>JVM内存模型</p>
<ul>
<li><p><a href="https://mp.weixin.qq.com/s/fit90VdZUa2pG9lbET0i7w">【JVM故事】了解JVM的结构，好在面试时吹牛</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/Wws24Fhg1nH4dHvtcFYi2g">Java堆内存是线程共享的！面试官：你确定吗？</a></p>
</li>
</ul>
</li>
<li><p>性能调优、线上问题排查</p>
<ul>
<li><p><a href="https://mp.weixin.qq.com/s/P8s3kuceBNovUP5adXpFCQ">线上服务的FGC问题排查，看这篇就够了！</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/yutHXOi6Xl3-Qn91Pvg9wA">记一次大促期间JVM堆外内存泄漏故障排查记录</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/7XGD-Z3wrThv5HyoK3B8AQ">怎么排查堆内存溢出啊？</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/roEMz-5tzBZvGxbjq8NhOQ">CPU100%，排查</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/LRx9tLtx1tficWPvUWUTuQ">排查YGC问题</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/nWghy4McYx6Ix3QPSLSmkQ">CPU飙高排查</a></p>
</li>
</ul>
</li>
<li><p>类加载机制详解</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/eHqFONXXNc-LD4ugaKM6UA">JVM必问知识点:类加载过程</a></li>
</ul>
</li>
<li><p>垃圾回收机制</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/_AKQs-xXDHlk84HbwKUzOw">看完这篇垃圾回收，和面试官扯皮没问题了</a></li>
</ul>
</li>
<li><p>垃圾回收器、垃圾回收算法</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/nY6vL5MlUXY1lfnIvNHMnw">垃圾回收底层原理</a></li>
</ul>
</li>
</ul>
</li>
<li><p>并发与多线程</p>
<ul>
<li>多线程基础知识<ul>
<li><p><a href="https://mp.weixin.qq.com/s/GDno-X1N8zc98h9MZ8_KoA">可重入锁</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/TsENp5ygFdE0_REgz5Y3Ew">(并发问题的根源到底是什么？)</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/g_eWT05_38AURchMIvNSnA">敖丙稳住了多线程翻车的现场</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/NZAJWBiFvGzCZXjr0KC9Dw">2w字 + 40张图带你参透并发编程！</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/XCR93HSm_E0c3KDcmZk3cA">图解Java中那18 把锁</a></p>
</li>
</ul>
</li>
<li>常见关键字  <ul>
<li><p><a href="https://mp.weixin.qq.com/s/2ka1cDTRyjsAGk_-ii4ngw">死磕Synchronized源码</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/Oa3tcfAFO9IgsbE22C5TEg">面试官想到，一个Volatile，敖丙都能吹半小时</a></p>
</li>
</ul>
</li>
<li>多线程锁机制<ul>
<li><p><a href="https://mp.weixin.qq.com/s/WtAdXvaRuBZ-SXayIKu1mA">乐观锁、悲观锁</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/6QrQ0TZVqSQq26Rms0_mvA">互斥锁、自旋锁、读写锁、悲观锁、乐观锁的应用场景</a></p>
</li>
</ul>
</li>
<li>线程池知识点<ul>
<li><a href="https://mp.weixin.qq.com/s/TQGtNpPiTypeKd5kUnfxEw">记一次线程池引发的故障 排查下来是三歪的锅</a></li>
<li><a href="https://mp.weixin.qq.com/s/NDOx94yY06OnHjrYq2lVYw">深入线程池，连环17问</a></li>
</ul>
</li>
<li>常见的JUC工具类<ul>
<li><p><a href="https://mp.weixin.qq.com/s/hB5ncpe7_tVovQj1sNlDRA">AQS</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/trsjgUFRrz40Simq2VKxTA">我画了35张图就是为了让你深入 AQS</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/iNz6sTen2CSOdLE0j7qu9A">1.5w字，30图带你彻底掌握 AQS！</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/Gf4MiHPz8DynY80UmwH04Q">TheadLocal 引起的内存泄露故障分析</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/TDw7GnzDw5FK3RWwkIzzZA">终于有人把 CountDownLatch，CyclicBarrier，Semaphore 说明白了!</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/LzkZXPtLW2dqPoz3kh3pBQ">Java面试必问：ThreadLocal</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/gjfeayR36vDAr3FAVd4w4g">StampedLock</a></p>
</li>
</ul>
</li>
<li>多线程经典面试题<ul>
<li><p><a href="https://mp.weixin.qq.com/s/PrUa0tFyu3UZllP2FRDyVA">【面试】如果把线程当作一个人来对待，所有问题都瞬间明白了</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/cdHfTTvMpH60SwG2bjTMBw">Java 并发进阶常见面试题总结</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/WDeewsvWUEBIuabvVVhweA">如果你这样回答“什么是线程安全”，面试官都会对你刮目相看（建议珍藏）</a></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>常用工具集</p>
<ul>
<li><p>JVM问题排查工具-JMC</p>
</li>
<li><p>IDEA开发神器</p>
</li>
<li><p>线上调试神器-btrace</p>
</li>
<li><p>Git原理与工作流</p>
</li>
<li><p>Linux常用分析工具</p>
</li>
</ul>
</li>
<li><p>数据结构与算法</p>
<ul>
<li><p>从二叉搜索树到B+树</p>
</li>
<li><p>经典问题之字符串</p>
</li>
<li><p>经典问题之TOPK</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/Yx3uRVGFYikx8gm-oi-0vg">最大公共子串</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/1dG8Dk7nZeIGHQ0Hp8gq7Q">动态规划</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/B9MVq1617YgtgBtwvhVg-Q">大厂面试爱问的「调度算法」，20 张图一举拿下</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/-8JFh5iLr88XA4AJ9mMf6g">图解红黑树</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/_DJgsdhY4drJyEPN9xZX6Q">面试必备 | 不可不会的反转链表</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/sPIE54UmvNgINZIATQKyew">红黑树【图解】</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/pWXxg9O5BwcC9Zi68PT3TQ">算法学习工具网站</a></p>
</li>
</ul>
</li>
<li><p>必会框架</p>
<ul>
<li>Spring全家桶以及源码分析<ul>
<li><p><a href="https://mp.weixin.qq.com/s/WpRSitDqtgOuU9GnI1-HDw">一分钟带你玩转 Spring IoC</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/NXZp8a3n-ssnC6Y1Hy9lzw">AOP 面试造火箭事件始末</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/qlAvW10TRNVak1oJyHO39Q">SpringAOP面试题</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/IglQITCkmx7Lpz60QOW7HA">Spring事务传播行为</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/5mwkgJB7GyLdKDgzijyvXw">什么是 Spring 循环依赖？</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/wcK2qsZxKDJTLIGqEIyaNg">Spring常见问题总结（补充版）</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/OMlwHHnGcN7iZ8lerUvW7w">15个经典的Spring面试常见问题</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/6YhpbuhdTX9BM_OimoW8MA">敖丙说精通字符串，面试官竟然问Java中的String有没有长度限制！</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/kS0K5P4FdF3v-fiIjGIvvQ">Spring中的循环依赖</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/ut3mRwhfqXNjrBtTmI0oWg">Spring容器启动流程</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/u29hMRkfTj_1RHNSukDtEw">Spring循环依赖</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/JcHt99SAbNIlY063rmylpA">我是如何在面试别人Spring事务时“套路”对方的</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/4z9V4-k2Whqiz69gXy5iMQ">SpringIOC 面试题（下）</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/SH4laewpIsio66MUJFLTyg">SpringIOC 面试题（上）</a></p>
</li>
</ul>
</li>
<li>SpringCloud <ul>
<li><a href="https://mp.weixin.qq.com/s/MJrahcDXwxgDr5zBdO3XWw">外行人都能看懂的SpringCloud，错过了血亏！</a></li>
<li><a href="https://mp.weixin.qq.com/s/pGSx8eKFH3YnUos3SM2ITw">20000 字的 Spring Cloud 总结</a></li>
</ul>
</li>
<li>分布式框架基石-RPC<ul>
<li>Dubbo<ul>
<li><a href="https://mp.weixin.qq.com/s/FPbu8rFOHyTGROIV8XJeTA">Dubbo基础</a></li>
<li><a href="https://mp.weixin.qq.com/s/ISiN06QynyE2pPtX3cGQ9w">Dubbo的服务暴露过程</a></li>
<li><a href="https://mp.weixin.qq.com/s/9oDy1OPcfDaEhKD4eNUdOA">Dubbo的服务引用过程</a></li>
<li><a href="https://mp.weixin.qq.com/s/oNR9v_ID2oAlEvDI93hRcw">Dubbo服务调用过程</a></li>
<li><a href="https://mp.weixin.qq.com/s/gwWOsdQGEN0t2GJVMQQexw">Dubbo的SPI机制是啥？</a></li>
<li><a href="https://mp.weixin.qq.com/s/-IkHNAM4B0R_j50LkQunig">Dubbo集群容错负载均衡</a></li>
<li><a href="https://mp.weixin.qq.com/s/FwL6qArqYc2ENymXk1eZFQ">Dubbo面试题</a></li>
<li><a href="https://mp.weixin.qq.com/s/2qSA6aJn6KRXrATVE44k0w">1w+字的 Dubbo 面试题/知识点总结！（2021 最新版）</a></li>
</ul>
</li>
<li>RPC实践<ul>
<li><a href="https://mp.weixin.qq.com/s/pkWkD1VhMxhZPRrybLcQjA">敖丙RPC的超时设置，一不小心搞了线上事故</a></li>
<li><a href="https://mp.weixin.qq.com/s/_5YMfQK1tmYbmRMldBPlaQ">敖丙找出Dubbo源码BUG，三歪夸了我一天</a></li>
</ul>
</li>
<li>Netty<ul>
<li><a href="https://mp.weixin.qq.com/s/I9PGsWo7-ykGf2diKklGtA">高性能NIO框架-Netty</a></li>
<li><a href="https://mp.weixin.qq.com/s/eJ-dAtOYsxylGL7pBv7VVA">Netty常见面试题总结</a></li>
</ul>
</li>
</ul>
</li>
<li>ORM框架Mybatis源码分析</li>
<li>Zookeeper<ul>
<li><p><a href="https://mp.weixin.qq.com/s/gphDLJMO3QcRoN3zkco4EA">什么是Zookeeper</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/ZqQHWLfVD1Rz1agmH3LWrg">分布式锁之Zookeeper</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/k0zAExTvMsrugCaNJxs7hQ">Zookeeper之ZAB协议</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/YawG0GqznDHaiHXZuTsCjA">Zookeeper夺命连环9问</a></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>高并发架构基石-缓存</p>
<ul>
<li>Redis数据结构、基础知识<ul>
<li><p><a href="https://mp.weixin.qq.com/s/aOiadiWG2nNaZowmoDQPMQ">Redis基础知识</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/EjDeypra_d9Tfsn-WkJZdw">集群高可用、哨兵、持久化、LRU</a></p>
</li>
<li><p><a href="https://github.com/AobingJava/JavaFamily/blob/master/docs/redis/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8(BloomFilter).md">布隆过滤器(BloomFilter)</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/49hgH3COla3wU0rgyiUVgg">Redis—分布式锁深入探究</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/NOsXdrMrWwq4NTm180a6vw">Redis—跳跃表</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/MT1tB2_7f5RuOxKhuEm1vQ">Redis—5种基本数据结构</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/O_qDco6-Dasu3RomWIK_Ig">Redis—持久化</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/9dtGe3d_mbbxW5FpVPDNow">Reids—神奇的HyperLoglog解决统计问题</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/Z_xriP-jc2Bnmdcm0l5xzg">Redis分布式锁</a> </p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/VY31lBOSggOHvVf54GzvYw">Redis数据结构底层系列-SDS</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/eSx4aL7iaMZlW0cPZswghA">短小精悍之 Redis 命令行工具有趣的罕见用法</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/RnSokJxYxYDeenOP_JE3fQ">Redis分布式锁(全)</a></p>
</li>
</ul>
</li>
<li>Redis常见线上故障及其解决方案<ul>
<li><p><a href="https://mp.weixin.qq.com/s/knz-j-m8bTg5GnKc7oeZLg">缓存击穿、雪崩、穿透</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/BdwZViiAqnFhCde4ZsxwPg">布隆过滤器实战【防止缓存击穿】</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/2hTgP3MRTVDxmmoUFhOaGw">分布式锁、并发竞争、双写一致性</a></p>
</li>
</ul>
</li>
<li>Redis常见面试题<ul>
<li><p><a href="https://mp.weixin.qq.com/s/LkIcGS9kFTXNLFlxASPYUA">Redis面试题</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/R1TJMo2IbPUUMox9OAAafQ">Redis常见面试题</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/rw42cFbJXwPtsGiqkFErfw">Redis为什么变慢了？一文讲透如何排查Redis性能问题</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/mscKInWNAuhCbg183Um9_g">Redis不是一直号称单线程效率也很高吗，为什么又采用多线程了？</a> </p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/dYvM8_6SQnYRB6KjPsprbw">缓存一致性问题怎么解决？</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/-caMTrOXQu-o0O44e6I9dQ">内存耗尽后Redis会发生什么？</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/vXBFscXqDcXS_VaIERplMQ">妈妈再也不担心我面试被Redis问得脸都绿了</a></p>
</li>
</ul>
</li>
<li>知识点之外的缓存之路<ul>
<li><a href="https://mp.weixin.qq.com/s/D4Ik6lTA_ySBOyD3waNj1w">缓存和数据库一致性问题</a></li>
<li><a href="https://mp.weixin.qq.com/s/Ls-Bld0Q6OQ1VD_az3iqbg">一个架构师的缓存修炼之路</a>  </li>
<li><a href="https://mp.weixin.qq.com/s/u3Ws1FGhJVIJdpM8IHI7OQ">再见了Antirez我永远的神</a></li>
<li><a href="https://mp.weixin.qq.com/s/xS2dqi5IG10AF7cHbzguAA">敖丙在蘑菇街的redis技术分享</a></li>
<li><a href="https://mp.weixin.qq.com/s/lLTbL5YW0gIJu9Yx2T2OtA">课代表总结</a></li>
<li><a href="https://mp.weixin.qq.com/s/8EN9vrZMhCK-40o_OdnOlg">Redis最佳实践：7个维度+43条使用规范，带你彻底玩转Redis</a></li>
<li><a href="https://mp.weixin.qq.com/s/XxY3b5FoVXCvHJWMxQH29g">布隆过滤器过时了，未来属于布谷鸟过滤器？</a></li>
<li><a href="https://mp.weixin.qq.com/s/5NOTLJ6AM3QJfhvXMSR-MA">什么鬼，面试官竟然让敖丙用Redis实现一个消息队列！！？</a></li>
</ul>
</li>
</ul>
</li>
<li><p>消息队列</p>
<ul>
<li>消息队列基础知识<ul>
<li><a href="https://mp.weixin.qq.com/s/Qhw4oS0OeN1N7uT1z6rbqg">消息队列基础知识</a></li>
<li><a href="https://mp.weixin.qq.com/s/OKon95MRUqDc9IwtEqPSjQ">消息重复消费、分布式事务、顺序消费</a></li>
</ul>
</li>
<li>Kafka<ul>
<li><a href="https://mp.weixin.qq.com/s/-IPfWPS1WQMEgcIu0Ak2VQ">Kafka架构与原理</a></li>
<li><a href="https://mp.weixin.qq.com/s/kMIhPW2uLdy-mgS9sF6agw">Kafka性能篇：为何Kafka这么”快”？</a></li>
</ul>
</li>
<li>RocketMQ    <ul>
<li><a href="https://mp.weixin.qq.com/s/y-4TVwbc7AFGEA7q-_OkYw">RocketMQ</a></li>
</ul>
</li>
<li>消息队列面试题  <ul>
<li><a href="https://mp.weixin.qq.com/s/1r1x-Irbatvzdc90haaecA">面试题：如何保证消息不丢失？处理重复消息？消息有序性？消息堆积处理？</a></li>
<li><a href="https://mp.weixin.qq.com/s/68XX9qnEvDTCOw8gYLNBxQ">面试官：你对Kafka比较熟？ 那说说kafka日志段如何读写的吧？</a></li>
<li><a href="https://mp.weixin.qq.com/s/ejZBAGI7qLE_QYSe-AqipA">师兄大厂面试遇到面试官的 Kafka 暴击三连问，快面哭了！</a></li>
<li><a href="https://mp.weixin.qq.com/s/S_0YCwUtyQqeBml02jPYqg">消息队列之推还是拉，RocketMQ 和 Kafka是如何做的？</a></li>
</ul>
</li>
</ul>
</li>
<li><p>数据库</p>
<ul>
<li>MySQL基础知识<ul>
<li><p><a href="https://mp.weixin.qq.com/s/J3kCOJwyv2nzvI0_X0tlnA">国庆肝了8天整整2W字的数据库知识点</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/pinOFeF09orQCnIp4L6XyA">MySQL大表怎么DDL变更</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/eEWMSTAUF1H-gFBx26jujw">MySql主从复制，从原理到实践！</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/LZBctWNWi3qehb-dgUCmxQ">MySQL查询缓存</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/wr2gJGQSA8QH_lmPh1XOkw">MySQL 的 InnoDB 存储引擎是怎么设计的？</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/ygvuP35B_sJAlBHuuEJhfg">你怎么连模糊匹配like %%怎么优化都不知道</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/NDL1Q6nqdPq5oMBWSpq4ug">数据库基础知识</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/vwHkXGNCdRdx8k7BeBMy9w">MySQL面试夺命20问</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/3d66-yXVZoDFRG1wyRw7kA">mysql 的一行记录是怎么存储的？</a></p>
</li>
</ul>
</li>
<li>索引、锁机制<ul>
<li><p><a href="https://mp.weixin.qq.com/s/_9rDde9wRYoZeh07EASNQQ">数据库索引</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/faOaXRQM8p0kwseSHaMCbg">一口气搞懂MySQL索引所有知识点</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/fShA7jxjshKyHEHfVDrLVA">你都是如何设计索引的？</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/7TPVOT7sloDUKmhldf9uvg">MySQL的索引是怎么加速查询的？</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/87qsrj-_hG54uxcOlFr35Q">索引下推</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/1LGJjbx_n_cvZndjM3R8mQ">MySQL 的全局锁、表锁和行锁</a></p>
</li>
</ul>
</li>
<li>事务特性、隔离级别、数据安全<ul>
<li><p><a href="https://mp.weixin.qq.com/s/rQDitOOnLpLEoj8M11NHwg">MySQL安全方案</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/dQFSrXEmgBMh1PW835rlwQ">数据库连接池到底应该设多大？这篇文章可能会颠覆你的认知</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/yo_LJ6IwGnjiBXSA7ZHdOA">数据库设计</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/L0XUMHInnwN9gSYGH2nzdg">漫话：如何给女朋友解释什么是撞库、脱库和洗库？</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/0-YEqTMd0OaIhW99WqavgQ">MVCC和事务隔离级别的关系</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/CZHuGT4sKs_QHD_bv3BfAQ">MySQL事务与MVCC如何实现的隔离级别</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/iFmvvt4DJ-_qFeb0XUh6QA">数据库事务</a></p>
</li>
</ul>
</li>
<li>数据库性能调优<ul>
<li><p><a href="https://mp.weixin.qq.com/s/7dpNkLaglIyb_9DKdH43eQ">为什么MySQL不建议使用delete删除数据？</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/nEmN4S9JOTVGj5IHyfNtCw">工作以来总结的大厂SQL调优姿势</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/oVjm_iLvbkximBjHv9d8ig">为啥阿里巴巴不建议MySQL使用Text类型？</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/-gmAPfiKMNJgHhIZqR2C4A">用对了这些场景下的索引，技术总监夸我棒</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/qESZSzHoxUKQRJhb1EQA_Q">MySQL索引凭什么让查询效率提高这么多？</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/e0CqJG2-PCDgKLjQfh02tw">MySQL调优</a></p>
</li>
</ul>
</li>
<li>分库分表<ul>
<li><p><a href="https://mp.weixin.qq.com/s/-Jipxjwe-jAax4hJSe-9Jg">我们为什么要分库分表？</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/dMqXBW6W8DeqfAPvko3ViQ">分库分表方案</a></p>
</li>
</ul>
</li>
<li>数据库面试题<ul>
<li><p><a href="https://mp.weixin.qq.com/s/SqSPxSRslkjUcDasBHGRSQ">innodb是如何插入数据的?</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/qEA1pC2pfh3xz9HuM8iIBg">数据库自增ID用完了会怎么样？</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/qHzb6oPrrbAPoIlfLJVNAg">阿里面试：说说一致性读实现原理？</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/SNRvdmyS57oWS_CyYKVvSA">我说 SELECT COUNT(*) 会造成全表扫描，面试官让我回去等通知</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/Lx4TNPLQzYaknR7D3gmOmQ">原来MySQL面试还会问这些(undo log)</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/izOKK9Ft5wLts8hWIo4ODQ">explain</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/-5N6eg1yMBUvDMbJOXp0eg">你说说一条更新SQL的执行过程？</a></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>大数据</p>
<ul>
<li><p>ODPS离线分析</p>
</li>
<li><p>Hive</p>
</li>
<li><p>Spark</p>
</li>
<li><p>Hadoop</p>
</li>
<li><p>Hbase</p>
</li>
<li><p>HDFS</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/7rW9eHxdRXtWJExVupcZZQ">大数据体系</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/xa2iGrmyoXq3FtZeU9GU-w">Flink入门教程</a></p>
</li>
</ul>
</li>
<li><p>搜索引擎</p>
<ul>
<li>ElasticSearch<ul>
<li><p><a href="https://mp.weixin.qq.com/s/AjGiMikSVgCk6INyf-m8hA">Elasticsearch入门</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/F8BsSg6R9LHxKt-gbH_JKQ">记一次害敖丙差点丢工作的线上P0事故</a></p>
</li>
</ul>
</li>
<li>Canal</li>
<li>Kibana</li>
<li>Lucene</li>
<li>Logstash</li>
</ul>
</li>
<li><p>优秀开源框架推荐</p>
<ul>
<li><p><a href="https://mp.weixin.qq.com/s/NgS9tL4IVwGZrssz7fURpA">阿里巴巴开源限流系统 Sentinel 全解析</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/d4K9hJHzZ5IAd2aarsdQrw">支付宝的架构到底有多牛逼？还没看完我就跪了！</a></p>
</li>
</ul>
</li>
<li><p>架构演进之路</p>
<ul>
<li><p>从All in one 到微服务</p>
</li>
<li><p>互联网架构之路</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/Pi_fHXhSf17l8q5CZ_U5UA">我难道天生就是个架构师？这可是100k并发啊</a></li>
</ul>
</li>
<li><p>怎么设计一个能顶住双十一的系统？</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/RzJkQuMAszkC8jw8hF-k1w">压测都做些什么?</a></li>
<li><a href="https://mp.weixin.qq.com/s/CxqnaB9cUemvCcWkw2nUcw">千万级、亿级流量怎么处理？</a></li>
</ul>
</li>
<li><p>分布式&amp;分布式事务</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/uv9xYgYrHWqM5acXQYFegA">分布式架构由来</a></li>
<li><a href="https://mp.weixin.qq.com/s/XknegP66mnYboiBx556Kzw">分布式事务</a></li>
<li><a href="https://mp.weixin.qq.com/s/ujRRtdLOeKEHsHrtDRNXGA">1.4 w字，25 张图让你彻底掌握分布式事务原理</a></li>
</ul>
</li>
</ul>
</li>
<li><p>互联网前沿技术</p>
<ul>
<li>容器化：Docker与k8s详解</li>
</ul>
</li>
<li><p>面试技巧</p>
<ul>
<li><p><a href="https://mp.weixin.qq.com/s/KeIJDrHbMH_BRUKLnCqExw">敖丙迟早被你们气死</a></p>
</li>
<li><p>简历 </p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/0pNv6pMnenKn1A9PE61VnQ">简历怎么写?</a></li>
<li><a href="https://mp.weixin.qq.com/s/LxVeT49GMKu72PZJ-rDHpA">能不能好好写简历？</a></li>
<li><a href="https://mp.weixin.qq.com/s/tl4DpsQPVh-bvlFzNsrzvw">简历这样写，技术人都不直男了！</a></li>
<li><a href="https://mp.weixin.qq.com/s/NyJ2gLDLIomlgkIFYWVvJg">10个简历小技巧，成为面试战神</a></li>
</ul>
</li>
<li><p>语言组织</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/br7Ak88kA5GkZ26hxwKUiw">自我介绍</a></li>
</ul>
</li>
<li><p>加分项</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/2mdcZnlTWCDYejGkZCdNOQ">面试官喜欢怎样的人</a></li>
</ul>
</li>
<li><p>面试流程</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/jhmpG2bBb4aXoUJzahC0Rg">互联网公司面试流程 注意事项 加分点 防骗指南</a></li>
<li><a href="https://mp.weixin.qq.com/s/7Rq8QR58Adi5WGHRlnhDeQ">互联网公司面试流程&amp;加分点，别跟敖丙一样被无良HR坑了</a></li>
</ul>
</li>
</ul>
</li>
<li><p>研发规范</p>
<ul>
<li><p>阿里巴巴技术规范</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/3XX-Lu1KrKEc3IfB9Iqz5A">为什么阿里巴巴禁止使用Apache Beanutils进行属性的copy？</a></li>
<li><a href="https://mp.weixin.qq.com/s/xvTCaBXkRc7e6dGCUJxRPQ">为什么阿里巴巴禁止开发人员使用isSuccess作为变量名？</a></li>
<li><a href="https://mp.weixin.qq.com/s/9y89Hy-YnpPjXpcmXpy_GQ">为什么阿里巴巴要求谨慎使用ArrayList中的subList方法</a></li>
<li><a href="https://mp.weixin.qq.com/s/fLUf8V0Qahe8piNrRp1UVQ">为什么阿里巴巴不建议在for循环中使用”+”进行字符串拼接</a></li>
<li><a href="https://mp.weixin.qq.com/s/JduY7OAeywOlVLbLiX3Xnw">为什么阿里巴巴禁止使用BigDecimal的equals方法做等值比较？</a></li>
</ul>
</li>
<li><p>开源漏洞    </p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/iV9DbX3LhbBkNiaKLL7PxA">fastjson到底做错了什么？为什么会被频繁爆出漏洞？</a></li>
</ul>
</li>
<li><p>大厂技术研发规范  </p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/ROMzeipOwWZWNrVGdVwisg">大厂是如何设计接口的？</a></li>
<li><a href="https://mp.weixin.qq.com/s/ynYi_dMlP2Y9GnQXzQxa3Q">不要再在对外接口中使用枚举类型了！</a></li>
</ul>
</li>
</ul>
</li>
<li><p>面试真题&amp;面经分享</p>
<ul>
<li><p>阿里巴巴面试题</p>
<ul>
<li><p><a href="https://mp.weixin.qq.com/s/oEGSxv5KuNI9BsCxpdi82A">淘宝|蚂蚁|菜鸟|盒马|嘀嘀|饿了么面经(已拿多个offer)</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/gYpZCSYK3YYEvGFFeHdFJQ">互联网寒冬，敖丙挚友7面阿里，终获Offer</a>  </p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/16cZLY9_uJwhi50RJXknIg">一道蚂蚁金服笔试题，还行，中等难度</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/HtLwChoLzqhbM4pKldLDng">一份还热乎的蚂蚁金服面经（已拿Offer）！附答案！！</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/-DZj158-LOQmnCayf1_n3A">我和阿里面试官的一次“邂逅”(附问题详解)</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/WOS6HMdt1-mAGuLiC30_-Q">二本 两年经验读者 阿里P6面经</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/nzvg3e-RgM59zs9WSeUpLg">小姐姐面试蚂蚁金服被虐经历，心疼…</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/jnegDdp4OMSKynZl8OBIpw">一位读者小姐姐的阿里面经分享，快被问哭了！（附部分问题详解）</a> </p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/e6MpOuxeZ53fAatNBhiC9A">朋友怎样刚拿饿了么P7 offer，然后途虎一轮游的</a></p>
</li>
</ul>
</li>
<li><p>字节跳动面试题</p>
<ul>
<li><p><a href="https://mp.weixin.qq.com/s/sWtI7M8K1iajreEo3LtwIw">读者字节、滴滴面经（已拿offer）</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/g6qFbEWfJeahzuzjECuvDg">敖丙读者只复习了半年，怒拿字节跳动Offer</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/xBC1IRr6v8hmIJ9lqCp5pQ">春招字节跳动、蘑菇街四轮面试，分别问了啥？</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/0opKiGbKjAfJkRVeVHzpZg">蚂蚁金服2019实习生面经总结(已拿口头offer)</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/hr2pDs2wsiHQuDzW7jmOow">2020 字节跳动后端面经分享！已拿 offer!</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/BiaXzNw5rp69CPPNBRii3g">百度、字节跳动等后台面经，已拿Offer！</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/WOIkWLsA7fyyoHPyNT7HdQ">学妹字节、蘑菇街、阿里、莉莉丝…面经</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/P2lTpC7yQ7VD8if_rMUcPg">双非本科逆袭 拿下ACM金牌、字节和旷视offer、保研985！</a></p>
</li>
</ul>
</li>
<li><p>拼多多面试题</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/kSiLvSrAMwrHLwxvesyjBw">读者一个月拿到阿里字节拼多多offer</a></li>
</ul>
</li>
<li><p>bilibili</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/tMPwanTRC3pj3X4Rx4SeTQ">B站五面面经</a>    </li>
</ul>
</li>
<li><p>京东</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/-04X2NS165vedIGb85q7QQ">京东二面：为什么需要分布式ID？你项目中是怎么做的？</a>  </li>
</ul>
</li>
<li><p>美团面试题</p>
<ul>
<li><p><a href="https://mp.weixin.qq.com/s/gSG_ZzZN7Ek2HEGtdi_Nkg">美团面经</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/oAnGGBkre7Z4VkhME-TgzQ">3 年经验的 Java 后端妹子，横扫阿里、滴滴、美团，看完面经我觉得敖丙是垃圾！</a></p>
</li>
</ul>
</li>
<li><p>网易</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/TzaV0dfbWw2zHiF55vq_kA">双非院校非科班的学弟，刚刚拿到了腾讯、网易、美团等大厂Offer</a>  </li>
</ul>
</li>
<li><p>腾讯面试题</p>
<ul>
<li><p><a href="https://mp.weixin.qq.com/s/EOQafymh7xVtxblstTbQUA">苦修月余，斩获bigo、腾讯offer，面经奉上！</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/yb6MtKMrCl2rAUZVLIfJow">来自朋友最近阿里、腾讯、美团等P7岗位面试题</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/0XJHz2seZAw4bDEA2i_i2Q">研二师弟拿下微信 offer</a></p>
</li>
</ul>
</li>
<li><p>国企面试题</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/d4OewL8-gCm_IkqDqufvsQ">怎么面国企或银行？</a></li>
</ul>
</li>
<li><p>外企面试题</p>
<ul>
<li><p><a href="https://mp.weixin.qq.com/s/3_HnVzGm16zU2zhk7BnwFw">Bigo的Java面试，我挂在了第三轮技术面上……</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/yYy5YUeA3VAAQMtnMhaFUQ">我经历的7轮Google面试</a></p>
</li>
</ul>
</li>
<li><p>校招面试题</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/wTKSvziyEXrSyf21iMjhZQ">十道校招常见的面试题</a></li>
</ul>
</li>
<li><p>社招面试题</p>
</li>
<li><p>其他  </p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/VOVUQ2cbYX5UXrrWLIHFXQ">「面经」不小心拿到了B站意向书</a></li>
<li><a href="https://mp.weixin.qq.com/s/3OTwlqCpJHEwtUvSQn1xmw">小红书</a></li>
<li><a href="https://mp.weixin.qq.com/s/VVonP6MgGRUnBnWa2ukkyw">京东+百度一面，不小心都拿了Offer</a></li>
<li><a href="https://mp.weixin.qq.com/s/F2TiFw-LYFXMRj_hsD-TIw">敖丙读者一个月面试近20家大中小厂，在互联网寒冬突破重围，成功上岸阿里云 ！</a></li>
<li><a href="https://mp.weixin.qq.com/s/ttKI82_CQdMmxoBw8TS92g">Java后端实习面经，电子科大大三读者投稿！看了之后感触颇深！很开心！</a></li>
<li><a href="https://mp.weixin.qq.com/s/AQvDX0n8wBBaWl2OmcpnrA">敖丙8年经验读者，疫情期间面20家大厂总结</a></li>
<li><a href="https://mp.weixin.qq.com/s/MkjSYc0JA1-VErX3lJzPmQ">被裁一个月面试的面经和经验分享</a>  </li>
<li><a href="https://mp.weixin.qq.com/s/MNm3k1s8CrrI6vF-47cvcg">上岸哈工大！！</a></li>
<li><a href="https://mp.weixin.qq.com/s/el7wBmABxzsUng_QLdUtaQ">二本读者实习遭领导歧视，逆袭进百度！</a></li>
</ul>
</li>
</ul>
</li>
<li><p>职场杂谈</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/1rUYxXbb0PaVOkmDQAxHpg">提离职，涨薪 走，别回头</a></li>
<li><a href="https://mp.weixin.qq.com/s/lC6F1HVmAGQzXsFbpZz9Qw">我对外包的看法</a></li>
<li><a href="https://mp.weixin.qq.com/s/9vPZd1q1vpKuE2qZazLQmA">阿里五年老员工有什么话想对大家说？</a></li>
<li><a href="https://mp.weixin.qq.com/s/Sn7_FcNW7Sq3WVm_LgwVrA">读研or工作？</a></li>
<li><a href="https://mp.weixin.qq.com/s/XcrBvdlh1At_V42qfQZ9Kw">应届毕业生工作7个月小结</a></li>
<li><a href="https://mp.weixin.qq.com/s/HJ9wzgW6TAc6Cf6B8oZEdw">在国企里面当程序猿是一种怎样的体验?</a></li>
<li><a href="https://mp.weixin.qq.com/s/enq_fh0hq2gMSgeXfunP6Q">跳槽季，应不应该跳，怎么跳？</a></li>
<li><a href="https://mp.weixin.qq.com/s/vseVDxl3BjESeZsdKLd1eA">让你自制力提升300%的学习方法</a></li>
<li><a href="https://mp.weixin.qq.com/s/D0bxHiXJKU64SinO1mh7Mw">教你在服务器搭建个人面试项目</a></li>
<li><a href="https://mp.weixin.qq.com/s/MvA12XM_ZzOG_7ygTmzIfA">程序员只能吃青春饭？30岁后出路在何方？</a></li>
<li><a href="https://mp.weixin.qq.com/s/HafYjNNoBwuau-MI6W8EnQ">学历对程序员重要么？</a></li>
<li><a href="https://mp.weixin.qq.com/s/UIbINxc-lEktnXLJhLceZQ">有哪些事情是你成为程序员之后才知道的？</a></li>
<li><a href="https://mp.weixin.qq.com/s/3VDS3tku0ZYZ4M_v760TEQ">天天加班却不受重用，老板到底喜欢什么样的员工？</a></li>
<li><a href="https://mp.weixin.qq.com/s/RcL3Y6BZNSBQZJq8V3LCyw">纵使社会虐我千百遍，我依然待它如初恋</a></li>
<li><a href="https://mp.weixin.qq.com/s/10DvwjXysmGzLa6AoSsXNw">国家何时整治程序员的高薪现象？</a></li>
<li><a href="https://mp.weixin.qq.com/s/-bva0Cako549qUqK5BIHkw">大学毕业是去大城市好还是回小城市好？</a></li>
<li><a href="https://mp.weixin.qq.com/s/lr6qlbB6loJ1DMbdV-_Avw">大二那年，我发现学生思维在职场行不通</a></li>
<li><a href="https://mp.weixin.qq.com/s/UZyUclzkKIRhUM-8vioxvg">B站崩了，如何防止类似事故的出现？</a></li>
<li><a href="https://mp.weixin.qq.com/s/QW8a0ULgSo9uNyswril3Fg">每日灵魂拷问：“工作=有钱=快乐？”</a></li>
<li><a href="https://mp.weixin.qq.com/s/zv3hhsjCSrzrFIe3rEZRYQ">比渣男pua更可怕的，是职场pua</a></li>
<li><a href="https://mp.weixin.qq.com/s/MFtq7jEqnhfi-3OnTCuY5g">你热爱编程么？我先来：爱过</a></li>
</ul>
</li>
<li><p>程序人生系列</p>
<ul>
<li><p>成长经历</p>
<ul>
<li><p><a href="https://mp.weixin.qq.com/s/IM6ksfs4bWnOljB0EbsyxQ">嗯，读书就是我们唯一的出路</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/FJC2uEg9o56dqCPijgizFA">大学个人经历 | 如诗的青春</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/417im7XPERSMzGiHnNaiEQ">人生如水，由溪入海</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/66ZDj60KPEfohHg0g8Cggw">2019年个人经历</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/_HCBjYI9bcNy-zBHu58l7g">昂，我24岁了</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/aK6ASJO6G1q4mY3TUShCqQ">24岁我全款买了人生的第一辆车</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/H88XxwF3GCwc_cL4rGKu8g">2020个人经历</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/matyTWXuZ_qs9hGfAl9_NQ">我的青春结束了</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/oY3CxB2Dk82mBs4W77Zrcw">鲜衣怒马少年时，一日看尽长安花</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/WPY13Px6OeGssBkZVOL7Aw">敖丙离职了</a></p>
</li>
</ul>
</li>
<li><p>职场经历</p>
<ul>
<li><p><a href="https://mp.weixin.qq.com/s/JB6CT4SfOg8e9lhkiWwZNg">蘑菇街裁员说明 海阔凭鱼跃，天高任鸟飞</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/LjFfDwT62usphaock5pU8Q">入职一周年，我眼中的蘑菇街</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/_zK6ovSynkcmZ-iwzFHHMA">在美女如云的蘑菇街工作是怎样的体验？</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/0WurpFJlZQtjjdleGPK0Cw">【互联网寒冬】经历裁员，拿20W被迫去大厂</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/dzxUtvI1m9uO1OpkkcDq0g">再见了，蘑菇街最帅的男人</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/br7Ak88kA5GkZ26hxwKUiw">敖丙用20行代码拿了比赛冠军</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/fkByjmdaqdw0TELDzdm5mQ">敖丙我参加了蘑菇街年会，流了一晚上鼻血</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/wlfurOBpxeaf6iy7CtHRlA">时间刺客–敖丙</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/pHcgkDvKfElRIVZGd4Kzng">送别了好友，敖丙跟你聊聊【离职】这个话题</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/7t2-L7ZYAYXrp0CTbYpAUg">再见，三歪</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/MijvXeWtsJOJIzxcpJdRhA">阿里入职培训</a></p>
</li>
</ul>
</li>
<li><p>自媒体经历</p>
<ul>
<li><p><a href="https://mp.weixin.qq.com/s/g6SQ6nqjKrqjlzaGuLHpYA">写作一个月的感受</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/UC6NsEFlNfqMdEkzvHxKRA">我知道互联网不相信眼泪，但是敖丙今天还是没忍住</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/_5tVdE9oFPBUK3Z0gKH26g">50天全网2W粉，感谢坚持！</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/SBnev4kAzsqpA9l-unt4dw">华为现场和百万粉博主线下面基，敖丙c位出道</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/KB7Gkdu4S13mQnlHGAUHfQ">敖丙第一次见到一个亿…</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/LvgziYKKE7lLIxag1v3R1A">敖丙入职腾讯了</a></p>
</li>
</ul>
</li>
<li><p>生活趣事  </p>
<ul>
<li><p><a href="https://mp.weixin.qq.com/s/mLLbpnI1pVnlUzL7H3EuNQ">敖丙的第一次相亲，还没开始，就已经结束了。</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/bM7xtVDwAA82d42UrhEx2g">我第一次相亲就被大三岁的姐姐看上</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/sM3hJe5z3_pCH-8GWs0iOA">敖丙参加了一场温州游资的婚礼</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/1jQnRCXdrUQzZInQmzABvA">敖丙枯燥无味的假期，一直在吃狗粮</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/5C4UjGtHoZVu8uI4yP5wRg">请照顾好自己，周末病魔差点一套带走我。</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/s9HPYYi9VfYMt7UGCTqWVw">曾经我们并肩作战，敬未来一杯，敬资本一杯</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/yB9s771gDz6oMKZsUnJuyg">敖丙我写了一个新手都写不出的低级bug，被骂惨了。</a></p>
</li>
</ul>
</li>
<li><p>读者经历</p>
<ul>
<li><p><a href="https://mp.weixin.qq.com/s/irjvJkIRknxasM0D1v3FOw">从网瘾少年逆袭拿到微软 、字节等offer（上）</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/CTpY8oxxjdvleTotjrpAsA">从网瘾少年逆袭拿到微软 、字节等offer（下）</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/oSKKUOG-JO0PLMun13gi0A">我新浪学妹的北京日常</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/cMZN_T7Ar1skWyyx8iHI5g">朋友被裁员之后的工行、华为外包工作经历分享</a>    </p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/Bg0Qejvxd6nQMuG4gXFzLw">和华为的一位学长聊了很久，优秀的人果然都有过人之处</a></p>
</li>
</ul>
</li>
<li><p>家人</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/yGcgvp9s18CERp9nx2iigw">我的母亲</a></li>
</ul>
</li>
<li><p>过年特辑</p>
<ul>
<li><p><a href="https://mp.weixin.qq.com/s/MXSWBVQyVD4OW0tjy5UO8Q">贵州打工仔回家过年，遭遇流感，被隔离，偶遇读者，偶遇直播同行…</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/pQrepZAbgP59gmj42Z1kdA">敖丙回家过年，外婆说没带女朋友别回来了？喝了老爸89年的酒，当场反目。</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/VECNJbVV0Bz8PKlG8pYwVw">书房翻杂物，看到初恋的信件，看到奖牌，看到梅西、力宏，帅丙的眼角又湿了…..</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/8blBtbBLJtVvpnrJ7tmh_g">疫情之下，从一座空城，到另一座空城，贵州小伙带你看不一样的杭州</a></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>科普</p>
<ul>
<li><p><a href="https://mp.weixin.qq.com/s/WszidUcoV_cYeDf26EkAcA">你知道程序是怎么处理时区问题的么？</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/BMttkFZsKu0qmxSz-MqAlw">聊一聊理财</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/13ls90r8hWbzW4J1kuVzrQ">Swagger 官方 Starter 配上这个增强方案是真的香！</a></p>
</li>
</ul>
</li>
<li><p>人物&amp;杂谈  </p>
<ul>
<li><p><a href="https://mp.weixin.qq.com/s/FUbxHFAQeUgV59Zhp7Fe0w">罗永浩</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/Udd3B4L-94hH9ggEtOcJAw">俞敏洪</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/RasTw7_XpxZoDP5k2bpz0w">远方是门票机酒，前方是山川大海</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/lt_RxXC_OAl7aezCkmSyyg">门户前浪退市，从此只做“新浪”</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/a4CzPbx5Bim6mFzzqq0vrA">“小破站”二次上市 - ( ゜- ゜)つロ 乾杯~</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/s2xcFud-8IJq7MpgO1QSHA">我们在努力成为恒星</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/bTWTgiQInITy9Dv5BJ-Dgg">苏宁张近东：三十年沉沉浮浮，零售史上不为人知的秘密</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/LyWW3tXSNMGY6MNi-HnNOg">陈欧，带货网红鼻祖的起起落落落落落落创业路</a></p>
</li>
</ul>
</li>
<li><p><strong>福利</strong></p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/5QpuDtXAalR-pz59B5t27g">Java/后端学习路线</a></li>
<li><a href="https://mp.weixin.qq.com/s/QrRVMp6z7HjZA4trsga_cg">Java/后端学习路线 2.0优化版本</a></li>
<li><a href="https://mp.weixin.qq.com/s/Wod2cGjGkGeB0iLVAqpksQ">整理的书单(附个人喜欢的文学书)</a></li>
<li><a href="https://mp.weixin.qq.com/s/7NS452k5hVPW0dUQ-oTi-A">敖丙大学四年自学走来，这些私藏的实用工具/学习网站我贡献出来了</a></li>
<li><a href="https://mp.weixin.qq.com/s/WYiXHVJ-p1sZAf4jb5gIXg">整理好用的工具集</a></li>
<li><a href="https://mp.weixin.qq.com/s/JX72OoiNrZ9R0DTuOOtcoA">通用的学习方法</a></li>
<li><a href="https://github.com/AobingJava/JavaFamily/blob/master/docs/idea/idea.md">IDEA破解(请勿传播)</a></li>
<li><a href="https://github.com/AobingJava/JavaFamily/blob/master/docs/idea/%E7%94%B5%E5%AD%90%E4%B9%A6.md">电子书(请勿传播)</a></li>
<li><a href="https://github.com/AobingJava/JavaFamily/blob/master/docs/idea/%E8%B5%84%E6%96%99.md">面试资料(持续更新)</a></li>
<li><a href="https://github.com/AobingJava/JavaFamily/blob/master/docs/idea/%E8%B5%84%E6%96%99.md">简历模板(欢迎补充)</a></li>
<li><a href="https://github.com/AobingJava/JavaFamily/blob/master/docs/idea/%E8%B5%84%E6%96%99.md">概要设计模板</a></li>
<li><a href="https://mp.weixin.qq.com/s/2_hM5Z9IMLIRQ2QEPTABcQ">5分钟白嫖敖丙常用的免费效率软件/工具！</a></li>
</ul>
</li>
</ul>
<p>所有文章pdf版本 : 链接:<a href="https://pan.baidu.com/s/1PKO0LDspwJPNqT6qwqNorQ">https://pan.baidu.com/s/1PKO0LDspwJPNqT6qwqNorQ</a>  密码:f654</p>
<p>技术交流群：添加我微信  Aobingcool  备注【加群】即可</p>
<p>投稿：个人精力有限欢迎大家投稿 投稿可获得500-3000元不等的稿酬 点击 <a href="http://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&mid=305658311&idx=1&sn=4a38e5bbb8845a245452f8ffad9fe4b3&chksm=0cf2db443b855252577ac26a16bbf477942401f7e832bd075866d82a0fa25a02ab5b1534cb72#rd">【查看详情】</a></p>
<h1 id="祝福"><a href="#祝福" class="headerlink" title="祝福"></a>祝福</h1><p>希望大家都能找到心仪的工作，学习是一条时而郁郁寡欢，时而开环大笑的路，加油。</p>
<p>如果你通过努力成功进入到了心仪的公司，一定不要懈怠放松，职场成长和新技术学习一样，不进则退。</p>
<p>敖丙在工作中发现我身边的人真的就是实力越强的越努力，<strong>最高级的自律，享受孤独</strong>。</p>
<h1 id="知识星球（近期会重启在思考内容）"><a href="#知识星球（近期会重启在思考内容）" class="headerlink" title="知识星球（近期会重启在思考内容）"></a>知识星球（近期会重启在思考内容）</h1><p><strong><a href="https://github.com/AobingJava/JavaFamily/blob/master/docs/idea/%E7%9F%A5%E8%AF%86%E6%98%9F%E7%90%83.md"><strong>【点击了解详细 领取减32的优惠券】</strong></a></strong></p>
<p>我会在里面分享个人经历、分享经验、理财，职业规划，答疑等都会涉及，嘉宾分别是公众号大V、大厂架构师、阿里、美团、拼多多的技术专家，都是我朋友，希望能跟你共事（已经有读者去了阿里，也有一个来了蘑菇跟我做同事了，找机会我会分享出来）。</p>
<h1 id="项目经验-amp-服务器"><a href="#项目经验-amp-服务器" class="headerlink" title="项目经验&amp;服务器"></a>项目经验&amp;服务器</h1><p>大家都说简历没项目写，我就帮大家找了一个项目，还附赠<a href="https://github.com/AobingJava/JavaFamily/blob/master/docs/coderLife/%E6%95%99%E4%BD%A0%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E9%9D%A2%E8%AF%95%E9%A1%B9%E7%9B%AE.md"><strong>【搭建教程】</strong></a>。</p>
<p align="center">
  <a href="https://activity.huaweicloud.com/1111_promotion/index.html?fromacct=662497fd-8600-411b-9afd-ee2e218560a5&utm_source=V1g3MDY4NTY=&utm_medium=cps&utm_campaign=201905">
  <img src="https://tva1.sinaimg.cn/large/00831rSTly1gdfi1pc65nj306q02aglm.jpg">
  </a>
</p>

<p>云耀云服务器，88元一年起</p>
<p>华为云  <a href="https://activity.huaweicloud.com/1111_promotion/index.html?fromacct=662497fd-8600-411b-9afd-ee2e218560a5&utm_source=V1g3MDY4NTY=&utm_medium=cps&utm_campaign=201905"><strong>【点击购买】</strong></a></p>
<p align="center">
  <a href="https://dashi.aliyun.com/site/aobing/ali">
  <img src="https://tva1.sinaimg.cn/large/00831rSTly1gdfi3cmfhgj307e02k0sn.jpg">
  </a>
</p>

<p>活动折扣价：89/年，223/3年，比学生9.9每月还便宜(只阿里云新用户可用)</p>
<p>阿里云 <a href="https://dashi.aliyun.com/site/aobing/ali"><strong>【点击购买】</strong></a></p>
<p align="center">
  <a href="https://partners.cloud.tencent.com/invitation/1000144091425ee1dbcbc6093/100016776501">
  <img src="https://tva1.sinaimg.cn/large/0081Kckwly1gl0drrm2cjj308c02zglg.jpg"/>
  </a>
</p>

<p>腾讯云 <a href="https://partners.cloud.tencent.com/invitation/1000144091425ee1dbcbc6093/100016776501"><strong>【点击购买】</strong></a></p>
<h1 id="岗位内推"><a href="#岗位内推" class="headerlink" title="岗位内推"></a>岗位内推</h1><p>找所有职位比较出色的朋友，觉得合适的给我简历我可以内推，阿里、美团、蘑菇街、拼多多、字节跳动、腾讯等都可以.</p>
<p>阿里巴巴/腾讯/字节/快手其他岗位 : <a href="mailto:&#x61;&#111;&#x5f;&#x62;&#x69;&#x6e;&#x67;&#64;&#102;&#x6f;&#120;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;">&#x61;&#111;&#x5f;&#x62;&#x69;&#x6e;&#x67;&#64;&#102;&#x6f;&#120;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;</a></p>
<h2 id="社招近期机会"><a href="#社招近期机会" class="headerlink" title="社招近期机会"></a>社招近期机会</h2><h3 id="阿里校招学长内推"><a href="#阿里校招学长内推" class="headerlink" title="阿里校招学长内推"></a>阿里校招学长内推</h3><p><a href="mailto:&#97;&#111;&#95;&#x62;&#105;&#x6e;&#103;&#x40;&#x66;&#x6f;&#120;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;">&#97;&#111;&#95;&#x62;&#105;&#x6e;&#103;&#x40;&#x66;&#x6f;&#120;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;</a></p>
<h3 id="涂鸦智慧商业"><a href="#涂鸦智慧商业" class="headerlink" title="涂鸦智慧商业:"></a>涂鸦智慧商业:</h3><p>前端小伙伴欢迎尝试 ～</p>
<h4 id="关于部门："><a href="#关于部门：" class="headerlink" title="关于部门："></a>关于部门：</h4><p>我们大部门这边主要负责 SaaS 业务平台前端的开发，包括中后台，跨端以及工程化等方向。如果对其它团队感兴趣，也可以帮推。</p>
<h4 id="进来可以做的事情："><a href="#进来可以做的事情：" class="headerlink" title="进来可以做的事情："></a>进来可以做的事情：</h4><p>大部门这边有好些方向，比方说你擅长或者视频、WebRTC 相关技术，那可以来我们安防。或者你有其它喜欢的方向，也可以聊聊看。 有很多事来了可以一起做，比方说最近我们部门在做 React to Web Components 相关的技术、业务场景落地。</p>
<h4 id="关于技术栈："><a href="#关于技术栈：" class="headerlink" title="关于技术栈："></a>关于技术栈：</h4><p>大部门这边主要是以 React 为主，如果你是 Vue 经验的，同样欢迎来聊聊。只是框架层面不同，这个不是重点。</p>
<h4 id="关于面试："><a href="#关于面试：" class="headerlink" title="关于面试："></a>关于面试：</h4><p>之前遇到过 Vue 经验的小伙伴问我，说会不会问很多 React 的问题。放心，不会的。像比如社招的话，还是会更加注重项目经验的。然后就是，简历到我这里，不会直接就推进系统，会先跟你沟通一下哈，觉得 ok 我们再走流程。最后，流程会全程跟进，可加微信直接找我查进度。<br>邮箱: <a href="mailto:&#122;&#111;&#110;&#103;&#119;&#x65;&#x69;&#x2e;&#x68;&#x75;&#x40;&#116;&#117;&#x79;&#x61;&#x2e;&#x63;&#111;&#x6d;">&#122;&#111;&#110;&#103;&#119;&#x65;&#x69;&#x2e;&#x68;&#x75;&#x40;&#116;&#117;&#x79;&#x61;&#x2e;&#x63;&#111;&#x6d;</a> 微信联系: 15586548537 (昵称是接水怪，不要加错了哦~)</p>
<h3 id="支付宝网商银行"><a href="#支付宝网商银行" class="headerlink" title="支付宝网商银行:"></a>支付宝网商银行:</h3><p>Java工作两年及以上的同学欢迎尝试～</p>
<h4 id="关于部门：-1"><a href="#关于部门：-1" class="headerlink" title="关于部门："></a>关于部门：</h4><p>网商银行不做过多介绍了，网上很多相关资料，跟腾讯微众对标，每年绩效都很好。</p>
<p>我这边是信贷决策部门，绝对的核心，部门直招，如果对蚂蚁其他团队感兴趣也可以帮推，但没有本部门那么方便跟进。</p>
<p>进来可以做的事情：</p>
<p>可以保证的是一定不是单纯搬砖，本部门在整个网商都是底层核心系统，无论是流量还是数据量都是极大的技术挑战。</p>
<h4 id="关于职级："><a href="#关于职级：" class="headerlink" title="关于职级："></a>关于职级：</h4><p>p6-p8都有hc，真实hc不刷kpi，目前网商银行业务扩张，目标人数*2，所以放出了很多hc，是进蚂蚁的好机会。</p>
<h4 id="关于面试：-1"><a href="#关于面试：-1" class="headerlink" title="关于面试："></a>关于面试：</h4><p>很多同学可能很担心投了没有面好会对以后有影响，或者投了之后面下来发现不合适，这里说明一下，我们不会马上把你简历录系统，会先进行评估并且跟你电话沟通，双方都觉得合适才会开始面试，不会一来就传简历，而且面试时间和进度我可以随时帮跟进，不存在放鸽子这种情况。</p>
<p>邮箱: <a href="mailto:&#x6c;&#119;&#50;&#54;&#x33;&#x38;&#x38;&#56;&#64;&#97;&#108;&#x69;&#x62;&#97;&#x62;&#x61;&#x2d;&#x69;&#x6e;&#x63;&#x2e;&#99;&#111;&#109;">&#x6c;&#119;&#50;&#54;&#x33;&#x38;&#x38;&#56;&#64;&#97;&#108;&#x69;&#x62;&#97;&#x62;&#x61;&#x2d;&#x69;&#x6e;&#x63;&#x2e;&#99;&#111;&#109;</a>  微信联系: lwwei2222</p>
<h3 id="天猫国际"><a href="#天猫国际" class="headerlink" title="天猫国际:"></a>天猫国际:</h3><p>天猫国际是中国消费升级的第一跨境平台，是阿里经济体5年2000亿美金进口承诺的担纲。</p>
<p>2019年天猫国际技术部和考拉合并成立了阿里巴巴大进口技术部，是阿里巴巴国际化战略的核心技术部门。</p>
<p>我们致力于进口业务的技术突破和创新，助力中国的消费者实现“买遍全球”的需求。希望你加入我们，同我们一道引领电子商务、电子支付、供应链等全球化方向，建立一个让全球消费者喜爱，让全球商家受益的国际化技术体系。</p>
<p>1.你将致力于进口电商相关的推荐、搜索、用户增长、供应链规划等算法的设计和研发</p>
<p>2.你将致力于应用人工智能的最新技术，提高自动化和智能化程度，大幅提升业务效率</p>
<p>3.你将有机会深入到最前沿的大数据电商系统的设计和研发。近期成立的新BU，发展前景广阔，提供你足够施展才能的舞台。</p>
<p>现招聘 java研发实习生、前端实习生、算法、数据分析和测试实习生。</p>
<p>有意请发简历到 <a href="mailto:&#106;&#x6f;&#x73;&#104;&#117;&#97;&#x2e;&#x6c;&#105;&#102;&#102;&#x40;&#x61;&#108;&#105;&#x62;&#97;&#98;&#97;&#45;&#105;&#x6e;&#x63;&#x2e;&#x63;&#111;&#x6d;">&#106;&#x6f;&#x73;&#104;&#117;&#97;&#x2e;&#x6c;&#105;&#102;&#102;&#x40;&#x61;&#108;&#105;&#x62;&#97;&#98;&#97;&#45;&#105;&#x6e;&#x63;&#x2e;&#x63;&#111;&#x6d;</a></p>
<p>要求：2020年11-2021年10本科及以上毕业生，理工科相关专业优先，有论文发表或者程序设计大赛、acm等算法比赛获奖的优先。</p>
<h3 id="阿里国际化电商基础链路团队"><a href="#阿里国际化电商基础链路团队" class="headerlink" title="阿里国际化电商基础链路团队:"></a>阿里国际化电商基础链路团队:</h3><ul>
<li><p>Vision：AE基础链路的Vision是打造全球化、灵动性的基础链路团队，构建一个完整的电商基础领域闭环。在这里你可以领略到完整的国际化电商体系的进化和发展，在整个电商基础领域的生命周期里可以任意选择发挥你的所长。只要你敢想，我们就敢一起干；</p>
</li>
<li><p>领域：基于Siruis，Poloris中台架构体系，负责AE核心的交易、营销优惠、支付&amp;结算、会员店铺、钱包等基础域国际化小前台体系建设，并构建差异化的国家站的整体业务解决方案；</p>
</li>
<li><p>创新：基于AE跨境、本地化的多业务形态，小前台结合国际化中台的业务和技术策略，孵化创新业务与解决方案，如海外钱包解决方案、数字商品解决方案，助力海外业务多元化。联合算法赋能基础链路，创造更多结合算法能力的场景，如营销优惠，通过技术促进业务，更好的降成本促增收；</p>
</li>
<li><p>挑战：我们的基础领域业务遍布全世界各个角落，每个国家都会带给我们不一样的挑战和机遇，在这里我们可以重新定义电商基础领域，实现基础链路领域国家差异化；</p>
</li>
</ul>
<h4 id="岗位要求："><a href="#岗位要求：" class="headerlink" title="岗位要求："></a>岗位要求：</h4><ul>
<li><p>3 年及以上使用 JAVA 开发的经验，JAVA 基础扎实，理解io、多线程、集合等基础框架，了解 JVM 原理；</p>
</li>
<li><p>熟悉WEB开发，熟悉Servlet，MVC框架，具有扎实的数据结构与算法知识；</p>
</li>
<li><p>对用过的开源框架，能了解到它的原理和机制；对 Spring、mybatis 等开源框架熟悉；</p>
</li>
<li><p>熟悉分布式系统的设计和应用，熟悉分布式、缓存、消息等机制；能对分布式常用技术进行合理应用，解决问题；</p>
</li>
<li><p>熟悉 Linux 操作系统和大型数据库（RDBMS, NoSQL, NewSQL）；对 sql 优化有丰富的经验；</p>
</li>
<li><p>工作积极主动、很好的沟通能力、学习能力，适应能力好；能接受全栈任务，具备耐心和细心的品质。</p>
</li>
<li><p>英语流利为加分项</p>
</li>
</ul>
<p>有意请发简历到 <a href="mailto:&#102;&#105;&#103;&#x68;&#x74;&#105;&#110;&#x67;&#x63;&#114;&#x61;&#112;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;">&#102;&#105;&#103;&#x68;&#x74;&#105;&#110;&#x67;&#x63;&#114;&#x61;&#112;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;</a></p>
<h1 id="鸣谢列表"><a href="#鸣谢列表" class="headerlink" title="鸣谢列表"></a>鸣谢列表</h1><p>以下排名不分先后!</p>
<a href="https://github.com/simpleTo">
    <img src="https://avatars3.githubusercontent.com/u/24934495?s=400&v=4" width="45px">
</a>
<a href="https://github.com/programes">  
    <img src="敖丙的文章链接/6359325.png" width="45px">
</a>
<a href="https://github.com/bertChen812">  
    <img src="https://avatars3.githubusercontent.com/u/37893362?s=400&v=4" width="45px">
</a>
<a href="https://github.com/cyberwave">
    <img src="https://avatars2.githubusercontent.com/u/7488935?s=400&v=4" width="45px">
</a>
<a href="https://github.com/Gene1994">
    <img src="https://avatars3.githubusercontent.com/u/24930369?s=460&v=4" width="45px">
</a>
<a href="https://github.com/bertChen812">
    <img src="https://avatars0.githubusercontent.com/u/12581996?s=460&v=4" width="45px">
</a>
<a href="https://github.com/illusorycloud">
    <img src="https://avatars3.githubusercontent.com/u/31980412?s=460&v=4" width="45px">
</a>
<a href="https://github.com/LiWenGu">
    <img src="https://avatars0.githubusercontent.com/u/15909210?s=460&v=4" width="45px">
</a>
<a href="https://github.com/kinglaw1204">
    <img src="https://avatars1.githubusercontent.com/u/20039931?s=460&v=4" width="45px">
</a>
<a href="https://github.com/jun1st">
    <img src="https://avatars2.githubusercontent.com/u/14312378?s=460&v=4" width="45px">
</a>"
<a href="https://github.com/fantasygg">  
    <img src="https://avatars3.githubusercontent.com/u/13445354?s=460&v=4" width="45px">
</a>
<a href="https://github.com/debugjoker">  
    <img src="https://avatars3.githubusercontent.com/u/26218005?s=460&v=4" width="45px">
</a>
<a href="https://github.com/zhyank">  
    <img src="https://avatars0.githubusercontent.com/u/17696240?s=460&v=4" width="45px">
</a>
<a href="https://github.com/Goose9527">  
    <img src="https://avatars2.githubusercontent.com/u/43314997?s=460&v=4" width="45px">
</a>
<a href="https://github.com/yuechuanx">  
    <img src="https://avatars3.githubusercontent.com/u/19339293?s=460&v=4" width="45px">
</a>
<a href="https://github.com/cnLGMing">  
    <img src="https://avatars2.githubusercontent.com/u/15910705?s=460&v=4" width="45px">
</a>



<h1 id="赞助商"><a href="#赞助商" class="headerlink" title="赞助商"></a>赞助商</h1><p>以下排名不分先后!<br><img src="/%E6%95%96%E4%B8%99%E7%9A%84%E6%96%87%E7%AB%A0%E9%93%BE%E6%8E%A5/007S8ZIlly1ge4xvdlh0wj30zk0d1q6d.jpg"></p>
<p>  <a name="微信"></a>  <a name="公众号"></a></p>
<p> <img src="/%E6%95%96%E4%B8%99%E7%9A%84%E6%96%87%E7%AB%A0%E9%93%BE%E6%8E%A5/00831rSTly1gck2pplt8ej315u0u0k1b.jpg"></p>
]]></content>
  </entry>
  <entry>
    <title>终端连接并使用FTP/SFTP服务器</title>
    <url>/2021/08/01/%E7%BB%88%E7%AB%AF%E8%BF%9E%E6%8E%A5%E5%B9%B6%E4%BD%BF%E7%94%A8FTP-SFTP%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>下面列出一些常见的终端操作命令。</p>
<table>
<thead>
<tr>
<th>针对远方服务器主机 (Server) 之行为</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>切换目录</td>
<td>cd path</td>
</tr>
<tr>
<td>列出目前所在目录下的文件名</td>
<td>ls (or) dir</td>
</tr>
<tr>
<td>建立目录</td>
<td>mkdir directory</td>
</tr>
<tr>
<td>删除目录</td>
<td>rmdir directory</td>
</tr>
<tr>
<td>显示目前所在的目录</td>
<td>pwd</td>
</tr>
<tr>
<td>删除档案或目录</td>
<td>rm PATH</td>
</tr>
<tr>
<td>更改档案或目录名称</td>
<td>rename oldname newname</td>
</tr>
<tr>
<td>离开远程主机</td>
<td>exit (or) bye (or) quit</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>针对本机 (Client) 之行为(都加上 l (L的小写) )</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>变换目录到本机的 PATH 当中</td>
<td>lcd PATH</td>
</tr>
<tr>
<td>列出目前本机所在目录下的文件名</td>
<td>lls</td>
</tr>
<tr>
<td>在本机建立目录</td>
<td>lmkdir  directory</td>
</tr>
<tr>
<td>显示目前所在的本机目录</td>
<td>lpwd</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>针对资料上传/下载的行为</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>将档案由本机上传到远程主机</td>
<td>put local-file [remote-file]</td>
</tr>
<tr>
<td>将档案由远程主机下载回来</td>
<td>get remote-file [local-file]</td>
</tr>
<tr>
<td>上传多个文件件</td>
<td>mput files</td>
</tr>
<tr>
<td>下载多个文件</td>
<td>mget files</td>
</tr>
</tbody></table>
<ul>
<li>关于上传文件与文件夹的坑</li>
</ul>
<p>上传、下载文件肯定是没有问题的。</p>
<p>但是对于一整个文件夹的传输并不是像  scp命令一样通过 -r 参数就可以解决, 需要注意</p>
<blockquote>
<p>man sftp手册</p>
</blockquote>
]]></content>
      <categories>
        <category>FTP</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>FTP</tag>
      </tags>
  </entry>
  <entry>
    <title>算法题模板API</title>
    <url>/2021/11/28/%E7%AE%97%E6%B3%95%E9%A2%98%E6%A8%A1%E6%9D%BFAPI/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="语法类"><a href="#语法类" class="headerlink" title="语法类"></a>语法类</h1><h2 id="类与结构体"><a href="#类与结构体" class="headerlink" title="类与结构体"></a>类与结构体</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, z;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z) : x(x), y(y), z(z) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="function">Node <span class="title">node</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    Node node1 = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="重新定义类型"><a href="#重新定义类型" class="headerlink" title="重新定义类型"></a>重新定义类型</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P1 pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P2;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F1</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> P3 = <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> m, n;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line"><span class="comment">//        memset(g, 0, sizeof(g));</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, g[i + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, g[i] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h1><h2 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    reverse(a.begin(), a.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : a) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> b[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    reverse(b, b + <span class="number">3</span>); <span class="comment">// [)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : b) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a % <span class="number">2</span> &lt; b % <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对数组排序</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    sort(a, a + <span class="number">4</span>); <span class="comment">// 注意是 [)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从大到小</span></span><br><span class="line">    sort(a, a + <span class="number">4</span>, [](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt; y;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从大到小</span></span><br><span class="line">    sort(a, a + <span class="number">4</span>, cmp); <span class="comment">// 传入 cmp 函数指针</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// vector&lt;vector&lt;int&gt; &gt; vs;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vs(<span class="number">10</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>)); <span class="comment">// 10 * 2</span></span><br><span class="line">    sort(vs.begin(), vs.end(), [](<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] != b[<span class="number">0</span>] ? a[<span class="number">0</span>] &lt; b[<span class="number">0</span>] : a[<span class="number">1</span>] &gt; b[<span class="number">1</span>]; <span class="comment">// 先按第一维从小排序,再第二维从大到小排序</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 注意，默认的sort，其实是按vector&lt;int&gt;的字典序排序。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="lower-bound、upper-bound"><a href="#lower-bound、upper-bound" class="headerlink" title="lower_bound、upper_bound"></a>lower_bound、upper_bound</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    sort(a, a + <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回值 int*</span></span><br><span class="line">    <span class="keyword">int</span> idx = lower_bound(a, a + <span class="number">5</span>, <span class="number">5</span>) - a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; idx &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; a[idx] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> idx2 = upper_bound(a, a + <span class="number">5</span>, <span class="number">5</span>) - a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; idx2 &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; a[idx2] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> it1 = lower_bound(v.begin(), v.end(), <span class="number">7</span>);</span><br><span class="line">    <span class="comment">// 返回值是 vector&lt;int&gt;::iterator</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it2 = lower_bound(v.begin(), v.end(), <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *it1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *it2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> idx3 = lower_bound(v.begin(), v.end(), <span class="number">7</span>) - v.begin();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; idx3 &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; v[idx3] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="data-structure"><a href="#data-structure" class="headerlink" title="data structure"></a>data structure</h1><p>头文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br></pre></td></tr></table></figure>








<h2 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化方式</span></span><br><span class="line">    P2 p2 = &#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="function">P2 <span class="title">p3</span><span class="params">(<span class="number">5</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line">    P2 p4 = <span class="built_in">make_pair</span>(<span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p2.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; p2.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p3.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; p3.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p4.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; p4.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">vector</span>&lt;P2&gt; v = &#123;&#123;<span class="number">1</span>, <span class="number">5</span>&#125;,</span><br><span class="line">                    &#123;<span class="number">2</span>, <span class="number">4</span>&#125;,</span><br><span class="line">                    &#123;<span class="number">3</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解包</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [x, y] : v) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1;</span><br><span class="line">    s1.push_back(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    s1 += <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    s1 += <span class="string">&quot;c&quot;</span>;</span><br><span class="line">    s1.append(<span class="string">&quot;def&quot;</span>); <span class="comment">// aka +</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反转</span></span><br><span class="line">    reverse(s1.begin(), s1.end());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接访问</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s1[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s1[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 子串</span></span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">&quot;0123456&quot;</span>;</span><br><span class="line">    s1 = s.substr(<span class="number">2</span>,<span class="number">4</span>); <span class="comment">// s.substring(2, 2 + 4); aka 2345</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>字符串和数字互转</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> x = stoi(s);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">string</span> y = to_string(x);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a1;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a3 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a4</span><span class="params">(<span class="number">100</span>, <span class="number">0x3f3f3f3f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空</span></span><br><span class="line">    a1.clear();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;empty &quot;</span> &lt;&lt; a1.empty() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    a1.push_back(<span class="number">1</span>);</span><br><span class="line">    a1.push_back(<span class="number">2</span>);</span><br><span class="line">    a1.push_back(<span class="number">3</span>); <span class="comment">// 推入</span></span><br><span class="line">    a1.pop_back(); <span class="comment">// 弹出</span></span><br><span class="line">    a1.push_back(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  原来的值不清空</span></span><br><span class="line">    a1.resize(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器 [)</span></span><br><span class="line">    a1.begin();</span><br><span class="line">    a1.end(); <span class="comment">// 取不到</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a1.front() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// aka a1[0]</span></span><br><span class="line">    <span class="comment">// 尾巴</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a1.back() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 可以取到 aka a1[a1.size() - 1]</span></span><br><span class="line"></span><br><span class="line">    a1.insert(a1.begin() + <span class="number">1</span>, <span class="number">999</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; ---- &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : a1) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// 这么写是错的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = a.begin(); it != a.end(); ++it) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*it % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            a.erase(it);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : a) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// 正确做法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = a.begin(); it != a.end();) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*it % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            it = a.erase(it); <span class="comment">// 返回下一个有效的iterator</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; *(it++) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : a) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>





<h2 id="queue、stack"><a href="#queue、stack" class="headerlink" title="queue、stack"></a>queue、stack</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(<span class="number">1</span>);</span><br><span class="line">    q.push(<span class="number">2</span>);</span><br><span class="line">    q.push(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    st.push(<span class="number">1</span>);</span><br><span class="line">    st.push(<span class="number">2</span>);</span><br><span class="line">    st.push(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!st.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; st.top() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        st.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq;</span><br><span class="line">    </span><br><span class="line">    dq.push_back(<span class="number">1</span>);</span><br><span class="line">    dq.push_front(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    dq.pop_front();</span><br><span class="line">    dq.pop_back();</span><br><span class="line">    </span><br><span class="line">    dq.front();</span><br><span class="line">    dq.back();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;node) <span class="keyword">const</span> &#123; <span class="comment">// 注意两个 const 修饰</span></span><br><span class="line">        <span class="keyword">return</span> x * y &lt; node.x * node.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 大根堆</span></span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt; pq1;</span><br><span class="line">    <span class="comment">// 小根堆</span></span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; pq2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;Node&gt; pq3;</span><br><span class="line">    pq3.push(&#123;<span class="number">2</span>, <span class="number">2</span>&#125;);</span><br><span class="line">    pq3.push(&#123;<span class="number">3</span>, <span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(pq3.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node node = pq3.top();</span><br><span class="line">        pq3.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不可以既重写Node的操作符，又使用greater</span></span><br><span class="line"><span class="comment">//    priority_queue&lt;Node, vector&lt;Node&gt;, greater&lt;Node&gt;&gt; pq4;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="set、unordered-set"><a href="#set、unordered-set" class="headerlink" title="set、unordered_set"></a>set、unordered_set</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">    s.insert(<span class="number">3</span>);</span><br><span class="line">    s.insert(<span class="number">2</span>);</span><br><span class="line">    s.insert(<span class="number">1</span>);</span><br><span class="line">    s.insert(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断存在与否</span></span><br><span class="line">    <span class="keyword">if</span> (s.count(<span class="number">1</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s.find(<span class="number">1</span>) != s.end()) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正序遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : s) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 或者</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = s.begin(); it != s.end(); ++it) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    s.erase(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    s.erase(s.begin());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逆序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = s.rbegin(); it != s.rend(); ++it) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; -------------- &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历删除的正确做法</span></span><br><span class="line">    s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = s.begin(); it != s.end();) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*it % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            s.erase(it++);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; *(it++) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : s) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    s = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分查找</span></span><br><span class="line">    <span class="keyword">auto</span> it = s.lower_bound(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    advance(it, <span class="number">1</span>); <span class="comment">// O(len)</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    advance(it, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    advance(it, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (it == s.end()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;to end&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>unordered_set更简单，因为它是无序的，所以api’更少。</p>
<p><strong>自定义排序类型</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x != b.x ? x &lt; b.x : y &lt; b.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;Node&gt; <span class="built_in">set</span> = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">                    &#123;<span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                    &#123;<span class="number">2</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; node : <span class="built_in">set</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; node.x &lt;&lt;<span class="string">&quot;,&quot;</span> &lt;&lt; node.y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="map、unordered-map"><a href="#map、unordered-map" class="headerlink" title="map、unordered_map"></a>map、unordered_map</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line">    mp = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">          &#123;<span class="number">3</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mp[<span class="number">1</span>]++ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mp[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    mp.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 如果键已经存在，则不插入</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mp[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断存在与否</span></span><br><span class="line">    <span class="keyword">if</span> (mp.find(<span class="number">1</span>) != mp.end()) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mp.count(<span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    mp = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">          &#123;<span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">          &#123;<span class="number">5</span>, <span class="number">6</span>&#125;,</span><br><span class="line">          &#123;<span class="number">7</span>, <span class="number">8</span>&#125;&#125;;</span><br><span class="line">   	<span class="keyword">for</span>(<span class="keyword">auto</span> [k,v] : mp) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; k &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; v &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;item :mp) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; item.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; item.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = mp.rbegin(); it != mp.rend(); it++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="multiset、multimap"><a href="#multiset、multimap" class="headerlink" title="multiset、multimap"></a>multiset、multimap</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">multiset</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">multiset</span>.insert(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">multiset</span>.insert(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">multiset</span>.insert(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">multiset</span>.insert(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x : <span class="built_in">multiset</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">    mp.insert(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    mp.insert(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    mp.insert(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it:mp) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="容器的相互转换"><a href="#容器的相互转换" class="headerlink" title="容器的相互转换"></a>容器的相互转换</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(dq.begin(), dq.end())</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x : a) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">99</span>; <span class="comment">// 不影响原值</span></span><br><span class="line">    <span class="keyword">while</span> (!dq.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dq.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        dq.pop_front();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>c++</tag>
        <tag>算法题</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络协议层次</title>
    <url>/2021/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%B1%82%E6%AC%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h1><img src="osi.png" alt="image.png" style="zoom:60%;" />



<p>OSI 模型全称为开放式通信系统互连参考模型，是国际标准化组织 ( ISO ) 提出的一个试图使各种计算机在世界范围内互连为网络的标准框架。</p>
<p> OSI 将计算机网络体系结构划分为七层，每一层实现各自的功能和协议，并完成与相邻层的接口通信。</p>
<p>OSI 的服务定义详细说明了各层所提供的服务。某一层的服务就是该层及其下各层的一种能力，它通过接口提供给更高一层。各层所提供的服务与这些服务是怎么实现的无关。</p>
<p><strong>协议讲的是同一层的之间的约定，服务是底层提供给高层的功能。</strong></p>
<ul>
<li><strong>应用层</strong></li>
</ul>
<p>应用层位于 OSI 参考模型的第七层，其作用是通过应用程序间的交互来完成特定的网络应用。该层协议定义了应用<strong>进程之间</strong>的交互规则，<strong>通过不同的应用层协议为不同的网络应用提供服务</strong>。</p>
<p>例如域名系统 <em>DNS</em>，支持万维网应用的 <em>HTTP</em> 协议，电子邮件系统采用的 <em>SMTP</em> 协议等。</p>
<p>在应用层交互的数据单元我们称之为报文。</p>
<ul>
<li><strong>表示层</strong></li>
</ul>
<p>表示层的作用是使通信的应用程序能够解释交换数据的含义，其位于 OSI 参考模型的第六层，向上为应用层提供服务，向下接收来自会话层的服务。</p>
<p>该层提供的服务主要包括<em>数据压缩，数据加密以及数据描述</em>。这使得应用程序不必担心在各台计算机中表示和存储的内部格式差异。</p>
<ul>
<li><strong>会话层</strong></li>
</ul>
<p>会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层提供了<em>数据交换的定界和同步</em>功能，包括了<em>建立检查点和恢复方案</em>的方法。</p>
<ul>
<li><strong>传输层</strong></li>
</ul>
<p>传输层的主要任务是<strong>为两台主机进程之间的通信提供服务</strong>。</p>
<p>应用程序利用该服务传送应用层报文。该服务并不针对某一特定的应用，多种应用可以使用同一个传输层服务。由于一台主机可同时运行多个线程，因此传输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面传输层的服务，分用和复用相反，是传输层把收到的信息分别交付上面应用层中的相应进程。</p>
<p>在传输层交互的数据单元我们称之为<em>段</em>。</p>
<ul>
<li><strong>网络层</strong></li>
</ul>
<p>两台计算机之间传送数据时其通信链路往往不止一条，所传输的信息甚至可能经过很多通信子网。</p>
<p><strong>网络层的主要任务就是选择合适的网间路由和交换节点，确保数据按时成功传送</strong>。在发送数据时，网络层把传输层产生的报文或用户数据报封装成分组和包向下传输到数据链路层。</p>
<p><strong>在网络层使用的协议是无连接的网际协议（Internet Protocol）和许多路由协议</strong>，因此我们通常把该层简单地称为 IP 层。</p>
<p>在网络层交互的数据单元我们称之为<em>包</em>。</p>
<ul>
<li><strong>数据链路层</strong></li>
</ul>
<p>数据链路层通常也叫做链路层，在物理层和网络层之间。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层协议。</p>
<p>在两个相邻节点之间传送数据时，<strong>数据链路层将网络层交下来的 IP 数据报组装成帧</strong>，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息。通过控制信息我们可以知道一个帧的起止比特位置，此外，也能使接收端检测出所收到的帧有无差错，如果发现差错，数据链路层能够简单的丢弃掉这个帧，以避免继续占用网络资源。</p>
<p>在数据链路层交互的数据单元我们称之为<em>帧</em>。</p>
<ul>
<li><strong>物理层</strong></li>
</ul>
<p>作为 OSI 参考模型中最低的一层，<strong>物理层的作用是实现计算机节点之间比特流的透明传送</strong>，<strong>尽可能屏蔽掉具体传输介质和物理设备的差异</strong>。使其上面的数据链路层不必考虑网络的具体传输介质是什么。该层的主要任务是确定与传输媒体的接口的一些特性（机械特性、电气特性、功能特性，过程特性）。</p>
<p>在物理层交互的数据单元我们称之为<em>比特</em>。</p>
<h1 id="TCP-IP-参考模型"><a href="#TCP-IP-参考模型" class="headerlink" title="TCP/IP 参考模型"></a>TCP/IP 参考模型</h1><p> OSI 七层模型在提出时的出发点是基于标准化的考虑，而没有考虑到具体的市场需求，使得该模型结构复杂，部分功能冗余，因而完全实现 OSI 参考模型的系统不多。</p>
<p><strong>TCP/IP 参考模型直接面向市场需求，实现起来也比较容易</strong>，因此在一经提出便得到了广泛的应用。基于 TCP/IP 的参考模型将协议分成四个层次，如上图所示，它们自下而上分别是：网络访问层、网际互联层、传输层、和应用层。</p>
<ul>
<li><strong>应用层</strong></li>
</ul>
<p>TCP/IP 模型将 OSI 参考模型中的<strong>会话层、表示层和应用层的功能合并到一个应用层实现</strong>，通过不同的应用层协议为不同的应用提供服务。例如：HTTP、FTP、Telnet、DNS、SMTP 等。</p>
<ul>
<li><strong>传输层</strong></li>
</ul>
<p>该层对应于 OSI 参考模型的传输层，为上层实体提供源端到对端主机的通信功能。</p>
<p>传输层定义了两个主要协议：传输控制协议（TCP）和用户数据报协议（UDP）。其中面向连接的 TCP 协议保证了数据的传输可靠性，面向无连接的 UDP 协议能够实现数据包简单、快速地传输。</p>
<ul>
<li><strong>网际互联层</strong></li>
</ul>
<p>网际互联层对应 OSI 参考模型的网络层，主要负责相同或不同网络中计算机之间的通信。</p>
<p>在网际互联层， <strong>IP 协议提供的是一个不可靠、无连接的数据报传递服务</strong>。</p>
<p><strong>IP协议本身是不可靠的，存在着丢包、延时、无序等问题。</strong></p>
<p>该协议实现两个基本功能：<strong>寻址和分段</strong>。根据数据报报头中的目的地址将数据传送到目的地址，在这个过程中 IP 负责选择传送路线。</p>
<p>除了 IP 协议外，该层另外两个主要协议是互联网组管理协议（IGMP）和互联网控制报文协议（ICMP）。</p>
<ul>
<li><strong>网络接入层</strong></li>
</ul>
<p><strong>网络接入层的功能对应于 OSI 参考模型中的物理层和数据链路层</strong>，它负责监视数据在主机和网络之间的交换。事实上，<strong>TCP/IP 并未真正描述这一层的实现</strong>，而由参与互连的各网络使用自己的物理层和数据链路层协议，然后与 TCP/IP 的网络接入层进行连接，因此具体的实现方法将随着网络类型的不同而有所差异。</p>
<p><strong>TCP/IP 五层参考模型</strong></p>
<p>五层体系的协议结构是综合了 OSI 和 TCP/IP 优点的一种协议，包括应用层、传输层、网络层、数据链路层和物理层。其中应用层对应 OSI 的上三层，下四层和 OSI 相同。五层协议的体系结构只是为介绍网络原理而设计的，实际应用还是 TCP/IP 四层体系结构。</p>
<p>在《计算机网络》一书中也是根据这个层次划分进行编排的。</p>
<h1 id="OSI-模型和-TCP-IP-模型异同比较"><a href="#OSI-模型和-TCP-IP-模型异同比较" class="headerlink" title="OSI 模型和 TCP/IP 模型异同比较"></a>OSI 模型和 TCP/IP 模型异同比较</h1><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><p>① OSI 参考模型与 TCP/IP 参考模型都采用了层次结构。</p>
<p>② 都能够提供<strong>面向连接</strong>和<strong>无连接</strong>两种通信服务机制。</p>
<p>无连接套接字传输效率高，但是不可靠，有丢失数据包，捣乱数据的风险<br>如果注重效率和实时性，就选择无连接套接字（UDP服务），比如DNS和即时聊天软件等。<br>有连接套接字非常可靠，万无一失，但是传输效率低，耗费资源多<br>如果对数据完整性的要求高，就选择有连接套接字（TCP服务），比如HTTP和FTP等。</p>
<h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><p>① OSI 采用的七层模型； TCP/IP 是四层结构。</p>
<p>② TCP/IP 参考模型没有对网络接口层进行细分，只是一些概念性的描述； OSI 参考模型对服务和协议做了明确的区分。</p>
<p>③ OSI 先有模型，后有协议规范，适合于描述各种网络；TCP/IP 是先有协议集然后建立模型，不适用于非 TCP/IP 网络。</p>
<p>④ TCP/IP 一开始就提出面向连接和无连接服务，而 OSI 一开始只强调面向连接服务，直到很晚才开始制定无连接的服务标准。</p>
<p>⑤ OSI 参考模型虽然被看好，但将网络划分为七层，实现起来较困难；相反，TCP/IP 参考模型虽然有许多不尽人意的地方，但作为一种简化的分层结构还是比较成功的。</p>
<h2 id="为什么-TCP-IP-去除了表示层和会话层"><a href="#为什么-TCP-IP-去除了表示层和会话层" class="headerlink" title="为什么 TCP/IP 去除了表示层和会话层"></a>为什么 TCP/IP 去除了表示层和会话层</h2><p>OSI 参考模型在提出时，他们的理想是非常好的，但实际上，由于会话层、表示层、应用层都是在应用程序内部实现的，最终产出的是一个应用数据包，而应用程序之间是几乎无法实现代码的抽象共享的，这也就造成 OSI 设想中的应用程序维度的分层是无法实现的，例如，我们几乎不会认为数据的压缩、加密算法算是一种协议，而会话的概念则更为抽象，难以用协议来进行描述，所以在后来的 TCP/IP 协议框架的设计中，便将表示层和会话层与应用层整合在一起，让整个过程更为清晰明了。</p>
<blockquote>
<p>三层都在应用程序内实现，程序间无法共享，合三为一；</p>
</blockquote>
<h2 id="数据如何在各层之间传输（数据的封装过程）"><a href="#数据如何在各层之间传输（数据的封装过程）" class="headerlink" title="数据如何在各层之间传输（数据的封装过程）"></a>数据如何在各层之间传输（数据的封装过程）</h2><p>在发送主机端：</p>
<ol>
<li><p><strong>应用层</strong>向<strong>传输层</strong>传递应用层的报文：传输层收取到报文并附上附加信息，该首部将被接收端的传输层使用。应用层报文和传输层首部信息一道构成了传输层报文段。附加的信息可能包括：允许接收端传输层向上向适当的应用程序交付<strong>报文的信息</strong>以及<strong>差错检测位</strong>信息,该信息让接收端能够判断报文中的比特是否在途中已被改变。</p>
</li>
<li><p><strong>传输层</strong>向<strong>网络层</strong>传递该报文段：<strong>网络层增加了如源和目的端系统地址等网络层首部信息</strong>，生成了网络层数据报。</p>
</li>
<li><p><strong>网络层</strong>向<strong>链路层</strong>传递该分组，<strong>在数据链路层数据包添加发送端 MAC 地址和接收端 MAC 地址</strong>后被封装成数据帧。</p>
</li>
<li><p><strong>链路层</strong>向<strong>物理层</strong>传递帧：在物理层数据帧被封装成比特流，之后通过传输介质传送到对端。</p>
</li>
</ol>
<p><strong>应用数据报→传输层报文段→网络层成组→链路层成帧→物理层比特流</strong></p>
<h1 id="OSI-和-TCP-IP-协议之间的对应关系"><a href="#OSI-和-TCP-IP-协议之间的对应关系" class="headerlink" title="OSI 和 TCP/IP 协议之间的对应关系"></a>OSI 和 TCP/IP 协议之间的对应关系</h1><table>
<thead>
<tr>
<th>OSI 七层网络模型</th>
<th>TCP/IP 四层概念模型</th>
<th>对应的网络协议</th>
</tr>
</thead>
<tbody><tr>
<td>应用层（Application）</td>
<td>应用层</td>
<td>HTTP, TFTP, FTP, NFS, WAIS, SMTP, Telnet, DNS, SNMP</td>
</tr>
<tr>
<td>表示层（Presentation）</td>
<td>~</td>
<td>TIFF, GIF, JPEG, PICT</td>
</tr>
<tr>
<td>会话层（Session）</td>
<td>~</td>
<td>RPC, SQL, NFS, NetBIOS, names, AppleTalk</td>
</tr>
<tr>
<td>传输层（Transport）</td>
<td>传输层</td>
<td>TCP, UDP</td>
</tr>
<tr>
<td>网络层（Network）</td>
<td>网络层</td>
<td>IP, ICMP, ARP, RARP, RIP, IPX</td>
</tr>
<tr>
<td>数据链路层（Data Link）</td>
<td>数据链路层</td>
<td>FDDI, Frame Relay, HDLC, SLIP, PPP</td>
</tr>
<tr>
<td>物理层（Physical）</td>
<td>~</td>
<td>EIA/TIA-232, EIA/TIA-499, V.35, 802.3</td>
</tr>
</tbody></table>
<p>在TCP/IP模型中，ARP协议属于网络层；在OSI模型中，ARP协议属于链路层。</p>
<blockquote>
<p>其实在书上说在哪里都可以啊<br>ARP 其实是介于数据链路层和网络层之间的协议的。</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>OSI</tag>
      </tags>
  </entry>
  <entry>
    <title>架构</title>
    <url>/2021/09/07/%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="12306究竟难在哪里"><a href="#12306究竟难在哪里" class="headerlink" title="12306究竟难在哪里"></a>12306究竟难在哪里</h1><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><h3 id="12306-的业务数据量"><a href="#12306-的业务数据量" class="headerlink" title="12306 的业务数据量"></a>12306 的业务数据量</h3><p><a href="https://zhuanlan.zhihu.com/p/31074574">https://zhuanlan.zhihu.com/p/31074574</a></p>
<h3 id="大数据时代"><a href="#大数据时代" class="headerlink" title="大数据时代"></a>大数据时代</h3><p>互联网三高架构：高并发、高性能、高可用，简称三高（3H）<br>互联网应用系统开发肯定经常会看到高并发和高性能这两个词，可谓是耳熟能详。<br>对于12306这样的国民级应用来说，3H能否做到，直接关系到使用者的体验——也就是春运时能否安然买到火车票回家。</p>
<p>像12306这样如此大规模的分布式架构系统，深入研究其架构基础来说对于我们还为时尚早，<br>但是罗马不是一天建成的，此次数据课课设我也不妨从几个技术点，结合当前主流的工具去实践一番，探究其中数据库层面可能遇到的技术瓶颈, 从而窥一斑而见全豹，深化自身对数据库的理解，加强使用的熟练度。</p>
<h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><p>集群：一主多从（读写分离的配置）mysql binlog</p>
<p>分布式：数据分片  sharding、mycat</p>
<h4 id="SOA（分布式服务系统）"><a href="#SOA（分布式服务系统）" class="headerlink" title="SOA（分布式服务系统）"></a>SOA（分布式服务系统）</h4><p>面向服务的体系结构（英语：service-oriented architecture）并不特指一种技术，而是一种分布式运算的软件设计方法。软件的部分组件（调用者），可以透过网络上的通用协议调用另一个应用软件组件运行、运作，让调用者获得服务。SOA原则上采用开放标准、与软件资源进行交互并采用表示的标准方式。因此应能跨越厂商、产品与技术。一项服务应视为一个独立的功能单元，可以远程访问并独立运行与更新，例如在线查询信用卡账单。</p>
<p>图</p>
<h3 id="高并发-与-高性能"><a href="#高并发-与-高性能" class="headerlink" title="高并发 与 高性能"></a>高并发 与 高性能</h3><p>高效的IO、高效的计算、流量的负载均衡</p>
<h2 id="高效的IO"><a href="#高效的IO" class="headerlink" title="高效的IO"></a>高效的IO</h2><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>读多写少的二八法则在计算机世界里到处都是，下面从三个层面的缓存去深化对缓存的使用。</p>
<h4 id="innodb"><a href="#innodb" class="headerlink" title="innodb"></a>innodb</h4><p>innodb-buffer-pool设置多大<br>Innodb buffer pool缓存池中包含数据的页的数目，包括脏页。单位是page。</p>
<p>innodb_buffer_pool_size 参数为innodb_buffer_pool的大小设置。<br>innodb_buffer_pool_chunk_size参数为InnoDB缓冲池块大小。<br>innodb_buffer_pool_instances参数为缓冲池实例的个数。</p>
<p>规则：<br>innodb_buffer_pool_size = innodb_buffer_pool_chunk_size * innodb_buffer_pool_instances *N</p>
<p>系统默认的innodb_buffer_pool_chunk_size为128M<br>innodb_buffer_pool_instances参数的默认设置为1 最大设置为64 ，但是将innodb_buffer_pool_size大小设置为1GB或更大时，此选项才生效。（主要是防止有太多小的instance从而导致性能问题。）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@innodb</span>_buffer_pool_size<span class="operator">/</span><span class="number">1024</span><span class="operator">/</span><span class="number">1024</span><span class="operator">/</span><span class="number">1024</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> innodb_buffer_pool_size <span class="operator">=</span> <span class="number">4227858432</span>;</span><br></pre></td></tr></table></figure>


<p>建议设置为系统内存的50%-80%，但也不是越大越好，要根据具体项目具体分析（操作系统留1G左右，mysql连接数*4M，宿主程序缓存nM）。</p>
<p>查看缓冲池状态</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;Innodb_buffer_pool_%&#x27;</span></span><br></pre></td></tr></table></figure>
<p>变量解析<br>Innodb_buffer_pool_pages_total参数表示缓存页面的总数量;<br>Innodb_buffer_pool_pages_data代表有数据的缓存页数;<br>Innodb_buffer_pool_pages_free代表没有使用的缓存页数;<br>Innodb_buffer_pool_pages_misc: innodb buffer pool缓存池中当前已经被用作管理用途或hash index而不能用作为普通数据页的数目。</p>
<p>Innodb_buffer_pool_read_requests表示read请求的次数，<br>Innodb_buffer_pool_reads表示从物理磁盘中读取数据的请求次数，</p>
<p>innodb buffer的read命中率 =（Innodb_buffer_pool_read_requests - Innodb_buffer_pool_reads） / Innodb_buffer_pool_read_requests * 100%。<br>如果这个命中率小于95%，建议增大 innodb_buffer_pool_size</p>
<p>如果Innodb_buffer_pool_pages_free偏大的话，证明有很多缓存没有被利用到，这时可以考虑减小缓存;<br>相反Innodb_buffer_pool_pages_data过大就考虑增大缓存。</p>
<p>配置建议规则 （来自 阿里RDS配置参考）<br>| 实例内存大小（单位：MB） | 默认Buffer Pool（单位：MB） | 推荐最大Buffer Pool（单位：MB） |<br>| :———————– | :————————– | :—————————— |<br>| 1024                     | 256                         | 256                             |<br>| 2048                     | 512                         | 512                             |<br>| 4096                     | 1536                        | 1536                            |<br>| 8192                     | 4608                        | 4608                            |<br>| 16384                    | 12288                       | 12288                           |<br>| 24576                    | 18432                       | 19456                           |<br>| 32768                    | 24576                       | 25600                           |<br>| 49152                    | 36864                       | 38912                           |<br>| 65536                    | 49152                       | 52224                           |<br>| 98304                    | 73728                       | 77824                           |<br>| 131072                   | 98304                       | 104448                          |<br>| 196608                   | 147456                      | 156672                          |<br>| 229376                   | 172032                      | 183296                          |<br>| 262144                   | 196608                      | 208896                          |<br>| 393216                   | 294912                      | 314368                          |<br>| 491520                   | 368640                      | 393216                          |<br>| 786432                   | 589824                      | 628736                          |</p>
<h4 id="mybatis-一级缓存、二级缓存"><a href="#mybatis-一级缓存、二级缓存" class="headerlink" title="mybatis 一级缓存、二级缓存"></a>mybatis 一级缓存、二级缓存</h4><h5 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h5><p>查询时：只要两条SQL的下列五个值相同，即可以认为是相同的SQL。<br>Statement Id + Offset + Limmit + Sql + Params</p>
<p>更新时：每次执行update前都会清空localCache,避免脏读</p>
<ol>
<li>MyBatis一级缓存的生命周期和SqlSession一致，级缓存只在数据库会话内部共享。</li>
<li>MyBatis一级缓存内部设计简单，只是一个没有容量限定的HashMap，在缓存的功能性上有所欠缺。</li>
<li>MyBatis的一级缓存最大范围是SqlSession内部，有多个SqlSession或者分布式的环境下，数据库写操作会引起旧数据（不过考虑到mysql的MVCC下的RR，也是有价值的），建议设定缓存级别为Statement。</li>
</ol>
<h5 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h5><p>二级缓存 -&gt; 一级缓存 -&gt; 数据库。</p>
<p>当sqlsession没有调用commit()方法时，二级缓存并没有起到作用。<br>（但是在spring容器管理下的sqlsession 在没有开启事务的时，是不会commit的，二级缓存根本用不上）<br>即使是在 @Transactional 下，又有多少会在事务里调用同一段sql呢？</p>
<ol>
<li>MyBatis的二级缓存相对于一级缓存来说，实现了SqlSession之间缓存数据的共享，同时粒度更加的细，能够到namespace级别，通过Cache接口实现类不同的组合，对Cache的可控性也更强。</li>
<li>MyBatis在多表查询时，极大可能会出现脏数据，有设计上的缺陷，安全使用二级缓存的条件比较苛刻。</li>
<li>在分布式环境下，由于默认的MyBatis Cache实现都是基于本地的，分布式环境下必然会出现读取到脏数据，需要使用集中式缓存将MyBatis的Cache接口实现，有一定的开发成本，直接使用Redis、Memcached等分布式缓存可能成本更低，安全性也更高。</li>
</ol>
<h4 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h4><p>略去<br>更新逻辑</p>
<h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><h3 id="数据分片"><a href="#数据分片" class="headerlink" title="数据分片"></a>数据分片</h3><p>分库分表的需要</p>
<p>垂直分片<br>图<br>水平分片<br>图</p>
<p>分库分表带来的问题：</p>
<ol>
<li>维护困难</li>
<li>sql的支持度</li>
<li>跨库事务</li>
<li>跨库Join<br>后面会结合项目的具体问题进行细讲</li>
</ol>
<h3 id="数据库集群"><a href="#数据库集群" class="headerlink" title="数据库集群"></a>数据库集群</h3><p>数据分片与主从复制</p>
<p>主库会生成一个 log dump 线程,用来给从库 I/O 线程传 Binlog 数据。</p>
<p>从库的 I/O 线程会去请求主库的 Binlog，并将得到的 Binlog 写到本地的 relay log (中继日志)文件中。</p>
<p>SQL 线程,会读取 relay log 文件中的日志，并解析成 SQL 语句逐一执行。</p>
<h5 id="主节点-log-dump-线程"><a href="#主节点-log-dump-线程" class="headerlink" title="主节点 log dump 线程"></a>主节点 log dump 线程</h5><p>当从节点连接主节点时，主节点会为其创建一个 log dump 线程，用于发送和读取 Binlog 的内容。在读取 Binlog 中的操作时，log dump 线程会对主节点上的 Binlog 加锁；当读取完成发送给从节点之前，锁会被释放。<strong>主节点会为自己的每一个从节点创建一个 log dump 线程</strong>。</p>
<h5 id="从节点I-O线程"><a href="#从节点I-O线程" class="headerlink" title="从节点I/O线程"></a>从节点I/O线程</h5><p>当从节点上执行<code>start slave</code>命令之后，从节点会创建一个 I/O 线程用来连接主节点，请求主库中更新的Binlog。I/O 线程接收到主节点的 log dump 进程发来的更新之后，保存在本地 relay-log（中继日志）中。</p>
<h5 id="relay-log"><a href="#relay-log" class="headerlink" title="relay log"></a>relay log</h5><p>这里又引申出一个新的日志概念。MySQL 进行主主复制或主从复制的时候会在要复制的服务器下面产生相应的 relay log。</p>
<p>relay log 是怎么产生的呢？</p>
<p>从服务器 I/O 线程将主服务器的 Binlog 日志读取过来，解析到各类 Events 之后记录到从服务器本地文件，这个文件就被称为 relay log。然后 SQL 线程会读取 relay log 日志的内容并应用到从服务器，从而使从服务器和主服务器的数据保持一致。中继日志充当缓冲区，这样 master 就不必等待 slave 执行完成才发送下一个事件。</p>
<h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><h3 id="列车、站点与图论模型"><a href="#列车、站点与图论模型" class="headerlink" title="列车、站点与图论模型"></a>列车、站点与图论模型</h3><p>列车抽象为图论中的路径<br>车站抽象为图论中的点</p>
<p>不过，上述的建模还不够全面，这仅仅是对静态结构的描述，还要加上时间这个维度。</p>
<p>在本次系统实现中，使用Quartz的CronTrigger（基于日历的调度，可精确到秒），进行列车状态变化的驱动。<br>相比于SpringBoot 的  @Scheduled 调度强大的多。</p>
<p>（真实环境下，也许是列车驾驶员人工去发送信息）。</p>
<h3 id="ER图"><a href="#ER图" class="headerlink" title="ER图"></a>ER图</h3><h3 id="业务量究竟大在哪里"><a href="#业务量究竟大在哪里" class="headerlink" title="业务量究竟大在哪里"></a>业务量究竟大在哪里</h3><p>电商最头疼的是什么模块？</p>
<p>订单？支付？都不是，是库存！！！</p>
<p>为什么？因为库存是<strong>多读多写</strong>的场景，是整个性能的瓶颈！</p>
<p>订单，就用户一个人可以写，你爱怎么改怎么改，分布式也好做，因为只有单写。</p>
<p>库存不一样，同一个sku每个订单都要改库存，这太恐怖了，一般电商还可以通过分仓库，预分配等手段解决，火车票你怎么搞！！分仓库？哦，今天北京发往上海的G123车钱，华北地区还有三张票，西南地区库存为0？不可能！！！全国人民在极短的时间内，大量订单抢同一个库存，这本来就已经非常困难了，再加上，几乎所有热门车票都特么这么抢！而且，一列火车，由于乘客的起始站和终点站不同，可以逻辑上分成多种商品，但这些商品又相互有库存关联，无法划为独立sku…想想就头疼，再加上在多写的库上做分布式，同步问题又是老大难。所以，12306非常困难！！</p>
<h3 id="库存是什么-——-火车售票的余票算法"><a href="#库存是什么-——-火车售票的余票算法" class="headerlink" title="库存是什么? —— 火车售票的余票算法"></a>库存是什么? —— 火车售票的余票算法</h3><h4 id="路径节点对构成-sku"><a href="#路径节点对构成-sku" class="headerlink" title="路径节点对构成 sku"></a>路径节点对构成 sku</h4><p>网上自称某宝工程师写的12306文章。他们将<strong>路径上的每个站点对</strong>独立成一件商品，每次购、退票都需要查询删改库存，造成巨大的数据库操作开销。</p>
<p>将每站点全部商品位化，是为了<strong>营造高并发的假象</strong>而已，白白浪费了计算资源。以每趟车2000张票为例子。</p>
<p>某宝的工程师算法逻辑是直接操作库的逻辑，那么将数据库映射成为bmp处理，但这又带来新的问题，比如锁定机制，数据同步机制，写入仲裁机制，这些在本算法中由天然的cpu硬件机制来实施。与硬件有一致性，机制成熟算法健壮性有保证。如果人为的另立机制想拓展bmp算法的性能会导致很多问题，</p>
<h4 id="站点座位bitmap法"><a href="#站点座位bitmap法" class="headerlink" title="站点座位bitmap法"></a>站点座位bitmap法</h4><p>抢票的基本单位是某一列列车。</p>
<p>对此列列车经过的所有站点都创建等容量大小的位图（容量大小为座位数量）—— 当然，如果有多个类型的座位，同理每种类型都创建位图即可。</p>
<p>位图0表示空闲，1表示已占。</p>
<p>用户每次买票获取此列车对应所有中途站点的位图，对这些位图（或者说二进制串）做位运算，</p>
<p>运算结果为1的表明不能被购买（只要有一个为1，就不能购买），为0的表明还没有人购买，可以售出。</p>
<h2 id="”库存“扣减的问题"><a href="#”库存“扣减的问题" class="headerlink" title="”库存“扣减的问题"></a>”库存“扣减的问题</h2><h3 id="超卖问题的解决"><a href="#超卖问题的解决" class="headerlink" title="超卖问题的解决"></a>超卖问题的解决</h3><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>悲观锁（Pessimistic Lock），顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。</p>
<p>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。</p>
<p>Java synchronized、ReentrantLock 就属于悲观锁的一种实现，每次线程要修改数据时都先获得锁，保证同一时刻只有一个线程能操作数据，其他线程则会被block。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> UPDATE;</span><br></pre></td></tr></table></figure>


<h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>乐观锁（Optimistic Lock），顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。乐观锁适用于读多写少的应用场景，这样可以提高吞吐量。</p>
<p>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</p>
<p>使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">UPDATE ... SET ... = ... WHERE version = #&#123;version&#125;</span><br></pre></td></tr></table></figure>



<h4 id="自适应锁"><a href="#自适应锁" class="headerlink" title="自适应锁"></a>自适应锁</h4><p>不要有一种错觉，觉得乐观锁实现了无锁并发安全，就觉得乐观锁的性能远远优越悲观锁，</p>
<p>这个是有几个前提的，读多写少，竞争程度不激烈，短事务。（总而言之，减少因为乐观锁加锁失败重试的次数）</p>
<p>解决方案：<br>借鉴JUC源码中对于volatile变量的使用，多一次尝试volatile读从而尽可能避免volatile写的高额开销。</p>
<p>所以，我的策略是，对于上述两种加锁方式，同时予以实现。<br>具体的，默认先使用乐观锁并发修改数据，同时设定乐观锁失败重试次数做多为1次（可以根据实际情况修改配置），如果仍然未修改成功，再改用悲观锁进行竞争修改数据。</p>
<h2 id="技术难点举例"><a href="#技术难点举例" class="headerlink" title="技术难点举例"></a>技术难点举例</h2><h3 id="分片键与索引"><a href="#分片键与索引" class="headerlink" title="分片键与索引"></a>分片键与索引</h3><p>跨库join的问题：<br>如何调节分片键与索引的矛盾: 冗余。</p>
<ol>
<li>全量冗余</li>
<li>关系冗余</li>
</ol>
<p>举例:<br>order表</p>
<h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><h4 id="XA"><a href="#XA" class="headerlink" title="XA"></a>XA</h4><h4 id="Seata-的-AT"><a href="#Seata-的-AT" class="headerlink" title="Seata 的 AT"></a>Seata 的 AT</h4>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>计算机网络面试问题汇总</title>
    <url>/2021/11/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SYN-FLOOD"><a href="#SYN-FLOOD" class="headerlink" title="SYN FLOOD"></a>SYN FLOOD</h1><p>SYN Flood 是种典型的 DoS（拒绝服务）攻击，其目的是通过消耗服务器所有可用资源使服务器无法用于处理合法请求。通过重复发送初始连接请求（SYN）数据包，攻击者能够压倒目标服务器上的所有可用端口，导致目标设备根本不响应合法请求。</p>
<h2 id="SYN攻击的原理"><a href="#SYN攻击的原理" class="headerlink" title="SYN攻击的原理"></a>SYN攻击的原理</h2><p>在 TCP 建立连接的过程中，<strong>因为服务端不确定自己发给客户端的 SYN-ACK 消息或客户端反馈的 ACK 消息是否会丢在半路，所以会给每个待完成的半开连接状态设一个定时器</strong>，如果超过时间还没有收到客户端的 ACK 消息，则重新发送一次 SYN-ACK 消息给客户端，直到重试超过一定次数时才会放弃。</p>
<p><strong>服务端为了维持半开连接状态，需要分配内核资源维护半开连接</strong>。当攻击者伪造海量的虚假 IP 向服务端发送 SYN 包时，就形成了 SYN FLOOD 攻击。攻击者故意不响应 ACK 消息，导致服务端被大量注定不能完成的半开连接占据，直到资源耗尽，停止响应正常的连接请求。</p>
<p><strong>SYN flood攻击目前有两种方法，不过都与服务端没收到<em>ACK</em>有关</strong>。恶意用户可以跳过发送最后的<em>ACK</em>信息；或者在<em>SYN</em>里通过欺骗来源IP地址，这让服务器送<em>SYN-ACK</em>到假造的IP地址，因此永不可能收到<em>ACK</em>。这两个案例服务器会花点时间等待ACK通知，故一个简单的网络拥塞可能是由于没有<em>ACK</em>造成的。</p>
<p>解决方法：</p>
<ol>
<li><p>直接的方法是<strong>提高 TCP 端口容量</strong>，<strong>减少半开连接的资源占用时间</strong>，然而该方法只是稍稍提高了防御能力，算不上解决问题；</p>
</li>
<li><p><strong>部署能够辨别恶意 IP 的路由器</strong>，将伪造 IP 地址的发送方发送的 SYN 消息过滤掉，该方案作用一般不是太大；</p>
</li>
<li><p><strong>SYN Cache</strong>：该方法首先<strong>构造一个全局 Hash Table，用来缓存系统当前所有的半开连接信息</strong>。在 Hash Table 中的每个桶的容量大小是有限制的，<del>当桶满时，会主动丢掉早来的信息</del>。</p>
<p><strong>当服务端收到一个 SYN 消息后，会通过一个映射函数生成一个相应的 Key 值，使得当前半连接信息存入相应的桶中</strong>。<strong>当收到客户端正确的ack报文后，服务端才开始分配传输资源块</strong>，并将相应的半开连接信息从表中删除。<strong>和服务器传输资源相比，维护表的开销要小得多</strong>。</p>
</li>
<li><p><strong>SYN Cookie</strong>：<strong>服务端通过特定的算法将半开连接信息编码成序列号或者时间戳</strong>，<strong>用作服务端给客户端的消息编号，随 SYN-ACK 消息一同返回给连接发起方</strong>，这样<strong>在连接建立完成前服务端不保存任何信息</strong>，<strong>直到发送方发送 ACK 确认报文并且服务端成功验证编码信息后，服务端才开始分配传输资源</strong>。若请求方是攻击者，则不会向服务端会 ACK 消息，由于未成功建立连接，因此服务端并没有花费任何额外的开销。</p>
<p>然而该方案也存在一些缺点，<strong>由于服务端并不保存半开连接状态，因此也就丧失了超时重传的能力</strong>，这在一定程度上降低了正常用户的连接成功率。此外，客户端发送给服务端的确认报文存在传输丢失的可能，当 ACK 确认报文丢失时，服务端和客户端会对连接的成功与否产生歧义，此时就需要上层应用采取相应的策略进行处理了。</p>
</li>
</ol>
<blockquote>
<p><a href="https://zh.wikipedia.org/wiki/SYN_cookie">SYN cookie wiki</a></p>
<p>发起一个 TCP 连接时，客户端将一个 TCP SYN 包发送给服务器。作为响应，服务器将 TCP SYN + ACK 包返回给客户端。此数据包中有一个<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE#.E5.BA.8F.E5.88.97.E5.8F.B7.E5.92.8C.E7.A1.AE.E8.AE.A4">序号</a>（sequence number，TCP头中的第二个32 bit），它被 TCP 用来重新组装数据流。根据 TCP 规范，由端点发送的第一个序号可以是由该端点决定的任何值。SYN Cookies 是根据以下规则构造的初始序号：</p>
<ul>
<li>令 <strong>t</strong> 为一个缓慢递增的时间戳（通常为 <code>time() &gt;&gt; 6 </code>，提供 64 秒的分辨率）；</li>
<li>令 <strong>m</strong> 为服务器会在 SYN 队列条目中存储的<a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E5%88%86%E6%AE%B5%E5%A4%A7%E5%B0%8F">最大分段大小</a>（maximum segment size，简称为 MSS）；</li>
<li>令 <strong>s</strong> 为一个加密<a href="https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E7%AE%97%E6%B3%95">散列</a>函数对服务器和客户端各自的 IP 地址和端口号以及 <strong>t</strong> 进行运算的结果。返回得到的数值 <strong>s</strong> 必须是一个24位值。</li>
</ul>
<p>初始 TCP 序号，也就是所谓的 <em>SYN cookie</em>，按照如下算法得到：</p>
<ul>
<li>头五位：<strong>t</strong> <a href="https://zh.wikipedia.org/wiki/%E5%90%8C%E4%BD%99">mod</a> 32；</li>
<li>中三位：<strong>m</strong> 编码后的数值；</li>
<li>末24位：<strong>s</strong> 本身；</li>
</ul>
<p>注：由于 <em>m</em> 必须用 3 位进行编码，服务器在启用了 SYN Cookie 时只能为 <em>m</em> 发送八种不同的数值。</p>
<p>根据 TCP 规范，当客户端发回 TCP ACK 包给服务器以响应服务器的 SYN + ACK 包时，客户端必须使用由服务器发送的初始序号加1作为数据包中的确认号。服务器接着从确认号中减去 1 以便还原向客户端发送的原始 SYN Cookie。</p>
<p>接下来服务器进行以下检查：</p>
<ul>
<li>根据当前的时间以及 <strong>t</strong> 来检查连接是否过期。</li>
<li>重新计算 <strong>s</strong> 来确认这是不是一个有效的 SYN Cookie。</li>
<li>从 3 位编码中解码 <strong>m</strong>，以便之后用来重建 SYN 队列条目。在此之后，连接照常进行。</li>
</ul>
</blockquote>
<p><a href="https://zh.wikipedia.org/wiki/SYN_flood">SYN flood Wiki</a></p>
<h1 id="从浏览器输入域名到显示出网页的过程"><a href="#从浏览器输入域名到显示出网页的过程" class="headerlink" title="从浏览器输入域名到显示出网页的过程"></a>从浏览器输入域名到显示出网页的过程</h1><p><a href="https://www.cnblogs.com/lepeCoder/p/15147895.html">https://www.cnblogs.com/lepeCoder/p/15147895.html</a></p>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h2 id="TCP-粘包问题"><a href="#TCP-粘包问题" class="headerlink" title="TCP 粘包问题"></a>TCP 粘包问题</h2><p><strong>为什么会发生TCP粘包和拆包?</strong></p>
<p>① 发送方写入的数据大于套接字缓冲区的大小，此时将发生拆包。</p>
<p>② 发送方写入的数据小于套接字缓冲区大小，由于 TCP 默认使用 Nagle 算法，只有当收到一个确认后，才将分组发送给对端，当发送方收集了多个较小的分组，就会一起发送给对端，这将会发生粘包。</p>
<p>③ 进行 MSS （最大报文长度）大小的 TCP 分段，当 TCP 报文的数据部分大于 MSS 的时候将发生拆包。</p>
<p>④ 发送方发送的数据太快，接收方处理数据的速度赶不上发送端的速度，将发生粘包。</p>
<p><strong>常见解决方法</strong></p>
<p>① <strong>在消息的头部添加消息长度字段</strong>，服务端获取消息头的时候解析消息长度，然后向后读取相应长度的内容。</p>
<p>② 固定消息数据的长度，服务端每次读取既定长度的内容作为一条完整消息，当消息不够长时，空位补上固定字符。但是该方法会浪费网络资源。</p>
<p>③ <strong>设置消息边界，也可以理解为分隔符</strong>，服务端从数据流中按消息边界分离出消息内容，一般使用换行符。</p>
<blockquote>
<ol>
<li><p>单看传输层，TCP是「面向字节流」传输的，本身是没有「包」的概念的，接收方将接收的报文段（segment）的数据提取出来按序放置在缓存中。</p>
</li>
<li><p>但是从应用层的角度看是有「包」的概念的，例如http/1.1中采用了「管道(pipeline)」的思想，即可以多个http数据流「复用」同一个TCP，因此各个http数据流之间是「纠缠」的，那么就需要在应用层进行处理，「区分不同」的数据流，自然就需要处理「粘包」的问题。</p>
</li>
<li><p>个人认为TCP层没有「包」的概念反映了TCP层对应用层「多数据流」的支持较弱，这恰恰导致了粘包问题。而这种弱势也导致了HTTP/3转向了QUIC，也就是基于UDP，自行实现更好的「多数据流复用/分用」。</p>
</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题详解</title>
    <url>/2021/11/10/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><p>Model: 给定n个物品，第i个物品的体积为Vi,价值为Wi.背包容积为m。每件物品最多选择一次，总体积不超过m,要求总价值最大。</p>
<p> <strong>01背包，时间复杂度 O(nm),空间复杂度 O(nm)</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,w[maxn],v[maxn],f[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;w[i],&amp;v[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++) f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=v[i];j&lt;=m;j++) f[i][j] = max(f[i][j],f[i<span class="number">-1</span>][j-v[i]]+w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打表观察</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,f[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>状态表示</strong>：$f[i][j]$表示把 1，2，……i共 <strong>i</strong> 个物品放入容量为 <strong>j</strong> 的背包中所获得的最大价值。<br><strong>DP方程：</strong></p>
<p>$$f[i][j]=max\begin{cases}<br>f[i-1][j]，不选第i个物品\<br>f[i-1][j-v[i]]+w[i]，if(j&gt;=v[i]),选第i个物品<br>\end{cases}$$</p>
<p>样例<br>n=,m=15;<br>w[]  2 3 4 5 10<br>v[]   2 3 3 4 7<br><em>动态结果</em><br><img src="https://img-blog.csdnimg.cn/20200208195835563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0ODQ2MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>最终答案为  f [n] [m]</p>
<p>用<strong>滚动数组</strong>进行优化<br>空间复杂度被优化为 O(m)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> d[maxn];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;=v[i]) d[j]=max(d[j],d[j-v[i]]+w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>先使用，后更新</strong><br><strong>j</strong> 必须使用倒序循环，才保证先使用 <strong>i-1</strong> 阶段的状态，之后再更新为 <strong>i</strong> 阶段的状态，i.e. 要保证每个物品只加入一次。</p>
<h3 id="小栗子"><a href="#小栗子" class="headerlink" title="小栗子"></a>小栗子</h3><p>—<a href="https://vjudge.net/problem/OpenJ_Bailian-4004">数字组合方案</a><br>Description：给定整数a1、a2、…an，判断是否可以从中选出若干数，使它们的和恰好为m,求方案总数。</p>
<p>状态表示：f[i][j] 前 <strong>i</strong> 个数组合得到和为 <strong>j</strong> 的方案总数<br>DP方程：$f[i][j]=f[i-1][j]+f[i-1][j-a[i]]$<br>分别对应不取a[i]，取a[i]。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n,m,f[<span class="number">1000</span>][<span class="number">1000</span>],a[<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        f[i][<span class="number">0</span>]=<span class="number">1</span>; <span class="comment">// 边界值</span></span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;a[i];j++) f[i][j]= f[i<span class="number">-1</span>][j];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=a[i];j&lt;=m;j++) f[i][j]= f[i<span class="number">-1</span>][j]+f[i<span class="number">-1</span>][j-a[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打表观察</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;f[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[n][m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200208205516607.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0ODQ2MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>滚动数组优化</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n,m,f[<span class="number">10005</span>],a;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="comment">//边界值，即前i个数组合，和为0的方案数，方案数为1，也就是，前i个数都不取</span></span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);  <span class="comment">//可以边读入边运算</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=a;j--)&#123;</span><br><span class="line">            f[j]+=f[j-a];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p>Model :  给定n个物品，第i个物品的体积为Vi,价值为Wi.背包容积为m。<strong>每件物品可以选择无数次</strong>，总体积不超过m,要求总价值最大。</p>
<p><strong>状态表示</strong>：<code>f[i][j]</code>表示把 1，2，……i共 <strong>i</strong> 个物品放入容量为 <strong>j</strong> 的背包中所获得的最大价值。<br><strong>DP方程：</strong></p>
<p>$$f[i][j]=max\begin{cases}<br>f[i-1][j],从未选过第i种物品\<br>f[i][j-v[i]]+w[i]，if (j&gt;=v[i]) 从第i种物品中选择一个<br>\end{cases}$$</p>
<p>在 01背包中，使用倒序循环遍历 j ,限制了每种物品最多使用一次，<br>自然，正序循环的话，每个物品就可以重复加入。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;v,&amp;w);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=v;j&lt;=m;j++)&#123;</span><br><span class="line">        f[j] = max(f[j],f[j-v]+w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小栗子–自然数拆分"><a href="#小栗子–自然数拆分" class="headerlink" title="小栗子–自然数拆分"></a>小栗子–自然数拆分</h3><p>Description： 给定一个自然数N,要求把N拆分成若干个整数相加的形式，参与加法运算的数可以重复，求拆分方案。<br>思路： 1~N这N个数就是n个物品，总和 N 就是背包的容积.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ll mod = <span class="number">2147483648</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">ll f[<span class="number">4005</span>],n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>; <span class="comment">//边界值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123; <span class="comment">//依次加入n个物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j++)&#123; <span class="comment">//已有1~i这i个数求和得到j的方案数</span></span><br><span class="line">            f[j] = (f[j]+f[j-i])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;(f[n]%mod)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><p> Model:给定n个物品，第i个物品的体积为Vi,价值为Wi.<strong>并且有Ci个</strong>,背包容积为m。总体积不超过m,要求总价值最大。</p>
<h3 id="直接拆分法"><a href="#直接拆分法" class="headerlink" title="直接拆分法"></a>直接拆分法</h3><p>把第 i 种商品看做独立的Ci个商品，相当于一共有  ${ { \sum_{ i = 1 }^N Ci } }$个物品，就把物品转化为01背包问题了,但是效率比较低。<br>时间复杂度： $$O(M*\sum_{ i = 1 }^N Ci)$$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>  f[maxn],n,m,v[maxn],w[maxn],c[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=c[i];j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=m;k&gt;=v[i];k--)&#123;</span><br><span class="line">                f[k] = max(f[k],f[k-v[i]]+w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二进制拆分法"><a href="#二进制拆分法" class="headerlink" title="二进制拆分法"></a>二进制拆分法</h3><p>把数量为Ci个的第 i 种物品拆分成 p+2种物品，它们的价值与体积分别为：<br>$$ 2^0<em>Wi,2^1</em>Wi,……2^p<em>Wi，Ri</em>Wi $$<br>$$2^0<em>Vi,2^1</em>Vi,……2^p<em>Vi，Ri</em>Vi$$<br>其中 p为满足 ${ {2^{p+1}-1&lt;=Ci } }$ 的最大整数。<br>${ {Ri=Ci-(2^{p+1}-1) } }$。</p>
<p>时间复杂度： $$O(M*\sum_{i=1}^N log(Ci))$$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> f[maxn],n,m,w[maxn],v[maxn],c[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;n)==<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">        <span class="built_in">memset</span>(w, <span class="number">0</span>, <span class="keyword">sizeof</span>(w));</span><br><span class="line">        <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;c[i],&amp;w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> p = (<span class="keyword">int</span>)log2(c[i]+<span class="number">1</span>)<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> ri= -<span class="built_in">pow</span>(<span class="number">2</span>, p+<span class="number">1</span>)+c[i]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> wp[p+<span class="number">5</span>],vp[p+<span class="number">5</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;=p;x++)&#123;</span><br><span class="line">                wp[x]=<span class="built_in">pow</span>(<span class="number">2</span>,x)*w[i];</span><br><span class="line">                vp[x]=<span class="built_in">pow</span>(<span class="number">2</span>,x)*v[i]</span><br><span class="line">            &#125;</span><br><span class="line">            wp[p+<span class="number">1</span>]=ri*w[i];v[p+<span class="number">1</span>]=ri*v[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=p+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=m;k&gt;=vp[j];k--)&#123;</span><br><span class="line">                    f[k] = max(f[k],f[k-vp[j]]+wp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[m]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多重背包模板题"><a href="#多重背包模板题" class="headerlink" title="多重背包模板题."></a><a href="https://vjudge.net/problem/UVA-10626">多重背包模板题</a>.</h3><h2 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h2><p> Model : 给定 <strong>N</strong> 组物品，其中第 <strong>i</strong> 组有 <strong>Ci</strong> 个物品。第 i 组的第 <strong>j</strong> 个物品的体积为 <strong>Vij</strong>,价值为 <strong>Wij</strong>。有一个容积为 M 的背包，使得<strong>每组至多选择一个物品</strong>并且总体积不超过M的前提下，物品的价值和最大。<br><strong>状态</strong>:$F[i][j]$,表示从前 <strong>i</strong> 组中选出总体积为 <strong>j</strong> 的物品放入背包，物品的最大价值和。<br><strong>DP方程</strong>：<br>$$f[i][j]=max\begin{cases}<br>f[i-1][j]，不选第 i 组物品\<br>max_{(1=&lt;k&lt;=C_i)}f[i-1][j-V_{ik}]+W_{ik}，选第i组物品的某个物品k<br>\end{cases}$$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=c[i];k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=v[i][k])</span><br><span class="line">                f[j]=max(f[j],f[j-v[i][k]]+w[i][k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[m]);</span><br></pre></td></tr></table></figure>
<p>注意点：<strong>倒序循环j</strong>;<br><strong>对每一组物品的循环k应该放在j的内层，以保证每个物品只会放进去一次。</strong><br>从动态规划的角度：<br><strong>i</strong>是”阶段“，<strong>i</strong>和<strong>j</strong>共同构成”状态“，而<strong>k</strong>是”决策“——在第<strong>i</strong>个阶段使用哪个物品。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 —— 单例模式及Java实现</title>
    <url>/2021/11/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E2%80%94%E2%80%94-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%8F%8AJava%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>在整个项目中只提供这个类的一个实例，而不是需要这个实例对象时候去创建，用完就销毁。</p>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>创建此对象时间、空间开销非常大，而实际上这种类的对象具有静态属性，即属于类。<br>对于不同的调用者，不会因为需求不同，赋予它任意的性质——即这种类只会一种或少数形式创建出对象，完全可以事先创建创建、而后供人调用。<br>Spring的IOC容器里的对象的存在形式默认就是单例的。<br>常用于工具类，IO类、连接类的对象生成。</p>
<h1 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h1><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p>在编译时就加载完毕。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//饿汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><p>并不是程序初始时就生成对象，因为可能在整个程序运行时间都没有使用，那么懒汉式的加载就加大了开销。<br>也就是说，我们要<strong>在第一次要使用这个实例的时候才去创建它。</strong></p>
<ul>
<li>Java实现<br>这样就实现了懒加载的最基本的要求。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//懒汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="利用同步锁"><a href="#利用同步锁" class="headerlink" title="利用同步锁"></a>利用同步锁</h3>不难发现，上面的做法是线程不安全的。具体来说，有a、b、c三个线程调用了<code>getSingleton()</code>，它们在调用的时候，<code>singleton</code>都是<code>null</code>,于是三个线程都会创建出一个对象，破坏了单例的要求。<br>解决方法，也很简单。对这个方法加上同步锁，这样就保证同时只有一个线程抢到这把锁，然后第二个线程抢到这把锁的时候就不会创建了。<br>但是<code>synchronized</code>是重量级的同步锁，开销很大，这样使得每次调用这个方法都要进行同步操作，开销很大。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//懒汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>双重检查锁<br>下面的写法，并不是对方法加锁，而是在第一次判“空”的时候，才加锁，这样的话就不用每一次调用方法都会进行同步操作。<br>举个例子，有三个线程进入了if代码，然后它们将依次获得这把锁，而只有第一个抢到这把锁的线程才会去new一个实例，而之后的线程就会跳过if直接返回实例。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//懒汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(singleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
但是，这样的代码还有可能犯的一个的错误。<br>要知道，在上述场景中有多个线程对同一个变量（共享变量）又读又写，那么为了保证每个线程都对<code>singleton</code>的值实时可见，那么必须对共享变量加上<code>volatile</code>关键字修饰，才能避免对数据脏读。</li>
</ul>
<h3 id="利用静态内部类"><a href="#利用静态内部类" class="headerlink" title="利用静态内部类"></a>利用静态内部类</h3><p>这种写法巧妙的利用了静态内部类只会在第一次使用时才加载的特性，实现了懒加载，并且是线程安全的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//懒汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过很可惜这种做法还是可以使用反射去破坏单例。<br>验证如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException </span>&#123;</span><br><span class="line">        Constructor&lt;Singleton&gt; constructor = Singleton.class.getConstructor();</span><br><span class="line">        Singleton singleton1 = constructor.newInstance();</span><br><span class="line">        Singleton singleton2 = constructor.newInstance();</span><br><span class="line">        Singleton singleton3 = constructor.newInstance();</span><br><span class="line">        System.out.println(singleton1);</span><br><span class="line">        System.out.println(singleton2);</span><br><span class="line">        System.out.println(singleton3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="利用枚举实现单例"><a href="#利用枚举实现单例" class="headerlink" title="利用枚举实现单例"></a>利用枚举实现单例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getSingletonObject() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;new instance failure&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> SingletonObject singletonObject;</span><br><span class="line"></span><br><span class="line">        SingletonHolder() &#123;</span><br><span class="line">            <span class="keyword">this</span>.singletonObject = <span class="keyword">new</span> SingletonObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SingletonObject <span class="title">getSingletonObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE.singletonObject;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="能否用“反射”去破坏单例"><a href="#能否用“反射”去破坏单例" class="headerlink" title="能否用“反射”去破坏单例"></a>能否用“反射”去破坏单例</h2><p>单例模式很重要的一点就是保证全局只有一份实例，那么我们能够通过反射去强行破坏这一要求，去生成多个实例呢？<br>很不幸的是，是可以的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(singleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InvocationTargetException, InstantiationException </span>&#123;</span><br><span class="line">        Constructor constructor = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            constructor = Class.forName(<span class="string">&quot;单例模式.Singleton&quot;</span>).getConstructor();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Singleton singleton1 = (Singleton) constructor.newInstance();</span><br><span class="line">        Singleton singleton2 = (Singleton) constructor.newInstance();</span><br><span class="line">        Singleton singleton3 = (Singleton) constructor.newInstance();</span><br><span class="line">        System.out.println(singleton1);</span><br><span class="line">        System.out.println(singleton2);</span><br><span class="line">        System.out.println(singleton3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">单例模式.Singleton@38af3868</span><br><span class="line">单例模式.Singleton@<span class="number">77459877</span></span><br><span class="line">单例模式.Singleton@5b2133b1</span><br></pre></td></tr></table></figure>
<p>不过反射因为是一种认为操作，这种风险往往是已知的。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>运行、管理、配置RabbitMQ</title>
    <url>/2021/10/10/%E8%BF%90%E8%A1%8C%E3%80%81%E7%AE%A1%E7%90%86%E3%80%81%E9%85%8D%E7%BD%AERabbitMQ/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="Erlang节点与应用程序"><a href="#Erlang节点与应用程序" class="headerlink" title="Erlang节点与应用程序"></a>Erlang节点与应用程序</h2><p>Erlang节点指的是Erlang虚拟机运行erlang程序的Erlang虚拟机实例。</p>
<p>和Java不同，同一个Erlang节点可以运行多个erlang程序。</p>
<h2 id="RabbitMQ节点"><a href="#RabbitMQ节点" class="headerlink" title="RabbitMQ节点"></a>RabbitMQ节点</h2><p>RabbitMQ节点包含Erlang节点和rabbitmq程序两个概念。</p>
<h1 id="启动、关闭"><a href="#启动、关闭" class="headerlink" title="启动、关闭"></a>启动、关闭</h1><p>将 rabbitmq的安装目录下的 ./sbin加入PATH变量后。</p>
<ul>
<li>启动</li>
</ul>
<p>下面的命令就会同时启动 Rabbit和erlang实例。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmq-server -detached # -detached表示后台启动</span><br></pre></td></tr></table></figure>

<ul>
<li>关闭节点</li>
</ul>
<p>下面的命令会将整个Rabbit节点关闭，包括erlang实例。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmqctl stop</span><br></pre></td></tr></table></figure>

<ul>
<li>打开应用程序<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>关闭应用程序<br>仅停止rabbitmq应用程序。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>mac通过brew安装、Ubuntu通过apt安装可能通过 rabbitmq-env.conf文件中的<code>CONFIG_FILE</code>配置项去找到配置文件。</p>
<p><a href="https://www.rabbitmq.com/configure.html">配置文档参考</a></p>
<p>默认情况下，通过上述安装方式是没有按照配置文件的，需要自行配置。</p>
<p><a href="https://github.com/rabbitmq/rabbitmq-server/blob/master/docs/rabbitmq.conf.example">rabbitmq.conf.example下载地址</a></p>
<h1 id="使用-rabbitmqctl"><a href="#使用-rabbitmqctl" class="headerlink" title="使用 rabbitmqctl"></a>使用 rabbitmqctl</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看手册</span></span><br><span class="line">rabbitmqctl --help</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看某个具体的命令如何使用</span></span><br><span class="line">rabbitmqctl &lt;command&gt; --help</span><br></pre></td></tr></table></figure>

<h2 id="请求许可"><a href="#请求许可" class="headerlink" title="请求许可"></a>请求许可</h2><h3 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a>管理用户</h3><blockquote>
<p>这里展示出最常用的</p>
</blockquote>
<ul>
<li><p>添加用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmqctl add_user &#123;user_name&#125; &#123;password&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>删除用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmqctl delete_user &#123;user_name&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查看所有用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmqctl list_users</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="权限相关"><a href="#权限相关" class="headerlink" title="权限相关"></a>权限相关</h3><ul>
<li>分配权限<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmqctl set_permissions -p &#123;vhost&#125; &#123;username&#125; &#123;conf&#125; &#123;write&#125; &#123;read&#125;</span><br></pre></td></tr></table></figure>
举例<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 分配给 alice 用户所有权限</span></span><br><span class="line">rabbitmqctl set_permissions -p / alice &quot;.*&quot; &quot;.*&quot; &quot;*&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>清除权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmqctl clear_permissions -p &#123;vhost&#125; &#123;username&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查看权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmqctl list_permissions -p &#123;vhost&#125;</span><br><span class="line">rabbitmqctl list_user_permissions &#123;username&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Usage</span><br><span class="line"></span><br><span class="line">rabbitmqctl [--node &lt;node&gt;] [--timeout &lt;timeout&gt;] [--longnames] [--quiet] &lt;command&gt; [&lt;command options&gt;]</span><br><span class="line"></span><br><span class="line">Available commands:</span><br><span class="line"></span><br><span class="line">Help:</span><br><span class="line"></span><br><span class="line">   autocomplete                  Provides command name autocomplete variants</span><br><span class="line">   help                          Displays usage information for a command</span><br><span class="line">   version                       Displays CLI tools version</span><br><span class="line"></span><br><span class="line">Nodes:</span><br><span class="line"></span><br><span class="line">   await_startup                 Waits for the RabbitMQ application to start on the target node</span><br><span class="line">   reset                         Instructs a RabbitMQ node to leave the cluster and return to its virgin state</span><br><span class="line">   rotate_logs                   Does nothing [deprecated]</span><br><span class="line">   shutdown                      Stops RabbitMQ and its runtime (Erlang VM). Monitors progress for local nodes. Does not require a PID file path.</span><br><span class="line">   start_app                     Starts the RabbitMQ application but leaves the runtime (Erlang VM) running</span><br><span class="line">   stop                          Stops RabbitMQ and its runtime (Erlang VM). Requires a local node pid file path to monitor progress.</span><br><span class="line">   stop_app                      Stops the RabbitMQ application, leaving the runtime (Erlang VM) running</span><br><span class="line">   wait                          Waits for RabbitMQ node startup by monitoring a local PID file. See also &#x27;rabbitmqctl await_online_nodes&#x27;</span><br><span class="line"></span><br><span class="line">Cluster:</span><br><span class="line"></span><br><span class="line">   await_online_nodes            Waits for &lt;count&gt; nodes to join the cluster</span><br><span class="line">   change_cluster_node_type      Changes the type of the cluster node</span><br><span class="line">   cluster_status                Displays all the nodes in the cluster grouped by node type, together with the currently running nodes</span><br><span class="line">   force_boot                    Forces node to start even if it cannot contact or rejoin any of its previously known peers</span><br><span class="line">   force_reset                   Forcefully returns a RabbitMQ node to its virgin state</span><br><span class="line">   forget_cluster_node           Removes a node from the cluster</span><br><span class="line">   join_cluster                  Instructs the node to become a member of the cluster that the specified node is in</span><br><span class="line">   rename_cluster_node           Renames cluster nodes in the local database</span><br><span class="line">   update_cluster_nodes          Instructs a cluster member node to sync the list of known cluster members from &lt;seed_node&gt;</span><br><span class="line"></span><br><span class="line">Replication:</span><br><span class="line"></span><br><span class="line">   cancel_sync_queue             Instructs a synchronising mirrored queue to stop synchronising itself</span><br><span class="line">   sync_queue                    Instructs a mirrored queue with unsynchronised mirrors (follower replicas) to synchronise them</span><br><span class="line"></span><br><span class="line">Users:</span><br><span class="line"></span><br><span class="line">   add_user                      Creates a new user in the internal database. This user will have no permissions for any virtual hosts by default.</span><br><span class="line">   authenticate_user             Attempts to authenticate a user. Exits with a non-zero code if authentication fails.</span><br><span class="line">   change_password               Changes the user password</span><br><span class="line">   clear_password                Clears (resets) password and disables password login for a user</span><br><span class="line">   clear_user_limits             Clears user connection/channel limits</span><br><span class="line">   delete_user                   Removes a user from the internal database. Has no effect on users provided by external backends such as LDAP</span><br><span class="line">   list_user_limits              Displays configured user limits</span><br><span class="line">   list_users                    List user names and tags</span><br><span class="line">   set_user_limits               Sets user limits</span><br><span class="line">   set_user_tags                 Sets user tags</span><br><span class="line"></span><br><span class="line">Access Control:</span><br><span class="line"></span><br><span class="line">   clear_permissions             Revokes user permissions for a vhost</span><br><span class="line">   clear_topic_permissions       Clears user topic permissions for a vhost or exchange</span><br><span class="line">   list_permissions              Lists user permissions in a virtual host</span><br><span class="line">   list_topic_permissions        Lists topic permissions in a virtual host</span><br><span class="line">   list_user_permissions         Lists permissions of a user across all virtual hosts</span><br><span class="line">   list_user_topic_permissions   Lists user topic permissions</span><br><span class="line">   list_vhosts                   Lists virtual hosts</span><br><span class="line">   set_permissions               Sets user permissions for a vhost</span><br><span class="line">   set_topic_permissions         Sets user topic permissions for an exchange</span><br><span class="line"></span><br><span class="line">Monitoring, observability and health checks:</span><br><span class="line"></span><br><span class="line">   list_bindings                 Lists all bindings on a vhost</span><br><span class="line">   list_channels                 Lists all channels in the node</span><br><span class="line">   list_ciphers                  Lists cipher suites supported by encoding commands</span><br><span class="line">   list_connections              Lists AMQP 0.9.1 connections for the node</span><br><span class="line">   list_consumers                Lists all consumers for a vhost</span><br><span class="line">   list_exchanges                Lists exchanges</span><br><span class="line">   list_hashes                   Lists hash functions supported by encoding commands</span><br><span class="line">   list_node_auth_attempt_stats  Lists authentication attempts on the target node</span><br><span class="line">   list_queues                   Lists queues and their properties</span><br><span class="line">   list_unresponsive_queues      Tests queues to respond within timeout. Lists those which did not respond</span><br><span class="line">   ping                          Checks that the node OS process is up, registered with EPMD and CLI tools can authenticate with it</span><br><span class="line">   report                        Generate a server status report containing a concatenation of all server status information for support purposes</span><br><span class="line">   schema_info                   Lists schema database tables and their properties</span><br><span class="line">   status                        Displays status of a node</span><br><span class="line"></span><br><span class="line">Parameters:</span><br><span class="line"></span><br><span class="line">   clear_global_parameter        Clears a global runtime parameter</span><br><span class="line">   clear_parameter               Clears a runtime parameter.</span><br><span class="line">   list_global_parameters        Lists global runtime parameters</span><br><span class="line">   list_parameters               Lists runtime parameters for a virtual host</span><br><span class="line">   set_global_parameter          Sets a runtime parameter.</span><br><span class="line">   set_parameter                 Sets a runtime parameter.</span><br><span class="line"></span><br><span class="line">Policies:</span><br><span class="line"></span><br><span class="line">   clear_operator_policy         Clears an operator policy</span><br><span class="line">   clear_policy                  Clears (removes) a policy</span><br><span class="line">   list_operator_policies        Lists operator policy overrides for a virtual host</span><br><span class="line">   list_policies                 Lists all policies in a virtual host</span><br><span class="line">   set_operator_policy           Sets an operator policy that overrides a subset of arguments in user policies</span><br><span class="line">   set_policy                    Sets or updates a policy</span><br><span class="line"></span><br><span class="line">Virtual hosts:</span><br><span class="line"></span><br><span class="line">   add_vhost                     Creates a virtual host</span><br><span class="line">   clear_vhost_limits            Clears virtual host limits</span><br><span class="line">   delete_vhost                  Deletes a virtual host</span><br><span class="line">   list_vhost_limits             Displays configured virtual host limits</span><br><span class="line">   restart_vhost                 Restarts a failed vhost data stores and queues</span><br><span class="line">   set_vhost_limits              Sets virtual host limits</span><br><span class="line">   set_vhost_tags                Sets virtual host tags</span><br><span class="line">   trace_off</span><br><span class="line">   trace_on</span><br><span class="line"></span><br><span class="line">Configuration and Environment:</span><br><span class="line"></span><br><span class="line">   decode                        Decrypts an encrypted configuration value</span><br><span class="line">   encode                        Encrypts a sensitive configuration value</span><br><span class="line">   environment                   Displays the name and value of each variable in the application environment for each running application</span><br><span class="line">   set_cluster_name              Sets the cluster name</span><br><span class="line">   set_disk_free_limit           Sets the disk_free_limit setting</span><br><span class="line">   set_log_level                 Sets log level in the running node</span><br><span class="line">   set_vm_memory_high_watermark  Sets the vm_memory_high_watermark setting</span><br><span class="line"></span><br><span class="line">Definitions:</span><br><span class="line"></span><br><span class="line">   export_definitions            Exports definitions in JSON or compressed Erlang Term Format.</span><br><span class="line">   import_definitions            Imports definitions in JSON or compressed Erlang Term Format.</span><br><span class="line"></span><br><span class="line">Feature flags:</span><br><span class="line"></span><br><span class="line">   enable_feature_flag           Enables a feature flag or all supported feature flags on the target node</span><br><span class="line">   list_feature_flags            Lists feature flags</span><br><span class="line"></span><br><span class="line">Operations:</span><br><span class="line"></span><br><span class="line">   close_all_connections         Instructs the broker to close all connections for the specified vhost or entire RabbitMQ node</span><br><span class="line">   close_all_user_connections    Instructs the broker to close all connections of the specified user</span><br><span class="line">   close_connection              Instructs the broker to close the connection associated with the Erlang process id</span><br><span class="line">   eval                          Evaluates a snippet of Erlang code on the target node</span><br><span class="line">   eval_file                     Evaluates a file that contains a snippet of Erlang code on the target node</span><br><span class="line">   exec                          Evaluates a snippet of Elixir code on the CLI node</span><br><span class="line">   force_gc                      Makes all Erlang processes on the target node perform/schedule a full sweep garbage collection</span><br><span class="line">   resume_listeners              Resumes client connection listeners making them accept client connections again</span><br><span class="line">   suspend_listeners             Suspends client connection listeners so that no new client connections are accepted</span><br><span class="line"></span><br><span class="line">Queues:</span><br><span class="line"></span><br><span class="line">   delete_queue                  Deletes a queue</span><br><span class="line">   purge_queue                   Purges a queue (removes all messages in it)</span><br><span class="line"></span><br><span class="line">AMQP 1.0 plugin:</span><br><span class="line"></span><br><span class="line">   list_amqp10_connections       Lists AMQP 1.0 connections on the target node</span><br><span class="line"></span><br><span class="line">MQTT plugin:</span><br><span class="line"></span><br><span class="line">   decommission_mqtt_node        Removes cluster member and permanently deletes its cluster-wide MQTT state</span><br><span class="line">   list_mqtt_connections         Lists MQTT connections on the target node</span><br><span class="line"></span><br><span class="line">STOMP plugin:</span><br><span class="line"></span><br><span class="line">   list_stomp_connections        Lists STOMP connections on the target node</span><br><span class="line"></span><br><span class="line">Deprecated:</span><br><span class="line"></span><br><span class="line">   hipe_compile                  DEPRECATED. This command is a no-op. HiPE is no longer supported by modern Erlang versions</span><br><span class="line">   node_health_check             DEPRECATED. Performs intrusive, opinionated health checks on a fully booted node. See https://www.rabbitmq.com/monitoring.html#health-checks instead</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>消息中间件</category>
      </categories>
      <tags>
        <tag>Message Queue</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>这次彻底解决在Hexo中渲染MathJax数学公式出现的问题！！！</title>
    <url>/2021/07/21/%E8%BF%99%E6%AC%A1%E5%BD%BB%E5%BA%95%E8%A7%A3%E5%86%B3%E5%9C%A8Hexo%E4%B8%AD%E6%B8%B2%E6%9F%93MathJax%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%81%EF%BC%81%EF%BC%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>好家伙，这个问题已经困扰我好几个小时了。<br>网上的做法众说纷纭，有相似的东西，也有不同的。<br>这次我汇总一下。</p>
<p>具体的原因和过程可以看<a href="https://www.jianshu.com/p/7ab21c7f0674">在Hexo中渲染MathJax数学公式</a>这篇博客。</p>
<p>我遇到的问题是，在本地公式可以正常渲染。但是用hexo部署上去的时候，却又这么几种问题。</p>
<p>ok，分析一下几点原因。</p>
<ol>
<li><strong>渲染引擎缺失</strong></li>
</ol>
<p>渲染引擎更换一下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure>

<p>似乎装这一个就可以了，但是似乎还有人装其他引擎的。</p>
<ol start="2">
<li><strong>语义冲突</strong></li>
</ol>
<p>进入项目更目录下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim node_modules\kramed\lib\rules\inline.js</span><br></pre></td></tr></table></figure>

<p>修改这么两行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/,</span></span><br><span class="line">  <span class="built_in">escape</span>: <span class="regexp">/^\\([`*\[\]()#$+\-.!_&gt;])/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span></span><br><span class="line">  em: <span class="regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span></span><br></pre></td></tr></table></figure>


<ol start="3">
<li><strong>配置文件未将MathJax开启</strong></li>
</ol>
<p>这一步操作有些不同，但操作差不多，就是开启MathJax渲染。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Mathjax数学公式</span></span><br><span class="line"><span class="attr">mathjax:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Katex数学公式(allpost设置为false时只有头部设置math:true的文章才开启)</span></span><br><span class="line"><span class="attr">katex:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">allpost:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">copy_tex:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>


<ol start="4">
<li><strong>公式语法有误</strong><br>如果上述操作全部完成，还是不能成功，看看有没有语法问题。</li>
</ol>
<p>比如，我遇到的问题，如果在公式内连续使用两个花括号，必须加上空格。</p>
<p>如下面的会渲染失败。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$L_p  &#x3D; (\sum_&#123;i&#x3D;1&#125;^m |x_i - y_i |^&#123;p&#125;  )^&#123;&#123;\tfrac&#123;1&#125;&#123;p&#125;&#125;&#125;$$</span><br></pre></td></tr></table></figure>
<p>在连续的花括号之间加上空格即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$L_p  &#x3D; (\sum_&#123;i&#x3D;1&#125;^m |x_i - y_i |^&#123;p&#125;  )^&#123; &#123;\tfrac&#123;1&#125; &#123;p&#125; &#125; &#125;$$</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo - 写作</tag>
      </tags>
  </entry>
  <entry>
    <title>这次彻底解决HashMap!</title>
    <url>/2021/08/03/%E8%BF%99%E6%AC%A1%E5%BD%BB%E5%BA%95%E8%A7%A3%E5%86%B3HashMap!/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>前言，这篇文章着眼于JDK中HashMap的实现，源码解析，以及常见的面试问题。</p>
<p>对于一般的哈希表的实现，各种散列算法以及解决哈希冲突的方案本文并不完全介绍。</p>
<p>而且，关于红黑树的部分，本篇文章也不设计，只是直接调用api。</p>
</blockquote>
<h1 id="HashMap-文档"><a href="#HashMap-文档" class="headerlink" title="HashMap 文档"></a>HashMap 文档</h1><p>以下来自 HashMap 文档。</p>
<p>重点已加粗，并且增加了自己的批注。</p>
<blockquote>
<p>基于哈希表的Map接口的实现。</p>
<p>此实现提供所有可选的映射操作，并<strong>允许空值和空键</strong>。 </p>
<p>HashMap类与Hashtable底层都是hash表，不同之处在于<strong>HashMap线程不安全</strong>，并且允许 null。</p>
<p>该实现为<strong>基本操作（ get和put ）提供了常量时间的性能</strong>，假设哈希函数将元素正确地分散在存储桶中。 </p>
<p>集合视图上的迭代所需的时间与HashMap实例的“capacity”（存储桶数）及其 size（键-值映射数）成正比。 因此，如果迭代性能很重要，则不要将初始容量设置得过高（或负载因子过低），这一点非常重要。（<strong>否则会产生大量空桶,影响遍历效率</strong>）</p>
<p>HashMap的实例具有两个影响其性能的参数：<strong>初始容量（ initial capacity ）和负载因子（ load factor）</strong>。</p>
<p><strong>容量是哈希表中存储桶的数量</strong>，初始容量是创建哈希表时的容量。 </p>
<p><strong>负载因子是散列表的容量自动增加之前允许其填充的完整程度的度量</strong>。 当哈希表中的条目数超过<strong>负载因子和当前容量的乘积</strong>时，哈希表将被重新哈希（rehashed）（即内部数据结构将被重建）。</p>
<p>通常，<strong>默认负载因子（0.75）</strong>在时间和空间成本之间提供了一个很好的折衷方案。 较高的值会减少空间开销，但会增加查找成本（在HashMap类的大多数操作中都得到了体现，包括get和put ）。 设置其初始容量时，应考虑映射中的预期条目数及其负载因子，以最大程度地减少重新哈希操作的次数。 如果初始容量大于最大条目数除以负载因子，则将不会进行任何哈希操作。</p>
<p>如果将许多映射存储在HashMap实例中，则创建具有足够大容量的映射将比让其根据需要增长表的自动重新哈希处理更有效地存储映射（<strong>即如果确定在创建时就有大量映射存入HashMap,为了避免反复扩容，应确保足够大的初始容量</strong>）。 请注意，在具有大量相同hashCode()的键会降低哈希表性能， 为了改善影响，<strong>当键为Comparable</strong> ，此类可以使用键之间的比较顺序来帮助打破平局（<strong>即链表转红黑树</strong>）。</p>
<p>请注意，HashMap未实现同步。 如果多个线程同时访问一个哈希映射，并且至少有一个线程在结构上修改该映射，则必须在外部进行同步。 （<strong>结构修改是添加或删除一个或多个映射的任何操作；仅更改已经包含的键相关联的值不是结构修改</strong>。）</p>
</blockquote>
<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><h2 id="数据组织结构"><a href="#数据组织结构" class="headerlink" title="数据组织结构"></a>数据组织结构</h2><p><strong>数组+链表+红黑树—— 一般的哈希表 + 红黑树</strong></p>
<p>如下图：</p>
<p><img src="/2021/08/03/%E8%BF%99%E6%AC%A1%E5%BD%BB%E5%BA%95%E8%A7%A3%E5%86%B3HashMap!/hashmap1.png" alt="哈希表结构"></p>
<h2 id="HashMap的核心参数"><a href="#HashMap的核心参数" class="headerlink" title="HashMap的核心参数"></a>HashMap的核心参数</h2><ul>
<li><p><code>capacity</code>：HashMap的容量，即Node[]数组的size，HashMap会强制的将容量设置为2的幂，这样在对key取hash值的时候可以直接使用位运算来代替一般的取模。（比如容量为16时，只取key对象hash值的后4位，其值肯定在0~15的范围内，不会造成数组越界）</p>
</li>
<li><p><code>initialCapacity</code>：初始容量（默认为16），在使用HashMap的构造器实例化对象的时候，可以根据数据量设置map的初始化容量，来避免HashMap的频繁扩容</p>
</li>
<li><p><code>MAXIMUM_CAPACITY</code>：HashMap的最大容量（常量：2^30），当HashMap的容量达到MAXIMUM_CAPACITY后，将不再会扩容</p>
</li>
<li><p><code>loadFactor</code>：加载因子（默认为0.75），用来确定什么时候需要扩容。用于避免Node[]数组中有过多的链表或树形结构。加载因子越大，空间利用率越高，但是数组中的链表结构可能就越长，查找效率越小。下图是关于加载因子大小的分析。</p>
</li>
</ul>
<p><img src="/2021/08/03/%E8%BF%99%E6%AC%A1%E5%BD%BB%E5%BA%95%E8%A7%A3%E5%86%B3HashMap!/load-factor.png" alt="a"></p>
<ul>
<li><p><code>threshold</code>：阈值（默认为16*0.75），其值等于capacity×loadFactor，当HashMap中的键值对数量达到这个阈值时，就需要扩容了（JDK1.7还会判断当前的数组位置是否为空）</p>
</li>
<li><p><code>TREEIFY_THRESHOLD</code>：桶的树化阈值（常量，值为8），即链表转为红黑树的阈值，当某一链表的长度<strong>大于</strong>该值时，就考虑转化成红黑树了（还需要考虑最小树形化容量阈值MIN_TREEIFY_CAPACITY）</p>
</li>
<li><p><code>MIN_TREEIFY_CAPACITY</code>：最小树形化容量阈值（常量，值为64），当某一链表的长度大于8（桶的树化阈值）时，如果此时HashMap的容量不大于64，则此时不会将链表转化为红黑树，而是对HashMap进行扩容，只有容量大于64时，才对链表转化成红黑树。</p>
</li>
<li><p><code>UNTREEIFY_THRESHOLD</code>：桶的链表还原阈值（常量，值为6），即红黑树转化成链表的阈值，当在扩容（resize()）时，HashMap中数据的储存位置会发生改变，在重新计算过储存位置后，如果红黑树中元素的数量小于6，那么将会把红黑树结构转化成链表结构。</p>
</li>
</ul>
<h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p>如下，为HashMap提供的三种构造器，值得注意的是无论哪一种，都没有初始化数组，都只会在第一次添加元素的时候，惰性地去将<code>table数组</code>扩容，也就是一个空的HashMap没有浪费太多空间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以指定初始容量、负载因子</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity); <span class="comment">// 大于等于 initialCapacity 的最小2的整数次幂</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意此时 threshold = 0， 表示下次扩容时应扩展至 DEFAULT_INITIAL_CAPACITY </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="put-操作"><a href="#put-操作" class="headerlink" title="put 操作"></a>put 操作</h2><p>根据源码的put操作即可绘制下面的流程图：</p>
<p><img src="/2021/08/03/%E8%BF%99%E6%AC%A1%E5%BD%BB%E5%BA%95%E8%A7%A3%E5%86%B3HashMap!/HashMap-put.png" alt="put"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// onlyIfAbsent 的作用是为 putIfAbsent等 API提供服务</span></span><br><span class="line"><span class="comment">// 调用了 newNode()、resize()、putTreeVal()、treeifyBin()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// afterNodeAccess()、afterNodeInsertion （LinkedMap的性质维护）</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 1. tab 为空时，需要初始化一下</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 2.1 桶现在是空</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 判断第一个节点的性质———— 1.key相同（key相同的前提是hash相等）2. rb树的根， 3. 链表的表头</span></span><br><span class="line">        <span class="comment">// 2.2.1 找到一个 key 对应的节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 2.2.2 已经树化了，p 此时为 树根，调用它的 putTreeVal </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 2.2.3 遍历链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">//整体逻辑是 先判空，后判相等</span></span><br><span class="line">              </span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 链表走到头了</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 检查是否可以树化</span></span><br><span class="line">                    <span class="comment">// treeifyBin 里面会验证是否超过了 MIN_TREEIFY_CAPACITY</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="comment">// 进入这个逻辑即要退出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 和上面的key的判定是一样的</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 链表节点后移</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已经存在这个映射，用新值代替旧值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value; <span class="comment">// 替换旧值</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue; <span class="comment">// 返回旧值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount; <span class="comment">// fast-fail 机制</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 先插入后检查是否要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        <span class="comment">// 调用扩容方法</span></span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="get-操作"><a href="#get-操作" class="headerlink" title="get 操作"></a>get 操作</h2><p>get操作比较简单。</p>
<p>在数组不为空的情况下，hash值与数组长度取模（实际上是位于运算）定位到桶的位置。</p>
<p>一样的，先检查桶中的第一个节点，如果key匹配，返回。</p>
<p>如果第一个不匹配，要么在树中搜寻，要么在链表中遍历（根据节点的 instance 判断）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传入 key 的哈希吗以及key， 且 hash = hash(key)</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 总是先检查第一个节点，因为第一个节点既有可能是链表节点，也有可能是红黑树的树根</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            <span class="comment">// 注意这里的 k 是可能为 null 的（HashMap允许为空）</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果Node已经树化，则调用树的 getTreeNode 的 方法</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// 判断顺序 hash（最快） -&gt; key的==比较 -&gt; key 的equals比较</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="resize（扩容操作）"><a href="#resize（扩容操作）" class="headerlink" title="resize（扩容操作）"></a>resize（扩容操作）</h2><p>扩容操作分为两个部分：</p>
<h3 id="确定新的容量和阈值"><a href="#确定新的容量和阈值" class="headerlink" title="确定新的容量和阈值"></a>确定新的容量和阈值</h3><p>具体的：</p>
<ol>
<li><p>如果调用的是无参构造参数，在第一次扩容时，容量默认是16，扩容阈值为12（16*0.75）</p>
</li>
<li><p>如果调用的是有参构造函数，在第一次扩容时，容量为大于等于<code>initialCapacity</code>的最小二次幂，</p>
<p>阈值为容量*负载因子。</p>
</li>
<li><p>其他情况下，如果旧容量已经大于<code>MAXIMUM_CAPACITY</code>不选择扩容，直接返回；否则容量double一下, 阈值为容量*负载因子。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化或double容量</span></span><br><span class="line"><span class="comment">// 由于在capacity为2的整数次幂的情况下，取模具有这样的特点：</span></span><br><span class="line"><span class="comment">// 某个Node在扩容之后要么在table[index](aka 原位置)，要么在table[index + oldCap]</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// old容量大于0</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 原来的容量已经超过最大值， 此时无法扩容，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// double old容量</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;  <span class="comment">// oldCap 最大为 (2**30-1)*2</span></span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// old容量等于0，并且old“下次调整值”大于0 （也就是说用户指定了initialCapacity）</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 由用户初始化的容量（不过还要经过tableSizeFor方法）经 threshold 保存</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">// old容量等于0，并且old“下次调整值”等于0</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// 用户用无参构造器时的第一次初始化</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE); <span class="comment">// 赋值为 newCap * loadFactor， 除非超出最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr; <span class="comment">// 更新 threshold </span></span><br><span class="line">  </span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    <span class="comment">// 分配内存，创建新数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="元素的再散列"><a href="#元素的再散列" class="headerlink" title="元素的再散列"></a>元素的再散列</h3><p>再散列的逻辑，</p>
<p>遍历旧数组的每一个桶，若桶为空，跳过；</p>
<p>若不为空，如果是树，调用TreeNode的split方法将一棵树分裂开来（如果树的节点个数小于<code>UNTREEIFY_THRESHOLD</code>）将树链表化；</p>
<p>如果是链表，在遍历这条链表的时候，构造两条链表，一条称为”低链表”，第二条称为“高链表”。</p>
<p>分别在遍历完链表后，一条放在原位置，一条放在（原位置+oldCap）的位置上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果oldTab为null，也无需移动元素了</span></span><br><span class="line"><span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 遍历每一个桶</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="comment">// 链表为空就continue</span></span><br><span class="line">        <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            oldTab[j] = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span> (e.next == <span class="keyword">null</span>) <span class="comment">// 此时只有一个节点</span></span><br><span class="line">                newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 已经树化，则调用红黑树的方法，</span></span><br><span class="line">                <span class="comment">// 注意 split 方法中，可能将树链表化</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// 维护原顺序（“尾插法”）</span></span><br><span class="line">                </span><br><span class="line">                Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>; <span class="comment">// table[index]对应的链表 </span></span><br><span class="line">                Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>; <span class="comment">// table[index + oldLen]对应的链表</span></span><br><span class="line">                Node&lt;K,V&gt; next;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    next = e.next;</span><br><span class="line">                    <span class="comment">// e 是当前要处理的元素</span></span><br><span class="line">                    <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123; <span class="comment">// 注意此位运算的含义</span></span><br><span class="line">                        <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                            loHead = e;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            loTail.next = e;</span><br><span class="line">                        loTail = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                            hiHead = e;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            hiTail.next = e;</span><br><span class="line">                        hiTail = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>); <span class="comment">// 遍历链表</span></span><br><span class="line">              </span><br><span class="line">                <span class="comment">// 一条链经过resize后分裂成两条链</span></span><br><span class="line">                <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    loTail.next = <span class="keyword">null</span>; <span class="comment">// 必须去除这个冗余的节点引用</span></span><br><span class="line">                    newTab[j] = loHead; </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    hiTail.next = <span class="keyword">null</span>; <span class="comment">// 必须去除这个冗余的节点引用</span></span><br><span class="line">                    newTab[j + oldCap] = hiHead;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h1 id="面试常见问题"><a href="#面试常见问题" class="headerlink" title="面试常见问题"></a>面试常见问题</h1><h2 id="JDK1-7与JDK1-8的区别"><a href="#JDK1-7与JDK1-8的区别" class="headerlink" title="JDK1.7与JDK1.8的区别"></a>JDK1.7与JDK1.8的区别</h2><h3 id="头插法改尾插法"><a href="#头插法改尾插法" class="headerlink" title="头插法改尾插法"></a>头插法改尾插法</h3><p>JDK1.7时的头插法的导致的死循环问题：</p>
<p><img src="/2021/08/03/%E8%BF%99%E6%AC%A1%E5%BD%BB%E5%BA%95%E8%A7%A3%E5%86%B3HashMap!/resize.png" alt="resize"></p>
<p>头插法改为尾插法：<br><img src="/2021/08/03/%E8%BF%99%E6%AC%A1%E5%BD%BB%E5%BA%95%E8%A7%A3%E5%86%B3HashMap!/dif-resize.png" alt="dif-resize"></p>
<h3 id="引入红黑树"><a href="#引入红黑树" class="headerlink" title="引入红黑树"></a>引入红黑树</h3><p><img src="/2021/08/03/%E8%BF%99%E6%AC%A1%E5%BD%BB%E5%BA%95%E8%A7%A3%E5%86%B3HashMap!/dif-put.png" alt="dif-put"></p>
<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><h2 id="哈希表核心逻辑"><a href="#哈希表核心逻辑" class="headerlink" title="哈希表核心逻辑"></a>哈希表核心逻辑</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 默认初始容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  最大容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认负载因子</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表树化的最小阈值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 红黑树链表化的最小阈值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 树化的最小容量值（即如果容量小于 MIN_TREEIFY_CAPACITY ，即使链表长度大于 TREEIFY_THRESHOLD 也不会树化，这时会优先选择扩容）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部 Node</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        <span class="comment">// 由于是链表结构, 所以有 next</span></span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ---------------- Static utilities -------------- */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于使用了长度为 2 的整数次幂的模长，为了避免hashCode高位的失效，</span></span><br><span class="line">    <span class="comment">// 通过让hashCode的高16位与低16位进行异或，达到尽可能使用hashCode的全部</span></span><br><span class="line">    <span class="comment">// 当然，如果hashCode已经分散的足够好，此方法的增益也没有多大</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 返回 x 的类，如果它是“类 C 实现 Comparable”的形式  &quot;，否则为空。</span></span><br><span class="line">    <span class="comment">// 但必须是直接实现了 Comparable 接口</span></span><br><span class="line">    <span class="keyword">static</span> Class&lt;?&gt; comparableClassFor(Object x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x <span class="keyword">instanceof</span> Comparable) &#123;</span><br><span class="line">            Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p;</span><br><span class="line">          	<span class="comment">// String 使用的很频繁，所以直接先检查一下</span></span><br><span class="line">            <span class="keyword">if</span> ((c = x.getClass()) == String.class) <span class="comment">// bypass checks</span></span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            <span class="comment">// 返回表示由该对象表示的类或接口直接实现的接口的type</span></span><br><span class="line">            <span class="keyword">if</span> ((ts = c.getGenericInterfaces()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 遍历它实现的接口</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ts.length; ++i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (((t = ts[i]) <span class="keyword">instanceof</span> ParameterizedType) &amp;&amp;</span><br><span class="line">                        ((p = (ParameterizedType)t).getRawType() ==</span><br><span class="line">                         Comparable.class) &amp;&amp;</span><br><span class="line">                        (as = p.getActualTypeArguments()) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        as.length == <span class="number">1</span> &amp;&amp; as[<span class="number">0</span>] == c) <span class="comment">// type arg is c</span></span><br><span class="line">                        <span class="keyword">return</span> c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns k.compareTo(x) if x matches kc (k&#x27;s screened comparable</span></span><br><span class="line"><span class="comment">     * class), else 0.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span> <span class="comment">// for cast to Comparable</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareComparables</span><span class="params">(Class&lt;?&gt; kc, Object k, Object x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (x == <span class="keyword">null</span> || x.getClass() != kc ? <span class="number">0</span> :</span><br><span class="line">                ((Comparable)k).compareTo(x));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 大于等于 cap 的最小的2的整数次幂</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ---------------- Fields -------------- */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储 Node 的数组，len 为 2^n</span></span><br><span class="line">    <span class="comment">// 此时取模运算 index = hash % len = hash &amp; (n - 1) </span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也是视图性质的”集合“</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键值对的数目</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改的次数，支持 fast-fail 机制</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要调整大小的下一个大小值（容量 * 负载因子）cap*loadFactor 。 </span></span><br><span class="line">    <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* ---------------- Public operations -------------- */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法见上</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">        <span class="comment">// 源码解析见上</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 有无 key 对应的 entry</span></span><br><span class="line">        <span class="keyword">return</span> getNode(hash(key), key) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 源码解析见上</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 链表树化方法</span></span><br><span class="line">    <span class="comment">// 调用 TreeNode.treeify()</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) <span class="comment">// 如果table调小，优先扩容</span></span><br><span class="line">            resize();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>; <span class="comment">// 根、前驱</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                    hd = p;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    p.prev = tl;</span><br><span class="line">                    tl.next = p;</span><br><span class="line">                &#125;</span><br><span class="line">                tl = p;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);  <span class="comment">// 遍历链表</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 树化</span></span><br><span class="line">            <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">                hd.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 调用 getTreeNode()、removeTreeNode()</span></span><br><span class="line">    <span class="comment">// 调用回调方法 afterNodeRemoval()</span></span><br><span class="line">    <span class="comment">// matchValue、movable这两个控制变量主要是为了支持其他api方法</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;  <span class="comment">// node 维护为要删除的node</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 找到 node</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) <span class="comment">// 只有一个节点</span></span><br><span class="line">                node = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123; </span><br><span class="line">                <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);  <span class="comment">// 调用树的getNode方法</span></span><br><span class="line">                 <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key ||</span><br><span class="line">                             (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                            node = e;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        p = e;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// node 是要删除的节点、p是前驱</span></span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                                 (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (node == p) <span class="comment">// node 刚好是第一个节点</span></span><br><span class="line">                    tab[index] = node.next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p.next = node.next;</span><br><span class="line">                ++modCount;</span><br><span class="line">                --size;</span><br><span class="line">                afterNodeRemoval(node); <span class="comment">// 钩子函数善后</span></span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意 capacity 并没有发生变化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i)</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时间复杂度：O(n)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; V v;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((v = e.value) == value ||</span><br><span class="line">                        (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      下面是 keySet()、values、entrySet() 的代码部分：都是缓存性质的“视图集合”。</span></span><br><span class="line"><span class="comment">      实现方式也是一样，采用内部类继承抽象集合类（使用迭代器访问真实数据，自身不存储数据）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Set&lt;K&gt; ks = keySet;</span><br><span class="line">        <span class="keyword">if</span> (ks == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ks = <span class="keyword">new</span> KeySet();</span><br><span class="line">            keySet = ks;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ks;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">				<span class="comment">// </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Collection&lt;V&gt; vs = values;</span><br><span class="line">        <span class="keyword">if</span> (vs == <span class="keyword">null</span>) &#123;</span><br><span class="line">            vs = <span class="keyword">new</span> Values();</span><br><span class="line">            values = vs;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Values</span> <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">        Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">        <span class="keyword">return</span> (es = entrySet) == <span class="keyword">null</span> ? (entrySet = <span class="keyword">new</span> EntrySet()) : es;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="链表树化的具体实现类"><a href="#链表树化的具体实现类" class="headerlink" title="链表树化的具体实现类"></a>链表树化的具体实现类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ------------------------------------------------------------ */</span></span><br><span class="line"><span class="comment">// Tree bins</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 树箱的entry。 扩展 LinkedHashMap.Entry（进而扩展Node），因此可以用作常规链表节点的扩展。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 和标准红黑树字段设计相比，多了前项、后向引用</span></span><br><span class="line">    </span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev; </span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns root of tree containing this node.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="keyword">this</span>, p;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((p = r.parent) == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            r = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Ensures that the given root is the first node of its bin.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">moveRootToFront</span><span class="params">(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span> &amp;&amp; tab != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; root.hash;</span><br><span class="line">            TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index];</span><br><span class="line">            <span class="keyword">if</span> (root != first) &#123;</span><br><span class="line">                Node&lt;K,V&gt; rn;</span><br><span class="line">                tab[index] = root;</span><br><span class="line">                TreeNode&lt;K,V&gt; rp = root.prev;</span><br><span class="line">                <span class="keyword">if</span> ((rn = root.next) != <span class="keyword">null</span>)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)rn).prev = rp;</span><br><span class="line">                <span class="keyword">if</span> (rp != <span class="keyword">null</span>)</span><br><span class="line">                    rp.next = rn;</span><br><span class="line">                <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">                    first.prev = root;</span><br><span class="line">                root.next = first;</span><br><span class="line">                root.prev = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Finds the node starting at root p with the given hash and key.</span></span><br><span class="line"><span class="comment">     * The kc argument caches comparableClassFor(key) upon first use</span></span><br><span class="line"><span class="comment">     * comparing keys.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> ph, dir; K pk;</span><br><span class="line">            TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line">            <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                p = pl;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                p = pr;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>)</span><br><span class="line">                p = pr;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)</span><br><span class="line">                p = pl;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</span><br><span class="line">                      (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                     (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">                p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> q;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = pl;</span><br><span class="line">        &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls find for root node.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">getTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>).find(h, k, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tie-breaking utility for ordering insertions when equal</span></span><br><span class="line"><span class="comment">     * hashCodes and non-comparable. We don&#x27;t require a total</span></span><br><span class="line"><span class="comment">     * order, just a consistent insertion rule to maintain</span></span><br><span class="line"><span class="comment">     * equivalence across rebalancings. Tie-breaking further than</span></span><br><span class="line"><span class="comment">     * necessary simplifies testing a bit.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tieBreakOrder</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> d;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span> ||</span><br><span class="line">            (d = a.getClass().getName().</span><br><span class="line">             compareTo(b.getClass().getName())) == <span class="number">0</span>)</span><br><span class="line">            d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?</span><br><span class="line">                 -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Forms tree of the nodes linked from this node.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">            next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">            x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">                x.parent = <span class="keyword">null</span>;</span><br><span class="line">                x.red = <span class="keyword">false</span>;</span><br><span class="line">                root = x;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                K k = x.key;</span><br><span class="line">                <span class="keyword">int</span> h = x.hash;</span><br><span class="line">                Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                    <span class="keyword">int</span> dir, ph;</span><br><span class="line">                    K pk = p.key;</span><br><span class="line">                    <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                        dir = -<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                        dir = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                              (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                             (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                        dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">                    TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                    <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        x.parent = xp;</span><br><span class="line">                        <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                            xp.left = x;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            xp.right = x;</span><br><span class="line">                        root = balanceInsertion(root, x);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        moveRootToFront(tab, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a list of non-TreeNodes replacing those linked from</span></span><br><span class="line"><span class="comment">     * this node.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; q = <span class="keyword">this</span>; q != <span class="keyword">null</span>; q = q.next) &#123;</span><br><span class="line">            Node&lt;K,V&gt; p = map.replacementNode(q, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tl.next = p;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tree version of putVal.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">        TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">            <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                dir = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                dir = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                <span class="comment">// 如果找到直接返回</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                      (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                     (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                    TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                    searched = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                         (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                        ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                         (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                        <span class="keyword">return</span> q;</span><br><span class="line">                &#125;</span><br><span class="line">                dir = tieBreakOrder(k, pk);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">            <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">                TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">                <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                    xp.left = x;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    xp.right = x;</span><br><span class="line">                xp.next = x;</span><br><span class="line">                x.parent = x.prev = xp;</span><br><span class="line">                <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">                moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">                <span class="comment">// 如果是新插入的节点，返回 null</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the given node, that must be present before this call.</span></span><br><span class="line"><span class="comment">     * This is messier than typical red-black deletion code because we</span></span><br><span class="line"><span class="comment">     * cannot swap the contents of an interior node with a leaf</span></span><br><span class="line"><span class="comment">     * successor that is pinned by &quot;next&quot; pointers that are accessible</span></span><br><span class="line"><span class="comment">     * independently during traversal. So instead we swap the tree</span></span><br><span class="line"><span class="comment">     * linkages. If the current tree appears to have too few nodes,</span></span><br><span class="line"><span class="comment">     * the bin is converted back to a plain bin. (The test triggers</span></span><br><span class="line"><span class="comment">     * somewhere between 2 and 6 nodes, depending on tree structure).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeTreeNode</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl;</span><br><span class="line">        TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev;</span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">            tab[index] = first = succ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = succ;</span><br><span class="line">        <span class="keyword">if</span> (succ != <span class="keyword">null</span>)</span><br><span class="line">            succ.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.parent != <span class="keyword">null</span>)</span><br><span class="line">            root = root.root();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span></span><br><span class="line">            || (movable</span><br><span class="line">                &amp;&amp; (root.right == <span class="keyword">null</span></span><br><span class="line">                    || (rl = root.left) == <span class="keyword">null</span></span><br><span class="line">                    || rl.left == <span class="keyword">null</span>))) &#123;</span><br><span class="line">            tab[index] = first.untreeify(map);  <span class="comment">// too small</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>, pl = left, pr = right, replacement;</span><br><span class="line">        <span class="keyword">if</span> (pl != <span class="keyword">null</span> &amp;&amp; pr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; s = pr, sl;</span><br><span class="line">            <span class="keyword">while</span> ((sl = s.left) != <span class="keyword">null</span>) <span class="comment">// find successor</span></span><br><span class="line">                s = sl;</span><br><span class="line">            <span class="keyword">boolean</span> c = s.red; s.red = p.red; p.red = c; <span class="comment">// swap colors</span></span><br><span class="line">            TreeNode&lt;K,V&gt; sr = s.right;</span><br><span class="line">            TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">            <span class="keyword">if</span> (s == pr) &#123; <span class="comment">// p was s&#x27;s direct parent</span></span><br><span class="line">                p.parent = s;</span><br><span class="line">                s.right = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; sp = s.parent;</span><br><span class="line">                <span class="keyword">if</span> ((p.parent = sp) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s == sp.left)</span><br><span class="line">                        sp.left = p;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        sp.right = p;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((s.right = pr) != <span class="keyword">null</span>)</span><br><span class="line">                    pr.parent = s;</span><br><span class="line">            &#125;</span><br><span class="line">            p.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> ((p.right = sr) != <span class="keyword">null</span>)</span><br><span class="line">                sr.parent = p;</span><br><span class="line">            <span class="keyword">if</span> ((s.left = pl) != <span class="keyword">null</span>)</span><br><span class="line">                pl.parent = s;</span><br><span class="line">            <span class="keyword">if</span> ((s.parent = pp) == <span class="keyword">null</span>)</span><br><span class="line">                root = s;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                pp.left = s;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pp.right = s;</span><br><span class="line">            <span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">                replacement = sr;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                replacement = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pl != <span class="keyword">null</span>)</span><br><span class="line">            replacement = pl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pr != <span class="keyword">null</span>)</span><br><span class="line">            replacement = pr;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            replacement = p;</span><br><span class="line">        <span class="keyword">if</span> (replacement != p) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;</span><br><span class="line">            <span class="keyword">if</span> (pp == <span class="keyword">null</span>)</span><br><span class="line">                root = replacement;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                pp.left = replacement;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pp.right = replacement;</span><br><span class="line">            p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (replacement == p) &#123;  <span class="comment">// detach</span></span><br><span class="line">            TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">            p.parent = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (pp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                    pp.left = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.right)</span><br><span class="line">                    pp.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (movable)</span><br><span class="line">            moveRootToFront(tab, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Splits nodes in a tree bin into lower and upper tree bins,</span></span><br><span class="line"><span class="comment">     * or untreeifies if now too small. Called only from resize;</span></span><br><span class="line"><span class="comment">     * see above discussion about split bits and indices.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map the map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tab the table for recording bin heads</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index the index of the table being split</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bit the bit of hash to split on</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">        TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">        TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">            next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">            e.next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                    loHead = e;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    loTail.next = e;</span><br><span class="line">                loTail = e;</span><br><span class="line">                ++lc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                    hiHead = e;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    hiTail.next = e;</span><br><span class="line">                hiTail = e;</span><br><span class="line">                ++hc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">                tab[index] = loHead.untreeify(map);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                tab[index] = loHead;</span><br><span class="line">                <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">                    loHead.treeify(tab);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">                tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                tab[index + bit] = hiHead;</span><br><span class="line">                <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                    hiHead.treeify(tab);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ------------------------------------------------------------ */</span></span><br><span class="line">    <span class="comment">// 红黑树的算法，全部来自于《算法导论》，省略代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateLeft</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateRight</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceDeletion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">    </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">static</span> &lt;K,V&gt; <span class="keyword">boolean</span> checkInvariants(TreeNode&lt;K,V&gt; t)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="迭代器实现"><a href="#迭代器实现" class="headerlink" title="迭代器实现"></a>迭代器实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ------------------------------------------------------------ */</span></span><br><span class="line"><span class="comment">// iterators</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; next;        <span class="comment">// 下一个返回的节点</span></span><br><span class="line">    Node&lt;K,V&gt; current;     <span class="comment">// 当前节点</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount;  <span class="comment">// fast-fail 机制 </span></span><br><span class="line">    <span class="keyword">int</span> index;             <span class="comment">// current slot</span></span><br><span class="line"></span><br><span class="line">    HashIterator() &#123;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">        Node&lt;K,V&gt;[] t = table;</span><br><span class="line">        current = next = <span class="keyword">null</span>;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123; <span class="comment">// 找第一个不为null的entry</span></span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] t;</span><br><span class="line">        Node&lt;K,V&gt; e = next;</span><br><span class="line">        <span class="comment">// 先检查 expectedModCount</span></span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        </span><br><span class="line">      	<span class="comment">// 先遍历链表或者</span></span><br><span class="line">        <span class="keyword">if</span> ((next = (current = e).next) == <span class="keyword">null</span> &amp;&amp; (t = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 final removeNode的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; p = current;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) <span class="comment">// 检查 expectedModCount</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        current = <span class="keyword">null</span>;</span><br><span class="line">        K key = p.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> keySet、values、entrySet的迭代器直接继承 HashIterator 即可</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line">  </span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().key; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().value; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p><a href="https://blog.csdn.net/qq_36334929/article/details/117913430">Java学习笔记——HashMap底层源码分析</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/40515974">散列算法</a></p>
]]></content>
      <categories>
        <category>Java集合类</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Java集合类</tag>
        <tag>源码系列</tag>
      </tags>
  </entry>
  <entry>
    <title>高可靠性的消息队列 —— RabbitMQ</title>
    <url>/2021/10/12/%E9%AB%98%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%20%E2%80%94%E2%80%94%20RabbitMQ/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用消息代理的系统根据定义是分布式的。</p>
<p>由于发送的协议方法（消息）不能保证到达对等方或被其成功处理，</p>
<p>因此<strong>发布者和消费者都需要一种机制来进行传递和处理确认</strong>。RabbitMQ 支持的几种消息传递协议提供了这样的特性。</p>
<ul>
<li>从代理（broker）对发布者（publisher）的确认是一个称为<strong>publisher-confirms（发布者确认）</strong>的扩展 协议。</li>
</ul>
<ul>
<li>从消费者（consumer）到 RabbitMQ 的传递处理确认在消息传递协议中称为<strong>acknowledgement（简称 ack，计算机网络中经常用到）</strong>；</li>
</ul>
<p>这两个功能都基于相同的想法，并受到 TCP 的启发。</p>
<p>它们对于从发布者到 RabbitMQ 节点以及从 RabbitMQ 节点到消费者的可靠交付至关重要。换句话说，<strong>它们对于数据安全至关重要</strong>。</p>
<h1 id="生产者发布消息不丢失"><a href="#生产者发布消息不丢失" class="headerlink" title="生产者发布消息不丢失"></a>生产者发布消息不丢失</h1><blockquote>
<p>注意下面两种方案不可以同时选择，最多选其一。</p>
<p>即事务通道不能进入确认模式，并且确认模式的通道也不能成为事务通道。</p>
</blockquote>
<h2 id="事务机制"><a href="#事务机制" class="headerlink" title="事务机制"></a>事务机制</h2><ul>
<li>原生Java客户端</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">        Channel ch = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">        ch.txSelect();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MSG_COUNT; ++i) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ch.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME,</span><br><span class="line">                        MessageProperties.PERSISTENT_BASIC,</span><br><span class="line">                        <span class="string">&quot;nop&quot;</span>.getBytes());</span><br><span class="line">                ch.txCommit();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">                ch.txRollback();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>SpringBoot AMQP</li>
</ul>
<p>首先提供一个事务管理器供SpringBoot使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">RabbitTransactionManager <span class="title">transactionManager</span><span class="params">(ConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RabbitTransactionManager(connectionFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>接下来，在消息生产者上面做两件事：添加<code>@Transactional</code>并设置通信信道为事务模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        rabbitTemplate.setChannelTransacted(<span class="keyword">true</span>);</span><br><span class="line">     <span class="comment">// rabbitTemplate.convertAndSend(...);</span></span><br><span class="line">     <span class="comment">// int i = 1 / 0; 没有爆发异常，由spring提交事务，否则回滚（也就是不发生消息）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>但是使用事务有两个问题。</p>
<p>首先channel长时间处于阻塞：发布者必须依次等待broker处理每条消息。</p>
<p>不过有时候发布者只要知道broker宕机时哪些消息尚未处理就足够了。</p>
<p>其次是事务实现的繁重性：每次提交都需要一个 fsync()，这需要很多时间才能完成。</p>
<blockquote>
<p>发布 10000 条消息需要 4 多分钟（具体参数机器性能决定，总之确实非常慢）</p>
</blockquote>
<h2 id="发送方确认机制"><a href="#发送方确认机制" class="headerlink" title="发送方确认机制"></a>发送方确认机制</h2><p>一旦通道进入确认模式，代理将在处理消息时确认消息。</p>
<p>由于这是<strong>异步完成</strong>的，生产者可以流式发布而不用等待代理，代理也可以有效地<strong>批量写入磁盘</strong>。</p>
<ul>
<li>原生Java客户端</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 消息追踪记录（如果需要线程安全并且有序，可以使用 ConcurrentSkipListMap ）</span></span><br><span class="line">   HashMap&lt;Long, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">   <span class="comment">// 必须显式开启</span></span><br><span class="line">   channel.confirmSelect();</span><br><span class="line">   <span class="comment">// 监听被退回的消息(如消息路由到队列失败)</span></span><br><span class="line">   channel.addReturnListener(returnMessage -&gt; &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;return : &quot;</span> + System.currentTimeMillis());</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Thread.sleep(<span class="number">100</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       System.err.println(<span class="keyword">new</span> String(returnMessage.getBody()) + <span class="string">&quot; publish fail!&quot;</span>);</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 监听被到达或未到达交换机（exchange）的消息</span></span><br><span class="line">   channel.addConfirmListener(<span class="keyword">new</span> ConfirmListener() &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleAck</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">           map.remove(deliveryTag); <span class="comment">// 发送成功，缓存清除掉</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleNack</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">           System.err.println(map.get(deliveryTag) + <span class="string">&quot;not ack!&quot;</span>);</span><br><span class="line">           <span class="comment">// 下面可以进行重新发送等逻辑</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       Random random = <span class="keyword">new</span> Random();</span><br><span class="line">       <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (idx &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">           String message = <span class="string">&quot;from server...&quot;</span> + (++idx);</span><br><span class="line">           <span class="comment">// 追踪记录</span></span><br><span class="line">           map.put(channel.getNextPublishSeqNo(), message);</span><br><span class="line">           <span class="comment">// 发送消息</span></span><br><span class="line">           channel.basicPublish(<span class="string">&quot;&quot;</span>, queue, MessageProperties.PERSISTENT_BASIC, message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">           TimeUnit.MILLISECONDS.sleep(random.nextInt(<span class="number">300</span>) + <span class="number">200</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;以下为未成功发送的消息&quot;</span>);</span><br><span class="line">       <span class="comment">// 可以进行重试逻辑</span></span><br><span class="line">       map.values().forEach(s -&gt; System.out.println(<span class="string">&quot;not ack, may need publish again : &quot;</span> + s));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>SpringBoot AMQP</li>
</ul>
<p>首先<strong>在配置文件中配置中开启消息发送方确认机制</strong>。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span></span><br></pre></td></tr></table></figure>



<p><code>publisher-confirm-type</code>有三种属性：</p>
<ol>
<li>none：表示禁用发布确认模式，默认即此。</li>
<li>correlated：使用相关消息确认，回调中触发。</li>
<li>simple：使用 <code>waitForConfirms()</code> 和 <code>waitForConfirmsOrDie()</code> 方法的进行确认。</li>
</ol>
<p>然后<strong>配置回调的监听器</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PublisherConfirmConfig</span> <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ConfirmCallback</span>, <span class="title">RabbitTemplate</span>.<span class="title">ReturnsCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PublisherConfirmConfig</span><span class="params">(RabbitTemplate rabbitTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplate = rabbitTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@Bean 此处无需注入</span></span><br><span class="line">    <span class="function">RabbitTransactionManager <span class="title">transactionManager</span><span class="params">(ConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RabbitTransactionManager(connectionFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;correlationData : &quot;</span>+correlationData);</span><br><span class="line">        <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;cause : &quot;</span>+cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(ReturnedMessage returned)</span> </span>&#123;</span><br><span class="line">        System.err.println(returned);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initRabbitTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="keyword">this</span>);</span><br><span class="line">        rabbitTemplate.setReturnsCallback(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>发送消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意必须传入 CorrelationData，否则没有根据去跟踪（原生client使用deliveryTag跟踪）</span></span><br><span class="line">rabbitTemplate.convertAndSend(<span class="string">&quot;q1&quot;</span>, (Object) s, <span class="keyword">new</span> CorrelationData(<span class="string">&quot;correlation id = &quot;</span> + count));</span><br></pre></td></tr></table></figure>





<h1 id="MQ服务器存储消息不丢失"><a href="#MQ服务器存储消息不丢失" class="headerlink" title="MQ服务器存储消息不丢失"></a>MQ服务器存储消息不丢失</h1><h1 id="消费者消费消息不丢失"><a href="#消费者消费消息不丢失" class="headerlink" title="消费者消费消息不丢失"></a>消费者消费消息不丢失</h1><h2 id="关于ACK"><a href="#关于ACK" class="headerlink" title="关于ACK"></a>关于ACK</h2><h3 id="RabbitMQ的Client"><a href="#RabbitMQ的Client" class="headerlink" title="RabbitMQ的Client"></a>RabbitMQ的Client</h3><p>RabbitMQ中<code>channel</code>在消费消息（<code>basicConsume(String queue, boolean autoAck, Consumer callback)</code>）的时候，指定的ack的含义如下：</p>
<ul>
<li>autoAck = true</li>
</ul>
<p>当broker在消息发送后（写入TCP套接字后）此条消息就立即ack了，此条消息RabbitMQ服务器也不再保存了，</p>
<p>而丝毫不管收到消息的客户端是否处理。如果消费者在收到大量消息但没有处理的时候突然宕机了，那么那些未处理消息也就随着本地缓冲区的消失而消失了（服务器上也没有了）。</p>
<p>这种ack方式谨慎使用。</p>
<ul>
<li>autoAck = false</li>
</ul>
<p>这种ack方式必须要求用户自己主动ack消息（<code>channel.basicAck</code>）,常常和prefetchCount配合使用（后面会介绍到）。</p>
<h3 id="Spring-AMQP"><a href="#Spring-AMQP" class="headerlink" title="Spring AMQP"></a>Spring AMQP</h3><p>需要注意的是Spring AMQP中配置的ack的含义和上面的ack含义是不一样的。</p>
<ul>
<li>auto（default）</li>
</ul>
<p>容器将根据侦听器是正常返回还是抛出异常来发出 ack/nack。</p>
<ul>
<li>none</li>
</ul>
<p>这里的none和rabbitmq的auto是一个含义。</p>
<ul>
<li>manual</li>
</ul>
<p>用户必须通过channel去ack/nack</p>
<p><strong>配置方式</strong></p>
<ul>
<li>yaml配置<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">auto</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>方法级别（覆盖外部配置）<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;ququeName&quot;, ackMode = &quot;manual&quot;)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Ack的相关api"><a href="#Ack的相关api" class="headerlink" title="Ack的相关api"></a>Ack的相关api</h2><h3 id="deliveryTag（交付标签）"><a href="#deliveryTag（交付标签）" class="headerlink" title="deliveryTag（交付标签）"></a>deliveryTag（交付标签）</h3><p>当消费者（订阅）被注册时，消息将被 RabbitMQ 使用basic.deliver 方法传递。</p>
<p>该方法带有一个<em>交付标签</em>，它<strong>唯一地标识了一个通道上的交付</strong>。因此，<strong>交付标签的范围是每个channel</strong>。</p>
<p>交付标签是单调增长的正整数。确认交付的客户端库方法将交付标签作为参数。</p>
<p>由于交付标签的范围是每个通道，<strong>交付必须在接收它们的同一通道上得到确认</strong>。</p>
<p>在不同的通道上确认将导致“未知传递标签”协议异常并关闭通道。</p>
<h3 id="确认（ack）方法"><a href="#确认（ack）方法" class="headerlink" title="确认（ack）方法"></a>确认（ack）方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">oid <span class="title">basicAck</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span></span></span><br></pre></td></tr></table></figure>
<p>multiple为true的时候，会将之前的消息都ack（即交付标签小于deliveryTag的消息都会被ack）</p>
<h3 id="拒绝（rejecj-nack）方法"><a href="#拒绝（rejecj-nack）方法" class="headerlink" title="拒绝（rejecj\nack）方法"></a>拒绝（rejecj\nack）方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicReject</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> requeue)</span> </span></span><br></pre></td></tr></table></figure>
<p>requeue为true的时候会将消息重新入队，但必须要注意的是<strong>如果这个queue没有其他消费者，而本机由于某些原因会反复拉取这条消息并拒绝再拉取导致死循环。</strong>所以，在需要将消息重新入队的时候，需要注意消息重新入队的次数。</p>
<p>还有一个相似的方法，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">basicNack(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple, <span class="keyword">boolean</span> requeue)</span><br></pre></td></tr></table></figure>

<p>多了个 multiple 参数，含义和上面ack的multiple的一致。</p>
<h1 id="业务上实现"><a href="#业务上实现" class="headerlink" title="业务上实现"></a>业务上实现</h1><h2 id="投递失败的消息如何处理"><a href="#投递失败的消息如何处理" class="headerlink" title="投递失败的消息如何处理"></a>投递失败的消息如何处理</h2><h2 id="消费的幂等性如何做到"><a href="#消费的幂等性如何做到" class="headerlink" title="消费的幂等性如何做到"></a>消费的幂等性如何做到</h2><h2 id="消息中间件实现分布式事务"><a href="#消息中间件实现分布式事务" class="headerlink" title="消息中间件实现分布式事务"></a>消息中间件实现分布式事务</h2><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.rabbitmq.com/posts/2011/02/introducing-publisher-confirms">介绍发布者确认</a></p>
<p><a href="https://rabbitmq.com/tutorials/tutorial-seven-java.html">发布者确认</a> </p>
<p><a href="https://rabbitmq.com/confirms.html#consumer-acks-api-elements">消费者确认和发布者确认</a></p>
]]></content>
      <categories>
        <category>消息中间件</category>
      </categories>
      <tags>
        <tag>Message Queue</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>超详细的MongoDB的增删改查学习笔记！</title>
    <url>/2021/10/04/%E8%B6%85%E8%AF%A6%E7%BB%86%E7%9A%84MongoDB%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">show dbs</span><br></pre></td></tr></table></figure>

<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">use data_base_name</span><br></pre></td></tr></table></figure>

<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先切过去</span></span><br><span class="line">use to_delete_db</span><br><span class="line"><span class="comment"># 后删除</span></span><br><span class="line">db.dropDatabase()</span><br></pre></td></tr></table></figure>

<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="查看-1"><a href="#查看-1" class="headerlink" title="查看"></a>查看</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.getCollectionNames()</span><br></pre></td></tr></table></figure>

<h2 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建集合</span></span><br><span class="line">db.createCollection(collection_name,options)</span><br><span class="line"><span class="comment"># 或者直接使用集合名去插入文档，就自动创建集合</span></span><br><span class="line">db.mycol.insert(&#123;<span class="string">&quot;key&quot;</span> : <span class="string">&quot;value&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.collection_name.drop()</span><br></pre></td></tr></table></figure>


<h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><h2 id="插入文档"><a href="#插入文档" class="headerlink" title="插入文档"></a>插入文档</h2><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><ul>
<li><code>save()</code>：如果 _id 主键存在则更新数据，如果不存在就插入数据。该方法新版本中已废弃，可以使用 db.collection.insertOne() 或 db.collection.replaceOne() 来代替。</li>
<li><code>insert()</code>: 若插入的数据主键已经存在，则会抛 org.springframework.dao.DuplicateKeyException 异常，提示主键重复，不保存当前数据。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.COLLECTION_NAME.insert(document)</span><br><span class="line"></span><br><span class="line">db.COLLECTION_NAME.save(document)</span><br></pre></td></tr></table></figure>

<p><strong>不过下面的两个方法都已经过期，不要使用了.</strong></p>
<ul>
<li><p><code>insertOne()</code><br>传入一个json对象。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.inventory.insertOne(</span><br><span class="line">   &#123; item: <span class="string">&quot;canvas&quot;</span>, qty: 100, tags: [<span class="string">&quot;cotton&quot;</span>], size: &#123; h: 28, w: 35.5, uom: <span class="string">&quot;cm&quot;</span> &#125; &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><p><code>insertMany()</code><br>传入一个数组，里面是Json对象。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.inventory.insertMany([</span><br><span class="line">   &#123; item: <span class="string">&quot;journal&quot;</span>, qty: 25, tags: [<span class="string">&quot;blank&quot;</span>, <span class="string">&quot;red&quot;</span>], size: &#123; h: 14, w: 21, uom: <span class="string">&quot;cm&quot;</span> &#125; &#125;,</span><br><span class="line">   &#123; item: <span class="string">&quot;mat&quot;</span>, qty: 85, tags: [<span class="string">&quot;gray&quot;</span>], size: &#123; h: 27.9, w: 35.5, uom: <span class="string">&quot;cm&quot;</span> &#125; &#125;,</span><br><span class="line">   &#123; item: <span class="string">&quot;mousepad&quot;</span>, qty: 25, tags: [<span class="string">&quot;gel&quot;</span>, <span class="string">&quot;blue&quot;</span>], size: &#123; h: 19, w: 22.85, uom: <span class="string">&quot;cm&quot;</span> &#125; &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="插入行为"><a href="#插入行为" class="headerlink" title="插入行为"></a>插入行为</h3><ul>
<li><p>集合创建<br>如果该集合当前不存在，则插入操作将创建该集合。</p>
</li>
<li><p>_id字段<br>在MongoDB中，存储在集合中的每个文档都需要一个唯一的 _id字段作为主键。如果插入的文档省略了该_id字段，则MongoDB驱动程序会自动为该字段生成一个ObjectId, 键名为”_id” 。</p>
</li>
<li><p>原子性<br>MongoDB中的所有写操作在单个文档级别上都是原子性的。</p>
</li>
<li><p>写确认<br>对于写入问题，您可以指定从MongoDB请求的写入操作的确认级别。</p>
</li>
</ul>
<h2 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h2><p>在任何数据库中，差不多查询是花样的最多的了。</p>
<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>先介绍一个所谓的过滤器概念。<br>这个也就是<strong>对匹配的文档进行操作</strong>，如查询、投影、更改、删除。</p>
<p>在MongoDB里，文档是一个重要的要素，<strong>过滤器也是一个文档</strong>。<br><strong>文档通过并列、嵌套形成更复杂的查询条件。</strong></p>
<p>也不奇怪，MongoDB被称为文档型数据库了。</p>
<p>最简单的过滤器就是<strong>空过滤器</strong>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 空文档</span></span><br><span class="line">db.inventory.find( &#123;&#125; )</span><br><span class="line"><span class="comment"># </span></span><br><span class="line">db.inventory.find()</span><br></pre></td></tr></table></figure>

<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p><a href="https://docs.mongodb.com/manual/reference/operator/query/#std-label-query-selectors">更多的运算符，看这里</a></p>
<h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><table>
<thead>
<tr>
<th>运算符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>$eq</td>
<td>匹配等于指定值的值。 （=）</td>
</tr>
<tr>
<td>$gt</td>
<td>匹配大于指定值的值。（&gt;）</td>
</tr>
<tr>
<td>$gte</td>
<td>匹配大于或等于指定值的值。（&gt;=）</td>
</tr>
<tr>
<td>$in</td>
<td>匹配数组中指定的任何值。</td>
</tr>
<tr>
<td>$lt</td>
<td>匹配小于指定值的值。（&lt;）</td>
</tr>
<tr>
<td>$lte</td>
<td>匹配小于或等于指定值的值。（&lt;=）</td>
</tr>
<tr>
<td>$ne</td>
<td>匹配所有不等于指定值的值。 （!=）</td>
</tr>
<tr>
<td>$nin</td>
<td>不匹配数组中指定的任何值。</td>
</tr>
</tbody></table>
<p>举例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 相等条件</span></span><br><span class="line">&#123; &lt;field1&gt;: &lt;value1&gt;, ... &#125; </span><br><span class="line"><span class="comment"># 不等于条件</span></span><br><span class="line">&#123;&lt;key&gt;:&#123;<span class="string">&quot;<span class="variable">$ne</span>&quot;</span>:&lt;value&gt;&#125;&#125;</span><br><span class="line"><span class="comment"># 大于</span></span><br><span class="line">&#123;&lt;key&gt;:&#123;<span class="string">&quot;<span class="variable">$gt</span>&quot;</span>:&lt;value&gt;&#125;&#125;</span><br><span class="line"><span class="comment"># 小于</span></span><br><span class="line">&#123;&lt;key&gt;:&#123;<span class="string">&quot;<span class="variable">$lt</span>&quot;</span>:&lt;value&gt;&#125;&#125;</span><br><span class="line"><span class="comment"># 小于等于</span></span><br><span class="line">&#123;&lt;key&gt;:&#123;<span class="string">&quot;<span class="variable">$gte</span>&quot;</span>:&lt;value&gt;&#125;&#125;</span><br><span class="line"><span class="comment"># 大于等于</span></span><br><span class="line">&#123;&lt;key&gt;:&#123;<span class="string">&quot;<span class="variable">$lte</span>&quot;</span>:&lt;value&gt;&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># in</span></span><br><span class="line">&#123;&lt;key&gt;:&#123;<span class="string">&quot;<span class="variable">$in</span>&quot;</span>:[&lt;v1&gt;,&lt;v2&gt;,...]&#125;</span><br></pre></td></tr></table></figure>


<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><table>
<thead>
<tr>
<th>运算符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>$and</td>
<td>用逻辑联接查询子句AND将返回两个子句都符合条件的所有文档。</td>
</tr>
<tr>
<td>$not</td>
<td>反转查询表达式的效果，并返回与查询表达式不匹配的文档。</td>
</tr>
<tr>
<td>$nor</td>
<td>用逻辑联接查询子句NOR将返回两个子句均不匹配的所有文档。</td>
</tr>
<tr>
<td>$or</td>
<td>用逻辑联接查询子句OR将返回符合任一子句条件的所有文档。</td>
</tr>
</tbody></table>
<ul>
<li><strong>指定OR条件</strong><br>使用$or运算符，您可以指定一个复合查询，该查询将每个子句与逻辑连接符连接在一起，OR以便该查询选择集合中至少匹配一个条件的文档。</li>
</ul>
<p><strong>注意它的组织方式，其中键是”$or” ；值是一个数组，数组里面是 若干个文档，当然还可以继续嵌套下去。</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.inventory.find( &#123; <span class="variable">$or</span>: [ &#123; status: <span class="string">&quot;A&quot;</span> &#125;, &#123; qty: &#123; <span class="variable">$lt</span>: 30 &#125; &#125; ] &#125; )</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>指定AND条件</strong><br>对于AND的话，当然也可以按照OR的方式依葫芦画瓢。不过，还可以直接隐式使用 <code>,</code>分割多个键值对。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.inventory.find( &#123; status: <span class="string">&quot;A&quot;</span>, qty: &#123; <span class="variable">$lt</span>: 30 &#125; &#125; )</span><br></pre></td></tr></table></figure></li>
</ul>
<p>同时指定AND和OR</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.inventory.find( &#123;</span><br><span class="line">     status: <span class="string">&quot;A&quot;</span>,</span><br><span class="line">     <span class="variable">$or</span>: [ &#123; qty: &#123; <span class="variable">$lt</span>: 30 &#125; &#125;, &#123; item: <span class="string">&#x27;p&#x27;</span> &#125; ]</span><br><span class="line">&#125; )</span><br></pre></td></tr></table></figure>

<p>其余的运算符就不细说了，这里只介绍最常用的。</p>
<h3 id="其他查询技巧、用法"><a href="#其他查询技巧、用法" class="headerlink" title="其他查询技巧、用法"></a>其他查询技巧、用法</h3><h4 id="嵌套文档"><a href="#嵌套文档" class="headerlink" title="嵌套文档"></a>嵌套文档</h4><p>说白了，那些过滤器不仅仅可以出现数字、字符串这些，可以<strong>用文档过滤</strong>。</p>
<p>如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.inventory.find( &#123; size: &#123; h: 14, w: 21, uom: <span class="string">&quot;cm&quot;</span> &#125; &#125; )</span><br></pre></td></tr></table></figure>
<h4 id="嵌套字段"><a href="#嵌套字段" class="headerlink" title="嵌套字段"></a>嵌套字段</h4><p>就像使用 对象一样，链式地选择某个字段。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.inventory.find( &#123; <span class="string">&quot;size.h&quot;</span>: &#123; <span class="variable">$lt</span>: 15 &#125; &#125; )</span><br></pre></td></tr></table></figure>

<h3 id="关于数组"><a href="#关于数组" class="headerlink" title="关于数组"></a>关于数组</h3><h4 id="数组相关运算符。"><a href="#数组相关运算符。" class="headerlink" title="数组相关运算符。"></a>数组相关运算符。</h4><table>
<thead>
<tr>
<th>运算符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>$all</td>
<td>匹配包含查询中指定的所有元素的数组。（忽略顺序）</td>
</tr>
<tr>
<td>$size</td>
<td>如果数组字的大小为指定大小，则选择文档。</td>
</tr>
<tr>
<td>$elemMatch</td>
<td>如果array字段中的元素符合所有指定 $elemMatch 条件，则选择文档。</td>
</tr>
</tbody></table>
<p>下面的”tags”是一个数组</p>
<ol>
<li><p><strong>匹配一个数组</strong><br>这里匹配，必须是完全匹配，元素顺序也要相同。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.inventory.find( &#123; tags: [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blank&quot;</span>] &#125; )</span><br></pre></td></tr></table></figure>
<p>相反，如果您希望找到一个同时包含元素”red”和 “blank”的数组，而不考虑该数组中的顺序或其他元素，请使用$all运算符：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.inventory.find( &#123; tags: &#123; <span class="variable">$all</span>: [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blank&quot;</span>] &#125; &#125; )</span><br></pre></td></tr></table></figure></li>
<li><p><strong>针对一个元素去查询数组</strong><br>最简单的，数组包含这个元素：”tags”是一个数组，它有包含元素”red”</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.inventory.find( &#123; tags: <span class="string">&quot;red&quot;</span> &#125; )</span><br></pre></td></tr></table></figure></li>
</ol>
<p>你还可以使用操作符指定查询条件：</p>
<p>dim_cm是一个数组，匹配条件是数组里面至少有一个大于25的元素。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.inventory.find( &#123; dim_cm: &#123; <span class="variable">$gt</span>: 25 &#125; &#125; )</span><br></pre></td></tr></table></figure>



<ol start="3">
<li><strong>为数组元素指定多个条件</strong></li>
</ol>
<p>在数组元素上使用复合过滤条件查询数组:</p>
<p>注意匹配条件是，有一个元素大于15，有一个元素小于20（当然可以有同一个一个元素同时满足也算匹配）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.inventory.find( &#123; dim_cm: &#123; <span class="variable">$gt</span>: 15, <span class="variable">$lt</span>: 20 &#125; &#125; )</span><br></pre></td></tr></table></figure>

<p>查询满足多个条件的数组元素：</p>
<p>注意必须是至少包含同一个元素同时满足大于22且小于30</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.inventory.find( &#123; dim_cm: &#123; <span class="variable">$elemMatch</span>: &#123; <span class="variable">$gt</span>: 22, <span class="variable">$lt</span>: 30 &#125; &#125; &#125; )</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>通过数组索引位置查询元素</strong></li>
</ol>
<p>使用点号引用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.inventory.find( &#123; <span class="string">&quot;dim_cm.1&quot;</span>: &#123; <span class="variable">$gt</span>: 25 &#125; &#125; )</span><br></pre></td></tr></table></figure>



<p>按数组长度查询数组:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.inventory.find( &#123; <span class="string">&quot;tags&quot;</span>: &#123; <span class="variable">$size</span>: 3 &#125; &#125; )</span><br></pre></td></tr></table></figure>


<h3 id="关于嵌入文档的数组"><a href="#关于嵌入文档的数组" class="headerlink" title="关于嵌入文档的数组"></a>关于嵌入文档的数组</h3><p>demo data</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.inventory.insertMany( [</span><br><span class="line">   &#123; item: <span class="string">&quot;journal&quot;</span>, instock: [ &#123; warehouse: <span class="string">&quot;A&quot;</span>, qty: 5 &#125;, &#123; warehouse: <span class="string">&quot;C&quot;</span>, qty: 15 &#125; ] &#125;,</span><br><span class="line">   &#123; item: <span class="string">&quot;notebook&quot;</span>, instock: [ &#123; warehouse: <span class="string">&quot;C&quot;</span>, qty: 5 &#125; ] &#125;,</span><br><span class="line">   &#123; item: <span class="string">&quot;paper&quot;</span>, instock: [ &#123; warehouse: <span class="string">&quot;A&quot;</span>, qty: 60 &#125;, &#123; warehouse: <span class="string">&quot;B&quot;</span>, qty: 15 &#125; ] &#125;,</span><br><span class="line">   &#123; item: <span class="string">&quot;planner&quot;</span>, instock: [ &#123; warehouse: <span class="string">&quot;A&quot;</span>, qty: 40 &#125;, &#123; warehouse: <span class="string">&quot;B&quot;</span>, qty: 5 &#125; ] &#125;,</span><br><span class="line">   &#123; item: <span class="string">&quot;postcard&quot;</span>, instock: [ &#123; warehouse: <span class="string">&quot;B&quot;</span>, qty: 15 &#125;, &#123; warehouse: <span class="string">&quot;C&quot;</span>, qty: 35 &#125; ] &#125;</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>
<h4 id="查询嵌套在数组中的文档"><a href="#查询嵌套在数组中的文档" class="headerlink" title="查询嵌套在数组中的文档"></a>查询嵌套在数组中的文档</h4><p>相等匹配需要指定文档的精确匹配，包括字段顺序。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.inventory.find( &#123; <span class="string">&quot;instock&quot;</span>: &#123; warehouse: <span class="string">&quot;A&quot;</span>, qty: 5 &#125; &#125; )</span><br></pre></td></tr></table></figure>

<h4 id="在文档数组中的字段上指定查询条件"><a href="#在文档数组中的字段上指定查询条件" class="headerlink" title="在文档数组中的字段上指定查询条件"></a>在文档数组中的字段上指定查询条件</h4><ol>
<li><p>对嵌入在文档数组中的字段指定查询条件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.inventory.find( &#123; <span class="string">&#x27;instock.qty&#x27;</span>: &#123; <span class="variable">$lte</span>: 20 &#125; &#125; )</span><br></pre></td></tr></table></figure>
<p>其中instock是数组，qty是数组中的文档的字段。</p>
</li>
<li><p>使用数组索引查询嵌入文档中的字段</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.inventory.find( &#123; <span class="string">&#x27;instock.0.qty&#x27;</span>: &#123; <span class="variable">$lte</span>: 20 &#125; &#125; )</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="为文档数组指定多个条件"><a href="#为文档数组指定多个条件" class="headerlink" title="为文档数组指定多个条件"></a>为文档数组指定多个条件</h4><ol>
<li>同一个嵌入文档上指定多个条件</li>
</ol>
<p>使用<code>$elemMatch</code>运算符在一组嵌入文档上指定多个条件，以便至少一个嵌入文档满足所有指定的条件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.inventory.find( &#123; <span class="string">&quot;instock&quot;</span>: &#123; <span class="variable">$elemMatch</span>: &#123; qty: 5, warehouse: <span class="string">&quot;A&quot;</span> &#125; &#125; &#125; )</span><br></pre></td></tr></table></figure>
<p>意为：查询如下的文档，这些文档的 instock 字段（是一个文档数组）中，至少有一个嵌入文档，它的qty字段为5并且warehouse字段值为”A“。</p>
<ol start="2">
<li>多个嵌入文档元素组合满足标准</li>
</ol>
<p>如果数组字段上的复合查询条件不使用 $elemMatch运算符，则查询将选择其数组包含满足条件的任意元素组合的文档。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不一定是同一个嵌入文档满足</span></span><br><span class="line">db.inventory.find( &#123; <span class="string">&quot;instock.qty&quot;</span>: &#123; <span class="variable">$gt</span>: 10,  <span class="variable">$lte</span>: 20 &#125; &#125; )</span><br><span class="line">db.inventory.find( &#123; <span class="string">&quot;instock.qty&quot;</span>: 5, <span class="string">&quot;instock.warehouse&quot;</span>: <span class="string">&quot;A&quot;</span> &#125; )</span><br></pre></td></tr></table></figure>


<h3 id="返回文档的部分字段"><a href="#返回文档的部分字段" class="headerlink" title="返回文档的部分字段"></a>返回文档的部分字段</h3><p>和SQL一样可以指定返回的字段。<br>默认情况下返回文档的全部内容。</p>
<p>语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.COLLECTION.find(过滤器, 投影文档)</span><br></pre></td></tr></table></figure>



<p>投影文档，形如：<br>表明只返回item、status状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123; item: 1, status: 1&#125;</span><br></pre></td></tr></table></figure>
<p>或者也可以反过来，指定不返回那些字段</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123; status: 0, instock: 0 &#125; </span><br></pre></td></tr></table></figure>

<p>支持字段的嵌套，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123; item: 1, status: 1, <span class="string">&quot;size.uom&quot;</span>: 1 &#125;</span><br></pre></td></tr></table></figure>

<h3 id="查询空或缺失字段"><a href="#查询空或缺失字段" class="headerlink" title="查询空或缺失字段"></a>查询空或缺失字段</h3><p>demo data</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.inventory.insertMany([</span><br><span class="line">   &#123; _id: 1, item: null &#125;,</span><br><span class="line">   &#123; _id: 2 &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<h4 id="相等过滤器"><a href="#相等过滤器" class="headerlink" title="相等过滤器"></a>相等过滤器</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.inventory.find( &#123; item: null &#125; )</span><br></pre></td></tr></table></figure>
<p>字段为null或者字段不存在都匹配</p>
<h4 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h4><p>BSON type编号为10 表明是null字段。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.inventory.find( &#123; item : &#123; <span class="variable">$type</span>: 10 &#125; &#125; )</span><br></pre></td></tr></table></figure>
<p>只匹配null。</p>
<h4 id="存在性检查"><a href="#存在性检查" class="headerlink" title="存在性检查"></a>存在性检查</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.inventory.find( &#123; item : &#123; <span class="variable">$exists</span>: <span class="literal">false</span> &#125; &#125; )</span><br></pre></td></tr></table></figure>
<p>只匹配不存在。</p>
<h2 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h2><ol>
<li><p>更新单个文档</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.inventory.updateOne(</span><br><span class="line">   &#123; item: <span class="string">&quot;paper&quot;</span> &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="variable">$set</span>: &#123; <span class="string">&quot;size.uom&quot;</span>: <span class="string">&quot;cm&quot;</span>, status: <span class="string">&quot;P&quot;</span> &#125;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><p>替换整个文档</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.inventory.replaceOne(</span><br><span class="line">   &#123; item: <span class="string">&quot;paper&quot;</span> &#125;,</span><br><span class="line">   &#123; item: <span class="string">&quot;paper&quot;</span>, instock: [ &#123; warehouse: <span class="string">&quot;A&quot;</span>, qty: 60 &#125;, &#123; warehouse: <span class="string">&quot;B&quot;</span>, qty: 40 &#125; ] &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="更新方法"><a href="#更新方法" class="headerlink" title="更新方法"></a>更新方法</h3><p>MongoDB 提供了以下方法来更新集合中的文档：</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://docs.mongodb.com/manual/reference/method/db.collection.updateOne/#mongodb-method-db.collection.updateOne"><code>db.collection.updateOne()</code></a></td>
<td align="left">即使多个文档可能与指定的过滤器匹配，也最多更新与指定过滤器匹配的单个文档。<em>3.2版中的新功能</em>。</td>
</tr>
<tr>
<td align="left"><a href="https://docs.mongodb.com/manual/reference/method/db.collection.updateMany/#mongodb-method-db.collection.updateMany"><code>db.collection.updateMany()</code></a></td>
<td align="left">更新与指定过滤器匹配的所有文档。<em>3.2版中的新功能</em>。</td>
</tr>
<tr>
<td align="left"><a href="https://docs.mongodb.com/manual/reference/method/db.collection.replaceOne/#mongodb-method-db.collection.replaceOne"><code>db.collection.replaceOne()</code></a></td>
<td align="left">即使多个文档可能与指定的过滤器匹配，也最多替换与指定过滤器匹配的单个文档。<em>3.2版中的新功能</em>。</td>
</tr>
<tr>
<td align="left"><a href="https://docs.mongodb.com/manual/reference/method/db.collection.update/#mongodb-method-db.collection.update"><code>db.collection.update()</code></a></td>
<td align="left">更新或替换与指定过滤器匹配的单个文档，或者更新与指定过滤器匹配的所有文档。默认情况下，该<a href="https://docs.mongodb.com/manual/reference/method/db.collection.update/#mongodb-method-db.collection.update"><code>db.collection.update()</code></a>方法更新<strong>单个</strong>文档。要更新多个文档，请使用<a href="https://docs.mongodb.com/manual/reference/method/db.collection.update/#std-label-multi-parameter">multi</a>选项。</td>
</tr>
</tbody></table>
<h3 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h3><p>db.collection.updateOne(filter,update, options)<br>db.collection.updateMany(filter&gt;, update, options)<br>db.collection.replaceOne(filter, update, options)</p>
<p>第一个参数 filter 是过滤条件，也就是指定那些文档会被更新。</p>
<p>第二个参数 update指定具体的更新操作。</p>
<p>使用逗号分隔。</p>
<p>过滤器在介绍查询的时候已经介绍的差不多了。</p>
<p>update结构如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &lt;operator1&gt;: &#123; &lt;field1&gt;: &lt;value1&gt;, ... &#125;,</span><br><span class="line">   &lt;operator2&gt;: &#123; &lt;field2&gt;: &lt;value2&gt;, ... &#125;,</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 operator* 为操作符,下面会有介绍。</p>
<h3 id="更新操作符"><a href="#更新操作符" class="headerlink" title="更新操作符"></a>更新操作符</h3><p>这里只列出它们，详细的使用demo可以<a href="https://docs.mongodb.com/manual/reference/operator/update/">看这里</a>。</p>
<h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://docs.mongodb.com/manual/reference/operator/update/currentDate/#mongodb-update-up.-currentDate"><code>$currentDate</code></a></td>
<td align="left">将字段的值设置为当前日期，作为日期或时间戳。</td>
</tr>
<tr>
<td align="left"><a href="https://docs.mongodb.com/manual/reference/operator/update/inc/#mongodb-update-up.-inc"><code>$inc</code></a></td>
<td align="left"><strong>将字段的值增加指定的数量。</strong></td>
</tr>
<tr>
<td align="left"><a href="https://docs.mongodb.com/manual/reference/operator/update/min/#mongodb-update-up.-min"><code>$min</code></a></td>
<td align="left">仅当指定值小于现有字段值时才更新该字段。</td>
</tr>
<tr>
<td align="left"><a href="https://docs.mongodb.com/manual/reference/operator/update/max/#mongodb-update-up.-max"><code>$max</code></a></td>
<td align="left">仅当指定值大于现有字段值时才更新该字段。</td>
</tr>
<tr>
<td align="left"><a href="https://docs.mongodb.com/manual/reference/operator/update/mul/#mongodb-update-up.-mul"><code>$mul</code></a></td>
<td align="left">将字段的值乘以指定的数量。</td>
</tr>
<tr>
<td align="left"><a href="https://docs.mongodb.com/manual/reference/operator/update/rename/#mongodb-update-up.-rename"><code>$rename</code></a></td>
<td align="left"><strong>重命名字段。</strong></td>
</tr>
<tr>
<td align="left"><a href="https://docs.mongodb.com/manual/reference/operator/update/set/#mongodb-update-up.-set"><code>$set</code></a></td>
<td align="left"><strong>设置文档中字段的值。</strong></td>
</tr>
<tr>
<td align="left"><a href="https://docs.mongodb.com/manual/reference/operator/update/setOnInsert/#mongodb-update-up.-setOnInsert"><code>$setOnInsert</code></a></td>
<td align="left">如果更新导致插入文档，则设置字段的值。对修改现有文档的更新操作没有影响。</td>
</tr>
<tr>
<td align="left"><a href="https://docs.mongodb.com/manual/reference/operator/update/unset/#mongodb-update-up.-unset"><code>$unset</code></a></td>
<td align="left"><strong>从文档中删除指定的字段。</strong></td>
</tr>
</tbody></table>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="运算符-1"><a href="#运算符-1" class="headerlink" title="运算符"></a>运算符</h4><table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://docs.mongodb.com/manual/reference/operator/update/positional/#mongodb-update-up.-"><code>$</code></a></td>
<td align="left">充当占位符以更新与查询条件匹配的第一个元素。</td>
</tr>
<tr>
<td align="left"><a href="https://docs.mongodb.com/manual/reference/operator/update/positional-all/#mongodb-update-up.---"><code>$[]</code></a></td>
<td align="left">充当占位符，为匹配查询条件的文档更新数组中的所有元素。</td>
</tr>
<tr>
<td align="left"><a href="https://docs.mongodb.com/manual/reference/operator/update/positional-filtered/#mongodb-update-up.---identifier--"><code>$[]</code></a></td>
<td align="left">充当占位符，<code>arrayFilters</code>为符合查询条件的文档更新符合条件的所有元素。</td>
</tr>
<tr>
<td align="left"><a href="https://docs.mongodb.com/manual/reference/operator/update/addToSet/#mongodb-update-up.-addToSet"><code>$addToSet</code></a></td>
<td align="left">仅当集合中尚不存在元素时，才将元素添加到数组中。</td>
</tr>
<tr>
<td align="left"><a href="https://docs.mongodb.com/manual/reference/operator/update/pop/#mongodb-update-up.-pop"><code>$pop</code></a></td>
<td align="left"><strong>删除数组的第一项或最后一项。</strong></td>
</tr>
<tr>
<td align="left"><a href="https://docs.mongodb.com/manual/reference/operator/update/pull/#mongodb-update-up.-pull"><code>$pull</code></a></td>
<td align="left">删除与指定查询匹配的所有数组元素。</td>
</tr>
<tr>
<td align="left"><a href="https://docs.mongodb.com/manual/reference/operator/update/push/#mongodb-update-up.-push"><code>$push</code></a></td>
<td align="left"><strong>将项目添加到数组。</strong></td>
</tr>
<tr>
<td align="left"><a href="https://docs.mongodb.com/manual/reference/operator/update/pullAll/#mongodb-update-up.-pullAll"><code>$pullAll</code></a></td>
<td align="left">从数组中删除所有匹配的值。</td>
</tr>
</tbody></table>
<h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://docs.mongodb.com/manual/reference/operator/update/each/#mongodb-update-up.-each"><code>$each</code></a></td>
<td align="left">修改<a href="https://docs.mongodb.com/manual/reference/operator/update/push/#mongodb-update-up.-push"><code>$push</code></a>和<a href="https://docs.mongodb.com/manual/reference/operator/update/addToSet/#mongodb-update-up.-addToSet"><code>$addToSet</code></a>运算符以附加多个项目以进行数组更新。</td>
</tr>
<tr>
<td align="left"><a href="https://docs.mongodb.com/manual/reference/operator/update/position/#mongodb-update-up.-position"><code>$position</code></a></td>
<td align="left">修改<a href="https://docs.mongodb.com/manual/reference/operator/update/push/#mongodb-update-up.-push"><code>$push</code></a>运算符以指定要在数组中添加元素的位置。</td>
</tr>
<tr>
<td align="left"><a href="https://docs.mongodb.com/manual/reference/operator/update/slice/#mongodb-update-up.-slice"><code>$slice</code></a></td>
<td align="left">修改<a href="https://docs.mongodb.com/manual/reference/operator/update/push/#mongodb-update-up.-push"><code>$push</code></a>运算符以限制更新数组的大小。</td>
</tr>
<tr>
<td align="left"><a href="https://docs.mongodb.com/manual/reference/operator/update/sort/#mongodb-update-up.-sort"><code>$sort</code></a></td>
<td align="left">修改<a href="https://docs.mongodb.com/manual/reference/operator/update/push/#mongodb-update-up.-push"><code>$push</code></a>运算符以重新排序存储在数组中的文档。</td>
</tr>
</tbody></table>
<h3 id="按位"><a href="#按位" class="headerlink" title="按位"></a>按位</h3><table>
<thead>
<tr>
<th align="left">姓名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://docs.mongodb.com/manual/reference/operator/update/bit/#mongodb-update-up.-bit"><code>$bit</code></a></td>
<td align="left">执行整数值的按位<code>AND</code>、<code>OR</code>和<code>XOR</code>更新。</td>
</tr>
</tbody></table>
<h3 id="行为"><a href="#行为" class="headerlink" title="行为"></a>行为</h3><ul>
<li>原子性</li>
</ul>
<p><strong>MongoDB 中的所有写操作在单个文档的级别上都是原子的</strong>。</p>
<ul>
<li> _id字段<br>设置后，您不能更新_id字段的值，也不能用具有不同_id字段值的替换文档替换现有文档。</li>
<li> 次序<br>对于写操作，MongoDB 会保留文档字段的顺序， 但以下情况除外：</li>
</ul>
<ul>
<li><code>_id</code>字段始终是文档中的第一个字段。</li>
<li>包含renaming字段名称的更新可能会导致文档中字段的重新排序。</li>
</ul>
<h2 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h2><p>删除操作只需传入一个<strong>过滤器</strong>指定那些文档需要被删除即可。</p>
<p>举例：</p>
<ul>
<li>删除所有文档<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.inventory.deleteMany(&#123;&#125;)</span><br></pre></td></tr></table></figure></li>
<li>删除符合条件的文档<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.collection.deleteMany(&lt;filter&gt;)</span><br></pre></td></tr></table></figure></li>
<li>只删除一个符合条件的文档<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.collection.deleteMany(&lt;filter&gt;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="删除方法"><a href="#删除方法" class="headerlink" title="删除方法"></a>删除方法</h3><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://docs.mongodb.com/manual/reference/method/db.collection.deleteOne/#mongodb-method-db.collection.deleteOne"><code>db.collection.deleteOne()</code></a></td>
<td align="left">即使多个文档可能与指定的过滤器匹配，也最多删除一个与指定过滤器匹配的文档。<em>3.2版中的新功能</em>。</td>
</tr>
<tr>
<td align="left"><a href="https://docs.mongodb.com/manual/reference/method/db.collection.deleteMany/#mongodb-method-db.collection.deleteMany"><code>db.collection.deleteMany()</code></a></td>
<td align="left">删除与指定过滤器匹配的所有文档。<em>3.2版中的新功能</em>。</td>
</tr>
<tr>
<td align="left"><a href="https://docs.mongodb.com/manual/reference/method/db.collection.remove/#mongodb-method-db.collection.remove"><code>db.collection.remove()</code></a></td>
<td align="left">删除单个文档或与指定过滤器匹配的所有文档。</td>
</tr>
</tbody></table>
<h3 id="行为-1"><a href="#行为-1" class="headerlink" title="行为"></a>行为</h3><ul>
<li> 索引</li>
</ul>
<p><strong>删除操作不会删除索引</strong>，即使从集合中删除所有文档也是如此。</p>
<ul>
<li> 原子性</li>
</ul>
<p>MongoDB 中的所有写操作在单个文档的级别上都是原子的。</p>
<blockquote>
<p>参考文献<br><a href="https://docs.mongodb.com/manual/reference/sql-comparison/">SQL到MongoDB的转换</a></p>
<p><a href="https://docs.mongodb.com/manual/crud/">MongoDB的CRUD</a></p>
</blockquote>
]]></content>
      <categories>
        <category>NoSQL</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
</search>
